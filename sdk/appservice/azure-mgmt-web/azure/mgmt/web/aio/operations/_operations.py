# pylint: disable=line-too-long,useless-suppression,too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
import datetime
from io import IOBase
import json
from typing import Any, AsyncIterator, Callable, IO, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core import AsyncPipelineClient
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling

from ... import models as _models
from ..._utils.model_base import SdkJSONEncoder, _deserialize, _deserialize_xml, _failsafe_deserialize
from ..._utils.serialization import Deserializer, Serializer
from ..._utils.utils import ClientMixinABC
from ...operations._operations import (
    build_app_service_environments_approve_or_reject_private_endpoint_connection_request,
    build_app_service_environments_change_vnet_request,
    build_app_service_environments_create_or_update_multi_role_pool_request,
    build_app_service_environments_create_or_update_request,
    build_app_service_environments_create_or_update_worker_pool_request,
    build_app_service_environments_delete_ase_custom_dns_suffix_configuration_request,
    build_app_service_environments_delete_private_endpoint_connection_request,
    build_app_service_environments_delete_request,
    build_app_service_environments_get_ase_custom_dns_suffix_configuration_request,
    build_app_service_environments_get_ase_v3_networking_configuration_request,
    build_app_service_environments_get_diagnostics_item_request,
    build_app_service_environments_get_inbound_network_dependencies_endpoints_request,
    build_app_service_environments_get_multi_role_pool_request,
    build_app_service_environments_get_outbound_network_dependencies_endpoints_request,
    build_app_service_environments_get_private_endpoint_connection_list_request,
    build_app_service_environments_get_private_endpoint_connection_request,
    build_app_service_environments_get_private_link_resources_request,
    build_app_service_environments_get_request,
    build_app_service_environments_get_vip_info_request,
    build_app_service_environments_get_worker_pool_request,
    build_app_service_environments_list_app_service_plans_request,
    build_app_service_environments_list_by_resource_group_request,
    build_app_service_environments_list_capacities_request,
    build_app_service_environments_list_diagnostics_request,
    build_app_service_environments_list_multi_role_metric_definitions_request,
    build_app_service_environments_list_multi_role_pool_instance_metric_definitions_request,
    build_app_service_environments_list_multi_role_pool_skus_request,
    build_app_service_environments_list_multi_role_pools_request,
    build_app_service_environments_list_multi_role_usages_request,
    build_app_service_environments_list_operations_request,
    build_app_service_environments_list_request,
    build_app_service_environments_list_usages_request,
    build_app_service_environments_list_web_apps_request,
    build_app_service_environments_list_web_worker_metric_definitions_request,
    build_app_service_environments_list_web_worker_usages_request,
    build_app_service_environments_list_worker_pool_instance_metric_definitions_request,
    build_app_service_environments_list_worker_pool_skus_request,
    build_app_service_environments_list_worker_pools_request,
    build_app_service_environments_reboot_request,
    build_app_service_environments_resume_request,
    build_app_service_environments_suspend_request,
    build_app_service_environments_test_upgrade_available_notification_request,
    build_app_service_environments_update_ase_custom_dns_suffix_configuration_request,
    build_app_service_environments_update_ase_networking_configuration_request,
    build_app_service_environments_update_multi_role_pool_request,
    build_app_service_environments_update_request,
    build_app_service_environments_update_worker_pool_request,
    build_app_service_environments_upgrade_request,
    build_app_service_plans_create_or_update_request,
    build_app_service_plans_create_or_update_vnet_route_request,
    build_app_service_plans_delete_hybrid_connection_request,
    build_app_service_plans_delete_request,
    build_app_service_plans_delete_vnet_route_request,
    build_app_service_plans_get_hybrid_connection_plan_limit_request,
    build_app_service_plans_get_hybrid_connection_request,
    build_app_service_plans_get_request,
    build_app_service_plans_get_route_for_vnet_request,
    build_app_service_plans_get_server_farm_instance_details_request,
    build_app_service_plans_get_server_farm_rdp_password_request,
    build_app_service_plans_get_server_farm_skus_request,
    build_app_service_plans_get_vnet_from_server_farm_request,
    build_app_service_plans_get_vnet_gateway_request,
    build_app_service_plans_list_by_resource_group_request,
    build_app_service_plans_list_capabilities_request,
    build_app_service_plans_list_hybrid_connection_keys_request,
    build_app_service_plans_list_hybrid_connections_request,
    build_app_service_plans_list_request,
    build_app_service_plans_list_routes_for_vnet_request,
    build_app_service_plans_list_usages_request,
    build_app_service_plans_list_vnets_request,
    build_app_service_plans_list_web_apps_by_hybrid_connection_request,
    build_app_service_plans_list_web_apps_request,
    build_app_service_plans_reboot_worker_request,
    build_app_service_plans_recycle_managed_instance_worker_request,
    build_app_service_plans_restart_web_apps_request,
    build_app_service_plans_update_request,
    build_app_service_plans_update_vnet_gateway_request,
    build_app_service_plans_update_vnet_route_request,
    build_certificates_create_or_update_request,
    build_certificates_delete_request,
    build_certificates_get_request,
    build_certificates_list_by_resource_group_request,
    build_certificates_list_request,
    build_certificates_update_request,
    build_deleted_web_apps_get_deleted_web_app_by_location_request,
    build_deleted_web_apps_list_by_location_request,
    build_deleted_web_apps_list_request,
    build_diagnostics_execute_site_analysis_request,
    build_diagnostics_execute_site_analysis_slot_request,
    build_diagnostics_execute_site_detector_request,
    build_diagnostics_execute_site_detector_slot_request,
    build_diagnostics_get_hosting_environment_detector_response_request,
    build_diagnostics_get_site_analysis_request,
    build_diagnostics_get_site_analysis_slot_request,
    build_diagnostics_get_site_detector_request,
    build_diagnostics_get_site_detector_response_request,
    build_diagnostics_get_site_detector_response_slot_request,
    build_diagnostics_get_site_detector_slot_request,
    build_diagnostics_get_site_diagnostic_category_request,
    build_diagnostics_get_site_diagnostic_category_slot_request,
    build_diagnostics_list_hosting_environment_detector_responses_request,
    build_diagnostics_list_site_analyses_request,
    build_diagnostics_list_site_analyses_slot_request,
    build_diagnostics_list_site_detector_responses_request,
    build_diagnostics_list_site_detector_responses_slot_request,
    build_diagnostics_list_site_detectors_request,
    build_diagnostics_list_site_detectors_slot_request,
    build_diagnostics_list_site_diagnostic_categories_request,
    build_diagnostics_list_site_diagnostic_categories_slot_request,
    build_get_usages_in_location_list_request,
    build_global_operations_get_deleted_web_app_request,
    build_global_operations_get_deleted_web_app_snapshots_request,
    build_global_operations_get_subscription_operation_with_async_response_request,
    build_kube_environments_create_or_update_request,
    build_kube_environments_delete_request,
    build_kube_environments_get_request,
    build_kube_environments_list_by_resource_group_request,
    build_kube_environments_list_by_subscription_request,
    build_kube_environments_update_request,
    build_provider_get_available_stacks_on_prem_request,
    build_provider_get_available_stacks_request,
    build_provider_get_function_app_stacks_for_location_request,
    build_provider_get_function_app_stacks_request,
    build_provider_get_web_app_stacks_for_location_request,
    build_provider_get_web_app_stacks_request,
    build_provider_list_operations_request,
    build_recommendations_disable_all_for_hosting_environment_request,
    build_recommendations_disable_all_for_web_app_request,
    build_recommendations_disable_recommendation_for_hosting_environment_request,
    build_recommendations_disable_recommendation_for_site_request,
    build_recommendations_disable_recommendation_for_subscription_request,
    build_recommendations_get_rule_details_by_hosting_environment_request,
    build_recommendations_get_rule_details_by_web_app_request,
    build_recommendations_list_history_for_hosting_environment_request,
    build_recommendations_list_history_for_web_app_request,
    build_recommendations_list_recommended_rules_for_hosting_environment_request,
    build_recommendations_list_recommended_rules_for_web_app_request,
    build_recommendations_list_request,
    build_recommendations_reset_all_filters_for_hosting_environment_request,
    build_recommendations_reset_all_filters_for_web_app_request,
    build_recommendations_reset_all_filters_request,
    build_resource_health_metadata_get_by_site_request,
    build_resource_health_metadata_get_by_site_slot_request,
    build_resource_health_metadata_list_by_resource_group_request,
    build_resource_health_metadata_list_by_site_request,
    build_resource_health_metadata_list_by_site_slot_request,
    build_resource_health_metadata_list_request,
    build_site_certificates_create_or_update_request,
    build_site_certificates_create_or_update_slot_request,
    build_site_certificates_delete_request,
    build_site_certificates_delete_slot_request,
    build_site_certificates_get_request,
    build_site_certificates_get_slot_request,
    build_site_certificates_list_request,
    build_site_certificates_list_slot_request,
    build_site_certificates_update_request,
    build_site_certificates_update_slot_request,
    build_static_sites_approve_or_reject_private_endpoint_connection_request,
    build_static_sites_create_or_update_basic_auth_request,
    build_static_sites_create_or_update_build_database_connection_request,
    build_static_sites_create_or_update_database_connection_request,
    build_static_sites_create_or_update_static_site_app_settings_request,
    build_static_sites_create_or_update_static_site_build_app_settings_request,
    build_static_sites_create_or_update_static_site_build_function_app_settings_request,
    build_static_sites_create_or_update_static_site_custom_domain_request,
    build_static_sites_create_or_update_static_site_function_app_settings_request,
    build_static_sites_create_or_update_static_site_request,
    build_static_sites_create_user_roles_invitation_link_request,
    build_static_sites_create_zip_deployment_for_static_site_build_request,
    build_static_sites_create_zip_deployment_for_static_site_request,
    build_static_sites_delete_build_database_connection_request,
    build_static_sites_delete_database_connection_request,
    build_static_sites_delete_private_endpoint_connection_request,
    build_static_sites_delete_static_site_build_request,
    build_static_sites_delete_static_site_custom_domain_request,
    build_static_sites_delete_static_site_request,
    build_static_sites_delete_static_site_user_request,
    build_static_sites_detach_static_site_request,
    build_static_sites_detach_user_provided_function_app_from_static_site_build_request,
    build_static_sites_detach_user_provided_function_app_from_static_site_request,
    build_static_sites_get_basic_auth_request,
    build_static_sites_get_build_database_connection_request,
    build_static_sites_get_build_database_connection_with_details_request,
    build_static_sites_get_build_database_connections_request,
    build_static_sites_get_build_database_connections_with_details_request,
    build_static_sites_get_database_connection_request,
    build_static_sites_get_database_connection_with_details_request,
    build_static_sites_get_database_connections_request,
    build_static_sites_get_database_connections_with_details_request,
    build_static_sites_get_linked_backend_for_build_request,
    build_static_sites_get_linked_backend_request,
    build_static_sites_get_linked_backends_for_build_request,
    build_static_sites_get_linked_backends_request,
    build_static_sites_get_private_endpoint_connection_list_request,
    build_static_sites_get_private_endpoint_connection_request,
    build_static_sites_get_private_link_resources_request,
    build_static_sites_get_static_site_build_request,
    build_static_sites_get_static_site_builds_request,
    build_static_sites_get_static_site_custom_domain_request,
    build_static_sites_get_static_site_request,
    build_static_sites_get_static_sites_by_resource_group_request,
    build_static_sites_get_user_provided_function_app_for_static_site_build_request,
    build_static_sites_get_user_provided_function_app_for_static_site_request,
    build_static_sites_get_user_provided_function_apps_for_static_site_build_request,
    build_static_sites_get_user_provided_function_apps_for_static_site_request,
    build_static_sites_link_backend_request,
    build_static_sites_link_backend_to_build_request,
    build_static_sites_list_basic_auth_request,
    build_static_sites_list_request,
    build_static_sites_list_static_site_app_settings_request,
    build_static_sites_list_static_site_build_app_settings_request,
    build_static_sites_list_static_site_build_function_app_settings_request,
    build_static_sites_list_static_site_build_functions_request,
    build_static_sites_list_static_site_configured_roles_request,
    build_static_sites_list_static_site_custom_domains_request,
    build_static_sites_list_static_site_function_app_settings_request,
    build_static_sites_list_static_site_functions_request,
    build_static_sites_list_static_site_secrets_request,
    build_static_sites_list_static_site_users_request,
    build_static_sites_preview_workflow_request,
    build_static_sites_register_user_provided_function_app_with_static_site_build_request,
    build_static_sites_register_user_provided_function_app_with_static_site_request,
    build_static_sites_reset_static_site_api_key_request,
    build_static_sites_unlink_backend_from_build_request,
    build_static_sites_unlink_backend_request,
    build_static_sites_update_build_database_connection_request,
    build_static_sites_update_database_connection_request,
    build_static_sites_update_static_site_request,
    build_static_sites_update_static_site_user_request,
    build_static_sites_validate_backend_for_build_request,
    build_static_sites_validate_backend_request,
    build_static_sites_validate_custom_domain_can_be_added_to_static_site_request,
    build_web_apps_add_premier_add_on_request,
    build_web_apps_add_premier_add_on_slot_request,
    build_web_apps_analyze_custom_hostname_request,
    build_web_apps_analyze_custom_hostname_slot_request,
    build_web_apps_apply_slot_config_to_production_request,
    build_web_apps_apply_slot_configuration_slot_request,
    build_web_apps_approve_or_reject_private_endpoint_connection_request,
    build_web_apps_approve_or_reject_private_endpoint_connection_slot_request,
    build_web_apps_backup_request,
    build_web_apps_backup_slot_request,
    build_web_apps_create_deployment_request,
    build_web_apps_create_deployment_slot_request,
    build_web_apps_create_function_request,
    build_web_apps_create_instance_function_slot_request,
    build_web_apps_create_instance_ms_deploy_operation_request,
    build_web_apps_create_instance_ms_deploy_operation_slot_request,
    build_web_apps_create_ms_deploy_operation_request,
    build_web_apps_create_ms_deploy_operation_slot_request,
    build_web_apps_create_one_deploy_operation_request,
    build_web_apps_create_or_update_configuration_request,
    build_web_apps_create_or_update_configuration_slot_request,
    build_web_apps_create_or_update_domain_ownership_identifier_request,
    build_web_apps_create_or_update_domain_ownership_identifier_slot_request,
    build_web_apps_create_or_update_function_secret_request,
    build_web_apps_create_or_update_function_secret_slot_request,
    build_web_apps_create_or_update_host_name_binding_request,
    build_web_apps_create_or_update_host_name_binding_slot_request,
    build_web_apps_create_or_update_host_secret_request,
    build_web_apps_create_or_update_host_secret_slot_request,
    build_web_apps_create_or_update_hybrid_connection_request,
    build_web_apps_create_or_update_hybrid_connection_slot_request,
    build_web_apps_create_or_update_public_certificate_request,
    build_web_apps_create_or_update_public_certificate_slot_request,
    build_web_apps_create_or_update_relay_service_connection_request,
    build_web_apps_create_or_update_relay_service_connection_slot_request,
    build_web_apps_create_or_update_request,
    build_web_apps_create_or_update_site_container_request,
    build_web_apps_create_or_update_site_container_slot_request,
    build_web_apps_create_or_update_slot_request,
    build_web_apps_create_or_update_source_control_request,
    build_web_apps_create_or_update_source_control_slot_request,
    build_web_apps_create_or_update_swift_virtual_network_connection_with_check_request,
    build_web_apps_create_or_update_swift_virtual_network_connection_with_check_slot_request,
    build_web_apps_create_or_update_vnet_connection_gateway_request,
    build_web_apps_create_or_update_vnet_connection_gateway_slot_request,
    build_web_apps_create_or_update_vnet_connection_request,
    build_web_apps_create_or_update_vnet_connection_slot_request,
    build_web_apps_delete_backup_configuration_request,
    build_web_apps_delete_backup_configuration_slot_request,
    build_web_apps_delete_backup_request,
    build_web_apps_delete_backup_slot_request,
    build_web_apps_delete_continuous_web_job_request,
    build_web_apps_delete_continuous_web_job_slot_request,
    build_web_apps_delete_deployment_request,
    build_web_apps_delete_deployment_slot_request,
    build_web_apps_delete_domain_ownership_identifier_request,
    build_web_apps_delete_domain_ownership_identifier_slot_request,
    build_web_apps_delete_function_request,
    build_web_apps_delete_function_secret_request,
    build_web_apps_delete_function_secret_slot_request,
    build_web_apps_delete_host_name_binding_request,
    build_web_apps_delete_host_name_binding_slot_request,
    build_web_apps_delete_host_secret_request,
    build_web_apps_delete_host_secret_slot_request,
    build_web_apps_delete_hybrid_connection_request,
    build_web_apps_delete_hybrid_connection_slot_request,
    build_web_apps_delete_instance_function_slot_request,
    build_web_apps_delete_instance_process_request,
    build_web_apps_delete_instance_process_slot_request,
    build_web_apps_delete_premier_add_on_request,
    build_web_apps_delete_premier_add_on_slot_request,
    build_web_apps_delete_private_endpoint_connection_request,
    build_web_apps_delete_private_endpoint_connection_slot_request,
    build_web_apps_delete_process_request,
    build_web_apps_delete_process_slot_request,
    build_web_apps_delete_public_certificate_request,
    build_web_apps_delete_public_certificate_slot_request,
    build_web_apps_delete_relay_service_connection_request,
    build_web_apps_delete_relay_service_connection_slot_request,
    build_web_apps_delete_request,
    build_web_apps_delete_site_container_request,
    build_web_apps_delete_site_container_slot_request,
    build_web_apps_delete_site_extension_request,
    build_web_apps_delete_site_extension_slot_request,
    build_web_apps_delete_slot_request,
    build_web_apps_delete_source_control_request,
    build_web_apps_delete_source_control_slot_request,
    build_web_apps_delete_swift_virtual_network_request,
    build_web_apps_delete_swift_virtual_network_slot_request,
    build_web_apps_delete_triggered_web_job_request,
    build_web_apps_delete_triggered_web_job_slot_request,
    build_web_apps_delete_vnet_connection_request,
    build_web_apps_delete_vnet_connection_slot_request,
    build_web_apps_deploy_workflow_artifacts_request,
    build_web_apps_deploy_workflow_artifacts_slot_request,
    build_web_apps_discover_backup_request,
    build_web_apps_discover_backup_slot_request,
    build_web_apps_generate_new_site_publishing_password_request,
    build_web_apps_generate_new_site_publishing_password_slot_request,
    build_web_apps_get_app_setting_key_vault_reference_request,
    build_web_apps_get_app_setting_key_vault_reference_slot_request,
    build_web_apps_get_app_settings_key_vault_references_request,
    build_web_apps_get_app_settings_key_vault_references_slot_request,
    build_web_apps_get_auth_settings_request,
    build_web_apps_get_auth_settings_slot_request,
    build_web_apps_get_auth_settings_v2_request,
    build_web_apps_get_auth_settings_v2_slot_request,
    build_web_apps_get_auth_settings_v2_without_secrets_request,
    build_web_apps_get_auth_settings_v2_without_secrets_slot_request,
    build_web_apps_get_backup_configuration_request,
    build_web_apps_get_backup_configuration_slot_request,
    build_web_apps_get_backup_status_request,
    build_web_apps_get_backup_status_slot_request,
    build_web_apps_get_configuration_request,
    build_web_apps_get_configuration_slot_request,
    build_web_apps_get_configuration_snapshot_request,
    build_web_apps_get_configuration_snapshot_slot_request,
    build_web_apps_get_container_logs_zip_request,
    build_web_apps_get_container_logs_zip_slot_request,
    build_web_apps_get_continuous_web_job_request,
    build_web_apps_get_continuous_web_job_slot_request,
    build_web_apps_get_deployment_request,
    build_web_apps_get_deployment_slot_request,
    build_web_apps_get_diagnostic_logs_configuration_request,
    build_web_apps_get_diagnostic_logs_configuration_slot_request,
    build_web_apps_get_domain_ownership_identifier_request,
    build_web_apps_get_domain_ownership_identifier_slot_request,
    build_web_apps_get_ftp_allowed_request,
    build_web_apps_get_ftp_allowed_slot_request,
    build_web_apps_get_function_request,
    build_web_apps_get_functions_admin_token_request,
    build_web_apps_get_functions_admin_token_slot_request,
    build_web_apps_get_host_name_binding_request,
    build_web_apps_get_host_name_binding_slot_request,
    build_web_apps_get_hybrid_connection_request,
    build_web_apps_get_hybrid_connection_slot_request,
    build_web_apps_get_instance_function_slot_request,
    build_web_apps_get_instance_info_request,
    build_web_apps_get_instance_info_slot_request,
    build_web_apps_get_instance_ms_deploy_log_request,
    build_web_apps_get_instance_ms_deploy_log_slot_request,
    build_web_apps_get_instance_ms_deploy_status_request,
    build_web_apps_get_instance_ms_deploy_status_slot_request,
    build_web_apps_get_instance_process_dump_request,
    build_web_apps_get_instance_process_dump_slot_request,
    build_web_apps_get_instance_process_module_request,
    build_web_apps_get_instance_process_module_slot_request,
    build_web_apps_get_instance_process_request,
    build_web_apps_get_instance_process_slot_request,
    build_web_apps_get_instance_workflow_slot_request,
    build_web_apps_get_migrate_my_sql_status_request,
    build_web_apps_get_migrate_my_sql_status_slot_request,
    build_web_apps_get_ms_deploy_log_request,
    build_web_apps_get_ms_deploy_log_slot_request,
    build_web_apps_get_ms_deploy_status_request,
    build_web_apps_get_ms_deploy_status_slot_request,
    build_web_apps_get_network_trace_operation_request,
    build_web_apps_get_network_trace_operation_slot_request,
    build_web_apps_get_network_trace_operation_slot_v2_request,
    build_web_apps_get_network_trace_operation_v2_request,
    build_web_apps_get_network_traces_request,
    build_web_apps_get_network_traces_slot_request,
    build_web_apps_get_network_traces_slot_v2_request,
    build_web_apps_get_network_traces_v2_request,
    build_web_apps_get_one_deploy_status_request,
    build_web_apps_get_premier_add_on_request,
    build_web_apps_get_premier_add_on_slot_request,
    build_web_apps_get_private_access_request,
    build_web_apps_get_private_access_slot_request,
    build_web_apps_get_private_endpoint_connection_list_request,
    build_web_apps_get_private_endpoint_connection_list_slot_request,
    build_web_apps_get_private_endpoint_connection_request,
    build_web_apps_get_private_endpoint_connection_slot_request,
    build_web_apps_get_private_link_resources_request,
    build_web_apps_get_private_link_resources_slot_request,
    build_web_apps_get_process_dump_request,
    build_web_apps_get_process_dump_slot_request,
    build_web_apps_get_process_module_request,
    build_web_apps_get_process_module_slot_request,
    build_web_apps_get_process_request,
    build_web_apps_get_process_slot_request,
    build_web_apps_get_production_site_deployment_status_request,
    build_web_apps_get_public_certificate_request,
    build_web_apps_get_public_certificate_slot_request,
    build_web_apps_get_relay_service_connection_request,
    build_web_apps_get_relay_service_connection_slot_request,
    build_web_apps_get_request,
    build_web_apps_get_scm_allowed_request,
    build_web_apps_get_scm_allowed_slot_request,
    build_web_apps_get_site_connection_string_key_vault_reference_request,
    build_web_apps_get_site_connection_string_key_vault_reference_slot_request,
    build_web_apps_get_site_connection_string_key_vault_references_request,
    build_web_apps_get_site_connection_string_key_vault_references_slot_request,
    build_web_apps_get_site_container_request,
    build_web_apps_get_site_container_slot_request,
    build_web_apps_get_site_extension_request,
    build_web_apps_get_site_extension_slot_request,
    build_web_apps_get_site_php_error_log_flag_request,
    build_web_apps_get_site_php_error_log_flag_slot_request,
    build_web_apps_get_slot_request,
    build_web_apps_get_slot_site_deployment_status_slot_request,
    build_web_apps_get_source_control_request,
    build_web_apps_get_source_control_slot_request,
    build_web_apps_get_swift_virtual_network_connection_request,
    build_web_apps_get_swift_virtual_network_connection_slot_request,
    build_web_apps_get_triggered_web_job_history_request,
    build_web_apps_get_triggered_web_job_history_slot_request,
    build_web_apps_get_triggered_web_job_request,
    build_web_apps_get_triggered_web_job_slot_request,
    build_web_apps_get_vnet_connection_gateway_request,
    build_web_apps_get_vnet_connection_gateway_slot_request,
    build_web_apps_get_vnet_connection_request,
    build_web_apps_get_vnet_connection_slot_request,
    build_web_apps_get_web_job_request,
    build_web_apps_get_web_job_slot_request,
    build_web_apps_get_web_site_container_logs_request,
    build_web_apps_get_web_site_container_logs_slot_request,
    build_web_apps_get_workflow_request,
    build_web_apps_install_site_extension_request,
    build_web_apps_install_site_extension_slot_request,
    build_web_apps_is_cloneable_request,
    build_web_apps_is_cloneable_slot_request,
    build_web_apps_list_application_settings_request,
    build_web_apps_list_application_settings_slot_request,
    build_web_apps_list_azure_storage_accounts_request,
    build_web_apps_list_azure_storage_accounts_slot_request,
    build_web_apps_list_backup_status_secrets_request,
    build_web_apps_list_backup_status_secrets_slot_request,
    build_web_apps_list_backups_request,
    build_web_apps_list_backups_slot_request,
    build_web_apps_list_basic_publishing_credentials_policies_request,
    build_web_apps_list_basic_publishing_credentials_policies_slot_request,
    build_web_apps_list_by_resource_group_request,
    build_web_apps_list_configuration_snapshot_info_request,
    build_web_apps_list_configuration_snapshot_info_slot_request,
    build_web_apps_list_configurations_request,
    build_web_apps_list_configurations_slot_request,
    build_web_apps_list_connection_strings_request,
    build_web_apps_list_connection_strings_slot_request,
    build_web_apps_list_continuous_web_jobs_request,
    build_web_apps_list_continuous_web_jobs_slot_request,
    build_web_apps_list_deployment_log_request,
    build_web_apps_list_deployment_log_slot_request,
    build_web_apps_list_deployments_request,
    build_web_apps_list_deployments_slot_request,
    build_web_apps_list_domain_ownership_identifiers_request,
    build_web_apps_list_domain_ownership_identifiers_slot_request,
    build_web_apps_list_function_keys_request,
    build_web_apps_list_function_keys_slot_request,
    build_web_apps_list_function_secrets_request,
    build_web_apps_list_function_secrets_slot_request,
    build_web_apps_list_functions_request,
    build_web_apps_list_host_keys_request,
    build_web_apps_list_host_keys_slot_request,
    build_web_apps_list_host_name_bindings_request,
    build_web_apps_list_host_name_bindings_slot_request,
    build_web_apps_list_hybrid_connections_request,
    build_web_apps_list_hybrid_connections_slot_request,
    build_web_apps_list_instance_functions_slot_request,
    build_web_apps_list_instance_identifiers_request,
    build_web_apps_list_instance_identifiers_slot_request,
    build_web_apps_list_instance_process_modules_request,
    build_web_apps_list_instance_process_modules_slot_request,
    build_web_apps_list_instance_process_threads_request,
    build_web_apps_list_instance_process_threads_slot_request,
    build_web_apps_list_instance_processes_request,
    build_web_apps_list_instance_processes_slot_request,
    build_web_apps_list_instance_workflows_slot_request,
    build_web_apps_list_metadata_request,
    build_web_apps_list_metadata_slot_request,
    build_web_apps_list_network_features_request,
    build_web_apps_list_network_features_slot_request,
    build_web_apps_list_perf_mon_counters_request,
    build_web_apps_list_perf_mon_counters_slot_request,
    build_web_apps_list_premier_add_ons_request,
    build_web_apps_list_premier_add_ons_slot_request,
    build_web_apps_list_process_modules_request,
    build_web_apps_list_process_modules_slot_request,
    build_web_apps_list_process_threads_request,
    build_web_apps_list_process_threads_slot_request,
    build_web_apps_list_processes_request,
    build_web_apps_list_processes_slot_request,
    build_web_apps_list_production_site_deployment_statuses_request,
    build_web_apps_list_public_certificates_request,
    build_web_apps_list_public_certificates_slot_request,
    build_web_apps_list_publishing_credentials_request,
    build_web_apps_list_publishing_credentials_slot_request,
    build_web_apps_list_publishing_profile_xml_with_secrets_request,
    build_web_apps_list_publishing_profile_xml_with_secrets_slot_request,
    build_web_apps_list_relay_service_connections_request,
    build_web_apps_list_relay_service_connections_slot_request,
    build_web_apps_list_request,
    build_web_apps_list_site_backups_request,
    build_web_apps_list_site_backups_slot_request,
    build_web_apps_list_site_containers_request,
    build_web_apps_list_site_containers_slot_request,
    build_web_apps_list_site_extensions_request,
    build_web_apps_list_site_extensions_slot_request,
    build_web_apps_list_site_push_settings_request,
    build_web_apps_list_site_push_settings_slot_request,
    build_web_apps_list_slot_configuration_names_request,
    build_web_apps_list_slot_differences_from_production_request,
    build_web_apps_list_slot_differences_slot_request,
    build_web_apps_list_slot_site_deployment_statuses_slot_request,
    build_web_apps_list_slots_request,
    build_web_apps_list_snapshots_from_dr_secondary_request,
    build_web_apps_list_snapshots_from_dr_secondary_slot_request,
    build_web_apps_list_snapshots_request,
    build_web_apps_list_snapshots_slot_request,
    build_web_apps_list_sync_function_triggers_request,
    build_web_apps_list_sync_function_triggers_slot_request,
    build_web_apps_list_sync_status_request,
    build_web_apps_list_sync_status_slot_request,
    build_web_apps_list_triggered_web_job_history_request,
    build_web_apps_list_triggered_web_job_history_slot_request,
    build_web_apps_list_triggered_web_jobs_request,
    build_web_apps_list_triggered_web_jobs_slot_request,
    build_web_apps_list_usages_request,
    build_web_apps_list_usages_slot_request,
    build_web_apps_list_vnet_connections_request,
    build_web_apps_list_vnet_connections_slot_request,
    build_web_apps_list_web_jobs_request,
    build_web_apps_list_web_jobs_slot_request,
    build_web_apps_list_workflows_connections_request,
    build_web_apps_list_workflows_connections_slot_request,
    build_web_apps_list_workflows_request,
    build_web_apps_migrate_my_sql_request,
    build_web_apps_migrate_storage_request,
    build_web_apps_put_private_access_vnet_request,
    build_web_apps_put_private_access_vnet_slot_request,
    build_web_apps_recover_site_configuration_snapshot_request,
    build_web_apps_recover_site_configuration_snapshot_slot_request,
    build_web_apps_reset_production_slot_config_request,
    build_web_apps_reset_slot_configuration_slot_request,
    build_web_apps_restart_request,
    build_web_apps_restart_slot_request,
    build_web_apps_restore_from_backup_blob_request,
    build_web_apps_restore_from_backup_blob_slot_request,
    build_web_apps_restore_from_deleted_app_request,
    build_web_apps_restore_from_deleted_app_slot_request,
    build_web_apps_restore_request,
    build_web_apps_restore_slot_request,
    build_web_apps_restore_snapshot_request,
    build_web_apps_restore_snapshot_slot_request,
    build_web_apps_run_triggered_web_job_request,
    build_web_apps_run_triggered_web_job_slot_request,
    build_web_apps_start_continuous_web_job_request,
    build_web_apps_start_continuous_web_job_slot_request,
    build_web_apps_start_network_trace_request,
    build_web_apps_start_network_trace_slot_request,
    build_web_apps_start_request,
    build_web_apps_start_slot_request,
    build_web_apps_start_web_site_network_trace_operation_request,
    build_web_apps_start_web_site_network_trace_operation_slot_request,
    build_web_apps_start_web_site_network_trace_request,
    build_web_apps_start_web_site_network_trace_slot_request,
    build_web_apps_stop_continuous_web_job_request,
    build_web_apps_stop_continuous_web_job_slot_request,
    build_web_apps_stop_network_trace_request,
    build_web_apps_stop_network_trace_slot_request,
    build_web_apps_stop_request,
    build_web_apps_stop_slot_request,
    build_web_apps_stop_web_site_network_trace_request,
    build_web_apps_stop_web_site_network_trace_slot_request,
    build_web_apps_swap_slot_request,
    build_web_apps_swap_slot_with_production_request,
    build_web_apps_sync_function_triggers_request,
    build_web_apps_sync_function_triggers_slot_request,
    build_web_apps_sync_functions_request,
    build_web_apps_sync_functions_slot_request,
    build_web_apps_sync_repository_request,
    build_web_apps_sync_repository_slot_request,
    build_web_apps_update_application_settings_request,
    build_web_apps_update_application_settings_slot_request,
    build_web_apps_update_auth_settings_request,
    build_web_apps_update_auth_settings_slot_request,
    build_web_apps_update_auth_settings_v2_request,
    build_web_apps_update_auth_settings_v2_slot_request,
    build_web_apps_update_azure_storage_accounts_request,
    build_web_apps_update_azure_storage_accounts_slot_request,
    build_web_apps_update_backup_configuration_request,
    build_web_apps_update_backup_configuration_slot_request,
    build_web_apps_update_configuration_request,
    build_web_apps_update_configuration_slot_request,
    build_web_apps_update_connection_strings_request,
    build_web_apps_update_connection_strings_slot_request,
    build_web_apps_update_diagnostic_logs_config_request,
    build_web_apps_update_diagnostic_logs_config_slot_request,
    build_web_apps_update_domain_ownership_identifier_request,
    build_web_apps_update_domain_ownership_identifier_slot_request,
    build_web_apps_update_ftp_allowed_request,
    build_web_apps_update_ftp_allowed_slot_request,
    build_web_apps_update_hybrid_connection_request,
    build_web_apps_update_hybrid_connection_slot_request,
    build_web_apps_update_machine_key_request,
    build_web_apps_update_metadata_request,
    build_web_apps_update_metadata_slot_request,
    build_web_apps_update_premier_add_on_request,
    build_web_apps_update_premier_add_on_slot_request,
    build_web_apps_update_relay_service_connection_request,
    build_web_apps_update_relay_service_connection_slot_request,
    build_web_apps_update_request,
    build_web_apps_update_scm_allowed_request,
    build_web_apps_update_scm_allowed_slot_request,
    build_web_apps_update_site_push_settings_request,
    build_web_apps_update_site_push_settings_slot_request,
    build_web_apps_update_slot_configuration_names_request,
    build_web_apps_update_slot_request,
    build_web_apps_update_source_control_request,
    build_web_apps_update_source_control_slot_request,
    build_web_apps_update_swift_virtual_network_connection_with_check_request,
    build_web_apps_update_swift_virtual_network_connection_with_check_slot_request,
    build_web_apps_update_vnet_connection_gateway_request,
    build_web_apps_update_vnet_connection_gateway_slot_request,
    build_web_apps_update_vnet_connection_request,
    build_web_apps_update_vnet_connection_slot_request,
    build_web_site_management_check_name_availability_request,
    build_web_site_management_get_publishing_user_request,
    build_web_site_management_get_source_control_request,
    build_web_site_management_get_subscription_deployment_locations_request,
    build_web_site_management_list_ase_regions_request,
    build_web_site_management_list_billing_meters_request,
    build_web_site_management_list_custom_host_name_sites_request,
    build_web_site_management_list_geo_regions_request,
    build_web_site_management_list_premier_add_on_offers_request,
    build_web_site_management_list_site_identifiers_assigned_to_host_name_request,
    build_web_site_management_list_skus_request,
    build_web_site_management_list_source_controls_request,
    build_web_site_management_move_request,
    build_web_site_management_regional_check_name_availability_request,
    build_web_site_management_update_publishing_user_request,
    build_web_site_management_update_source_control_request,
    build_web_site_management_validate_move_request,
    build_web_site_management_validate_request,
    build_web_site_management_verify_hosting_environment_vnet_request,
    build_workflow_run_action_repetitions_get_request,
    build_workflow_run_action_repetitions_list_expression_traces_request,
    build_workflow_run_action_repetitions_list_request,
    build_workflow_run_action_repetitions_request_histories_get_request,
    build_workflow_run_action_repetitions_request_histories_list_request,
    build_workflow_run_action_scope_repetitions_get_request,
    build_workflow_run_action_scope_repetitions_list_request,
    build_workflow_run_actions_get_request,
    build_workflow_run_actions_list_expression_traces_request,
    build_workflow_run_actions_list_request,
    build_workflow_runs_cancel_request,
    build_workflow_runs_get_request,
    build_workflow_runs_list_request,
    build_workflow_trigger_histories_get_request,
    build_workflow_trigger_histories_list_request,
    build_workflow_trigger_histories_resubmit_request,
    build_workflow_triggers_get_request,
    build_workflow_triggers_get_schema_json_request,
    build_workflow_triggers_list_callback_url_request,
    build_workflow_triggers_list_request,
    build_workflow_triggers_run_request,
    build_workflow_versions_get_request,
    build_workflow_versions_list_request,
    build_workflows_regenerate_access_key_request,
    build_workflows_validate_request,
)
from .._configuration import WebSiteManagementClientConfiguration

JSON = MutableMapping[str, Any]
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, dict[str, Any]], Any]]
List = list


class AppServiceEnvironmentsOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`app_service_environments` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_worker_pool(
        self, resource_group_name: str, name: str, worker_pool_name: str, **kwargs: Any
    ) -> _models.WorkerPoolResource:
        """Get properties of a worker pool.

        Description for Get properties of a worker pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :return: WorkerPoolResource. The WorkerPoolResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkerPoolResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkerPoolResource] = kwargs.pop("cls", None)

        _request = build_app_service_environments_get_worker_pool_request(
            resource_group_name=resource_group_name,
            name=name,
            worker_pool_name=worker_pool_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkerPoolResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_worker_pool_initial(
        self,
        resource_group_name: str,
        name: str,
        worker_pool_name: str,
        worker_pool_envelope: Union[_models.WorkerPoolResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(worker_pool_envelope, (IOBase, bytes)):
            _content = worker_pool_envelope
        else:
            _content = json.dumps(worker_pool_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_environments_create_or_update_worker_pool_request(
            resource_group_name=resource_group_name,
            name=name,
            worker_pool_name=worker_pool_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update_worker_pool(
        self,
        resource_group_name: str,
        name: str,
        worker_pool_name: str,
        worker_pool_envelope: _models.WorkerPoolResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkerPoolResource]:
        """Create or update a worker pool.

        Description for Create or update a worker pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :param worker_pool_envelope: Properties of the worker pool. Required.
        :type worker_pool_envelope: ~azure.mgmt.web.models.WorkerPoolResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkerPoolResource. The WorkerPoolResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.WorkerPoolResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_worker_pool(
        self,
        resource_group_name: str,
        name: str,
        worker_pool_name: str,
        worker_pool_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkerPoolResource]:
        """Create or update a worker pool.

        Description for Create or update a worker pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :param worker_pool_envelope: Properties of the worker pool. Required.
        :type worker_pool_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkerPoolResource. The WorkerPoolResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.WorkerPoolResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_worker_pool(
        self,
        resource_group_name: str,
        name: str,
        worker_pool_name: str,
        worker_pool_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkerPoolResource]:
        """Create or update a worker pool.

        Description for Create or update a worker pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :param worker_pool_envelope: Properties of the worker pool. Required.
        :type worker_pool_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkerPoolResource. The WorkerPoolResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.WorkerPoolResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update_worker_pool(
        self,
        resource_group_name: str,
        name: str,
        worker_pool_name: str,
        worker_pool_envelope: Union[_models.WorkerPoolResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkerPoolResource]:
        """Create or update a worker pool.

        Description for Create or update a worker pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :param worker_pool_envelope: Properties of the worker pool. Is one of the following types:
         WorkerPoolResource, JSON, IO[bytes] Required.
        :type worker_pool_envelope: ~azure.mgmt.web.models.WorkerPoolResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkerPoolResource. The WorkerPoolResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.WorkerPoolResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkerPoolResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_worker_pool_initial(
                resource_group_name=resource_group_name,
                name=name,
                worker_pool_name=worker_pool_name,
                worker_pool_envelope=worker_pool_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkerPoolResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkerPoolResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkerPoolResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update_worker_pool(
        self,
        resource_group_name: str,
        name: str,
        worker_pool_name: str,
        worker_pool_envelope: _models.WorkerPoolResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkerPoolResource:
        """Create or update a worker pool.

        Description for Create or update a worker pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :param worker_pool_envelope: Properties of the worker pool. Required.
        :type worker_pool_envelope: ~azure.mgmt.web.models.WorkerPoolResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkerPoolResource. The WorkerPoolResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkerPoolResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_worker_pool(
        self,
        resource_group_name: str,
        name: str,
        worker_pool_name: str,
        worker_pool_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkerPoolResource:
        """Create or update a worker pool.

        Description for Create or update a worker pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :param worker_pool_envelope: Properties of the worker pool. Required.
        :type worker_pool_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkerPoolResource. The WorkerPoolResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkerPoolResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_worker_pool(
        self,
        resource_group_name: str,
        name: str,
        worker_pool_name: str,
        worker_pool_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkerPoolResource:
        """Create or update a worker pool.

        Description for Create or update a worker pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :param worker_pool_envelope: Properties of the worker pool. Required.
        :type worker_pool_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkerPoolResource. The WorkerPoolResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkerPoolResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_worker_pool(
        self,
        resource_group_name: str,
        name: str,
        worker_pool_name: str,
        worker_pool_envelope: Union[_models.WorkerPoolResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.WorkerPoolResource:
        """Create or update a worker pool.

        Description for Create or update a worker pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :param worker_pool_envelope: Properties of the worker pool. Is one of the following types:
         WorkerPoolResource, JSON, IO[bytes] Required.
        :type worker_pool_envelope: ~azure.mgmt.web.models.WorkerPoolResource or JSON or IO[bytes]
        :return: WorkerPoolResource. The WorkerPoolResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkerPoolResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkerPoolResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(worker_pool_envelope, (IOBase, bytes)):
            _content = worker_pool_envelope
        else:
            _content = json.dumps(worker_pool_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_environments_update_worker_pool_request(
            resource_group_name=resource_group_name,
            name=name,
            worker_pool_name=worker_pool_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkerPoolResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_worker_pools(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.WorkerPoolResource"]:
        """Get all worker pools of an App Service Environment.

        Description for Get all worker pools of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An iterator like instance of WorkerPoolResource
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WorkerPoolResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkerPoolResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_worker_pools_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkerPoolResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_worker_pool_instance_metric_definitions(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, worker_pool_name: str, instance: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ResourceMetricDefinition"]:
        """Get metric definitions for a specific instance of a worker pool of an App Service Environment.

        Description for Get metric definitions for a specific instance of a worker pool of an App
        Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :param instance: Name of the instance in the worker pool. Required.
        :type instance: str
        :return: An iterator like instance of ResourceMetricDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ResourceMetricDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ResourceMetricDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_worker_pool_instance_metric_definitions_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    worker_pool_name=worker_pool_name,
                    instance=instance,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ResourceMetricDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_web_worker_metric_definitions(
        self, resource_group_name: str, name: str, worker_pool_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ResourceMetricDefinition"]:
        """Get metric definitions for a worker pool of an App Service Environment.

        Description for Get metric definitions for a worker pool of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :return: An iterator like instance of ResourceMetricDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ResourceMetricDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ResourceMetricDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_web_worker_metric_definitions_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    worker_pool_name=worker_pool_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ResourceMetricDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_worker_pool_skus(
        self, resource_group_name: str, name: str, worker_pool_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.SkuInfo"]:
        """Get available SKUs for scaling a worker pool.

        Description for Get available SKUs for scaling a worker pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :return: An iterator like instance of SkuInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SkuInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SkuInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_worker_pool_skus_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    worker_pool_name=worker_pool_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SkuInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_web_worker_usages(
        self, resource_group_name: str, name: str, worker_pool_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.Usage"]:
        """Get usage metrics for a worker pool of an App Service Environment.

        Description for Get usage metrics for a worker pool of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param worker_pool_name: Name of the worker pool. Required.
        :type worker_pool_name: str
        :return: An iterator like instance of Usage
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Usage]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Usage]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_web_worker_usages_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    worker_pool_name=worker_pool_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Usage], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.AppServiceEnvironmentResource:
        """Get the properties of an App Service Environment.

        Description for Get the properties of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: AppServiceEnvironmentResource. The AppServiceEnvironmentResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.AppServiceEnvironmentResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AppServiceEnvironmentResource] = kwargs.pop("cls", None)

        _request = build_app_service_environments_get_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AppServiceEnvironmentResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        name: str,
        hosting_environment_envelope: Union[_models.AppServiceEnvironmentResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(hosting_environment_envelope, (IOBase, bytes)):
            _content = hosting_environment_envelope
        else:
            _content = json.dumps(hosting_environment_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_environments_create_or_update_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        hosting_environment_envelope: _models.AppServiceEnvironmentResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AppServiceEnvironmentResource]:
        """Create or update an App Service Environment.

        Description for Create or update an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param hosting_environment_envelope: Configuration details of the App Service Environment.
         Required.
        :type hosting_environment_envelope: ~azure.mgmt.web.models.AppServiceEnvironmentResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns AppServiceEnvironmentResource. The
         AppServiceEnvironmentResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.AppServiceEnvironmentResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        hosting_environment_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AppServiceEnvironmentResource]:
        """Create or update an App Service Environment.

        Description for Create or update an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param hosting_environment_envelope: Configuration details of the App Service Environment.
         Required.
        :type hosting_environment_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns AppServiceEnvironmentResource. The
         AppServiceEnvironmentResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.AppServiceEnvironmentResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        hosting_environment_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AppServiceEnvironmentResource]:
        """Create or update an App Service Environment.

        Description for Create or update an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param hosting_environment_envelope: Configuration details of the App Service Environment.
         Required.
        :type hosting_environment_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns AppServiceEnvironmentResource. The
         AppServiceEnvironmentResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.AppServiceEnvironmentResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        hosting_environment_envelope: Union[_models.AppServiceEnvironmentResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AppServiceEnvironmentResource]:
        """Create or update an App Service Environment.

        Description for Create or update an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param hosting_environment_envelope: Configuration details of the App Service Environment. Is
         one of the following types: AppServiceEnvironmentResource, JSON, IO[bytes] Required.
        :type hosting_environment_envelope: ~azure.mgmt.web.models.AppServiceEnvironmentResource or
         JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns AppServiceEnvironmentResource. The
         AppServiceEnvironmentResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.AppServiceEnvironmentResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AppServiceEnvironmentResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                name=name,
                hosting_environment_envelope=hosting_environment_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.AppServiceEnvironmentResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.AppServiceEnvironmentResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.AppServiceEnvironmentResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        hosting_environment_envelope: _models.AppServiceEnvironmentPatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AppServiceEnvironmentResource:
        """Create or update an App Service Environment.

        Description for Create or update an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param hosting_environment_envelope: Configuration details of the App Service Environment.
         Required.
        :type hosting_environment_envelope: ~azure.mgmt.web.models.AppServiceEnvironmentPatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AppServiceEnvironmentResource. The AppServiceEnvironmentResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.AppServiceEnvironmentResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        hosting_environment_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AppServiceEnvironmentResource:
        """Create or update an App Service Environment.

        Description for Create or update an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param hosting_environment_envelope: Configuration details of the App Service Environment.
         Required.
        :type hosting_environment_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AppServiceEnvironmentResource. The AppServiceEnvironmentResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.AppServiceEnvironmentResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        hosting_environment_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AppServiceEnvironmentResource:
        """Create or update an App Service Environment.

        Description for Create or update an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param hosting_environment_envelope: Configuration details of the App Service Environment.
         Required.
        :type hosting_environment_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AppServiceEnvironmentResource. The AppServiceEnvironmentResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.AppServiceEnvironmentResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        name: str,
        hosting_environment_envelope: Union[_models.AppServiceEnvironmentPatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.AppServiceEnvironmentResource:
        """Create or update an App Service Environment.

        Description for Create or update an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param hosting_environment_envelope: Configuration details of the App Service Environment. Is
         one of the following types: AppServiceEnvironmentPatchResource, JSON, IO[bytes] Required.
        :type hosting_environment_envelope: ~azure.mgmt.web.models.AppServiceEnvironmentPatchResource
         or JSON or IO[bytes]
        :return: AppServiceEnvironmentResource. The AppServiceEnvironmentResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.AppServiceEnvironmentResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AppServiceEnvironmentResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(hosting_environment_envelope, (IOBase, bytes)):
            _content = hosting_environment_envelope
        else:
            _content = json.dumps(hosting_environment_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_environments_update_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AppServiceEnvironmentResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _delete_initial(
        self, resource_group_name: str, name: str, *, force_delete: Optional[bool] = None, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_app_service_environments_delete_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            force_delete=force_delete,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, name: str, *, force_delete: Optional[bool] = None, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete an App Service Environment.

        Description for Delete an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :keyword force_delete: Specify <code>true</code> to force the deletion even if the App Service
         Environment contains resources. The default is <code>false</code>. Default value is None.
        :paramtype force_delete: bool
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(
                resource_group_name=resource_group_name,
                name=name,
                force_delete=force_delete,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_by_resource_group(
        self, resource_group_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.AppServiceEnvironmentResource"]:
        """Get all App Service Environments in a resource group.

        Description for Get all App Service Environments in a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of AppServiceEnvironmentResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.AppServiceEnvironmentResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AppServiceEnvironmentResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AppServiceEnvironmentResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncItemPaged["_models.AppServiceEnvironmentResource"]:
        """Get all App Service Environments for a subscription.

        Description for Get all App Service Environments for a subscription.

        :return: An iterator like instance of AppServiceEnvironmentResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.AppServiceEnvironmentResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AppServiceEnvironmentResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AppServiceEnvironmentResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_capacities(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StampCapacity"]:
        """Get the used, available, and total worker capacity an App Service Environment.

        Description for Get the used, available, and total worker capacity an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An iterator like instance of StampCapacity
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StampCapacity]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StampCapacity]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_capacities_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.StampCapacity], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _change_vnet_initial(
        self,
        resource_group_name: str,
        name: str,
        vnet_info: Union[_models.VirtualNetworkProfile, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(vnet_info, (IOBase, bytes)):
            _content = vnet_info
        else:
            _content = json.dumps(vnet_info, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_environments_change_vnet_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_change_vnet(
        self,
        resource_group_name: str,
        name: str,
        vnet_info: _models.VirtualNetworkProfile,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[AsyncItemPaged["_models.Site"]]:
        """Move an App Service Environment to a different VNET.

        Description for Move an App Service Environment to a different VNET.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param vnet_info: Details for the new virtual network. Required.
        :type vnet_info: ~azure.mgmt.web.models.VirtualNetworkProfile
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns an iterator like instance of list of Site
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Site]]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_change_vnet(
        self,
        resource_group_name: str,
        name: str,
        vnet_info: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[AsyncItemPaged["_models.Site"]]:
        """Move an App Service Environment to a different VNET.

        Description for Move an App Service Environment to a different VNET.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param vnet_info: Details for the new virtual network. Required.
        :type vnet_info: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns an iterator like instance of list of Site
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Site]]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_change_vnet(
        self,
        resource_group_name: str,
        name: str,
        vnet_info: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[AsyncItemPaged["_models.Site"]]:
        """Move an App Service Environment to a different VNET.

        Description for Move an App Service Environment to a different VNET.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param vnet_info: Details for the new virtual network. Required.
        :type vnet_info: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns an iterator like instance of list of Site
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Site]]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_change_vnet(
        self,
        resource_group_name: str,
        name: str,
        vnet_info: Union[_models.VirtualNetworkProfile, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[AsyncItemPaged["_models.Site"]]:
        """Move an App Service Environment to a different VNET.

        Description for Move an App Service Environment to a different VNET.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param vnet_info: Details for the new virtual network. Is one of the following types:
         VirtualNetworkProfile, JSON, IO[bytes] Required.
        :type vnet_info: ~azure.mgmt.web.models.VirtualNetworkProfile or JSON or IO[bytes]
        :return: An instance of LROPoller that returns an iterator like instance of list of Site
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Site]]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.Site]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})
        content_type = content_type or "application/json"
        _content = None
        if isinstance(vnet_info, (IOBase, bytes)):
            _content = vnet_info
        else:
            _content = json.dumps(vnet_info, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_change_vnet_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    content_type=content_type,
                    api_version=self._config.api_version,
                    content=_content,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Site], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._change_vnet_initial(
                resource_group_name=resource_group_name,
                name=name,
                vnet_info=vnet_info,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            async def internal_get_next(next_link=None):
                if next_link is None:
                    return pipeline_response
                return await get_next(next_link)

            return AsyncItemPaged(internal_get_next, extract_data)

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[AsyncItemPaged["_models.Site"]].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[AsyncItemPaged["_models.Site"]](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def list_diagnostics(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> List[_models.HostingEnvironmentDiagnostics]:
        """Get diagnostic information for an App Service Environment.

        Description for Get diagnostic information for an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: list of HostingEnvironmentDiagnostics
        :rtype: list[~azure.mgmt.web.models.HostingEnvironmentDiagnostics]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.HostingEnvironmentDiagnostics]] = kwargs.pop("cls", None)

        _request = build_app_service_environments_list_diagnostics_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.HostingEnvironmentDiagnostics], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_diagnostics_item(
        self, resource_group_name: str, name: str, diagnostics_name: str, **kwargs: Any
    ) -> _models.HostingEnvironmentDiagnostics:
        """Get a diagnostics item for an App Service Environment.

        Description for Get a diagnostics item for an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param diagnostics_name: Required.
        :type diagnostics_name: str
        :return: HostingEnvironmentDiagnostics. The HostingEnvironmentDiagnostics is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.HostingEnvironmentDiagnostics
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HostingEnvironmentDiagnostics] = kwargs.pop("cls", None)

        _request = build_app_service_environments_get_diagnostics_item_request(
            resource_group_name=resource_group_name,
            name=name,
            diagnostics_name=diagnostics_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HostingEnvironmentDiagnostics, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_inbound_network_dependencies_endpoints(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.InboundEnvironmentEndpoint"]:
        """Get the network endpoints of all inbound dependencies of an App Service Environment.

        Description for Get the network endpoints of all inbound dependencies of an App Service
        Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An iterator like instance of InboundEnvironmentEndpoint
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.InboundEnvironmentEndpoint]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.InboundEnvironmentEndpoint]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_get_inbound_network_dependencies_endpoints_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.InboundEnvironmentEndpoint], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def test_upgrade_available_notification(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Send a test notification that an upgrade is available for this App Service Environment.

        Send a test notification that an upgrade is available for this App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_app_service_environments_test_upgrade_available_notification_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    async def _upgrade_initial(self, resource_group_name: str, name: str, **kwargs: Any) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_app_service_environments_upgrade_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_upgrade(self, resource_group_name: str, name: str, **kwargs: Any) -> AsyncLROPoller[None]:
        """Initiate an upgrade of an App Service Environment if one is available.

        Description for Initiate an upgrade of an App Service Environment if one is available.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._upgrade_initial(
                resource_group_name=resource_group_name,
                name=name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def list_operations(self, resource_group_name: str, name: str, **kwargs: Any) -> List[_models.Operation]:
        """List all currently running operations on the App Service Environment.

        Description for List all currently running operations on the App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: list of Operation
        :rtype: list[~azure.mgmt.web.models.Operation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Operation]] = kwargs.pop("cls", None)

        _request = build_app_service_environments_list_operations_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.Operation], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_outbound_network_dependencies_endpoints(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.OutboundEnvironmentEndpoint"]:
        """Get the network endpoints of all outbound dependencies of an App Service Environment.

        Description for Get the network endpoints of all outbound dependencies of an App Service
        Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An iterator like instance of OutboundEnvironmentEndpoint
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.OutboundEnvironmentEndpoint]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.OutboundEnvironmentEndpoint]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_get_outbound_network_dependencies_endpoints_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.OutboundEnvironmentEndpoint], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_private_link_resources(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.PrivateLinkResourcesWrapper:
        """Gets the private link resources.

        Description for Gets the private link resources.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: PrivateLinkResourcesWrapper. The PrivateLinkResourcesWrapper is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateLinkResourcesWrapper
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PrivateLinkResourcesWrapper] = kwargs.pop("cls", None)

        _request = build_app_service_environments_get_private_link_resources_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PrivateLinkResourcesWrapper, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def reboot(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Reboot all machines in an App Service Environment.

        Description for Reboot all machines in an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_app_service_environments_reboot_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    async def _resume_initial(self, resource_group_name: str, name: str, **kwargs: Any) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_app_service_environments_resume_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_resume(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncLROPoller[AsyncItemPaged["_models.Site"]]:
        """Resume an App Service Environment.

        Description for Resume an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An instance of LROPoller that returns an iterator like instance of list of Site
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Site]]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Site]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_resume_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Site], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._resume_initial(
                resource_group_name=resource_group_name,
                name=name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            async def internal_get_next(next_link=None):
                if next_link is None:
                    return pipeline_response
                return await get_next(next_link)

            return AsyncItemPaged(internal_get_next, extract_data)

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[AsyncItemPaged["_models.Site"]].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[AsyncItemPaged["_models.Site"]](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def list_app_service_plans(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.AppServicePlan"]:
        """Get all App Service plans in an App Service Environment.

        Description for Get all App Service plans in an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An iterator like instance of AppServicePlan
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.AppServicePlan]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AppServicePlan]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_app_service_plans_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AppServicePlan], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_web_apps(
        self, resource_group_name: str, name: str, *, properties_to_include: Optional[str] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.Site"]:
        """Get all apps in an App Service Environment.

        Description for Get all apps in an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :keyword properties_to_include: Comma separated list of app properties to include. Default
         value is None.
        :paramtype properties_to_include: str
        :return: An iterator like instance of Site
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Site]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_web_apps_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    properties_to_include=properties_to_include,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Site], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _suspend_initial(self, resource_group_name: str, name: str, **kwargs: Any) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_app_service_environments_suspend_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_suspend(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncLROPoller[AsyncItemPaged["_models.Site"]]:
        """Suspend an App Service Environment.

        Description for Suspend an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An instance of LROPoller that returns an iterator like instance of list of Site
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Site]]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Site]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_suspend_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Site], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._suspend_initial(
                resource_group_name=resource_group_name,
                name=name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            async def internal_get_next(next_link=None):
                if next_link is None:
                    return pipeline_response
                return await get_next(next_link)

            return AsyncItemPaged(internal_get_next, extract_data)

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[AsyncItemPaged["_models.Site"]].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[AsyncItemPaged["_models.Site"]](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def list_usages(
        self, resource_group_name: str, name: str, *, filter: Optional[str] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.CsmUsageQuota"]:
        """Get global usage metrics of an App Service Environment.

        Description for Get global usage metrics of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :keyword filter: Return only usages/metrics specified in the filter. Filter conforms to odata
         syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq
         2014-01-01T00:00:00Z and endTime eq 2014-12-31T23:59:59Z and timeGrain eq
         duration'[Hour|Minute|Day]'. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of CsmUsageQuota
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.CsmUsageQuota]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CsmUsageQuota]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_usages_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CsmUsageQuota], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_vip_info(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.AddressResponse:
        """Get IP addresses assigned to an App Service Environment.

        Description for Get IP addresses assigned to an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: AddressResponse. The AddressResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AddressResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AddressResponse] = kwargs.pop("cls", None)

        _request = build_app_service_environments_get_vip_info_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddressResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_ase_custom_dns_suffix_configuration(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.CustomDnsSuffixConfiguration:
        """Get Custom Dns Suffix configuration of an App Service Environment.

        Get Custom Dns Suffix configuration of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: CustomDnsSuffixConfiguration. The CustomDnsSuffixConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.CustomDnsSuffixConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CustomDnsSuffixConfiguration] = kwargs.pop("cls", None)

        _request = build_app_service_environments_get_ase_custom_dns_suffix_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CustomDnsSuffixConfiguration, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_ase_custom_dns_suffix_configuration(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        custom_dns_suffix_configuration: _models.CustomDnsSuffixConfiguration,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CustomDnsSuffixConfiguration:
        """Update Custom Dns Suffix configuration of an App Service Environment.

        Update Custom Dns Suffix configuration of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param custom_dns_suffix_configuration: Required.
        :type custom_dns_suffix_configuration: ~azure.mgmt.web.models.CustomDnsSuffixConfiguration
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CustomDnsSuffixConfiguration. The CustomDnsSuffixConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.CustomDnsSuffixConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_ase_custom_dns_suffix_configuration(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        custom_dns_suffix_configuration: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CustomDnsSuffixConfiguration:
        """Update Custom Dns Suffix configuration of an App Service Environment.

        Update Custom Dns Suffix configuration of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param custom_dns_suffix_configuration: Required.
        :type custom_dns_suffix_configuration: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CustomDnsSuffixConfiguration. The CustomDnsSuffixConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.CustomDnsSuffixConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_ase_custom_dns_suffix_configuration(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        custom_dns_suffix_configuration: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CustomDnsSuffixConfiguration:
        """Update Custom Dns Suffix configuration of an App Service Environment.

        Update Custom Dns Suffix configuration of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param custom_dns_suffix_configuration: Required.
        :type custom_dns_suffix_configuration: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CustomDnsSuffixConfiguration. The CustomDnsSuffixConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.CustomDnsSuffixConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_ase_custom_dns_suffix_configuration(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        custom_dns_suffix_configuration: Union[_models.CustomDnsSuffixConfiguration, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.CustomDnsSuffixConfiguration:
        """Update Custom Dns Suffix configuration of an App Service Environment.

        Update Custom Dns Suffix configuration of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param custom_dns_suffix_configuration: Is one of the following types:
         CustomDnsSuffixConfiguration, JSON, IO[bytes] Required.
        :type custom_dns_suffix_configuration: ~azure.mgmt.web.models.CustomDnsSuffixConfiguration or
         JSON or IO[bytes]
        :return: CustomDnsSuffixConfiguration. The CustomDnsSuffixConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.CustomDnsSuffixConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CustomDnsSuffixConfiguration] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(custom_dns_suffix_configuration, (IOBase, bytes)):
            _content = custom_dns_suffix_configuration
        else:
            _content = json.dumps(custom_dns_suffix_configuration, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_environments_update_ase_custom_dns_suffix_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CustomDnsSuffixConfiguration, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_ase_custom_dns_suffix_configuration(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> Any:
        """Delete Custom Dns Suffix configuration of an App Service Environment.

        Delete Custom Dns Suffix configuration of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_app_service_environments_delete_ase_custom_dns_suffix_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Any, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_ase_v3_networking_configuration(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.AseV3NetworkingConfiguration:
        """Get networking configuration of an App Service Environment.

        Description for Get networking configuration of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: AseV3NetworkingConfiguration. The AseV3NetworkingConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.AseV3NetworkingConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AseV3NetworkingConfiguration] = kwargs.pop("cls", None)

        _request = build_app_service_environments_get_ase_v3_networking_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AseV3NetworkingConfiguration, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_ase_networking_configuration(
        self,
        resource_group_name: str,
        name: str,
        ase_networking_configuration: _models.AseV3NetworkingConfiguration,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AseV3NetworkingConfiguration:
        """Update networking configuration of an App Service Environment.

        Description for Update networking configuration of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param ase_networking_configuration: Required.
        :type ase_networking_configuration: ~azure.mgmt.web.models.AseV3NetworkingConfiguration
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AseV3NetworkingConfiguration. The AseV3NetworkingConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.AseV3NetworkingConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_ase_networking_configuration(
        self,
        resource_group_name: str,
        name: str,
        ase_networking_configuration: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AseV3NetworkingConfiguration:
        """Update networking configuration of an App Service Environment.

        Description for Update networking configuration of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param ase_networking_configuration: Required.
        :type ase_networking_configuration: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AseV3NetworkingConfiguration. The AseV3NetworkingConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.AseV3NetworkingConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_ase_networking_configuration(
        self,
        resource_group_name: str,
        name: str,
        ase_networking_configuration: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AseV3NetworkingConfiguration:
        """Update networking configuration of an App Service Environment.

        Description for Update networking configuration of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param ase_networking_configuration: Required.
        :type ase_networking_configuration: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AseV3NetworkingConfiguration. The AseV3NetworkingConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.AseV3NetworkingConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_ase_networking_configuration(
        self,
        resource_group_name: str,
        name: str,
        ase_networking_configuration: Union[_models.AseV3NetworkingConfiguration, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.AseV3NetworkingConfiguration:
        """Update networking configuration of an App Service Environment.

        Description for Update networking configuration of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param ase_networking_configuration: Is one of the following types:
         AseV3NetworkingConfiguration, JSON, IO[bytes] Required.
        :type ase_networking_configuration: ~azure.mgmt.web.models.AseV3NetworkingConfiguration or JSON
         or IO[bytes]
        :return: AseV3NetworkingConfiguration. The AseV3NetworkingConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.AseV3NetworkingConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AseV3NetworkingConfiguration] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(ase_networking_configuration, (IOBase, bytes)):
            _content = ase_networking_configuration
        else:
            _content = json.dumps(ase_networking_configuration, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_environments_update_ase_networking_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AseV3NetworkingConfiguration, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_multi_role_pool(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.WorkerPoolResource:
        """Get properties of a multi-role pool.

        Description for Get properties of a multi-role pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: WorkerPoolResource. The WorkerPoolResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkerPoolResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkerPoolResource] = kwargs.pop("cls", None)

        _request = build_app_service_environments_get_multi_role_pool_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkerPoolResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_multi_role_pool_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        multi_role_pool_envelope: Union[_models.WorkerPoolResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(multi_role_pool_envelope, (IOBase, bytes)):
            _content = multi_role_pool_envelope
        else:
            _content = json.dumps(multi_role_pool_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_environments_create_or_update_multi_role_pool_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update_multi_role_pool(
        self,
        resource_group_name: str,
        name: str,
        multi_role_pool_envelope: _models.WorkerPoolResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkerPoolResource]:
        """Create or update a multi-role pool.

        Description for Create or update a multi-role pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param multi_role_pool_envelope: Properties of the multi-role pool. Required.
        :type multi_role_pool_envelope: ~azure.mgmt.web.models.WorkerPoolResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkerPoolResource. The WorkerPoolResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.WorkerPoolResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_multi_role_pool(
        self,
        resource_group_name: str,
        name: str,
        multi_role_pool_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkerPoolResource]:
        """Create or update a multi-role pool.

        Description for Create or update a multi-role pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param multi_role_pool_envelope: Properties of the multi-role pool. Required.
        :type multi_role_pool_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkerPoolResource. The WorkerPoolResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.WorkerPoolResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_multi_role_pool(
        self,
        resource_group_name: str,
        name: str,
        multi_role_pool_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkerPoolResource]:
        """Create or update a multi-role pool.

        Description for Create or update a multi-role pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param multi_role_pool_envelope: Properties of the multi-role pool. Required.
        :type multi_role_pool_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkerPoolResource. The WorkerPoolResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.WorkerPoolResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update_multi_role_pool(
        self,
        resource_group_name: str,
        name: str,
        multi_role_pool_envelope: Union[_models.WorkerPoolResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkerPoolResource]:
        """Create or update a multi-role pool.

        Description for Create or update a multi-role pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param multi_role_pool_envelope: Properties of the multi-role pool. Is one of the following
         types: WorkerPoolResource, JSON, IO[bytes] Required.
        :type multi_role_pool_envelope: ~azure.mgmt.web.models.WorkerPoolResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkerPoolResource. The WorkerPoolResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.WorkerPoolResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkerPoolResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_multi_role_pool_initial(
                resource_group_name=resource_group_name,
                name=name,
                multi_role_pool_envelope=multi_role_pool_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkerPoolResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkerPoolResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkerPoolResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update_multi_role_pool(
        self,
        resource_group_name: str,
        name: str,
        multi_role_pool_envelope: _models.WorkerPoolResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkerPoolResource:
        """Create or update a multi-role pool.

        Description for Create or update a multi-role pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param multi_role_pool_envelope: Properties of the multi-role pool. Required.
        :type multi_role_pool_envelope: ~azure.mgmt.web.models.WorkerPoolResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkerPoolResource. The WorkerPoolResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkerPoolResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_multi_role_pool(
        self,
        resource_group_name: str,
        name: str,
        multi_role_pool_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkerPoolResource:
        """Create or update a multi-role pool.

        Description for Create or update a multi-role pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param multi_role_pool_envelope: Properties of the multi-role pool. Required.
        :type multi_role_pool_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkerPoolResource. The WorkerPoolResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkerPoolResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_multi_role_pool(
        self,
        resource_group_name: str,
        name: str,
        multi_role_pool_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkerPoolResource:
        """Create or update a multi-role pool.

        Description for Create or update a multi-role pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param multi_role_pool_envelope: Properties of the multi-role pool. Required.
        :type multi_role_pool_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkerPoolResource. The WorkerPoolResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkerPoolResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_multi_role_pool(
        self,
        resource_group_name: str,
        name: str,
        multi_role_pool_envelope: Union[_models.WorkerPoolResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.WorkerPoolResource:
        """Create or update a multi-role pool.

        Description for Create or update a multi-role pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param multi_role_pool_envelope: Properties of the multi-role pool. Is one of the following
         types: WorkerPoolResource, JSON, IO[bytes] Required.
        :type multi_role_pool_envelope: ~azure.mgmt.web.models.WorkerPoolResource or JSON or IO[bytes]
        :return: WorkerPoolResource. The WorkerPoolResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkerPoolResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkerPoolResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(multi_role_pool_envelope, (IOBase, bytes)):
            _content = multi_role_pool_envelope
        else:
            _content = json.dumps(multi_role_pool_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_environments_update_multi_role_pool_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkerPoolResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_multi_role_pools(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.WorkerPoolResource"]:
        """Get all multi-role pools.

        Description for Get all multi-role pools.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An iterator like instance of WorkerPoolResource
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WorkerPoolResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkerPoolResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_multi_role_pools_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkerPoolResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_multi_role_pool_instance_metric_definitions(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, instance: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ResourceMetricDefinition"]:
        """Get metric definitions for a specific instance of a multi-role pool of an App Service
        Environment.

        Description for Get metric definitions for a specific instance of a multi-role pool of an App
        Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param instance: Name of the instance in the multi-role pool. Required.
        :type instance: str
        :return: An iterator like instance of ResourceMetricDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ResourceMetricDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ResourceMetricDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_multi_role_pool_instance_metric_definitions_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    instance=instance,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ResourceMetricDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_multi_role_metric_definitions(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ResourceMetricDefinition"]:
        """Get metric definitions for a multi-role pool of an App Service Environment.

        Description for Get metric definitions for a multi-role pool of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An iterator like instance of ResourceMetricDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ResourceMetricDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ResourceMetricDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_multi_role_metric_definitions_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ResourceMetricDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_multi_role_pool_skus(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.SkuInfo"]:
        """Get available SKUs for scaling a multi-role pool.

        Description for Get available SKUs for scaling a multi-role pool.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An iterator like instance of SkuInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SkuInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SkuInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_multi_role_pool_skus_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SkuInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_multi_role_usages(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.Usage"]:
        """Get usage metrics for a multi-role pool of an App Service Environment.

        Description for Get usage metrics for a multi-role pool of an App Service Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An iterator like instance of Usage
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Usage]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Usage]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_list_multi_role_usages_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Usage], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_private_endpoint_connection(
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> _models.RemotePrivateEndpointConnectionARMResource:
        """Gets a private endpoint connection.

        Description for Gets a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :return: RemotePrivateEndpointConnectionARMResource. The
         RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RemotePrivateEndpointConnectionARMResource] = kwargs.pop("cls", None)

        _request = build_app_service_environments_get_private_endpoint_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RemotePrivateEndpointConnectionARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _approve_or_reject_private_endpoint_connection_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: Union[_models.RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(private_endpoint_wrapper, (IOBase, bytes)):
            _content = private_endpoint_wrapper
        else:
            _content = json.dumps(private_endpoint_wrapper, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_environments_approve_or_reject_private_endpoint_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: _models.RemotePrivateEndpointConnectionARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Required.
        :type private_endpoint_wrapper:
         ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Required.
        :type private_endpoint_wrapper: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Required.
        :type private_endpoint_wrapper: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: Union[_models.RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Is one of the following types:
         RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes] Required.
        :type private_endpoint_wrapper:
         ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RemotePrivateEndpointConnectionARMResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._approve_or_reject_private_endpoint_connection_initial(
                resource_group_name=resource_group_name,
                name=name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                private_endpoint_wrapper=private_endpoint_wrapper,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.RemotePrivateEndpointConnectionARMResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_private_endpoint_connection_initial(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_app_service_environments_delete_private_endpoint_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_delete_private_endpoint_connection(
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes a private endpoint connection.

        Description for Deletes a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_private_endpoint_connection_initial(
                resource_group_name=resource_group_name,
                name=name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_private_endpoint_connection_list(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.RemotePrivateEndpointConnectionARMResource"]:
        """Gets the list of private endpoints associated with a hosting environment.

        Description for Gets the list of private endpoints associated with a hosting environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service Environment. Required.
        :type name: str
        :return: An iterator like instance of RemotePrivateEndpointConnectionARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.RemotePrivateEndpointConnectionARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_environments_get_private_endpoint_connection_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.RemotePrivateEndpointConnectionARMResource], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class RecommendationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`recommendations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_rule_details_by_web_app(
        self,
        resource_group_name: str,
        site_name: str,
        name: str,
        *,
        update_seen: Optional[bool] = None,
        recommendation_id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.RecommendationRule:
        """Get a recommendation rule for an app.

        Description for Get a recommendation rule for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Name of the app. Required.
        :type site_name: str
        :param name: Name of the recommendation. Required.
        :type name: str
        :keyword update_seen: Specify <code>true</code> to update the last-seen timestamp of the
         recommendation object. Default value is None.
        :paramtype update_seen: bool
        :keyword recommendation_id: The GUID of the recommendation object if you query an expired one.
         You don't need to specify it to query an active entry. Default value is None.
        :paramtype recommendation_id: str
        :return: RecommendationRule. The RecommendationRule is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RecommendationRule
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RecommendationRule] = kwargs.pop("cls", None)

        _request = build_recommendations_get_rule_details_by_web_app_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            name=name,
            subscription_id=self._config.subscription_id,
            update_seen=update_seen,
            recommendation_id=recommendation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RecommendationRule, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def disable_recommendation_for_site(
        self, resource_group_name: str, site_name: str, name: str, **kwargs: Any
    ) -> None:
        """Disables the specific rule for a web site permanently.

        Description for Disables the specific rule for a web site permanently.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Name of the app. Required.
        :type site_name: str
        :param name: Name of the recommendation. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_recommendations_disable_recommendation_for_site_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_history_for_hosting_environment(
        self,
        resource_group_name: str,
        hosting_environment_name: str,
        *,
        expired_only: Optional[bool] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.Recommendation"]:
        """Get past recommendations for an app, optionally specified by the time range.

        Description for Get past recommendations for an app, optionally specified by the time range.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param hosting_environment_name: Name of the App Service Environment. Required.
        :type hosting_environment_name: str
        :keyword expired_only: Specify <code>false</code> to return all recommendations. The default is
         <code>true</code>, which returns only expired recommendations. Default value is None.
        :paramtype expired_only: bool
        :keyword filter: Filter is specified by using OData syntax. Example: $filter=channel eq 'Api'
         or channel eq 'Notification' and startTime eq 2014-01-01T00:00:00Z and endTime eq
         2014-12-31T23:59:59Z and timeGrain eq duration'[PT1H|PT1M|P1D]. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of Recommendation
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Recommendation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Recommendation]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_recommendations_list_history_for_hosting_environment_request(
                    resource_group_name=resource_group_name,
                    hosting_environment_name=hosting_environment_name,
                    subscription_id=self._config.subscription_id,
                    expired_only=expired_only,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Recommendation], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_recommended_rules_for_hosting_environment(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        hosting_environment_name: str,
        *,
        featured: Optional[bool] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.Recommendation"]:
        """Get all recommendations for a hosting environment.

        Description for Get all recommendations for a hosting environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param hosting_environment_name: Name of the App Service Environment. Required.
        :type hosting_environment_name: str
        :keyword featured: Specify <code>true</code> to return only the most critical recommendations.
         The default is <code>false</code>, which returns all recommendations. Default value is None.
        :paramtype featured: bool
        :keyword filter: Return only channels specified in the filter. Filter is specified by using
         OData syntax. Example: $filter=channel eq 'Api' or channel eq 'Notification'. Default value is
         None.
        :paramtype filter: str
        :return: An iterator like instance of Recommendation
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Recommendation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Recommendation]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_recommendations_list_recommended_rules_for_hosting_environment_request(
                    resource_group_name=resource_group_name,
                    hosting_environment_name=hosting_environment_name,
                    subscription_id=self._config.subscription_id,
                    featured=featured,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Recommendation], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def disable_all_for_hosting_environment(
        self, resource_group_name: str, hosting_environment_name: str, *, environment_name: str, **kwargs: Any
    ) -> None:
        """Disable all recommendations for an app.

        Description for Disable all recommendations for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param hosting_environment_name: Name of the App Service Environment. Required.
        :type hosting_environment_name: str
        :keyword environment_name: Name of the app. Required.
        :paramtype environment_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_recommendations_disable_all_for_hosting_environment_request(
            resource_group_name=resource_group_name,
            hosting_environment_name=hosting_environment_name,
            subscription_id=self._config.subscription_id,
            environment_name=environment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def reset_all_filters_for_hosting_environment(  # pylint: disable=name-too-long
        self, resource_group_name: str, hosting_environment_name: str, *, environment_name: str, **kwargs: Any
    ) -> None:
        """Reset all recommendation opt-out settings for an app.

        Description for Reset all recommendation opt-out settings for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param hosting_environment_name: Name of the App Service Environment. Required.
        :type hosting_environment_name: str
        :keyword environment_name: Name of the app. Required.
        :paramtype environment_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_recommendations_reset_all_filters_for_hosting_environment_request(
            resource_group_name=resource_group_name,
            hosting_environment_name=hosting_environment_name,
            subscription_id=self._config.subscription_id,
            environment_name=environment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_rule_details_by_hosting_environment(
        self,
        resource_group_name: str,
        hosting_environment_name: str,
        name: str,
        *,
        update_seen: Optional[bool] = None,
        recommendation_id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.RecommendationRule:
        """Get a recommendation rule for an app.

        Description for Get a recommendation rule for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param hosting_environment_name: Name of the hosting environment. Required.
        :type hosting_environment_name: str
        :param name: Name of the recommendation. Required.
        :type name: str
        :keyword update_seen: Specify <code>true</code> to update the last-seen timestamp of the
         recommendation object. Default value is None.
        :paramtype update_seen: bool
        :keyword recommendation_id: The GUID of the recommendation object if you query an expired one.
         You don't need to specify it to query an active entry. Default value is None.
        :paramtype recommendation_id: str
        :return: RecommendationRule. The RecommendationRule is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RecommendationRule
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RecommendationRule] = kwargs.pop("cls", None)

        _request = build_recommendations_get_rule_details_by_hosting_environment_request(
            resource_group_name=resource_group_name,
            hosting_environment_name=hosting_environment_name,
            name=name,
            subscription_id=self._config.subscription_id,
            update_seen=update_seen,
            recommendation_id=recommendation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RecommendationRule, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def disable_recommendation_for_hosting_environment(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        hosting_environment_name: str,
        *,
        environment_name: str,
        **kwargs: Any
    ) -> None:
        """Disables the specific rule for a web site permanently.

        Description for Disables the specific rule for a web site permanently.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the recommendation. Required.
        :type name: str
        :param hosting_environment_name: Name of the hosting environment. Required.
        :type hosting_environment_name: str
        :keyword environment_name: Site name. Required.
        :paramtype environment_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_recommendations_disable_recommendation_for_hosting_environment_request(
            resource_group_name=resource_group_name,
            name=name,
            hosting_environment_name=hosting_environment_name,
            subscription_id=self._config.subscription_id,
            environment_name=environment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_history_for_web_app(
        self,
        resource_group_name: str,
        site_name: str,
        *,
        expired_only: Optional[bool] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.Recommendation"]:
        """Get past recommendations for an app, optionally specified by the time range.

        Description for Get past recommendations for an app, optionally specified by the time range.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Name of the app. Required.
        :type site_name: str
        :keyword expired_only: Specify <code>false</code> to return all recommendations. The default is
         <code>true</code>, which returns only expired recommendations. Default value is None.
        :paramtype expired_only: bool
        :keyword filter: Filter is specified by using OData syntax. Example: $filter=channel eq 'Api'
         or channel eq 'Notification' and startTime eq 2014-01-01T00:00:00Z and endTime eq
         2014-12-31T23:59:59Z and timeGrain eq duration'[PT1H|PT1M|P1D]. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of Recommendation
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Recommendation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Recommendation]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_recommendations_list_history_for_web_app_request(
                    resource_group_name=resource_group_name,
                    site_name=site_name,
                    subscription_id=self._config.subscription_id,
                    expired_only=expired_only,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Recommendation], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_recommended_rules_for_web_app(
        self,
        resource_group_name: str,
        site_name: str,
        *,
        featured: Optional[bool] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.Recommendation"]:
        """Get all recommendations for an app.

        Description for Get all recommendations for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Name of the app. Required.
        :type site_name: str
        :keyword featured: Specify <code>true</code> to return only the most critical recommendations.
         The default is <code>false</code>, which returns all recommendations. Default value is None.
        :paramtype featured: bool
        :keyword filter: Return only channels specified in the filter. Filter is specified by using
         OData syntax. Example: $filter=channel eq 'Api' or channel eq 'Notification'. Default value is
         None.
        :paramtype filter: str
        :return: An iterator like instance of Recommendation
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Recommendation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Recommendation]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_recommendations_list_recommended_rules_for_web_app_request(
                    resource_group_name=resource_group_name,
                    site_name=site_name,
                    subscription_id=self._config.subscription_id,
                    featured=featured,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Recommendation], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def disable_all_for_web_app(self, resource_group_name: str, site_name: str, **kwargs: Any) -> None:
        """Disable all recommendations for an app.

        Description for Disable all recommendations for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Name of the app. Required.
        :type site_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_recommendations_disable_all_for_web_app_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def reset_all_filters_for_web_app(self, resource_group_name: str, site_name: str, **kwargs: Any) -> None:
        """Reset all recommendation opt-out settings for an app.

        Description for Reset all recommendation opt-out settings for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Name of the app. Required.
        :type site_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_recommendations_reset_all_filters_for_web_app_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list(
        self, *, featured: Optional[bool] = None, filter: Optional[str] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.Recommendation"]:
        """List all recommendations for a subscription.

        Description for List all recommendations for a subscription.

        :keyword featured: Specify <code>true</code> to return only the most critical recommendations.
         The default is <code>false</code>, which returns all recommendations. Default value is None.
        :paramtype featured: bool
        :keyword filter: Filter is specified by using OData syntax. Example: $filter=channel eq 'Api'
         or channel eq 'Notification' and startTime eq 2014-01-01T00:00:00Z and endTime eq
         2014-12-31T23:59:59Z and timeGrain eq duration'[PT1H|PT1M|P1D]. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of Recommendation
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Recommendation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Recommendation]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_recommendations_list_request(
                    subscription_id=self._config.subscription_id,
                    featured=featured,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Recommendation], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def reset_all_filters(self, **kwargs: Any) -> None:
        """Reset all recommendation opt-out settings for a subscription.

        Description for Reset all recommendation opt-out settings for a subscription.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_recommendations_reset_all_filters_request(
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def disable_recommendation_for_subscription(self, name: str, **kwargs: Any) -> None:
        """Disables the specified rule so it will not apply to a subscription in the future.

        Description for Disables the specified rule so it will not apply to a subscription in the
        future.

        :param name: Rule name. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_recommendations_disable_recommendation_for_subscription_request(
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class StaticSitesOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`static_sites` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_private_endpoint_connection(
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> _models.RemotePrivateEndpointConnectionARMResource:
        """Gets a private endpoint connection.

        Description for Gets a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :return: RemotePrivateEndpointConnectionARMResource. The
         RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RemotePrivateEndpointConnectionARMResource] = kwargs.pop("cls", None)

        _request = build_static_sites_get_private_endpoint_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RemotePrivateEndpointConnectionARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _approve_or_reject_private_endpoint_connection_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: Union[_models.RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(private_endpoint_wrapper, (IOBase, bytes)):
            _content = private_endpoint_wrapper
        else:
            _content = json.dumps(private_endpoint_wrapper, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_approve_or_reject_private_endpoint_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: _models.RemotePrivateEndpointConnectionARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Request body. Required.
        :type private_endpoint_wrapper:
         ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Request body. Required.
        :type private_endpoint_wrapper: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Request body. Required.
        :type private_endpoint_wrapper: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: Union[_models.RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Request body. Is one of the following types:
         RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes] Required.
        :type private_endpoint_wrapper:
         ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RemotePrivateEndpointConnectionARMResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._approve_or_reject_private_endpoint_connection_initial(
                resource_group_name=resource_group_name,
                name=name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                private_endpoint_wrapper=private_endpoint_wrapper,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.RemotePrivateEndpointConnectionARMResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_private_endpoint_connection_initial(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_static_sites_delete_private_endpoint_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_delete_private_endpoint_connection(
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes a private endpoint connection.

        Description for Deletes a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_private_endpoint_connection_initial(
                resource_group_name=resource_group_name,
                name=name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_private_endpoint_connection_list(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.RemotePrivateEndpointConnectionARMResource"]:
        """Gets the list of private endpoint connections associated with a static site.

        Description for Gets the list of private endpoint connections associated with a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: An iterator like instance of RemotePrivateEndpointConnectionARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.RemotePrivateEndpointConnectionARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_get_private_endpoint_connection_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.RemotePrivateEndpointConnectionARMResource], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_static_site(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.StaticSiteARMResource:
        """Gets the details of a static site.

        Description for Gets the details of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: StaticSiteARMResource. The StaticSiteARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StaticSiteARMResource] = kwargs.pop("cls", None)

        _request = build_static_sites_get_static_site_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_static_site_initial(
        self,
        resource_group_name: str,
        name: str,
        static_site_envelope: Union[_models.StaticSiteARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_envelope, (IOBase, bytes)):
            _content = static_site_envelope
        else:
            _content = json.dumps(static_site_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_or_update_static_site_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update_static_site(
        self,
        resource_group_name: str,
        name: str,
        static_site_envelope: _models.StaticSiteARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteARMResource]:
        """Creates a new static site in an existing resource group, or updates an existing static site.

        Description for Creates a new static site in an existing resource group, or updates an existing
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_envelope: A JSON representation of the staticsite properties. See example.
         Required.
        :type static_site_envelope: ~azure.mgmt.web.models.StaticSiteARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteARMResource. The
         StaticSiteARMResource is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_static_site(
        self,
        resource_group_name: str,
        name: str,
        static_site_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteARMResource]:
        """Creates a new static site in an existing resource group, or updates an existing static site.

        Description for Creates a new static site in an existing resource group, or updates an existing
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_envelope: A JSON representation of the staticsite properties. See example.
         Required.
        :type static_site_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteARMResource. The
         StaticSiteARMResource is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_static_site(
        self,
        resource_group_name: str,
        name: str,
        static_site_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteARMResource]:
        """Creates a new static site in an existing resource group, or updates an existing static site.

        Description for Creates a new static site in an existing resource group, or updates an existing
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_envelope: A JSON representation of the staticsite properties. See example.
         Required.
        :type static_site_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteARMResource. The
         StaticSiteARMResource is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update_static_site(
        self,
        resource_group_name: str,
        name: str,
        static_site_envelope: Union[_models.StaticSiteARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteARMResource]:
        """Creates a new static site in an existing resource group, or updates an existing static site.

        Description for Creates a new static site in an existing resource group, or updates an existing
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_envelope: A JSON representation of the staticsite properties. See example.
         Is one of the following types: StaticSiteARMResource, JSON, IO[bytes] Required.
        :type static_site_envelope: ~azure.mgmt.web.models.StaticSiteARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns StaticSiteARMResource. The
         StaticSiteARMResource is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StaticSiteARMResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_static_site_initial(
                resource_group_name=resource_group_name,
                name=name,
                static_site_envelope=static_site_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.StaticSiteARMResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.StaticSiteARMResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.StaticSiteARMResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update_static_site(
        self,
        resource_group_name: str,
        name: str,
        static_site_envelope: _models.StaticSitePatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteARMResource:
        """Creates a new static site in an existing resource group, or updates an existing static site.

        Description for Creates a new static site in an existing resource group, or updates an existing
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_envelope: A JSON representation of the staticsite properties. See example.
         Required.
        :type static_site_envelope: ~azure.mgmt.web.models.StaticSitePatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteARMResource. The StaticSiteARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_static_site(
        self,
        resource_group_name: str,
        name: str,
        static_site_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteARMResource:
        """Creates a new static site in an existing resource group, or updates an existing static site.

        Description for Creates a new static site in an existing resource group, or updates an existing
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_envelope: A JSON representation of the staticsite properties. See example.
         Required.
        :type static_site_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteARMResource. The StaticSiteARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_static_site(
        self,
        resource_group_name: str,
        name: str,
        static_site_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteARMResource:
        """Creates a new static site in an existing resource group, or updates an existing static site.

        Description for Creates a new static site in an existing resource group, or updates an existing
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_envelope: A JSON representation of the staticsite properties. See example.
         Required.
        :type static_site_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteARMResource. The StaticSiteARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_static_site(
        self,
        resource_group_name: str,
        name: str,
        static_site_envelope: Union[_models.StaticSitePatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StaticSiteARMResource:
        """Creates a new static site in an existing resource group, or updates an existing static site.

        Description for Creates a new static site in an existing resource group, or updates an existing
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_envelope: A JSON representation of the staticsite properties. See example.
         Is one of the following types: StaticSitePatchResource, JSON, IO[bytes] Required.
        :type static_site_envelope: ~azure.mgmt.web.models.StaticSitePatchResource or JSON or IO[bytes]
        :return: StaticSiteARMResource. The StaticSiteARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StaticSiteARMResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_envelope, (IOBase, bytes)):
            _content = static_site_envelope
        else:
            _content = json.dumps(static_site_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_update_static_site_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _delete_static_site_initial(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_static_sites_delete_static_site_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_delete_static_site(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes a static site.

        Description for Deletes a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_static_site_initial(
                resource_group_name=resource_group_name,
                name=name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_static_sites_by_resource_group(
        self, resource_group_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StaticSiteARMResource"]:
        """Gets all static sites in the specified resource group.

        Description for Gets all static sites in the specified resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of StaticSiteARMResource
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_get_static_sites_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.StaticSiteARMResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncItemPaged["_models.StaticSiteARMResource"]:
        """Get all Static Sites for a subscription.

        Description for Get all Static Sites for a subscription.

        :return: An iterator like instance of StaticSiteARMResource
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.StaticSiteARMResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_static_site_users(
        self, resource_group_name: str, name: str, authprovider: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StaticSiteUserARMResource"]:
        """Gets the list of users of a static site.

        Description for Gets the list of users of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param authprovider: The auth provider for the users. Required.
        :type authprovider: str
        :return: An iterator like instance of StaticSiteUserARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteUserARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteUserARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_list_static_site_users_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    authprovider=authprovider,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.StaticSiteUserARMResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete_static_site_user(
        self, resource_group_name: str, name: str, authprovider: str, userid: str, **kwargs: Any
    ) -> None:
        """Deletes the user entry from the static site.

        Description for Deletes the user entry from the static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param authprovider: Required.
        :type authprovider: str
        :param userid: Required.
        :type userid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_static_sites_delete_static_site_user_request(
            resource_group_name=resource_group_name,
            name=name,
            authprovider=authprovider,
            userid=userid,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_static_site_user(
        self,
        resource_group_name: str,
        name: str,
        authprovider: str,
        userid: str,
        static_site_user_envelope: _models.StaticSiteUserARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteUserARMResource:
        """Updates a user entry with the listed roles.

        Description for Updates a user entry with the listed roles.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param authprovider: Required.
        :type authprovider: str
        :param userid: Required.
        :type userid: str
        :param static_site_user_envelope: A JSON representation of the StaticSiteUser properties. See
         example. Required.
        :type static_site_user_envelope: ~azure.mgmt.web.models.StaticSiteUserARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteUserARMResource. The StaticSiteUserARMResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteUserARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_static_site_user(
        self,
        resource_group_name: str,
        name: str,
        authprovider: str,
        userid: str,
        static_site_user_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteUserARMResource:
        """Updates a user entry with the listed roles.

        Description for Updates a user entry with the listed roles.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param authprovider: Required.
        :type authprovider: str
        :param userid: Required.
        :type userid: str
        :param static_site_user_envelope: A JSON representation of the StaticSiteUser properties. See
         example. Required.
        :type static_site_user_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteUserARMResource. The StaticSiteUserARMResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteUserARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_static_site_user(
        self,
        resource_group_name: str,
        name: str,
        authprovider: str,
        userid: str,
        static_site_user_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteUserARMResource:
        """Updates a user entry with the listed roles.

        Description for Updates a user entry with the listed roles.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param authprovider: Required.
        :type authprovider: str
        :param userid: Required.
        :type userid: str
        :param static_site_user_envelope: A JSON representation of the StaticSiteUser properties. See
         example. Required.
        :type static_site_user_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteUserARMResource. The StaticSiteUserARMResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteUserARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_static_site_user(
        self,
        resource_group_name: str,
        name: str,
        authprovider: str,
        userid: str,
        static_site_user_envelope: Union[_models.StaticSiteUserARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StaticSiteUserARMResource:
        """Updates a user entry with the listed roles.

        Description for Updates a user entry with the listed roles.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param authprovider: Required.
        :type authprovider: str
        :param userid: Required.
        :type userid: str
        :param static_site_user_envelope: A JSON representation of the StaticSiteUser properties. See
         example. Is one of the following types: StaticSiteUserARMResource, JSON, IO[bytes] Required.
        :type static_site_user_envelope: ~azure.mgmt.web.models.StaticSiteUserARMResource or JSON or
         IO[bytes]
        :return: StaticSiteUserARMResource. The StaticSiteUserARMResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteUserARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StaticSiteUserARMResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_user_envelope, (IOBase, bytes)):
            _content = static_site_user_envelope
        else:
            _content = json.dumps(static_site_user_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_update_static_site_user_request(
            resource_group_name=resource_group_name,
            name=name,
            authprovider=authprovider,
            userid=userid,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteUserARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_static_site_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        app_settings: _models.StringDictionary,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the app settings of a static site.

        Description for Creates or updates the app settings of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param app_settings: The dictionary containing the static site app settings to update.
         Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_static_site_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        app_settings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the app settings of a static site.

        Description for Creates or updates the app settings of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param app_settings: The dictionary containing the static site app settings to update.
         Required.
        :type app_settings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_static_site_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        app_settings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the app settings of a static site.

        Description for Creates or updates the app settings of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param app_settings: The dictionary containing the static site app settings to update.
         Required.
        :type app_settings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_static_site_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        app_settings: Union[_models.StringDictionary, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the app settings of a static site.

        Description for Creates or updates the app settings of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param app_settings: The dictionary containing the static site app settings to update. Is one
         of the following types: StringDictionary, JSON, IO[bytes] Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary or JSON or IO[bytes]
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(app_settings, (IOBase, bytes)):
            _content = app_settings
        else:
            _content = json.dumps(app_settings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_or_update_static_site_app_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_static_site_function_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        app_settings: _models.StringDictionary,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the function app settings of a static site.

        Description for Creates or updates the function app settings of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param app_settings: The dictionary containing the static site function app settings to update.
         Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_static_site_function_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        app_settings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the function app settings of a static site.

        Description for Creates or updates the function app settings of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param app_settings: The dictionary containing the static site function app settings to update.
         Required.
        :type app_settings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_static_site_function_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        app_settings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the function app settings of a static site.

        Description for Creates or updates the function app settings of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param app_settings: The dictionary containing the static site function app settings to update.
         Required.
        :type app_settings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_static_site_function_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        app_settings: Union[_models.StringDictionary, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the function app settings of a static site.

        Description for Creates or updates the function app settings of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param app_settings: The dictionary containing the static site function app settings to update.
         Is one of the following types: StringDictionary, JSON, IO[bytes] Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary or JSON or IO[bytes]
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(app_settings, (IOBase, bytes)):
            _content = app_settings
        else:
            _content = json.dumps(app_settings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_or_update_static_site_function_app_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_user_roles_invitation_link(
        self,
        resource_group_name: str,
        name: str,
        static_site_user_roles_invitation_envelope: _models.StaticSiteUserInvitationRequestResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteUserInvitationResponseResource:
        """Creates an invitation link for a user with the role.

        Description for Creates an invitation link for a user with the role.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_user_roles_invitation_envelope: Required.
        :type static_site_user_roles_invitation_envelope:
         ~azure.mgmt.web.models.StaticSiteUserInvitationRequestResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteUserInvitationResponseResource. The StaticSiteUserInvitationResponseResource
         is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteUserInvitationResponseResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_user_roles_invitation_link(
        self,
        resource_group_name: str,
        name: str,
        static_site_user_roles_invitation_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteUserInvitationResponseResource:
        """Creates an invitation link for a user with the role.

        Description for Creates an invitation link for a user with the role.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_user_roles_invitation_envelope: Required.
        :type static_site_user_roles_invitation_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteUserInvitationResponseResource. The StaticSiteUserInvitationResponseResource
         is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteUserInvitationResponseResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_user_roles_invitation_link(
        self,
        resource_group_name: str,
        name: str,
        static_site_user_roles_invitation_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteUserInvitationResponseResource:
        """Creates an invitation link for a user with the role.

        Description for Creates an invitation link for a user with the role.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_user_roles_invitation_envelope: Required.
        :type static_site_user_roles_invitation_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteUserInvitationResponseResource. The StaticSiteUserInvitationResponseResource
         is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteUserInvitationResponseResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_user_roles_invitation_link(
        self,
        resource_group_name: str,
        name: str,
        static_site_user_roles_invitation_envelope: Union[
            _models.StaticSiteUserInvitationRequestResource, JSON, IO[bytes]
        ],
        **kwargs: Any
    ) -> _models.StaticSiteUserInvitationResponseResource:
        """Creates an invitation link for a user with the role.

        Description for Creates an invitation link for a user with the role.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_user_roles_invitation_envelope: Is one of the following types:
         StaticSiteUserInvitationRequestResource, JSON, IO[bytes] Required.
        :type static_site_user_roles_invitation_envelope:
         ~azure.mgmt.web.models.StaticSiteUserInvitationRequestResource or JSON or IO[bytes]
        :return: StaticSiteUserInvitationResponseResource. The StaticSiteUserInvitationResponseResource
         is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteUserInvitationResponseResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StaticSiteUserInvitationResponseResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_user_roles_invitation_envelope, (IOBase, bytes)):
            _content = static_site_user_roles_invitation_envelope
        else:
            _content = json.dumps(static_site_user_roles_invitation_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_user_roles_invitation_link_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteUserInvitationResponseResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _detach_static_site_initial(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_static_sites_detach_static_site_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_detach_static_site(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Detaches a static site.

        Description for Detaches a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._detach_static_site_initial(
                resource_group_name=resource_group_name,
                name=name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_static_site_functions(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StaticSiteFunctionOverviewARMResource"]:
        """Gets the functions of a static site.

        Description for Gets the functions of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: An iterator like instance of StaticSiteFunctionOverviewARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteFunctionOverviewARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteFunctionOverviewARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_list_static_site_functions_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.StaticSiteFunctionOverviewARMResource], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_static_site_app_settings(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.StringDictionary:
        """Gets the application settings of a static site.

        Description for Gets the application settings of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        _request = build_static_sites_list_static_site_app_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_static_site_configured_roles(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.StringList:
        """Lists the roles configured for the static site.

        Description for Lists the roles configured for the static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: StringList. The StringList is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringList
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringList] = kwargs.pop("cls", None)

        _request = build_static_sites_list_static_site_configured_roles_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringList, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_static_site_function_app_settings(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.StringDictionary:
        """Gets the application settings of a static site.

        Description for Gets the application settings of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        _request = build_static_sites_list_static_site_function_app_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_static_site_secrets(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.StringDictionary:
        """Lists the secrets for an existing static site.

        Description for Lists the secrets for an existing static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        _request = build_static_sites_list_static_site_secrets_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_private_link_resources(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.PrivateLinkResourcesWrapper:
        """Gets the private link resources.

        Description for Gets the private link resources.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: PrivateLinkResourcesWrapper. The PrivateLinkResourcesWrapper is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateLinkResourcesWrapper
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PrivateLinkResourcesWrapper] = kwargs.pop("cls", None)

        _request = build_static_sites_get_private_link_resources_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PrivateLinkResourcesWrapper, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def reset_static_site_api_key(
        self,
        resource_group_name: str,
        name: str,
        reset_properties_envelope: _models.StaticSiteResetPropertiesARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Resets the api key for an existing static site.

        Description for Resets the api key for an existing static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param reset_properties_envelope: Required.
        :type reset_properties_envelope: ~azure.mgmt.web.models.StaticSiteResetPropertiesARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def reset_static_site_api_key(
        self,
        resource_group_name: str,
        name: str,
        reset_properties_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Resets the api key for an existing static site.

        Description for Resets the api key for an existing static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param reset_properties_envelope: Required.
        :type reset_properties_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def reset_static_site_api_key(
        self,
        resource_group_name: str,
        name: str,
        reset_properties_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Resets the api key for an existing static site.

        Description for Resets the api key for an existing static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param reset_properties_envelope: Required.
        :type reset_properties_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def reset_static_site_api_key(
        self,
        resource_group_name: str,
        name: str,
        reset_properties_envelope: Union[_models.StaticSiteResetPropertiesARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> None:
        """Resets the api key for an existing static site.

        Description for Resets the api key for an existing static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param reset_properties_envelope: Is one of the following types:
         StaticSiteResetPropertiesARMResource, JSON, IO[bytes] Required.
        :type reset_properties_envelope: ~azure.mgmt.web.models.StaticSiteResetPropertiesARMResource or
         JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(reset_properties_envelope, (IOBase, bytes)):
            _content = reset_properties_envelope
        else:
            _content = json.dumps(reset_properties_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_reset_static_site_api_key_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_database_connections_with_details(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DatabaseConnection"]:
        """Returns details of database connections for a static site.

        Returns details of database connections for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: An iterator like instance of DatabaseConnection
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DatabaseConnection]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DatabaseConnection]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_get_database_connections_with_details_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DatabaseConnection], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _create_zip_deployment_for_static_site_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        static_site_zip_deployment_envelope: Union[_models.StaticSiteZipDeploymentARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_zip_deployment_envelope, (IOBase, bytes)):
            _content = static_site_zip_deployment_envelope
        else:
            _content = json.dumps(static_site_zip_deployment_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_zip_deployment_for_static_site_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_zip_deployment_for_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        static_site_zip_deployment_envelope: _models.StaticSiteZipDeploymentARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deploys zipped content to a static site.

        Description for Deploys zipped content to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_zip_deployment_envelope: A JSON representation of the
         StaticSiteZipDeployment properties. See example. Required.
        :type static_site_zip_deployment_envelope:
         ~azure.mgmt.web.models.StaticSiteZipDeploymentARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_zip_deployment_for_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        static_site_zip_deployment_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deploys zipped content to a static site.

        Description for Deploys zipped content to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_zip_deployment_envelope: A JSON representation of the
         StaticSiteZipDeployment properties. See example. Required.
        :type static_site_zip_deployment_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_zip_deployment_for_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        static_site_zip_deployment_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deploys zipped content to a static site.

        Description for Deploys zipped content to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_zip_deployment_envelope: A JSON representation of the
         StaticSiteZipDeployment properties. See example. Required.
        :type static_site_zip_deployment_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_zip_deployment_for_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        static_site_zip_deployment_envelope: Union[_models.StaticSiteZipDeploymentARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deploys zipped content to a static site.

        Description for Deploys zipped content to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param static_site_zip_deployment_envelope: A JSON representation of the
         StaticSiteZipDeployment properties. See example. Is one of the following types:
         StaticSiteZipDeploymentARMResource, JSON, IO[bytes] Required.
        :type static_site_zip_deployment_envelope:
         ~azure.mgmt.web.models.StaticSiteZipDeploymentARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_zip_deployment_for_static_site_initial(
                resource_group_name=resource_group_name,
                name=name,
                static_site_zip_deployment_envelope=static_site_zip_deployment_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def get_static_site_build(
        self, resource_group_name: str, name: str, environment_name: str, **kwargs: Any
    ) -> _models.StaticSiteBuildARMResource:
        """Gets the details of a static site build.

        Description for Gets the details of a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :return: StaticSiteBuildARMResource. The StaticSiteBuildARMResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteBuildARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StaticSiteBuildARMResource] = kwargs.pop("cls", None)

        _request = build_static_sites_get_static_site_build_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteBuildARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _delete_static_site_build_initial(
        self, resource_group_name: str, name: str, environment_name: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_static_sites_delete_static_site_build_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_delete_static_site_build(
        self, resource_group_name: str, name: str, environment_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes a static site build.

        Description for Deletes a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_static_site_build_initial(
                resource_group_name=resource_group_name,
                name=name,
                environment_name=environment_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_static_site_builds(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StaticSiteBuildARMResource"]:
        """Gets all static site builds for a particular static site.

        Description for Gets all static site builds for a particular static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: An iterator like instance of StaticSiteBuildARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteBuildARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteBuildARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_get_static_site_builds_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.StaticSiteBuildARMResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def create_or_update_static_site_build_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        app_settings: _models.StringDictionary,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the app settings of a static site build.

        Description for Creates or updates the app settings of a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param app_settings: The dictionary containing the static site app settings to update.
         Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_static_site_build_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        app_settings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the app settings of a static site build.

        Description for Creates or updates the app settings of a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param app_settings: The dictionary containing the static site app settings to update.
         Required.
        :type app_settings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_static_site_build_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        app_settings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the app settings of a static site build.

        Description for Creates or updates the app settings of a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param app_settings: The dictionary containing the static site app settings to update.
         Required.
        :type app_settings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_static_site_build_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        app_settings: Union[_models.StringDictionary, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the app settings of a static site build.

        Description for Creates or updates the app settings of a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param app_settings: The dictionary containing the static site app settings to update. Is one
         of the following types: StringDictionary, JSON, IO[bytes] Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary or JSON or IO[bytes]
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(app_settings, (IOBase, bytes)):
            _content = app_settings
        else:
            _content = json.dumps(app_settings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_or_update_static_site_build_app_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_static_site_build_function_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        app_settings: _models.StringDictionary,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the function app settings of a static site build.

        Description for Creates or updates the function app settings of a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param app_settings: The dictionary containing the static site function app settings to update.
         Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_static_site_build_function_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        app_settings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the function app settings of a static site build.

        Description for Creates or updates the function app settings of a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param app_settings: The dictionary containing the static site function app settings to update.
         Required.
        :type app_settings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_static_site_build_function_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        app_settings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the function app settings of a static site build.

        Description for Creates or updates the function app settings of a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param app_settings: The dictionary containing the static site function app settings to update.
         Required.
        :type app_settings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_static_site_build_function_app_settings(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        app_settings: Union[_models.StringDictionary, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Creates or updates the function app settings of a static site build.

        Description for Creates or updates the function app settings of a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param app_settings: The dictionary containing the static site function app settings to update.
         Is one of the following types: StringDictionary, JSON, IO[bytes] Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary or JSON or IO[bytes]
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(app_settings, (IOBase, bytes)):
            _content = app_settings
        else:
            _content = json.dumps(app_settings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_or_update_static_site_build_function_app_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_static_site_build_functions(
        self, resource_group_name: str, name: str, environment_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StaticSiteFunctionOverviewARMResource"]:
        """Gets the functions of a particular static site build.

        Description for Gets the functions of a particular static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :return: An iterator like instance of StaticSiteFunctionOverviewARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteFunctionOverviewARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteFunctionOverviewARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_list_static_site_build_functions_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    environment_name=environment_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.StaticSiteFunctionOverviewARMResource], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_static_site_build_app_settings(
        self, resource_group_name: str, name: str, environment_name: str, **kwargs: Any
    ) -> _models.StringDictionary:
        """Gets the application settings of a static site build.

        Description for Gets the application settings of a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        _request = build_static_sites_list_static_site_build_app_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_static_site_build_function_app_settings(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, environment_name: str, **kwargs: Any
    ) -> _models.StringDictionary:
        """Gets the application settings of a static site build.

        Description for Gets the application settings of a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        _request = build_static_sites_list_static_site_build_function_app_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_build_database_connections_with_details(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, environment_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DatabaseConnection"]:
        """Returns details of database connections for a static site build.

        Returns details of database connections for a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :return: An iterator like instance of DatabaseConnection
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DatabaseConnection]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DatabaseConnection]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_get_build_database_connections_with_details_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    environment_name=environment_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DatabaseConnection], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _create_zip_deployment_for_static_site_build_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        static_site_zip_deployment_envelope: Union[_models.StaticSiteZipDeploymentARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_zip_deployment_envelope, (IOBase, bytes)):
            _content = static_site_zip_deployment_envelope
        else:
            _content = json.dumps(static_site_zip_deployment_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_zip_deployment_for_static_site_build_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_zip_deployment_for_static_site_build(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        static_site_zip_deployment_envelope: _models.StaticSiteZipDeploymentARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deploys zipped content to a specific environment of a static site.

        Description for Deploys zipped content to a specific environment of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param static_site_zip_deployment_envelope: A JSON representation of the
         StaticSiteZipDeployment properties. See example. Required.
        :type static_site_zip_deployment_envelope:
         ~azure.mgmt.web.models.StaticSiteZipDeploymentARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_zip_deployment_for_static_site_build(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        static_site_zip_deployment_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deploys zipped content to a specific environment of a static site.

        Description for Deploys zipped content to a specific environment of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param static_site_zip_deployment_envelope: A JSON representation of the
         StaticSiteZipDeployment properties. See example. Required.
        :type static_site_zip_deployment_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_zip_deployment_for_static_site_build(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        static_site_zip_deployment_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deploys zipped content to a specific environment of a static site.

        Description for Deploys zipped content to a specific environment of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param static_site_zip_deployment_envelope: A JSON representation of the
         StaticSiteZipDeployment properties. See example. Required.
        :type static_site_zip_deployment_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_zip_deployment_for_static_site_build(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        static_site_zip_deployment_envelope: Union[_models.StaticSiteZipDeploymentARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deploys zipped content to a specific environment of a static site.

        Description for Deploys zipped content to a specific environment of a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param static_site_zip_deployment_envelope: A JSON representation of the
         StaticSiteZipDeployment properties. See example. Is one of the following types:
         StaticSiteZipDeploymentARMResource, JSON, IO[bytes] Required.
        :type static_site_zip_deployment_envelope:
         ~azure.mgmt.web.models.StaticSiteZipDeploymentARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_zip_deployment_for_static_site_build_initial(
                resource_group_name=resource_group_name,
                name=name,
                environment_name=environment_name,
                static_site_zip_deployment_envelope=static_site_zip_deployment_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def get_build_database_connection(
        self, resource_group_name: str, name: str, environment_name: str, database_connection_name: str, **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Returns overview of a database connection for a static site build by name.

        Returns overview of a database connection for a static site build by name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DatabaseConnection] = kwargs.pop("cls", None)

        _request = build_static_sites_get_build_database_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            database_connection_name=database_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DatabaseConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_build_database_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        database_connection_name: str,
        database_connection_request_envelope: _models.DatabaseConnection,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site build.

        Description for Create or update a database connection for a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope: ~azure.mgmt.web.models.DatabaseConnection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_build_database_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        database_connection_name: str,
        database_connection_request_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site build.

        Description for Create or update a database connection for a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_build_database_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        database_connection_name: str,
        database_connection_request_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site build.

        Description for Create or update a database connection for a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_build_database_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        database_connection_name: str,
        database_connection_request_envelope: Union[_models.DatabaseConnection, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site build.

        Description for Create or update a database connection for a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Is one of the following types: DatabaseConnection, JSON, IO[bytes]
         Required.
        :type database_connection_request_envelope: ~azure.mgmt.web.models.DatabaseConnection or JSON
         or IO[bytes]
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DatabaseConnection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(database_connection_request_envelope, (IOBase, bytes)):
            _content = database_connection_request_envelope
        else:
            _content = json.dumps(database_connection_request_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_or_update_build_database_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            database_connection_name=database_connection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DatabaseConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_build_database_connection(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        database_connection_name: str,
        database_connection_request_envelope: _models.DatabaseConnectionPatchRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site build.

        Description for Create or update a database connection for a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope:
         ~azure.mgmt.web.models.DatabaseConnectionPatchRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_build_database_connection(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        database_connection_name: str,
        database_connection_request_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site build.

        Description for Create or update a database connection for a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_build_database_connection(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        database_connection_name: str,
        database_connection_request_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site build.

        Description for Create or update a database connection for a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_build_database_connection(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        database_connection_name: str,
        database_connection_request_envelope: Union[_models.DatabaseConnectionPatchRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site build.

        Description for Create or update a database connection for a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Is one of the following types: DatabaseConnectionPatchRequest, JSON,
         IO[bytes] Required.
        :type database_connection_request_envelope:
         ~azure.mgmt.web.models.DatabaseConnectionPatchRequest or JSON or IO[bytes]
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DatabaseConnection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(database_connection_request_envelope, (IOBase, bytes)):
            _content = database_connection_request_envelope
        else:
            _content = json.dumps(database_connection_request_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_update_build_database_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            database_connection_name=database_connection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DatabaseConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_build_database_connection(
        self, resource_group_name: str, name: str, environment_name: str, database_connection_name: str, **kwargs: Any
    ) -> None:
        """Delete a database connection for a static site build.

        Delete a database connection for a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_static_sites_delete_build_database_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            database_connection_name=database_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_build_database_connections(
        self, resource_group_name: str, name: str, environment_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DatabaseConnection"]:
        """Returns overviews of database connections for a static site build.

        Returns overviews of database connections for a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :return: An iterator like instance of DatabaseConnection
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DatabaseConnection]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DatabaseConnection]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_get_build_database_connections_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    environment_name=environment_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DatabaseConnection], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_build_database_connection_with_details(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, environment_name: str, database_connection_name: str, **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Returns details of a database connection for a static site build by name.

        Returns details of a database connection for a static site build by name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DatabaseConnection] = kwargs.pop("cls", None)

        _request = build_static_sites_get_build_database_connection_with_details_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            database_connection_name=database_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DatabaseConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_database_connection(
        self, resource_group_name: str, name: str, database_connection_name: str, **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Returns overview of a database connection for a static site by name.

        Returns overview of a database connection for a static site by name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DatabaseConnection] = kwargs.pop("cls", None)

        _request = build_static_sites_get_database_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            database_connection_name=database_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DatabaseConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_database_connection(
        self,
        resource_group_name: str,
        name: str,
        database_connection_name: str,
        database_connection_request_envelope: _models.DatabaseConnection,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site.

        Description for Create or update a database connection for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope: ~azure.mgmt.web.models.DatabaseConnection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_database_connection(
        self,
        resource_group_name: str,
        name: str,
        database_connection_name: str,
        database_connection_request_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site.

        Description for Create or update a database connection for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_database_connection(
        self,
        resource_group_name: str,
        name: str,
        database_connection_name: str,
        database_connection_request_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site.

        Description for Create or update a database connection for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_database_connection(
        self,
        resource_group_name: str,
        name: str,
        database_connection_name: str,
        database_connection_request_envelope: Union[_models.DatabaseConnection, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site.

        Description for Create or update a database connection for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Is one of the following types: DatabaseConnection, JSON, IO[bytes]
         Required.
        :type database_connection_request_envelope: ~azure.mgmt.web.models.DatabaseConnection or JSON
         or IO[bytes]
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DatabaseConnection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(database_connection_request_envelope, (IOBase, bytes)):
            _content = database_connection_request_envelope
        else:
            _content = json.dumps(database_connection_request_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_or_update_database_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            database_connection_name=database_connection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DatabaseConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_database_connection(
        self,
        resource_group_name: str,
        name: str,
        database_connection_name: str,
        database_connection_request_envelope: _models.DatabaseConnectionPatchRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site.

        Description for Create or update a database connection for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope:
         ~azure.mgmt.web.models.DatabaseConnectionPatchRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_database_connection(
        self,
        resource_group_name: str,
        name: str,
        database_connection_name: str,
        database_connection_request_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site.

        Description for Create or update a database connection for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_database_connection(
        self,
        resource_group_name: str,
        name: str,
        database_connection_name: str,
        database_connection_request_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site.

        Description for Create or update a database connection for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Required.
        :type database_connection_request_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_database_connection(
        self,
        resource_group_name: str,
        name: str,
        database_connection_name: str,
        database_connection_request_envelope: Union[_models.DatabaseConnectionPatchRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Create or update a database connection for a static site.

        Description for Create or update a database connection for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :param database_connection_request_envelope: A JSON representation of the database connection
         request properties. Is one of the following types: DatabaseConnectionPatchRequest, JSON,
         IO[bytes] Required.
        :type database_connection_request_envelope:
         ~azure.mgmt.web.models.DatabaseConnectionPatchRequest or JSON or IO[bytes]
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DatabaseConnection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(database_connection_request_envelope, (IOBase, bytes)):
            _content = database_connection_request_envelope
        else:
            _content = json.dumps(database_connection_request_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_update_database_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            database_connection_name=database_connection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DatabaseConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_database_connection(
        self, resource_group_name: str, name: str, database_connection_name: str, **kwargs: Any
    ) -> None:
        """Delete a database connection for a static site.

        Delete a database connection for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_static_sites_delete_database_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            database_connection_name=database_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_database_connections(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DatabaseConnection"]:
        """Returns overviews of database connections for a static site.

        Returns overviews of database connections for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: An iterator like instance of DatabaseConnection
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DatabaseConnection]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DatabaseConnection]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_get_database_connections_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DatabaseConnection], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_database_connection_with_details(
        self, resource_group_name: str, name: str, database_connection_name: str, **kwargs: Any
    ) -> _models.DatabaseConnection:
        """Returns details of a database connection for a static site by name.

        Returns details of a database connection for a static site by name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param database_connection_name: Name of the database connection. Required.
        :type database_connection_name: str
        :return: DatabaseConnection. The DatabaseConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DatabaseConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DatabaseConnection] = kwargs.pop("cls", None)

        _request = build_static_sites_get_database_connection_with_details_request(
            resource_group_name=resource_group_name,
            name=name,
            database_connection_name=database_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DatabaseConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_user_provided_function_app_for_static_site_build(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, environment_name: str, function_app_name: str, **kwargs: Any
    ) -> _models.StaticSiteUserProvidedFunctionAppARMResource:
        """Gets the details of the user provided function app registered with a static site build.

        Description for Gets the details of the user provided function app registered with a static
        site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param function_app_name: Name of the function app registered with the static site build.
         Required.
        :type function_app_name: str
        :return: StaticSiteUserProvidedFunctionAppARMResource. The
         StaticSiteUserProvidedFunctionAppARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StaticSiteUserProvidedFunctionAppARMResource] = kwargs.pop("cls", None)

        _request = build_static_sites_get_user_provided_function_app_for_static_site_build_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            function_app_name=function_app_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteUserProvidedFunctionAppARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _register_user_provided_function_app_with_static_site_build_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        function_app_name: str,
        static_site_user_provided_function_envelope: Union[
            _models.StaticSiteUserProvidedFunctionAppARMResource, JSON, IO[bytes]
        ],
        *,
        is_forced: Optional[bool] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_user_provided_function_envelope, (IOBase, bytes)):
            _content = static_site_user_provided_function_envelope
        else:
            _content = json.dumps(static_site_user_provided_function_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_register_user_provided_function_app_with_static_site_build_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            function_app_name=function_app_name,
            subscription_id=self._config.subscription_id,
            is_forced=is_forced,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_register_user_provided_function_app_with_static_site_build(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        function_app_name: str,
        static_site_user_provided_function_envelope: _models.StaticSiteUserProvidedFunctionAppARMResource,
        *,
        is_forced: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource]:
        """Register a user provided function app with a static site build.

        Description for Register a user provided function app with a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param function_app_name: Name of the function app registered with the static site build.
         Required.
        :type function_app_name: str
        :param static_site_user_provided_function_envelope: A JSON representation of the user provided
         function app properties. See example. Required.
        :type static_site_user_provided_function_envelope:
         ~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource
        :keyword is_forced: Specify <code>true</code> to force the update of the auth configuration on
         the function app even if an AzureStaticWebApps provider is already configured on the function
         app. The default is <code>false</code>. Default value is None.
        :paramtype is_forced: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns
         StaticSiteUserProvidedFunctionAppARMResource. The StaticSiteUserProvidedFunctionAppARMResource
         is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_register_user_provided_function_app_with_static_site_build(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        function_app_name: str,
        static_site_user_provided_function_envelope: JSON,
        *,
        is_forced: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource]:
        """Register a user provided function app with a static site build.

        Description for Register a user provided function app with a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param function_app_name: Name of the function app registered with the static site build.
         Required.
        :type function_app_name: str
        :param static_site_user_provided_function_envelope: A JSON representation of the user provided
         function app properties. See example. Required.
        :type static_site_user_provided_function_envelope: JSON
        :keyword is_forced: Specify <code>true</code> to force the update of the auth configuration on
         the function app even if an AzureStaticWebApps provider is already configured on the function
         app. The default is <code>false</code>. Default value is None.
        :paramtype is_forced: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns
         StaticSiteUserProvidedFunctionAppARMResource. The StaticSiteUserProvidedFunctionAppARMResource
         is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_register_user_provided_function_app_with_static_site_build(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        function_app_name: str,
        static_site_user_provided_function_envelope: IO[bytes],
        *,
        is_forced: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource]:
        """Register a user provided function app with a static site build.

        Description for Register a user provided function app with a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param function_app_name: Name of the function app registered with the static site build.
         Required.
        :type function_app_name: str
        :param static_site_user_provided_function_envelope: A JSON representation of the user provided
         function app properties. See example. Required.
        :type static_site_user_provided_function_envelope: IO[bytes]
        :keyword is_forced: Specify <code>true</code> to force the update of the auth configuration on
         the function app even if an AzureStaticWebApps provider is already configured on the function
         app. The default is <code>false</code>. Default value is None.
        :paramtype is_forced: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns
         StaticSiteUserProvidedFunctionAppARMResource. The StaticSiteUserProvidedFunctionAppARMResource
         is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_register_user_provided_function_app_with_static_site_build(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        function_app_name: str,
        static_site_user_provided_function_envelope: Union[
            _models.StaticSiteUserProvidedFunctionAppARMResource, JSON, IO[bytes]
        ],
        *,
        is_forced: Optional[bool] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource]:
        """Register a user provided function app with a static site build.

        Description for Register a user provided function app with a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param function_app_name: Name of the function app registered with the static site build.
         Required.
        :type function_app_name: str
        :param static_site_user_provided_function_envelope: A JSON representation of the user provided
         function app properties. See example. Is one of the following types:
         StaticSiteUserProvidedFunctionAppARMResource, JSON, IO[bytes] Required.
        :type static_site_user_provided_function_envelope:
         ~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource or JSON or IO[bytes]
        :keyword is_forced: Specify <code>true</code> to force the update of the auth configuration on
         the function app even if an AzureStaticWebApps provider is already configured on the function
         app. The default is <code>false</code>. Default value is None.
        :paramtype is_forced: bool
        :return: An instance of AsyncLROPoller that returns
         StaticSiteUserProvidedFunctionAppARMResource. The StaticSiteUserProvidedFunctionAppARMResource
         is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StaticSiteUserProvidedFunctionAppARMResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._register_user_provided_function_app_with_static_site_build_initial(
                resource_group_name=resource_group_name,
                name=name,
                environment_name=environment_name,
                function_app_name=function_app_name,
                static_site_user_provided_function_envelope=static_site_user_provided_function_envelope,
                is_forced=is_forced,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.StaticSiteUserProvidedFunctionAppARMResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def detach_user_provided_function_app_from_static_site_build(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, environment_name: str, function_app_name: str, **kwargs: Any
    ) -> None:
        """Detach the user provided function app from the static site build.

        Description for Detach the user provided function app from the static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param function_app_name: Name of the function app registered with the static site build.
         Required.
        :type function_app_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_static_sites_detach_user_provided_function_app_from_static_site_build_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            function_app_name=function_app_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_user_provided_function_apps_for_static_site_build(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, environment_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StaticSiteUserProvidedFunctionAppARMResource"]:
        """Gets the details of the user provided function apps registered with a static site build.

        Description for Gets the details of the user provided function apps registered with a static
        site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :return: An iterator like instance of StaticSiteUserProvidedFunctionAppARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteUserProvidedFunctionAppARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_get_user_provided_function_apps_for_static_site_build_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    environment_name=environment_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.StaticSiteUserProvidedFunctionAppARMResource], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_user_provided_function_app_for_static_site(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, function_app_name: str, **kwargs: Any
    ) -> _models.StaticSiteUserProvidedFunctionAppARMResource:
        """Gets the details of the user provided function app registered with a static site.

        Description for Gets the details of the user provided function app registered with a static
        site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param function_app_name: Name of the function app registered with the static site. Required.
        :type function_app_name: str
        :return: StaticSiteUserProvidedFunctionAppARMResource. The
         StaticSiteUserProvidedFunctionAppARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StaticSiteUserProvidedFunctionAppARMResource] = kwargs.pop("cls", None)

        _request = build_static_sites_get_user_provided_function_app_for_static_site_request(
            resource_group_name=resource_group_name,
            name=name,
            function_app_name=function_app_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteUserProvidedFunctionAppARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _register_user_provided_function_app_with_static_site_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        function_app_name: str,
        static_site_user_provided_function_envelope: Union[
            _models.StaticSiteUserProvidedFunctionAppARMResource, JSON, IO[bytes]
        ],
        *,
        is_forced: Optional[bool] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_user_provided_function_envelope, (IOBase, bytes)):
            _content = static_site_user_provided_function_envelope
        else:
            _content = json.dumps(static_site_user_provided_function_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_register_user_provided_function_app_with_static_site_request(
            resource_group_name=resource_group_name,
            name=name,
            function_app_name=function_app_name,
            subscription_id=self._config.subscription_id,
            is_forced=is_forced,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_register_user_provided_function_app_with_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        function_app_name: str,
        static_site_user_provided_function_envelope: _models.StaticSiteUserProvidedFunctionAppARMResource,
        *,
        is_forced: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource]:
        """Register a user provided function app with a static site.

        Description for Register a user provided function app with a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param function_app_name: Name of the function app registered with the static site. Required.
        :type function_app_name: str
        :param static_site_user_provided_function_envelope: A JSON representation of the user provided
         function app properties. See example. Required.
        :type static_site_user_provided_function_envelope:
         ~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource
        :keyword is_forced: Specify <code>true</code> to force the update of the auth configuration on
         the function app even if an AzureStaticWebApps provider is already configured on the function
         app. The default is <code>false</code>. Default value is None.
        :paramtype is_forced: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns
         StaticSiteUserProvidedFunctionAppARMResource. The StaticSiteUserProvidedFunctionAppARMResource
         is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_register_user_provided_function_app_with_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        function_app_name: str,
        static_site_user_provided_function_envelope: JSON,
        *,
        is_forced: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource]:
        """Register a user provided function app with a static site.

        Description for Register a user provided function app with a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param function_app_name: Name of the function app registered with the static site. Required.
        :type function_app_name: str
        :param static_site_user_provided_function_envelope: A JSON representation of the user provided
         function app properties. See example. Required.
        :type static_site_user_provided_function_envelope: JSON
        :keyword is_forced: Specify <code>true</code> to force the update of the auth configuration on
         the function app even if an AzureStaticWebApps provider is already configured on the function
         app. The default is <code>false</code>. Default value is None.
        :paramtype is_forced: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns
         StaticSiteUserProvidedFunctionAppARMResource. The StaticSiteUserProvidedFunctionAppARMResource
         is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_register_user_provided_function_app_with_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        function_app_name: str,
        static_site_user_provided_function_envelope: IO[bytes],
        *,
        is_forced: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource]:
        """Register a user provided function app with a static site.

        Description for Register a user provided function app with a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param function_app_name: Name of the function app registered with the static site. Required.
        :type function_app_name: str
        :param static_site_user_provided_function_envelope: A JSON representation of the user provided
         function app properties. See example. Required.
        :type static_site_user_provided_function_envelope: IO[bytes]
        :keyword is_forced: Specify <code>true</code> to force the update of the auth configuration on
         the function app even if an AzureStaticWebApps provider is already configured on the function
         app. The default is <code>false</code>. Default value is None.
        :paramtype is_forced: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns
         StaticSiteUserProvidedFunctionAppARMResource. The StaticSiteUserProvidedFunctionAppARMResource
         is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_register_user_provided_function_app_with_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        function_app_name: str,
        static_site_user_provided_function_envelope: Union[
            _models.StaticSiteUserProvidedFunctionAppARMResource, JSON, IO[bytes]
        ],
        *,
        is_forced: Optional[bool] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource]:
        """Register a user provided function app with a static site.

        Description for Register a user provided function app with a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param function_app_name: Name of the function app registered with the static site. Required.
        :type function_app_name: str
        :param static_site_user_provided_function_envelope: A JSON representation of the user provided
         function app properties. See example. Is one of the following types:
         StaticSiteUserProvidedFunctionAppARMResource, JSON, IO[bytes] Required.
        :type static_site_user_provided_function_envelope:
         ~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource or JSON or IO[bytes]
        :keyword is_forced: Specify <code>true</code> to force the update of the auth configuration on
         the function app even if an AzureStaticWebApps provider is already configured on the function
         app. The default is <code>false</code>. Default value is None.
        :paramtype is_forced: bool
        :return: An instance of AsyncLROPoller that returns
         StaticSiteUserProvidedFunctionAppARMResource. The StaticSiteUserProvidedFunctionAppARMResource
         is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StaticSiteUserProvidedFunctionAppARMResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._register_user_provided_function_app_with_static_site_initial(
                resource_group_name=resource_group_name,
                name=name,
                function_app_name=function_app_name,
                static_site_user_provided_function_envelope=static_site_user_provided_function_envelope,
                is_forced=is_forced,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.StaticSiteUserProvidedFunctionAppARMResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.StaticSiteUserProvidedFunctionAppARMResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def detach_user_provided_function_app_from_static_site(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, function_app_name: str, **kwargs: Any
    ) -> None:
        """Detach the user provided function app from the static site.

        Description for Detach the user provided function app from the static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param function_app_name: Name of the function app registered with the static site. Required.
        :type function_app_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_static_sites_detach_user_provided_function_app_from_static_site_request(
            resource_group_name=resource_group_name,
            name=name,
            function_app_name=function_app_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_user_provided_function_apps_for_static_site(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StaticSiteUserProvidedFunctionAppARMResource"]:
        """Gets the details of the user provided function apps registered with a static site.

        Description for Gets the details of the user provided function apps registered with a static
        site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: An iterator like instance of StaticSiteUserProvidedFunctionAppARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteUserProvidedFunctionAppARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteUserProvidedFunctionAppARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_get_user_provided_function_apps_for_static_site_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.StaticSiteUserProvidedFunctionAppARMResource], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_basic_auth(
        self, resource_group_name: str, name: str, basic_auth_name: Union[str, _models.BasicAuthName], **kwargs: Any
    ) -> _models.StaticSiteBasicAuthPropertiesARMResource:
        """Gets the basic auth properties for a static site.

        Description for Gets the basic auth properties for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param basic_auth_name: name of the basic auth entry. "default" Required.
        :type basic_auth_name: str or ~azure.mgmt.web.models.BasicAuthName
        :return: StaticSiteBasicAuthPropertiesARMResource. The StaticSiteBasicAuthPropertiesARMResource
         is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteBasicAuthPropertiesARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StaticSiteBasicAuthPropertiesARMResource] = kwargs.pop("cls", None)

        _request = build_static_sites_get_basic_auth_request(
            resource_group_name=resource_group_name,
            name=name,
            basic_auth_name=basic_auth_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteBasicAuthPropertiesARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_basic_auth(
        self,
        resource_group_name: str,
        name: str,
        basic_auth_name: Union[str, _models.BasicAuthName],
        basic_auth_envelope: _models.StaticSiteBasicAuthPropertiesARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteBasicAuthPropertiesARMResource:
        """Adds or updates basic auth for a static site.

        Description for Adds or updates basic auth for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param basic_auth_name: name of the basic auth entry. "default" Required.
        :type basic_auth_name: str or ~azure.mgmt.web.models.BasicAuthName
        :param basic_auth_envelope: A JSON representation of the basic auth properties. Required.
        :type basic_auth_envelope: ~azure.mgmt.web.models.StaticSiteBasicAuthPropertiesARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteBasicAuthPropertiesARMResource. The StaticSiteBasicAuthPropertiesARMResource
         is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteBasicAuthPropertiesARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_basic_auth(
        self,
        resource_group_name: str,
        name: str,
        basic_auth_name: Union[str, _models.BasicAuthName],
        basic_auth_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteBasicAuthPropertiesARMResource:
        """Adds or updates basic auth for a static site.

        Description for Adds or updates basic auth for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param basic_auth_name: name of the basic auth entry. "default" Required.
        :type basic_auth_name: str or ~azure.mgmt.web.models.BasicAuthName
        :param basic_auth_envelope: A JSON representation of the basic auth properties. Required.
        :type basic_auth_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteBasicAuthPropertiesARMResource. The StaticSiteBasicAuthPropertiesARMResource
         is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteBasicAuthPropertiesARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_basic_auth(
        self,
        resource_group_name: str,
        name: str,
        basic_auth_name: Union[str, _models.BasicAuthName],
        basic_auth_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSiteBasicAuthPropertiesARMResource:
        """Adds or updates basic auth for a static site.

        Description for Adds or updates basic auth for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param basic_auth_name: name of the basic auth entry. "default" Required.
        :type basic_auth_name: str or ~azure.mgmt.web.models.BasicAuthName
        :param basic_auth_envelope: A JSON representation of the basic auth properties. Required.
        :type basic_auth_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSiteBasicAuthPropertiesARMResource. The StaticSiteBasicAuthPropertiesARMResource
         is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteBasicAuthPropertiesARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_basic_auth(
        self,
        resource_group_name: str,
        name: str,
        basic_auth_name: Union[str, _models.BasicAuthName],
        basic_auth_envelope: Union[_models.StaticSiteBasicAuthPropertiesARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StaticSiteBasicAuthPropertiesARMResource:
        """Adds or updates basic auth for a static site.

        Description for Adds or updates basic auth for a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param basic_auth_name: name of the basic auth entry. "default" Required.
        :type basic_auth_name: str or ~azure.mgmt.web.models.BasicAuthName
        :param basic_auth_envelope: A JSON representation of the basic auth properties. Is one of the
         following types: StaticSiteBasicAuthPropertiesARMResource, JSON, IO[bytes] Required.
        :type basic_auth_envelope: ~azure.mgmt.web.models.StaticSiteBasicAuthPropertiesARMResource or
         JSON or IO[bytes]
        :return: StaticSiteBasicAuthPropertiesARMResource. The StaticSiteBasicAuthPropertiesARMResource
         is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteBasicAuthPropertiesARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StaticSiteBasicAuthPropertiesARMResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(basic_auth_envelope, (IOBase, bytes)):
            _content = basic_auth_envelope
        else:
            _content = json.dumps(basic_auth_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_or_update_basic_auth_request(
            resource_group_name=resource_group_name,
            name=name,
            basic_auth_name=basic_auth_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteBasicAuthPropertiesARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_basic_auth(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StaticSiteBasicAuthPropertiesARMResource"]:
        """Gets the basic auth properties for a static site as a collection.

        Description for Gets the basic auth properties for a static site as a collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: An iterator like instance of StaticSiteBasicAuthPropertiesARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteBasicAuthPropertiesARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteBasicAuthPropertiesARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_list_basic_auth_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.StaticSiteBasicAuthPropertiesARMResource], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_static_site_custom_domain(
        self, resource_group_name: str, name: str, domain_name: str, **kwargs: Any
    ) -> _models.StaticSiteCustomDomainOverviewARMResource:
        """Gets an existing custom domain for a particular static site.

        Description for Gets an existing custom domain for a particular static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param domain_name: The custom domain name. Required.
        :type domain_name: str
        :return: StaticSiteCustomDomainOverviewARMResource. The
         StaticSiteCustomDomainOverviewARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteCustomDomainOverviewARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StaticSiteCustomDomainOverviewARMResource] = kwargs.pop("cls", None)

        _request = build_static_sites_get_static_site_custom_domain_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_name=domain_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteCustomDomainOverviewARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_static_site_custom_domain_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_name: str,
        static_site_custom_domain_request_properties_envelope: Union[
            _models.StaticSiteCustomDomainRequestPropertiesARMResource, JSON, IO[bytes]
        ],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_custom_domain_request_properties_envelope, (IOBase, bytes)):
            _content = static_site_custom_domain_request_properties_envelope
        else:
            _content = json.dumps(static_site_custom_domain_request_properties_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_create_or_update_static_site_custom_domain_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_name=domain_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update_static_site_custom_domain(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_name: str,
        static_site_custom_domain_request_properties_envelope: _models.StaticSiteCustomDomainRequestPropertiesARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteCustomDomainOverviewARMResource]:
        """Creates a new static site custom domain in an existing resource group and static site.

        Description for Creates a new static site custom domain in an existing resource group and
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param domain_name: The custom domain name. Required.
        :type domain_name: str
        :param static_site_custom_domain_request_properties_envelope: A JSON representation of the
         static site custom domain request properties. See example. Required.
        :type static_site_custom_domain_request_properties_envelope:
         ~azure.mgmt.web.models.StaticSiteCustomDomainRequestPropertiesARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteCustomDomainOverviewARMResource.
         The StaticSiteCustomDomainOverviewARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteCustomDomainOverviewARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_static_site_custom_domain(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_name: str,
        static_site_custom_domain_request_properties_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteCustomDomainOverviewARMResource]:
        """Creates a new static site custom domain in an existing resource group and static site.

        Description for Creates a new static site custom domain in an existing resource group and
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param domain_name: The custom domain name. Required.
        :type domain_name: str
        :param static_site_custom_domain_request_properties_envelope: A JSON representation of the
         static site custom domain request properties. See example. Required.
        :type static_site_custom_domain_request_properties_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteCustomDomainOverviewARMResource.
         The StaticSiteCustomDomainOverviewARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteCustomDomainOverviewARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_static_site_custom_domain(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_name: str,
        static_site_custom_domain_request_properties_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteCustomDomainOverviewARMResource]:
        """Creates a new static site custom domain in an existing resource group and static site.

        Description for Creates a new static site custom domain in an existing resource group and
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param domain_name: The custom domain name. Required.
        :type domain_name: str
        :param static_site_custom_domain_request_properties_envelope: A JSON representation of the
         static site custom domain request properties. See example. Required.
        :type static_site_custom_domain_request_properties_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteCustomDomainOverviewARMResource.
         The StaticSiteCustomDomainOverviewARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteCustomDomainOverviewARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update_static_site_custom_domain(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_name: str,
        static_site_custom_domain_request_properties_envelope: Union[
            _models.StaticSiteCustomDomainRequestPropertiesARMResource, JSON, IO[bytes]
        ],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteCustomDomainOverviewARMResource]:
        """Creates a new static site custom domain in an existing resource group and static site.

        Description for Creates a new static site custom domain in an existing resource group and
        static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param domain_name: The custom domain name. Required.
        :type domain_name: str
        :param static_site_custom_domain_request_properties_envelope: A JSON representation of the
         static site custom domain request properties. See example. Is one of the following types:
         StaticSiteCustomDomainRequestPropertiesARMResource, JSON, IO[bytes] Required.
        :type static_site_custom_domain_request_properties_envelope:
         ~azure.mgmt.web.models.StaticSiteCustomDomainRequestPropertiesARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns StaticSiteCustomDomainOverviewARMResource.
         The StaticSiteCustomDomainOverviewARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteCustomDomainOverviewARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StaticSiteCustomDomainOverviewARMResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_static_site_custom_domain_initial(
                resource_group_name=resource_group_name,
                name=name,
                domain_name=domain_name,
                static_site_custom_domain_request_properties_envelope=static_site_custom_domain_request_properties_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.StaticSiteCustomDomainOverviewARMResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.StaticSiteCustomDomainOverviewARMResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.StaticSiteCustomDomainOverviewARMResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_static_site_custom_domain_initial(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, domain_name: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_static_sites_delete_static_site_custom_domain_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_name=domain_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_delete_static_site_custom_domain(
        self, resource_group_name: str, name: str, domain_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes a custom domain.

        Description for Deletes a custom domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param domain_name: The custom domain name. Required.
        :type domain_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_static_site_custom_domain_initial(
                resource_group_name=resource_group_name,
                name=name,
                domain_name=domain_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_static_site_custom_domains(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StaticSiteCustomDomainOverviewARMResource"]:
        """Gets all static site custom domains for a particular static site.

        Description for Gets all static site custom domains for a particular static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: An iterator like instance of StaticSiteCustomDomainOverviewARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteCustomDomainOverviewARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteCustomDomainOverviewARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_list_static_site_custom_domains_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.StaticSiteCustomDomainOverviewARMResource], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _validate_custom_domain_can_be_added_to_static_site_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_name: str,
        static_site_custom_domain_request_properties_envelope: Union[
            _models.StaticSiteCustomDomainRequestPropertiesARMResource, JSON, IO[bytes]
        ],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_custom_domain_request_properties_envelope, (IOBase, bytes)):
            _content = static_site_custom_domain_request_properties_envelope
        else:
            _content = json.dumps(static_site_custom_domain_request_properties_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_validate_custom_domain_can_be_added_to_static_site_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_name=domain_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_validate_custom_domain_can_be_added_to_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_name: str,
        static_site_custom_domain_request_properties_envelope: _models.StaticSiteCustomDomainRequestPropertiesARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates a particular custom domain can be added to a static site.

        Description for Validates a particular custom domain can be added to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param domain_name: The custom domain name. Required.
        :type domain_name: str
        :param static_site_custom_domain_request_properties_envelope: A JSON representation of the
         static site custom domain request properties. See example. Required.
        :type static_site_custom_domain_request_properties_envelope:
         ~azure.mgmt.web.models.StaticSiteCustomDomainRequestPropertiesARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_validate_custom_domain_can_be_added_to_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_name: str,
        static_site_custom_domain_request_properties_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates a particular custom domain can be added to a static site.

        Description for Validates a particular custom domain can be added to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param domain_name: The custom domain name. Required.
        :type domain_name: str
        :param static_site_custom_domain_request_properties_envelope: A JSON representation of the
         static site custom domain request properties. See example. Required.
        :type static_site_custom_domain_request_properties_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_validate_custom_domain_can_be_added_to_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_name: str,
        static_site_custom_domain_request_properties_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates a particular custom domain can be added to a static site.

        Description for Validates a particular custom domain can be added to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param domain_name: The custom domain name. Required.
        :type domain_name: str
        :param static_site_custom_domain_request_properties_envelope: A JSON representation of the
         static site custom domain request properties. See example. Required.
        :type static_site_custom_domain_request_properties_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_validate_custom_domain_can_be_added_to_static_site(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_name: str,
        static_site_custom_domain_request_properties_envelope: Union[
            _models.StaticSiteCustomDomainRequestPropertiesARMResource, JSON, IO[bytes]
        ],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates a particular custom domain can be added to a static site.

        Description for Validates a particular custom domain can be added to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param domain_name: The custom domain name. Required.
        :type domain_name: str
        :param static_site_custom_domain_request_properties_envelope: A JSON representation of the
         static site custom domain request properties. See example. Is one of the following types:
         StaticSiteCustomDomainRequestPropertiesARMResource, JSON, IO[bytes] Required.
        :type static_site_custom_domain_request_properties_envelope:
         ~azure.mgmt.web.models.StaticSiteCustomDomainRequestPropertiesARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._validate_custom_domain_can_be_added_to_static_site_initial(
                resource_group_name=resource_group_name,
                name=name,
                domain_name=domain_name,
                static_site_custom_domain_request_properties_envelope=static_site_custom_domain_request_properties_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def get_linked_backend(
        self, resource_group_name: str, name: str, linked_backend_name: str, **kwargs: Any
    ) -> _models.StaticSiteLinkedBackendARMResource:
        """Returns the details of a linked backend linked to a static site by name.

        Returns the details of a linked backend linked to a static site by name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :return: StaticSiteLinkedBackendARMResource. The StaticSiteLinkedBackendARMResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StaticSiteLinkedBackendARMResource] = kwargs.pop("cls", None)

        _request = build_static_sites_get_linked_backend_request(
            resource_group_name=resource_group_name,
            name=name,
            linked_backend_name=linked_backend_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteLinkedBackendARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _link_backend_initial(
        self,
        resource_group_name: str,
        name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: Union[_models.StaticSiteLinkedBackendARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_linked_backend_envelope, (IOBase, bytes)):
            _content = static_site_linked_backend_envelope
        else:
            _content = json.dumps(static_site_linked_backend_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_link_backend_request(
            resource_group_name=resource_group_name,
            name=name,
            linked_backend_name=linked_backend_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_link_backend(
        self,
        resource_group_name: str,
        name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: _models.StaticSiteLinkedBackendARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource]:
        """Link backend to a static site.

        Link backend to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope:
         ~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteLinkedBackendARMResource. The
         StaticSiteLinkedBackendARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_link_backend(
        self,
        resource_group_name: str,
        name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource]:
        """Link backend to a static site.

        Link backend to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteLinkedBackendARMResource. The
         StaticSiteLinkedBackendARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_link_backend(
        self,
        resource_group_name: str,
        name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource]:
        """Link backend to a static site.

        Link backend to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteLinkedBackendARMResource. The
         StaticSiteLinkedBackendARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_link_backend(
        self,
        resource_group_name: str,
        name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: Union[_models.StaticSiteLinkedBackendARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource]:
        """Link backend to a static site.

        Link backend to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Is one of the following types: StaticSiteLinkedBackendARMResource, JSON, IO[bytes]
         Required.
        :type static_site_linked_backend_envelope:
         ~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns StaticSiteLinkedBackendARMResource. The
         StaticSiteLinkedBackendARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StaticSiteLinkedBackendARMResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._link_backend_initial(
                resource_group_name=resource_group_name,
                name=name,
                linked_backend_name=linked_backend_name,
                static_site_linked_backend_envelope=static_site_linked_backend_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            deserialized = _deserialize(_models.StaticSiteLinkedBackendARMResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def unlink_backend(
        self,
        resource_group_name: str,
        name: str,
        linked_backend_name: str,
        *,
        is_cleaning_auth_config: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Unlink a backend from a static site.

        Unlink a backend from a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :keyword is_cleaning_auth_config: Decides if Easy Auth configuration will be removed from
         backend configuration. Default value is None.
        :paramtype is_cleaning_auth_config: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_static_sites_unlink_backend_request(
            resource_group_name=resource_group_name,
            name=name,
            linked_backend_name=linked_backend_name,
            subscription_id=self._config.subscription_id,
            is_cleaning_auth_config=is_cleaning_auth_config,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_linked_backends(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StaticSiteLinkedBackendARMResource"]:
        """Returns details of all backends linked to a static site.

        Returns details of all backends linked to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :return: An iterator like instance of StaticSiteLinkedBackendARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteLinkedBackendARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_get_linked_backends_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.StaticSiteLinkedBackendARMResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _validate_backend_initial(
        self,
        resource_group_name: str,
        name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: Union[_models.StaticSiteLinkedBackendARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_linked_backend_envelope, (IOBase, bytes)):
            _content = static_site_linked_backend_envelope
        else:
            _content = json.dumps(static_site_linked_backend_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_validate_backend_request(
            resource_group_name=resource_group_name,
            name=name,
            linked_backend_name=linked_backend_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_validate_backend(
        self,
        resource_group_name: str,
        name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: _models.StaticSiteLinkedBackendARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates that a backend can be linked to a static site.

        Validates that a backend can be linked to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope:
         ~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_validate_backend(
        self,
        resource_group_name: str,
        name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates that a backend can be linked to a static site.

        Validates that a backend can be linked to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_validate_backend(
        self,
        resource_group_name: str,
        name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates that a backend can be linked to a static site.

        Validates that a backend can be linked to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_validate_backend(
        self,
        resource_group_name: str,
        name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: Union[_models.StaticSiteLinkedBackendARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates that a backend can be linked to a static site.

        Validates that a backend can be linked to a static site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Is one of the following types: StaticSiteLinkedBackendARMResource, JSON, IO[bytes]
         Required.
        :type static_site_linked_backend_envelope:
         ~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._validate_backend_initial(
                resource_group_name=resource_group_name,
                name=name,
                linked_backend_name=linked_backend_name,
                static_site_linked_backend_envelope=static_site_linked_backend_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def get_linked_backend_for_build(
        self, resource_group_name: str, name: str, environment_name: str, linked_backend_name: str, **kwargs: Any
    ) -> _models.StaticSiteLinkedBackendARMResource:
        """Returns the details of a linked backend linked to a static site build by name.

        Returns the details of a linked backend linked to a static site build by name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :return: StaticSiteLinkedBackendARMResource. The StaticSiteLinkedBackendARMResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StaticSiteLinkedBackendARMResource] = kwargs.pop("cls", None)

        _request = build_static_sites_get_linked_backend_for_build_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            linked_backend_name=linked_backend_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSiteLinkedBackendARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _link_backend_to_build_initial(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: Union[_models.StaticSiteLinkedBackendARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_linked_backend_envelope, (IOBase, bytes)):
            _content = static_site_linked_backend_envelope
        else:
            _content = json.dumps(static_site_linked_backend_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_link_backend_to_build_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            linked_backend_name=linked_backend_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_link_backend_to_build(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: _models.StaticSiteLinkedBackendARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource]:
        """Link backend to a static site build.

        Link backend to a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope:
         ~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteLinkedBackendARMResource. The
         StaticSiteLinkedBackendARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_link_backend_to_build(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource]:
        """Link backend to a static site build.

        Link backend to a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteLinkedBackendARMResource. The
         StaticSiteLinkedBackendARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_link_backend_to_build(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource]:
        """Link backend to a static site build.

        Link backend to a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StaticSiteLinkedBackendARMResource. The
         StaticSiteLinkedBackendARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_link_backend_to_build(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: Union[_models.StaticSiteLinkedBackendARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource]:
        """Link backend to a static site build.

        Link backend to a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Is one of the following types: StaticSiteLinkedBackendARMResource, JSON, IO[bytes]
         Required.
        :type static_site_linked_backend_envelope:
         ~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns StaticSiteLinkedBackendARMResource. The
         StaticSiteLinkedBackendARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StaticSiteLinkedBackendARMResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._link_backend_to_build_initial(
                resource_group_name=resource_group_name,
                name=name,
                environment_name=environment_name,
                linked_backend_name=linked_backend_name,
                static_site_linked_backend_envelope=static_site_linked_backend_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            deserialized = _deserialize(_models.StaticSiteLinkedBackendARMResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.StaticSiteLinkedBackendARMResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def unlink_backend_from_build(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        linked_backend_name: str,
        *,
        is_cleaning_auth_config: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Unlink a backend from a static site build.

        Unlink a backend from a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :keyword is_cleaning_auth_config: Decides if auth will be removed from backend configuration.
         Default value is None.
        :paramtype is_cleaning_auth_config: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_static_sites_unlink_backend_from_build_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            linked_backend_name=linked_backend_name,
            subscription_id=self._config.subscription_id,
            is_cleaning_auth_config=is_cleaning_auth_config,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_linked_backends_for_build(
        self, resource_group_name: str, name: str, environment_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.StaticSiteLinkedBackendARMResource"]:
        """Returns details of all backends linked to a static site build.

        Returns details of all backends linked to a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :return: An iterator like instance of StaticSiteLinkedBackendARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.StaticSiteLinkedBackendARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_static_sites_get_linked_backends_for_build_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    environment_name=environment_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.StaticSiteLinkedBackendARMResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _validate_backend_for_build_initial(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: Union[_models.StaticSiteLinkedBackendARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_site_linked_backend_envelope, (IOBase, bytes)):
            _content = static_site_linked_backend_envelope
        else:
            _content = json.dumps(static_site_linked_backend_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_validate_backend_for_build_request(
            resource_group_name=resource_group_name,
            name=name,
            environment_name=environment_name,
            linked_backend_name=linked_backend_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_validate_backend_for_build(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: _models.StaticSiteLinkedBackendARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates that a backend can be linked to a static site build.

        Validates that a backend can be linked to a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope:
         ~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_validate_backend_for_build(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates that a backend can be linked to a static site build.

        Validates that a backend can be linked to a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_validate_backend_for_build(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates that a backend can be linked to a static site build.

        Validates that a backend can be linked to a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Required.
        :type static_site_linked_backend_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_validate_backend_for_build(
        self,
        resource_group_name: str,
        name: str,
        environment_name: str,
        linked_backend_name: str,
        static_site_linked_backend_envelope: Union[_models.StaticSiteLinkedBackendARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Validates that a backend can be linked to a static site build.

        Validates that a backend can be linked to a static site build.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the static site. Required.
        :type name: str
        :param environment_name: The stage site identifier. Required.
        :type environment_name: str
        :param linked_backend_name: Name of the linked backend that should be retrieved. Required.
        :type linked_backend_name: str
        :param static_site_linked_backend_envelope: A JSON representation of the linked backend request
         properties. Is one of the following types: StaticSiteLinkedBackendARMResource, JSON, IO[bytes]
         Required.
        :type static_site_linked_backend_envelope:
         ~azure.mgmt.web.models.StaticSiteLinkedBackendARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._validate_backend_for_build_initial(
                resource_group_name=resource_group_name,
                name=name,
                environment_name=environment_name,
                linked_backend_name=linked_backend_name,
                static_site_linked_backend_envelope=static_site_linked_backend_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    async def preview_workflow(
        self,
        location: str,
        static_sites_workflow_preview_request: _models.StaticSitesWorkflowPreviewRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSitesWorkflowPreview:
        """Generates a preview workflow file for the static site.

        Description for Generates a preview workflow file for the static site.

        :param location: The location name. Required.
        :type location: str
        :param static_sites_workflow_preview_request: The request body. Required.
        :type static_sites_workflow_preview_request:
         ~azure.mgmt.web.models.StaticSitesWorkflowPreviewRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSitesWorkflowPreview. The StaticSitesWorkflowPreview is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSitesWorkflowPreview
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def preview_workflow(
        self,
        location: str,
        static_sites_workflow_preview_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSitesWorkflowPreview:
        """Generates a preview workflow file for the static site.

        Description for Generates a preview workflow file for the static site.

        :param location: The location name. Required.
        :type location: str
        :param static_sites_workflow_preview_request: The request body. Required.
        :type static_sites_workflow_preview_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSitesWorkflowPreview. The StaticSitesWorkflowPreview is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSitesWorkflowPreview
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def preview_workflow(
        self,
        location: str,
        static_sites_workflow_preview_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StaticSitesWorkflowPreview:
        """Generates a preview workflow file for the static site.

        Description for Generates a preview workflow file for the static site.

        :param location: The location name. Required.
        :type location: str
        :param static_sites_workflow_preview_request: The request body. Required.
        :type static_sites_workflow_preview_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StaticSitesWorkflowPreview. The StaticSitesWorkflowPreview is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSitesWorkflowPreview
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def preview_workflow(
        self,
        location: str,
        static_sites_workflow_preview_request: Union[_models.StaticSitesWorkflowPreviewRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StaticSitesWorkflowPreview:
        """Generates a preview workflow file for the static site.

        Description for Generates a preview workflow file for the static site.

        :param location: The location name. Required.
        :type location: str
        :param static_sites_workflow_preview_request: The request body. Is one of the following types:
         StaticSitesWorkflowPreviewRequest, JSON, IO[bytes] Required.
        :type static_sites_workflow_preview_request:
         ~azure.mgmt.web.models.StaticSitesWorkflowPreviewRequest or JSON or IO[bytes]
        :return: StaticSitesWorkflowPreview. The StaticSitesWorkflowPreview is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.StaticSitesWorkflowPreview
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StaticSitesWorkflowPreview] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(static_sites_workflow_preview_request, (IOBase, bytes)):
            _content = static_sites_workflow_preview_request
        else:
            _content = json.dumps(static_sites_workflow_preview_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_static_sites_preview_workflow_request(
            location=location,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StaticSitesWorkflowPreview, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class WebAppsOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`web_apps` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_slots(self, resource_group_name: str, name: str, **kwargs: Any) -> AsyncItemPaged["_models.Site"]:
        """Gets an app's deployment slots.

        Description for Gets an app's deployment slots.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of Site
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Site]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_slots_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Site], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_slot(self, resource_group_name: str, name: str, slot: str, **kwargs: Any) -> _models.Site:
        """Gets the details of a web, mobile, or API app.

        Description for Gets the details of a web, mobile, or API app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: Site. The Site is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Site
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Site] = kwargs.pop("cls", None)

        _request = build_web_apps_get_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Site, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_slot_initial(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_envelope: Union[_models.Site, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_envelope, (IOBase, bytes)):
            _content = site_envelope
        else:
            _content = json.dumps(site_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_envelope: _models.Site,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Site]:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: ~azure.mgmt.web.models.Site
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Site. The Site is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Site]:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Site. The Site is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Site]:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Site. The Site is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_envelope: Union[_models.Site, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Site]:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_envelope: A JSON representation of the app properties. See example. Is one of the
         following types: Site, JSON, IO[bytes] Required.
        :type site_envelope: ~azure.mgmt.web.models.Site or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns Site. The Site is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Site] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                site_envelope=site_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.Site, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.Site].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.Site](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_envelope: _models.SitePatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Site:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: ~azure.mgmt.web.models.SitePatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Site. The Site is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Site
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Site:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Site. The Site is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Site
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Site:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Site. The Site is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Site
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_envelope: Union[_models.SitePatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Site:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_envelope: A JSON representation of the app properties. See example. Is one of the
         following types: SitePatchResource, JSON, IO[bytes] Required.
        :type site_envelope: ~azure.mgmt.web.models.SitePatchResource or JSON or IO[bytes]
        :return: Site. The Site is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Site
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Site] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_envelope, (IOBase, bytes)):
            _content = site_envelope
        else:
            _content = json.dumps(site_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Site, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        *,
        delete_metrics: Optional[bool] = None,
        delete_empty_server_farm: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a web, mobile, or API app, or one of the deployment slots.

        Description for Deletes a web, mobile, or API app, or one of the deployment slots.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :keyword delete_metrics: If true, web app metrics are also deleted. Default value is None.
        :paramtype delete_metrics: bool
        :keyword delete_empty_server_farm: Specify false if you want to keep empty App Service plan. By
         default, empty App Service plan is deleted. Default value is None.
        :paramtype delete_empty_server_farm: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            delete_metrics=delete_metrics,
            delete_empty_server_farm=delete_empty_server_farm,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_by_resource_group(
        self, resource_group_name: str, *, include_slots: Optional[bool] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.Site"]:
        """Gets all web, mobile, and API apps in the specified resource group.

        Description for Gets all web, mobile, and API apps in the specified resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :keyword include_slots: Specify <strong>true</strong> to include deployment slots in results.
         The default is false, which only gives you the production slot of all apps. Default value is
         None.
        :paramtype include_slots: bool
        :return: An iterator like instance of Site
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Site]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    include_slots=include_slots,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Site], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def analyze_custom_hostname_slot(
        self, resource_group_name: str, name: str, slot: str, *, host_name: Optional[str] = None, **kwargs: Any
    ) -> _models.CustomHostnameAnalysisResult:
        """Analyze a custom hostname.

        Description for Analyze a custom hostname.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :keyword host_name: Custom hostname. Default value is None.
        :paramtype host_name: str
        :return: CustomHostnameAnalysisResult. The CustomHostnameAnalysisResult is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.CustomHostnameAnalysisResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CustomHostnameAnalysisResult] = kwargs.pop("cls", None)

        _request = build_web_apps_analyze_custom_hostname_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            host_name=host_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CustomHostnameAnalysisResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def apply_slot_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: _models.CsmSlotEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Applies the configuration settings from the target slot onto the current slot.

        Description for Applies the configuration settings from the target slot onto the current slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def apply_slot_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Applies the configuration settings from the target slot onto the current slot.

        Description for Applies the configuration settings from the target slot onto the current slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def apply_slot_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Applies the configuration settings from the target slot onto the current slot.

        Description for Applies the configuration settings from the target slot onto the current slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def apply_slot_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: Union[_models.CsmSlotEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> None:
        """Applies the configuration settings from the target slot onto the current slot.

        Description for Applies the configuration settings from the target slot onto the current slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Is one of
         the following types: CsmSlotEntity, JSON, IO[bytes] Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(slot_swap_entity, (IOBase, bytes)):
            _content = slot_swap_entity
        else:
            _content = json.dumps(slot_swap_entity, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_apply_slot_configuration_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def backup_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: _models.BackupRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Creates a backup of an app.

        Description for Creates a backup of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Backup configuration. You can use the JSON response from the POST action as
         input here. Required.
        :type request: ~azure.mgmt.web.models.BackupRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def backup_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Creates a backup of an app.

        Description for Creates a backup of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Backup configuration. You can use the JSON response from the POST action as
         input here. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def backup_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Creates a backup of an app.

        Description for Creates a backup of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Backup configuration. You can use the JSON response from the POST action as
         input here. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def backup_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: Union[_models.BackupRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.BackupItem:
        """Creates a backup of an app.

        Description for Creates a backup of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Backup configuration. You can use the JSON response from the POST action as
         input here. Is one of the following types: BackupRequest, JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.BackupRequest or JSON or IO[bytes]
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BackupItem] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_backup_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BackupItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_application_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        app_settings: _models.StringDictionary,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the application settings of an app.

        Description for Replaces the application settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param app_settings: Application settings of the app. Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_application_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        app_settings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the application settings of an app.

        Description for Replaces the application settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param app_settings: Application settings of the app. Required.
        :type app_settings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_application_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        app_settings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the application settings of an app.

        Description for Replaces the application settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param app_settings: Application settings of the app. Required.
        :type app_settings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_application_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        app_settings: Union[_models.StringDictionary, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the application settings of an app.

        Description for Replaces the application settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param app_settings: Application settings of the app. Is one of the following types:
         StringDictionary, JSON, IO[bytes] Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary or JSON or IO[bytes]
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(app_settings, (IOBase, bytes)):
            _content = app_settings
        else:
            _content = json.dumps(app_settings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_application_settings_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_application_settings_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.StringDictionary:
        """Gets the application settings of an app.

        Description for Gets the application settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        _request = build_web_apps_list_application_settings_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_auth_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_auth_settings: _models.SiteAuthSettings,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettings:
        """Updates the Authentication / Authorization settings associated with web app.

        Description for Updates the Authentication / Authorization settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_auth_settings: Auth settings associated with web app. Required.
        :type site_auth_settings: ~azure.mgmt.web.models.SiteAuthSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettings. The SiteAuthSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_auth_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_auth_settings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettings:
        """Updates the Authentication / Authorization settings associated with web app.

        Description for Updates the Authentication / Authorization settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_auth_settings: Auth settings associated with web app. Required.
        :type site_auth_settings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettings. The SiteAuthSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_auth_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_auth_settings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettings:
        """Updates the Authentication / Authorization settings associated with web app.

        Description for Updates the Authentication / Authorization settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_auth_settings: Auth settings associated with web app. Required.
        :type site_auth_settings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettings. The SiteAuthSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_auth_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_auth_settings: Union[_models.SiteAuthSettings, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteAuthSettings:
        """Updates the Authentication / Authorization settings associated with web app.

        Description for Updates the Authentication / Authorization settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param site_auth_settings: Auth settings associated with web app. Is one of the following
         types: SiteAuthSettings, JSON, IO[bytes] Required.
        :type site_auth_settings: ~azure.mgmt.web.models.SiteAuthSettings or JSON or IO[bytes]
        :return: SiteAuthSettings. The SiteAuthSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteAuthSettings] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_auth_settings, (IOBase, bytes)):
            _content = site_auth_settings
        else:
            _content = json.dumps(site_auth_settings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_auth_settings_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteAuthSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_auth_settings_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.SiteAuthSettings:
        """Gets the Authentication/Authorization settings of an app.

        Description for Gets the Authentication/Authorization settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: SiteAuthSettings. The SiteAuthSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteAuthSettings] = kwargs.pop("cls", None)

        _request = build_web_apps_get_auth_settings_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteAuthSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_azure_storage_accounts_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        azure_storage_accounts: _models.AzureStoragePropertyDictionaryResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AzureStoragePropertyDictionaryResource:
        """Updates the Azure storage account configurations of an app.

        Description for Updates the Azure storage account configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param azure_storage_accounts: Azure storage accounts of the app. Required.
        :type azure_storage_accounts: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AzureStoragePropertyDictionaryResource. The AzureStoragePropertyDictionaryResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_azure_storage_accounts_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        azure_storage_accounts: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AzureStoragePropertyDictionaryResource:
        """Updates the Azure storage account configurations of an app.

        Description for Updates the Azure storage account configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param azure_storage_accounts: Azure storage accounts of the app. Required.
        :type azure_storage_accounts: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AzureStoragePropertyDictionaryResource. The AzureStoragePropertyDictionaryResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_azure_storage_accounts_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        azure_storage_accounts: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AzureStoragePropertyDictionaryResource:
        """Updates the Azure storage account configurations of an app.

        Description for Updates the Azure storage account configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param azure_storage_accounts: Azure storage accounts of the app. Required.
        :type azure_storage_accounts: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AzureStoragePropertyDictionaryResource. The AzureStoragePropertyDictionaryResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_azure_storage_accounts_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        azure_storage_accounts: Union[_models.AzureStoragePropertyDictionaryResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.AzureStoragePropertyDictionaryResource:
        """Updates the Azure storage account configurations of an app.

        Description for Updates the Azure storage account configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param azure_storage_accounts: Azure storage accounts of the app. Is one of the following
         types: AzureStoragePropertyDictionaryResource, JSON, IO[bytes] Required.
        :type azure_storage_accounts: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource or
         JSON or IO[bytes]
        :return: AzureStoragePropertyDictionaryResource. The AzureStoragePropertyDictionaryResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AzureStoragePropertyDictionaryResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(azure_storage_accounts, (IOBase, bytes)):
            _content = azure_storage_accounts
        else:
            _content = json.dumps(azure_storage_accounts, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_azure_storage_accounts_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AzureStoragePropertyDictionaryResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_azure_storage_accounts_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.AzureStoragePropertyDictionaryResource:
        """Gets the Azure storage account configurations of an app.

        Description for Gets the Azure storage account configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: AzureStoragePropertyDictionaryResource. The AzureStoragePropertyDictionaryResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AzureStoragePropertyDictionaryResource] = kwargs.pop("cls", None)

        _request = build_web_apps_list_azure_storage_accounts_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AzureStoragePropertyDictionaryResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_backup_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: _models.BackupRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupRequest:
        """Updates the backup configuration of an app.

        Description for Updates the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Edited backup configuration. Required.
        :type request: ~azure.mgmt.web.models.BackupRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupRequest. The BackupRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_backup_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupRequest:
        """Updates the backup configuration of an app.

        Description for Updates the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Edited backup configuration. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupRequest. The BackupRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_backup_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupRequest:
        """Updates the backup configuration of an app.

        Description for Updates the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Edited backup configuration. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupRequest. The BackupRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_backup_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: Union[_models.BackupRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.BackupRequest:
        """Updates the backup configuration of an app.

        Description for Updates the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Edited backup configuration. Is one of the following types: BackupRequest,
         JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.BackupRequest or JSON or IO[bytes]
        :return: BackupRequest. The BackupRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BackupRequest] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_backup_configuration_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BackupRequest, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_backup_configuration_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> None:
        """Deletes the backup configuration of an app.

        Description for Deletes the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_backup_configuration_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_backup_configuration_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.BackupRequest:
        """Gets the backup configuration of an app.

        Description for Gets the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: BackupRequest. The BackupRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BackupRequest] = kwargs.pop("cls", None)

        _request = build_web_apps_get_backup_configuration_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BackupRequest, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_connection_strings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_strings: _models.ConnectionStringDictionary,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConnectionStringDictionary:
        """Replaces the connection strings of an app.

        Description for Replaces the connection strings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param connection_strings: Connection strings of the app or deployment slot. See example.
         Required.
        :type connection_strings: ~azure.mgmt.web.models.ConnectionStringDictionary
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionStringDictionary. The ConnectionStringDictionary is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ConnectionStringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_connection_strings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_strings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConnectionStringDictionary:
        """Replaces the connection strings of an app.

        Description for Replaces the connection strings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param connection_strings: Connection strings of the app or deployment slot. See example.
         Required.
        :type connection_strings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionStringDictionary. The ConnectionStringDictionary is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ConnectionStringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_connection_strings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_strings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConnectionStringDictionary:
        """Replaces the connection strings of an app.

        Description for Replaces the connection strings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param connection_strings: Connection strings of the app or deployment slot. See example.
         Required.
        :type connection_strings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionStringDictionary. The ConnectionStringDictionary is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ConnectionStringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_connection_strings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_strings: Union[_models.ConnectionStringDictionary, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.ConnectionStringDictionary:
        """Replaces the connection strings of an app.

        Description for Replaces the connection strings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param connection_strings: Connection strings of the app or deployment slot. See example. Is
         one of the following types: ConnectionStringDictionary, JSON, IO[bytes] Required.
        :type connection_strings: ~azure.mgmt.web.models.ConnectionStringDictionary or JSON or
         IO[bytes]
        :return: ConnectionStringDictionary. The ConnectionStringDictionary is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ConnectionStringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ConnectionStringDictionary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_strings, (IOBase, bytes)):
            _content = connection_strings
        else:
            _content = json.dumps(connection_strings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_connection_strings_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConnectionStringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_connection_strings_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.ConnectionStringDictionary:
        """Gets the connection strings of an app.

        Description for Gets the connection strings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: ConnectionStringDictionary. The ConnectionStringDictionary is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ConnectionStringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ConnectionStringDictionary] = kwargs.pop("cls", None)

        _request = build_web_apps_list_connection_strings_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConnectionStringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_metadata_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        metadata: _models.StringDictionary,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the metadata of an app.

        Description for Replaces the metadata of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param metadata: Edited metadata of the app or deployment slot. See example. Required.
        :type metadata: ~azure.mgmt.web.models.StringDictionary
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_metadata_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        metadata: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the metadata of an app.

        Description for Replaces the metadata of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param metadata: Edited metadata of the app or deployment slot. See example. Required.
        :type metadata: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_metadata_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        metadata: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the metadata of an app.

        Description for Replaces the metadata of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param metadata: Edited metadata of the app or deployment slot. See example. Required.
        :type metadata: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_metadata_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        metadata: Union[_models.StringDictionary, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the metadata of an app.

        Description for Replaces the metadata of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param metadata: Edited metadata of the app or deployment slot. See example. Is one of the
         following types: StringDictionary, JSON, IO[bytes] Required.
        :type metadata: ~azure.mgmt.web.models.StringDictionary or JSON or IO[bytes]
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(metadata, (IOBase, bytes)):
            _content = metadata
        else:
            _content = json.dumps(metadata, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_metadata_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_metadata_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.StringDictionary:
        """Gets the metadata of an app.

        Description for Gets the metadata of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        _request = build_web_apps_list_metadata_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _list_publishing_credentials_slot_initial(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_list_publishing_credentials_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_list_publishing_credentials_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncLROPoller[_models.User]:
        """Gets the Git/FTP publishing credentials of an app.

        Description for Gets the Git/FTP publishing credentials of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: If true, the password is included in the response. The default is false. Required.
        :type slot: str
        :return: An instance of AsyncLROPoller that returns User. The User is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.User]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.User] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._list_publishing_credentials_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            deserialized = _deserialize(_models.User, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.User].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.User](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update_site_push_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        push_settings: _models.PushSettings,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PushSettings:
        """Updates the Push settings associated with web app.

        Description for Updates the Push settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param push_settings: Push settings associated with web app. Required.
        :type push_settings: ~azure.mgmt.web.models.PushSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PushSettings. The PushSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PushSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_site_push_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        push_settings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PushSettings:
        """Updates the Push settings associated with web app.

        Description for Updates the Push settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param push_settings: Push settings associated with web app. Required.
        :type push_settings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PushSettings. The PushSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PushSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_site_push_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        push_settings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PushSettings:
        """Updates the Push settings associated with web app.

        Description for Updates the Push settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param push_settings: Push settings associated with web app. Required.
        :type push_settings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PushSettings. The PushSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PushSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_site_push_settings_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        push_settings: Union[_models.PushSettings, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PushSettings:
        """Updates the Push settings associated with web app.

        Description for Updates the Push settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param push_settings: Push settings associated with web app. Is one of the following types:
         PushSettings, JSON, IO[bytes] Required.
        :type push_settings: ~azure.mgmt.web.models.PushSettings or JSON or IO[bytes]
        :return: PushSettings. The PushSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PushSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PushSettings] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(push_settings, (IOBase, bytes)):
            _content = push_settings
        else:
            _content = json.dumps(push_settings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_site_push_settings_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PushSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_site_push_settings_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.PushSettings:
        """Gets the Push settings associated with web app.

        Description for Gets the Push settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: PushSettings. The PushSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PushSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PushSettings] = kwargs.pop("cls", None)

        _request = build_web_apps_list_site_push_settings_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PushSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_web_site_container_logs_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> Optional[AsyncIterator[bytes]]:
        """Gets the last lines of docker logs for the given site.

        Description for Gets the last lines of docker logs for the given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: AsyncIterator[bytes] or None
        :rtype: AsyncIterator[bytes] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[AsyncIterator[bytes]]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_web_site_container_logs_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_container_logs_zip_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> Optional[AsyncIterator[bytes]]:
        """Gets the ZIP archived docker log files for the given site.

        Description for Gets the ZIP archived docker log files for the given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: AsyncIterator[bytes] or None
        :rtype: AsyncIterator[bytes] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[AsyncIterator[bytes]]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_container_logs_zip_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def discover_backup_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: _models.RestoreRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RestoreRequest:
        """Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to
        get information about the databases stored in a backup.

        Description for Discovers an existing app backup that can be restored from a blob in Azure
        storage. Use this to get information about the databases stored in a backup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: A RestoreRequest object that includes Azure storage URL and blog name for
         discovery of backup. Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RestoreRequest. The RestoreRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RestoreRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def discover_backup_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RestoreRequest:
        """Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to
        get information about the databases stored in a backup.

        Description for Discovers an existing app backup that can be restored from a blob in Azure
        storage. Use this to get information about the databases stored in a backup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: A RestoreRequest object that includes Azure storage URL and blog name for
         discovery of backup. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RestoreRequest. The RestoreRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RestoreRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def discover_backup_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RestoreRequest:
        """Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to
        get information about the databases stored in a backup.

        Description for Discovers an existing app backup that can be restored from a blob in Azure
        storage. Use this to get information about the databases stored in a backup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: A RestoreRequest object that includes Azure storage URL and blog name for
         discovery of backup. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RestoreRequest. The RestoreRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RestoreRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def discover_backup_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: Union[_models.RestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.RestoreRequest:
        """Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to
        get information about the databases stored in a backup.

        Description for Discovers an existing app backup that can be restored from a blob in Azure
        storage. Use this to get information about the databases stored in a backup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: A RestoreRequest object that includes Azure storage URL and blog name for
         discovery of backup. Is one of the following types: RestoreRequest, JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest or JSON or IO[bytes]
        :return: RestoreRequest. The RestoreRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RestoreRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RestoreRequest] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_discover_backup_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RestoreRequest, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_functions_admin_token_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> str:
        """Fetch a short lived token that can be exchanged for a master key.

        Description for Fetch a short lived token that can be exchanged for a master key.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[str] = kwargs.pop("cls", None)

        _request = build_web_apps_get_functions_admin_token_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(str, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_host_keys_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.HostKeys:
        """Get host secrets for a function app.

        Description for Get host secrets for a function app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: HostKeys. The HostKeys is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostKeys
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HostKeys] = kwargs.pop("cls", None)

        _request = build_web_apps_list_host_keys_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HostKeys, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_sync_status_slot(self, resource_group_name: str, name: str, slot: str, **kwargs: Any) -> None:
        """This is to allow calling via powershell and ARM template.

        Description for This is to allow calling via powershell and ARM template.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_list_sync_status_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def sync_functions_slot(self, resource_group_name: str, name: str, slot: str, **kwargs: Any) -> None:
        """Syncs function trigger metadata to the management database.

        Description for Syncs function trigger metadata to the management database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_sync_functions_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_or_update_host_secret_slot(
        self,
        resource_group_name: str,
        name: str,
        key_type: str,
        key_name: str,
        slot: str,
        key: _models.KeyInfo,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a host level secret.

        Description for Add or update a host level secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param key_type: The type of host key. Required.
        :type key_type: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param key: The key to create or update. Required.
        :type key: ~azure.mgmt.web.models.KeyInfo
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_host_secret_slot(
        self,
        resource_group_name: str,
        name: str,
        key_type: str,
        key_name: str,
        slot: str,
        key: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a host level secret.

        Description for Add or update a host level secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param key_type: The type of host key. Required.
        :type key_type: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param key: The key to create or update. Required.
        :type key: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_host_secret_slot(
        self,
        resource_group_name: str,
        name: str,
        key_type: str,
        key_name: str,
        slot: str,
        key: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a host level secret.

        Description for Add or update a host level secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param key_type: The type of host key. Required.
        :type key_type: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param key: The key to create or update. Required.
        :type key: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_host_secret_slot(
        self,
        resource_group_name: str,
        name: str,
        key_type: str,
        key_name: str,
        slot: str,
        key: Union[_models.KeyInfo, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a host level secret.

        Description for Add or update a host level secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param key_type: The type of host key. Required.
        :type key_type: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param key: The key to create or update. Is one of the following types: KeyInfo, JSON,
         IO[bytes] Required.
        :type key: ~azure.mgmt.web.models.KeyInfo or JSON or IO[bytes]
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.KeyInfo] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(key, (IOBase, bytes)):
            _content = key
        else:
            _content = json.dumps(key, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_host_secret_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            key_type=key_type,
            key_name=key_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.KeyInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_host_secret_slot(
        self, resource_group_name: str, name: str, key_type: str, key_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Delete a host level secret.

        Description for Delete a host level secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param key_type: The type of host key. Required.
        :type key_type: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_host_secret_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            key_type=key_type,
            key_name=key_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_hybrid_connections_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.HybridConnection:
        """Retrieves all Service Bus Hybrid Connections used by this Web App.

        Description for Retrieves all Service Bus Hybrid Connections used by this Web App.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HybridConnection] = kwargs.pop("cls", None)

        _request = build_web_apps_list_hybrid_connections_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HybridConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_relay_service_connections_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Gets hybrid connections configured for an app (or deployment slot, if specified).

        Description for Gets hybrid connections configured for an app (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RelayServiceConnectionEntity] = kwargs.pop("cls", None)

        _request = build_web_apps_list_relay_service_connections_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RelayServiceConnectionEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def is_cloneable_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.SiteCloneability:
        """Shows whether an app can be cloned to another resource group or subscription.

        Description for Shows whether an app can be cloned to another resource group or subscription.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: SiteCloneability. The SiteCloneability is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteCloneability
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteCloneability] = kwargs.pop("cls", None)

        _request = build_web_apps_is_cloneable_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteCloneability, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_site_backups_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.BackupItem"]:
        """Gets existing backups of an app.

        Description for Gets existing backups of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: An iterator like instance of BackupItem
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.BackupItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BackupItem]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_site_backups_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.BackupItem], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_sync_function_triggers_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.FunctionSecrets:
        """This is to allow calling via powershell and ARM template.

        Description for This is to allow calling via powershell and ARM template.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: FunctionSecrets. The FunctionSecrets is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.FunctionSecrets
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FunctionSecrets] = kwargs.pop("cls", None)

        _request = build_web_apps_list_sync_function_triggers_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FunctionSecrets, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_network_trace_operation_slot(
        self, resource_group_name: str, name: str, operation_id: str, slot: str, **kwargs: Any
    ) -> List[_models.NetworkTrace]:
        """Gets a named operation for a network trace capturing (or deployment slot, if specified).

        Description for Gets a named operation for a network trace capturing (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param operation_id: GUID of the operation. Required.
        :type operation_id: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: list of NetworkTrace
        :rtype: list[~azure.mgmt.web.models.NetworkTrace]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.NetworkTrace]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_network_trace_operation_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            operation_id=operation_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.NetworkTrace], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def start_web_site_network_trace_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        *,
        duration_in_seconds: Optional[int] = None,
        max_frame_length: Optional[int] = None,
        sas_url: Optional[str] = None,
        **kwargs: Any
    ) -> str:
        """Start capturing network packets for the site (To be deprecated).

        Description for Start capturing network packets for the site (To be deprecated).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :keyword duration_in_seconds: The duration to keep capturing in seconds. Default value is None.
        :paramtype duration_in_seconds: int
        :keyword max_frame_length: The maximum frame length in bytes (Optional). Default value is None.
        :paramtype max_frame_length: int
        :keyword sas_url: The Blob URL to store capture file. Default value is None.
        :paramtype sas_url: str
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[str] = kwargs.pop("cls", None)

        _request = build_web_apps_start_web_site_network_trace_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            duration_in_seconds=duration_in_seconds,
            max_frame_length=max_frame_length,
            sas_url=sas_url,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(str, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _start_web_site_network_trace_operation_slot_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        *,
        duration_in_seconds: Optional[int] = None,
        max_frame_length: Optional[int] = None,
        sas_url: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_start_web_site_network_trace_operation_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            duration_in_seconds=duration_in_seconds,
            max_frame_length=max_frame_length,
            sas_url=sas_url,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_start_web_site_network_trace_operation_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        *,
        duration_in_seconds: Optional[int] = None,
        max_frame_length: Optional[int] = None,
        sas_url: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Start capturing network packets for the site.

        Description for Start capturing network packets for the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :keyword duration_in_seconds: The duration to keep capturing in seconds. Default value is None.
        :paramtype duration_in_seconds: int
        :keyword max_frame_length: The maximum frame length in bytes (Optional). Default value is None.
        :paramtype max_frame_length: int
        :keyword sas_url: The Blob URL to store capture file. Default value is None.
        :paramtype sas_url: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._start_web_site_network_trace_operation_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                duration_in_seconds=duration_in_seconds,
                max_frame_length=max_frame_length,
                sas_url=sas_url,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def stop_web_site_network_trace_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> None:
        """Stop ongoing capturing network packets for the site.

        Description for Stop ongoing capturing network packets for the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_stop_web_site_network_trace_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_network_traces_slot(
        self, resource_group_name: str, name: str, operation_id: str, slot: str, **kwargs: Any
    ) -> List[_models.NetworkTrace]:
        """Gets a named operation for a network trace capturing (or deployment slot, if specified).

        Description for Gets a named operation for a network trace capturing (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param operation_id: GUID of the operation. Required.
        :type operation_id: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: list of NetworkTrace
        :rtype: list[~azure.mgmt.web.models.NetworkTrace]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.NetworkTrace]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_network_traces_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            operation_id=operation_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.NetworkTrace], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_network_trace_operation_slot_v2(
        self, resource_group_name: str, name: str, operation_id: str, slot: str, **kwargs: Any
    ) -> List[_models.NetworkTrace]:
        """Gets a named operation for a network trace capturing (or deployment slot, if specified).

        Description for Gets a named operation for a network trace capturing (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param operation_id: GUID of the operation. Required.
        :type operation_id: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: list of NetworkTrace
        :rtype: list[~azure.mgmt.web.models.NetworkTrace]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.NetworkTrace]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_network_trace_operation_slot_v2_request(
            resource_group_name=resource_group_name,
            name=name,
            operation_id=operation_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.NetworkTrace], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_network_traces_slot_v2(
        self, resource_group_name: str, name: str, operation_id: str, slot: str, **kwargs: Any
    ) -> List[_models.NetworkTrace]:
        """Gets a named operation for a network trace capturing (or deployment slot, if specified).

        Description for Gets a named operation for a network trace capturing (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param operation_id: GUID of the operation. Required.
        :type operation_id: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: list of NetworkTrace
        :rtype: list[~azure.mgmt.web.models.NetworkTrace]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.NetworkTrace]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_network_traces_slot_v2_request(
            resource_group_name=resource_group_name,
            name=name,
            operation_id=operation_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.NetworkTrace], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def generate_new_site_publishing_password_slot(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> None:
        """Generates a new publishing password for an app (or deployment slot, if specified).

        Description for Generates a new publishing password for an app (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_generate_new_site_publishing_password_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_perf_mon_counters_slot(
        self, resource_group_name: str, name: str, slot: str, *, filter: Optional[str] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PerfMonResponse"]:
        """Gets perfmon counters for web app.

        Description for Gets perfmon counters for web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :keyword filter: Return only usages/metrics specified in the filter. Filter conforms to odata
         syntax. Example: $filter=(startTime eq 2014-01-01T00:00:00Z and endTime eq 2014-12-31T23:59:59Z
         and timeGrain eq duration'[Hour|Minute|Day]'. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of PerfMonResponse
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.PerfMonResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PerfMonResponse]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_perf_mon_counters_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PerfMonResponse], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_php_error_log_flag_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.SitePhpErrorLogFlag:
        """Gets web app's event logs.

        Description for Gets web app's event logs.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: SitePhpErrorLogFlag. The SitePhpErrorLogFlag is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SitePhpErrorLogFlag
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SitePhpErrorLogFlag] = kwargs.pop("cls", None)

        _request = build_web_apps_get_site_php_error_log_flag_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SitePhpErrorLogFlag, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_premier_add_ons_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.PremierAddOn:
        """Gets the premier add-ons of an app.

        Description for Gets the premier add-ons of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PremierAddOn] = kwargs.pop("cls", None)

        _request = build_web_apps_list_premier_add_ons_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PremierAddOn, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_private_link_resources_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.PrivateLinkResourcesWrapper:
        """Gets the private link resources.

        Description for Gets the private link resources.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: PrivateLinkResourcesWrapper. The PrivateLinkResourcesWrapper is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateLinkResourcesWrapper
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PrivateLinkResourcesWrapper] = kwargs.pop("cls", None)

        _request = build_web_apps_get_private_link_resources_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PrivateLinkResourcesWrapper, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def list_publishing_profile_xml_with_secrets_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        publishing_profile_options: _models.CsmPublishingProfileOptions,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Gets the publishing profile for an app (or deployment slot, if specified).

        Description for Gets the publishing profile for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param publishing_profile_options: Specifies publishingProfileOptions for publishing profile.
         For example, use {" format": "FileZilla3"} to get a FileZilla publishing profile. Required.
        :type publishing_profile_options: ~azure.mgmt.web.models.CsmPublishingProfileOptions
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_publishing_profile_xml_with_secrets_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        publishing_profile_options: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Gets the publishing profile for an app (or deployment slot, if specified).

        Description for Gets the publishing profile for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param publishing_profile_options: Specifies publishingProfileOptions for publishing profile.
         For example, use {" format": "FileZilla3"} to get a FileZilla publishing profile. Required.
        :type publishing_profile_options: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_publishing_profile_xml_with_secrets_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        publishing_profile_options: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Gets the publishing profile for an app (or deployment slot, if specified).

        Description for Gets the publishing profile for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param publishing_profile_options: Specifies publishingProfileOptions for publishing profile.
         For example, use {" format": "FileZilla3"} to get a FileZilla publishing profile. Required.
        :type publishing_profile_options: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def list_publishing_profile_xml_with_secrets_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        publishing_profile_options: Union[_models.CsmPublishingProfileOptions, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Gets the publishing profile for an app (or deployment slot, if specified).

        Description for Gets the publishing profile for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param publishing_profile_options: Specifies publishingProfileOptions for publishing profile.
         For example, use {" format": "FileZilla3"} to get a FileZilla publishing profile. Is one of the
         following types: CsmPublishingProfileOptions, JSON, IO[bytes] Required.
        :type publishing_profile_options: ~azure.mgmt.web.models.CsmPublishingProfileOptions or JSON or
         IO[bytes]
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(publishing_profile_options, (IOBase, bytes)):
            _content = publishing_profile_options
        else:
            _content = json.dumps(publishing_profile_options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_list_publishing_profile_xml_with_secrets_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def reset_slot_configuration_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> None:
        """Resets the configuration settings of the current slot if they were previously modified by
        calling the API with POST.

        Description for Resets the configuration settings of the current slot if they were previously
        modified by calling the API with POST.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_reset_slot_configuration_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def restart_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        *,
        soft_restart: Optional[bool] = None,
        synchronous: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Restarts an app (or deployment slot, if specified).

        Description for Restarts an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :keyword soft_restart: Specify true to apply the configuration settings and restarts the app
         only if necessary. By default, the API always restarts and reprovisions the app. Default value
         is None.
        :paramtype soft_restart: bool
        :keyword synchronous: Specify true to block until the app is restarted. By default, it is set
         to false, and the API responds immediately (asynchronous). Default value is None.
        :paramtype synchronous: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_restart_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            soft_restart=soft_restart,
            synchronous=synchronous,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    async def _restore_from_backup_blob_slot_initial(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: Union[_models.RestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_restore_from_backup_blob_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_restore_from_backup_blob_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: _models.RestoreRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores an app from a backup blob in Azure Storage.

        Description for Restores an app from a backup blob in Azure Storage.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Information on restore request . Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_from_backup_blob_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores an app from a backup blob in Azure Storage.

        Description for Restores an app from a backup blob in Azure Storage.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Information on restore request . Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_from_backup_blob_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores an app from a backup blob in Azure Storage.

        Description for Restores an app from a backup blob in Azure Storage.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Information on restore request . Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_restore_from_backup_blob_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        request: Union[_models.RestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores an app from a backup blob in Azure Storage.

        Description for Restores an app from a backup blob in Azure Storage.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param request: Information on restore request . Is one of the following types: RestoreRequest,
         JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._restore_from_backup_blob_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                request=request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    async def _restore_from_deleted_app_slot_initial(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        restore_request: Union[_models.DeletedAppRestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(restore_request, (IOBase, bytes)):
            _content = restore_request
        else:
            _content = json.dumps(restore_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_restore_from_deleted_app_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_restore_from_deleted_app_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        restore_request: _models.DeletedAppRestoreRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a deleted web app to this web app.

        Description for Restores a deleted web app to this web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param restore_request: Deleted web app restore information. Required.
        :type restore_request: ~azure.mgmt.web.models.DeletedAppRestoreRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_from_deleted_app_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        restore_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a deleted web app to this web app.

        Description for Restores a deleted web app to this web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param restore_request: Deleted web app restore information. Required.
        :type restore_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_from_deleted_app_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        restore_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a deleted web app to this web app.

        Description for Restores a deleted web app to this web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param restore_request: Deleted web app restore information. Required.
        :type restore_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_restore_from_deleted_app_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        restore_request: Union[_models.DeletedAppRestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a deleted web app to this web app.

        Description for Restores a deleted web app to this web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param restore_request: Deleted web app restore information. Is one of the following types:
         DeletedAppRestoreRequest, JSON, IO[bytes] Required.
        :type restore_request: ~azure.mgmt.web.models.DeletedAppRestoreRequest or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._restore_from_deleted_app_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                restore_request=restore_request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    async def _restore_snapshot_slot_initial(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        restore_request: Union[_models.SnapshotRestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(restore_request, (IOBase, bytes)):
            _content = restore_request
        else:
            _content = json.dumps(restore_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_restore_snapshot_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_restore_snapshot_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        restore_request: _models.SnapshotRestoreRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a web app from a snapshot.

        Description for Restores a web app from a snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param restore_request: Snapshot restore settings. Snapshot information can be obtained by
         calling GetDeletedSites or GetSiteSnapshots API. Required.
        :type restore_request: ~azure.mgmt.web.models.SnapshotRestoreRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_snapshot_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        restore_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a web app from a snapshot.

        Description for Restores a web app from a snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param restore_request: Snapshot restore settings. Snapshot information can be obtained by
         calling GetDeletedSites or GetSiteSnapshots API. Required.
        :type restore_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_snapshot_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        restore_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a web app from a snapshot.

        Description for Restores a web app from a snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param restore_request: Snapshot restore settings. Snapshot information can be obtained by
         calling GetDeletedSites or GetSiteSnapshots API. Required.
        :type restore_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_restore_snapshot_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        restore_request: Union[_models.SnapshotRestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a web app from a snapshot.

        Description for Restores a web app from a snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param restore_request: Snapshot restore settings. Snapshot information can be obtained by
         calling GetDeletedSites or GetSiteSnapshots API. Is one of the following types:
         SnapshotRestoreRequest, JSON, IO[bytes] Required.
        :type restore_request: ~azure.mgmt.web.models.SnapshotRestoreRequest or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._restore_snapshot_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                restore_request=restore_request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def list_slot_differences_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: _models.CsmSlotEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncItemPaged["_models.SlotDifference"]:
        """Get the difference in configuration settings between two web app slots.

        Description for Get the difference in configuration settings between two web app slots.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of SlotDifference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SlotDifference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def list_slot_differences_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncItemPaged["_models.SlotDifference"]:
        """Get the difference in configuration settings between two web app slots.

        Description for Get the difference in configuration settings between two web app slots.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of SlotDifference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SlotDifference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def list_slot_differences_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncItemPaged["_models.SlotDifference"]:
        """Get the difference in configuration settings between two web app slots.

        Description for Get the difference in configuration settings between two web app slots.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of SlotDifference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SlotDifference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def list_slot_differences_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: Union[_models.CsmSlotEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncItemPaged["_models.SlotDifference"]:
        """Get the difference in configuration settings between two web app slots.

        Description for Get the difference in configuration settings between two web app slots.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Is one of
         the following types: CsmSlotEntity, JSON, IO[bytes] Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity or JSON or IO[bytes]
        :return: An iterator like instance of SlotDifference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SlotDifference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.SlotDifference]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})
        content_type = content_type or "application/json"
        _content = None
        if isinstance(slot_swap_entity, (IOBase, bytes)):
            _content = slot_swap_entity
        else:
            _content = json.dumps(slot_swap_entity, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_slot_differences_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    content_type=content_type,
                    api_version=self._config.api_version,
                    content=_content,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SlotDifference], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _swap_slot_initial(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: Union[_models.CsmSlotEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(slot_swap_entity, (IOBase, bytes)):
            _content = slot_swap_entity
        else:
            _content = json.dumps(slot_swap_entity, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_swap_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_swap_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: _models.CsmSlotEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Swaps two deployment slots of an app.

        Description for Swaps two deployment slots of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_swap_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Swaps two deployment slots of an app.

        Description for Swaps two deployment slots of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_swap_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Swaps two deployment slots of an app.

        Description for Swaps two deployment slots of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_swap_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        slot_swap_entity: Union[_models.CsmSlotEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Swaps two deployment slots of an app.

        Description for Swaps two deployment slots of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Is one of
         the following types: CsmSlotEntity, JSON, IO[bytes] Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._swap_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                slot_swap_entity=slot_swap_entity,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_snapshots_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.Snapshot"]:
        """Returns all Snapshots to the user.

        Description for Returns all Snapshots to the user.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: An iterator like instance of Snapshot
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Snapshot]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Snapshot]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_snapshots_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Snapshot], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_snapshots_from_dr_secondary_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.Snapshot"]:
        """Returns all Snapshots to the user from DRSecondary endpoint.

        Description for Returns all Snapshots to the user from DRSecondary endpoint.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: An iterator like instance of Snapshot
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Snapshot]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Snapshot]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_snapshots_from_dr_secondary_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Snapshot], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def start_slot(self, resource_group_name: str, name: str, slot: str, **kwargs: Any) -> None:
        """Starts an app (or deployment slot, if specified).

        Description for Starts an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_start_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    async def _start_network_trace_slot_initial(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        *,
        duration_in_seconds: Optional[int] = None,
        max_frame_length: Optional[int] = None,
        sas_url: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_start_network_trace_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            duration_in_seconds=duration_in_seconds,
            max_frame_length=max_frame_length,
            sas_url=sas_url,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_start_network_trace_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        *,
        duration_in_seconds: Optional[int] = None,
        max_frame_length: Optional[int] = None,
        sas_url: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Start capturing network packets for the site.

        Description for Start capturing network packets for the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :keyword duration_in_seconds: The duration to keep capturing in seconds. Default value is None.
        :paramtype duration_in_seconds: int
        :keyword max_frame_length: The maximum frame length in bytes (Optional). Default value is None.
        :paramtype max_frame_length: int
        :keyword sas_url: The Blob URL to store capture file. Default value is None.
        :paramtype sas_url: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._start_network_trace_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                duration_in_seconds=duration_in_seconds,
                max_frame_length=max_frame_length,
                sas_url=sas_url,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def stop_slot(self, resource_group_name: str, name: str, slot: str, **kwargs: Any) -> None:
        """Stops an app (or deployment slot, if specified).

        Description for Stops an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_stop_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def stop_network_trace_slot(self, resource_group_name: str, name: str, slot: str, **kwargs: Any) -> None:
        """Stop ongoing capturing network packets for the site.

        Description for Stop ongoing capturing network packets for the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_stop_network_trace_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def sync_repository_slot(self, resource_group_name: str, name: str, slot: str, **kwargs: Any) -> None:
        """Sync web app repository.

        Description for Sync web app repository.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_sync_repository_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def sync_function_triggers_slot(self, resource_group_name: str, name: str, slot: str, **kwargs: Any) -> None:
        """Syncs function trigger metadata to the management database.

        Description for Syncs function trigger metadata to the management database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_sync_function_triggers_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_usages_slot(
        self, resource_group_name: str, name: str, slot: str, *, filter: Optional[str] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.CsmUsageQuota"]:
        """Gets the quota usage information of an app (or deployment slot, if specified).

        Description for Gets the quota usage information of an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :keyword filter: Return only information specified in the filter (using OData syntax). For
         example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq
         2014-01-01T00:00:00Z and endTime eq 2014-12-31T23:59:59Z and timeGrain eq
         duration'[Hour|Minute|Day]'. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of CsmUsageQuota
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.CsmUsageQuota]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CsmUsageQuota]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_usages_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CsmUsageQuota], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def deploy_workflow_artifacts_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        workflow_artifacts: Optional[_models.WorkflowArtifacts] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Creates the artifacts for web site, or a deployment slot.

        Description for Creates the artifacts for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param workflow_artifacts: Application settings and files of the workflow. Default value is
         None.
        :type workflow_artifacts: ~azure.mgmt.web.models.WorkflowArtifacts
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def deploy_workflow_artifacts_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        workflow_artifacts: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Creates the artifacts for web site, or a deployment slot.

        Description for Creates the artifacts for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param workflow_artifacts: Application settings and files of the workflow. Default value is
         None.
        :type workflow_artifacts: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def deploy_workflow_artifacts_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        workflow_artifacts: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Creates the artifacts for web site, or a deployment slot.

        Description for Creates the artifacts for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param workflow_artifacts: Application settings and files of the workflow. Default value is
         None.
        :type workflow_artifacts: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def deploy_workflow_artifacts_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        workflow_artifacts: Optional[Union[_models.WorkflowArtifacts, JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """Creates the artifacts for web site, or a deployment slot.

        Description for Creates the artifacts for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :param workflow_artifacts: Application settings and files of the workflow. Is one of the
         following types: WorkflowArtifacts, JSON, IO[bytes] Default value is None.
        :type workflow_artifacts: ~azure.mgmt.web.models.WorkflowArtifacts or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        content_type = content_type if workflow_artifacts else None
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json" if workflow_artifacts else None
        _content = None
        if isinstance(workflow_artifacts, (IOBase, bytes)):
            _content = workflow_artifacts
        else:
            if workflow_artifacts is not None:
                _content = json.dumps(workflow_artifacts, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_web_apps_deploy_workflow_artifacts_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_workflows_connections_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.WorkflowEnvelope:
        """Lists logic app's connections for web site, or a deployment slot.

        Lists logic app's connections for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. By default, this API returns the production slot.
         Required.
        :type slot: str
        :return: WorkflowEnvelope. The WorkflowEnvelope is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowEnvelope
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowEnvelope] = kwargs.pop("cls", None)

        _request = build_web_apps_list_workflows_connections_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowEnvelope, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_private_endpoint_connection(
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> _models.RemotePrivateEndpointConnectionARMResource:
        """Gets a private endpoint connection.

        Description for Gets a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :return: RemotePrivateEndpointConnectionARMResource. The
         RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RemotePrivateEndpointConnectionARMResource] = kwargs.pop("cls", None)

        _request = build_web_apps_get_private_endpoint_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RemotePrivateEndpointConnectionARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _approve_or_reject_private_endpoint_connection_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: Union[_models.RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(private_endpoint_wrapper, (IOBase, bytes)):
            _content = private_endpoint_wrapper
        else:
            _content = json.dumps(private_endpoint_wrapper, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_approve_or_reject_private_endpoint_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: _models.RemotePrivateEndpointConnectionARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Required.
        :type private_endpoint_wrapper:
         ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Required.
        :type private_endpoint_wrapper: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Required.
        :type private_endpoint_wrapper: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_approve_or_reject_private_endpoint_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        private_endpoint_wrapper: Union[_models.RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_wrapper: Is one of the following types:
         RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes] Required.
        :type private_endpoint_wrapper:
         ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RemotePrivateEndpointConnectionARMResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._approve_or_reject_private_endpoint_connection_initial(
                resource_group_name=resource_group_name,
                name=name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                private_endpoint_wrapper=private_endpoint_wrapper,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.RemotePrivateEndpointConnectionARMResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_private_endpoint_connection_initial(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_private_endpoint_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_delete_private_endpoint_connection(
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes a private endpoint connection.

        Description for Deletes a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_private_endpoint_connection_initial(
                resource_group_name=resource_group_name,
                name=name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_private_endpoint_connection_list(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.RemotePrivateEndpointConnectionARMResource"]:
        """Gets the list of private endpoint connections associated with a site.

        Description for Gets the list of private endpoint connections associated with a site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :return: An iterator like instance of RemotePrivateEndpointConnectionARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.RemotePrivateEndpointConnectionARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_get_private_endpoint_connection_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.RemotePrivateEndpointConnectionARMResource], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_private_endpoint_connection_slot(
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, slot: str, **kwargs: Any
    ) -> _models.RemotePrivateEndpointConnectionARMResource:
        """Gets a private endpoint connection.

        Description for Gets a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param slot: Name of the site deployment slot. Required.
        :type slot: str
        :return: RemotePrivateEndpointConnectionARMResource. The
         RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RemotePrivateEndpointConnectionARMResource] = kwargs.pop("cls", None)

        _request = build_web_apps_get_private_endpoint_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RemotePrivateEndpointConnectionARMResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _approve_or_reject_private_endpoint_connection_slot_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        slot: str,
        private_endpoint_wrapper: Union[_models.RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(private_endpoint_wrapper, (IOBase, bytes)):
            _content = private_endpoint_wrapper
        else:
            _content = json.dumps(private_endpoint_wrapper, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_approve_or_reject_private_endpoint_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_approve_or_reject_private_endpoint_connection_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        slot: str,
        private_endpoint_wrapper: _models.RemotePrivateEndpointConnectionARMResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param slot: Name of the site deployment slot. Required.
        :type slot: str
        :param private_endpoint_wrapper: Required.
        :type private_endpoint_wrapper:
         ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_approve_or_reject_private_endpoint_connection_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        slot: str,
        private_endpoint_wrapper: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param slot: Name of the site deployment slot. Required.
        :type slot: str
        :param private_endpoint_wrapper: Required.
        :type private_endpoint_wrapper: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_approve_or_reject_private_endpoint_connection_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        slot: str,
        private_endpoint_wrapper: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param slot: Name of the site deployment slot. Required.
        :type slot: str
        :param private_endpoint_wrapper: Required.
        :type private_endpoint_wrapper: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_approve_or_reject_private_endpoint_connection_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        private_endpoint_connection_name: str,
        slot: str,
        private_endpoint_wrapper: Union[_models.RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource]:
        """Approves or rejects a private endpoint connection.

        Description for Approves or rejects a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param slot: Name of the site deployment slot. Required.
        :type slot: str
        :param private_endpoint_wrapper: Is one of the following types:
         RemotePrivateEndpointConnectionARMResource, JSON, IO[bytes] Required.
        :type private_endpoint_wrapper:
         ~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns RemotePrivateEndpointConnectionARMResource.
         The RemotePrivateEndpointConnectionARMResource is compatible with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RemotePrivateEndpointConnectionARMResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._approve_or_reject_private_endpoint_connection_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                slot=slot,
                private_endpoint_wrapper=private_endpoint_wrapper,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.RemotePrivateEndpointConnectionARMResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.RemotePrivateEndpointConnectionARMResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_private_endpoint_connection_slot_initial(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, slot: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_private_endpoint_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_delete_private_endpoint_connection_slot(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, private_endpoint_connection_name: str, slot: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes a private endpoint connection.

        Description for Deletes a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param private_endpoint_connection_name: Name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param slot: Name of the site deployment slot. Required.
        :type slot: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_private_endpoint_connection_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                slot=slot,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_private_endpoint_connection_list_slot(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.RemotePrivateEndpointConnectionARMResource"]:
        """Gets the list of private endpoint connections associated with a site.

        Description for Gets the list of private endpoint connections associated with a site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the site deployment slot. Required.
        :type slot: str
        :return: An iterator like instance of RemotePrivateEndpointConnectionARMResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.RemotePrivateEndpointConnectionARMResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.RemotePrivateEndpointConnectionARMResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_get_private_endpoint_connection_list_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.RemotePrivateEndpointConnectionARMResource], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_hybrid_connection(
        self, resource_group_name: str, name: str, namespace_name: str, relay_name: str, **kwargs: Any
    ) -> _models.HybridConnection:
        """Retrieves a specific Service Bus Hybrid Connection used by this Web App.

        Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HybridConnection] = kwargs.pop("cls", None)

        _request = build_web_apps_get_hybrid_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            namespace_name=namespace_name,
            relay_name=relay_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HybridConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_hybrid_connection(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        connection_envelope: _models.HybridConnection,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: ~azure.mgmt.web.models.HybridConnection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_hybrid_connection(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_hybrid_connection(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_hybrid_connection(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        connection_envelope: Union[_models.HybridConnection, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param connection_envelope: The details of the hybrid connection. Is one of the following
         types: HybridConnection, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.HybridConnection or JSON or IO[bytes]
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.HybridConnection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_hybrid_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            namespace_name=namespace_name,
            relay_name=relay_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HybridConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_hybrid_connection(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        connection_envelope: _models.HybridConnection,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: ~azure.mgmt.web.models.HybridConnection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_hybrid_connection(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_hybrid_connection(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_hybrid_connection(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        connection_envelope: Union[_models.HybridConnection, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param connection_envelope: The details of the hybrid connection. Is one of the following
         types: HybridConnection, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.HybridConnection or JSON or IO[bytes]
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.HybridConnection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_hybrid_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            namespace_name=namespace_name,
            relay_name=relay_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HybridConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_hybrid_connection(
        self, resource_group_name: str, name: str, namespace_name: str, relay_name: str, **kwargs: Any
    ) -> None:
        """Removes a Hybrid Connection from this site.

        Description for Removes a Hybrid Connection from this site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_hybrid_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            namespace_name=namespace_name,
            relay_name=relay_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_hybrid_connection_slot(
        self, resource_group_name: str, name: str, namespace_name: str, relay_name: str, slot: str, **kwargs: Any
    ) -> _models.HybridConnection:
        """Retrieves a specific Service Bus Hybrid Connection used by this Web App.

        Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HybridConnection] = kwargs.pop("cls", None)

        _request = build_web_apps_get_hybrid_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            namespace_name=namespace_name,
            relay_name=relay_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HybridConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_hybrid_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        slot: str,
        connection_envelope: _models.HybridConnection,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: ~azure.mgmt.web.models.HybridConnection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_hybrid_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        slot: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_hybrid_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        slot: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_hybrid_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        slot: str,
        connection_envelope: Union[_models.HybridConnection, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param connection_envelope: The details of the hybrid connection. Is one of the following
         types: HybridConnection, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.HybridConnection or JSON or IO[bytes]
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.HybridConnection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_hybrid_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            namespace_name=namespace_name,
            relay_name=relay_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HybridConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_hybrid_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        slot: str,
        connection_envelope: _models.HybridConnection,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: ~azure.mgmt.web.models.HybridConnection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_hybrid_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        slot: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_hybrid_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        slot: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param connection_envelope: The details of the hybrid connection. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_hybrid_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        namespace_name: str,
        relay_name: str,
        slot: str,
        connection_envelope: Union[_models.HybridConnection, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.HybridConnection:
        """Creates a new Hybrid Connection using a Service Bus relay.

        Description for Creates a new Hybrid Connection using a Service Bus relay.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param connection_envelope: The details of the hybrid connection. Is one of the following
         types: HybridConnection, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.HybridConnection or JSON or IO[bytes]
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.HybridConnection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_hybrid_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            namespace_name=namespace_name,
            relay_name=relay_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HybridConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_hybrid_connection_slot(
        self, resource_group_name: str, name: str, namespace_name: str, relay_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Removes a Hybrid Connection from this site.

        Description for Removes a Hybrid Connection from this site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param namespace_name: The namespace for this hybrid connection. Required.
        :type namespace_name: str
        :param relay_name: The relay name for this hybrid connection. Required.
        :type relay_name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_hybrid_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            namespace_name=namespace_name,
            relay_name=relay_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_vnet_connection_slot(
        self, resource_group_name: str, name: str, vnet_name: str, slot: str, **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Gets a virtual network the app (or deployment slot) is connected to by name.

        Description for Gets a virtual network the app (or deployment slot) is connected to by name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named virtual network for the production slot. Required.
        :type slot: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VnetInfoResource] = kwargs.pop("cls", None)

        _request = build_web_apps_get_vnet_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetInfoResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_vnet_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        slot: str,
        connection_envelope: _models.VnetInfoResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named virtual network for the production slot. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetInfoResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_vnet_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        slot: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named virtual network for the production slot. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_vnet_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        slot: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named virtual network for the production slot. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_vnet_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        slot: str,
        connection_envelope: Union[_models.VnetInfoResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named virtual network for the production slot. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example. Is one
         of the following types: VnetInfoResource, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetInfoResource or JSON or IO[bytes]
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetInfoResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_vnet_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetInfoResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_vnet_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        slot: str,
        connection_envelope: _models.VnetInfoResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named virtual network for the production slot. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetInfoResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        slot: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named virtual network for the production slot. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        slot: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named virtual network for the production slot. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_vnet_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        slot: str,
        connection_envelope: Union[_models.VnetInfoResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named virtual network for the production slot. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example. Is one
         of the following types: VnetInfoResource, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetInfoResource or JSON or IO[bytes]
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetInfoResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_vnet_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetInfoResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_vnet_connection_slot(
        self, resource_group_name: str, name: str, vnet_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Deletes a connection from an app (or deployment slot to a named virtual network.

        Description for Deletes a connection from an app (or deployment slot to a named virtual
        network.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named virtual network for the production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_vnet_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_vnet_connections_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> List[_models.VnetInfoResource]:
        """Gets the virtual networks the app (or deployment slot) is connected to.

        Description for Gets the virtual networks the app (or deployment slot) is connected to.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named virtual network for the production slot. Required.
        :type slot: str
        :return: list of VnetInfoResource
        :rtype: list[~azure.mgmt.web.models.VnetInfoResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VnetInfoResource]] = kwargs.pop("cls", None)

        _request = build_web_apps_list_vnet_connections_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.VnetInfoResource], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_vnet_connection(
        self, resource_group_name: str, name: str, vnet_name: str, **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Gets a virtual network the app (or deployment slot) is connected to by name.

        Description for Gets a virtual network the app (or deployment slot) is connected to by name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VnetInfoResource] = kwargs.pop("cls", None)

        _request = build_web_apps_get_vnet_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetInfoResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_vnet_connection(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        connection_envelope: _models.VnetInfoResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetInfoResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_vnet_connection(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_vnet_connection(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_vnet_connection(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        connection_envelope: Union[_models.VnetInfoResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example. Is one
         of the following types: VnetInfoResource, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetInfoResource or JSON or IO[bytes]
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetInfoResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_vnet_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetInfoResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_vnet_connection(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        connection_envelope: _models.VnetInfoResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetInfoResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_connection(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_connection(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_vnet_connection(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        connection_envelope: Union[_models.VnetInfoResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
        (PATCH).

        Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
        connection properties (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example. Is one
         of the following types: VnetInfoResource, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetInfoResource or JSON or IO[bytes]
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetInfoResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_vnet_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetInfoResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_vnet_connection(self, resource_group_name: str, name: str, vnet_name: str, **kwargs: Any) -> None:
        """Deletes a connection from an app (or deployment slot to a named virtual network.

        Description for Deletes a connection from an app (or deployment slot to a named virtual
        network.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the virtual network. Required.
        :type vnet_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_vnet_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_vnet_connections(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> List[_models.VnetInfoResource]:
        """Gets the virtual networks the app (or deployment slot) is connected to.

        Description for Gets the virtual networks the app (or deployment slot) is connected to.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: list of VnetInfoResource
        :rtype: list[~azure.mgmt.web.models.VnetInfoResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VnetInfoResource]] = kwargs.pop("cls", None)

        _request = build_web_apps_list_vnet_connections_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.VnetInfoResource], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_vnet_connection_gateway_slot(
        self, resource_group_name: str, name: str, vnet_name: str, gateway_name: str, slot: str, **kwargs: Any
    ) -> _models.VnetGateway:
        """Gets an app's Virtual Network gateway.

        Description for Gets an app's Virtual Network gateway.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VnetGateway] = kwargs.pop("cls", None)

        _request = build_web_apps_get_vnet_connection_gateway_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            gateway_name=gateway_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetGateway, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_vnet_connection_gateway_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        slot: str,
        connection_envelope: _models.VnetGateway,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetGateway
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_vnet_connection_gateway_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        slot: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_vnet_connection_gateway_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        slot: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_vnet_connection_gateway_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        slot: str,
        connection_envelope: Union[_models.VnetGateway, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: The properties to update this gateway with. Is one of the following
         types: VnetGateway, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetGateway or JSON or IO[bytes]
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetGateway] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_vnet_connection_gateway_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            gateway_name=gateway_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetGateway, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_vnet_connection_gateway_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        slot: str,
        connection_envelope: _models.VnetGateway,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetGateway
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_connection_gateway_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        slot: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_connection_gateway_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        slot: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_vnet_connection_gateway_slot(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        slot: str,
        connection_envelope: Union[_models.VnetGateway, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: The properties to update this gateway with. Is one of the following
         types: VnetGateway, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetGateway or JSON or IO[bytes]
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetGateway] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_vnet_connection_gateway_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            gateway_name=gateway_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetGateway, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_vnet_connection_gateway(
        self, resource_group_name: str, name: str, vnet_name: str, gateway_name: str, **kwargs: Any
    ) -> _models.VnetGateway:
        """Gets an app's Virtual Network gateway.

        Description for Gets an app's Virtual Network gateway.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VnetGateway] = kwargs.pop("cls", None)

        _request = build_web_apps_get_vnet_connection_gateway_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            gateway_name=gateway_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetGateway, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_vnet_connection_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: _models.VnetGateway,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetGateway
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_vnet_connection_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_vnet_connection_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_vnet_connection_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: Union[_models.VnetGateway, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param connection_envelope: The properties to update this gateway with. Is one of the following
         types: VnetGateway, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetGateway or JSON or IO[bytes]
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetGateway] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_vnet_connection_gateway_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            gateway_name=gateway_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetGateway, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_vnet_connection_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: _models.VnetGateway,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetGateway
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_connection_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_connection_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param connection_envelope: The properties to update this gateway with. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_vnet_connection_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: Union[_models.VnetGateway, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Currently, the only supported string is "primary".
         Required.
        :type gateway_name: str
        :param connection_envelope: The properties to update this gateway with. Is one of the following
         types: VnetGateway, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetGateway or JSON or IO[bytes]
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetGateway] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_vnet_connection_gateway_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            gateway_name=gateway_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetGateway, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.Site:
        """Gets the details of a web, mobile, or API app.

        Description for Gets the details of a web, mobile, or API app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: Site. The Site is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Site
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Site] = kwargs.pop("cls", None)

        _request = build_web_apps_get_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Site, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self, resource_group_name: str, name: str, site_envelope: Union[_models.Site, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_envelope, (IOBase, bytes)):
            _content = site_envelope
        else:
            _content = json.dumps(site_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        site_envelope: _models.Site,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Site]:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: ~azure.mgmt.web.models.Site
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Site. The Site is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        site_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Site]:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Site. The Site is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        site_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Site]:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Site. The Site is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self, resource_group_name: str, name: str, site_envelope: Union[_models.Site, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncLROPoller[_models.Site]:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_envelope: A JSON representation of the app properties. See example. Is one of the
         following types: Site, JSON, IO[bytes] Required.
        :type site_envelope: ~azure.mgmt.web.models.Site or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns Site. The Site is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Site] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                name=name,
                site_envelope=site_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.Site, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.Site].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.Site](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        site_envelope: _models.SitePatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Site:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: ~azure.mgmt.web.models.SitePatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Site. The Site is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Site
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        site_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Site:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Site. The Site is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Site
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        site_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Site:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_envelope: A JSON representation of the app properties. See example. Required.
        :type site_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Site. The Site is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Site
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        name: str,
        site_envelope: Union[_models.SitePatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Site:
        """Creates a new web, mobile, or API app in an existing resource group, or updates an existing
        app.

        Description for Creates a new web, mobile, or API app in an existing resource group, or updates
        an existing app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_envelope: A JSON representation of the app properties. See example. Is one of the
         following types: SitePatchResource, JSON, IO[bytes] Required.
        :type site_envelope: ~azure.mgmt.web.models.SitePatchResource or JSON or IO[bytes]
        :return: Site. The Site is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Site
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Site] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_envelope, (IOBase, bytes)):
            _content = site_envelope
        else:
            _content = json.dumps(site_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Site, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(
        self,
        resource_group_name: str,
        name: str,
        *,
        delete_metrics: Optional[bool] = None,
        delete_empty_server_farm: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a web, mobile, or API app, or one of the deployment slots.

        Description for Deletes a web, mobile, or API app, or one of the deployment slots.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :keyword delete_metrics: If true, web app metrics are also deleted. Default value is None.
        :paramtype delete_metrics: bool
        :keyword delete_empty_server_farm: Specify false if you want to keep empty App Service plan. By
         default, empty App Service plan is deleted. Default value is None.
        :paramtype delete_empty_server_farm: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            delete_metrics=delete_metrics,
            delete_empty_server_farm=delete_empty_server_farm,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncItemPaged["_models.Site"]:
        """Get all apps for a subscription.

        Description for Get all apps for a subscription.

        :return: An iterator like instance of Site
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Site]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Site], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def analyze_custom_hostname(
        self, resource_group_name: str, name: str, *, host_name: Optional[str] = None, **kwargs: Any
    ) -> _models.CustomHostnameAnalysisResult:
        """Analyze a custom hostname.

        Description for Analyze a custom hostname.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :keyword host_name: Custom hostname. Default value is None.
        :paramtype host_name: str
        :return: CustomHostnameAnalysisResult. The CustomHostnameAnalysisResult is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.CustomHostnameAnalysisResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CustomHostnameAnalysisResult] = kwargs.pop("cls", None)

        _request = build_web_apps_analyze_custom_hostname_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            host_name=host_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CustomHostnameAnalysisResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def apply_slot_config_to_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: _models.CsmSlotEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Applies the configuration settings from the target slot onto the current slot.

        Description for Applies the configuration settings from the target slot onto the current slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def apply_slot_config_to_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Applies the configuration settings from the target slot onto the current slot.

        Description for Applies the configuration settings from the target slot onto the current slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def apply_slot_config_to_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Applies the configuration settings from the target slot onto the current slot.

        Description for Applies the configuration settings from the target slot onto the current slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def apply_slot_config_to_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: Union[_models.CsmSlotEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> None:
        """Applies the configuration settings from the target slot onto the current slot.

        Description for Applies the configuration settings from the target slot onto the current slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Is one of
         the following types: CsmSlotEntity, JSON, IO[bytes] Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(slot_swap_entity, (IOBase, bytes)):
            _content = slot_swap_entity
        else:
            _content = json.dumps(slot_swap_entity, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_apply_slot_config_to_production_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def backup(
        self,
        resource_group_name: str,
        name: str,
        request: _models.BackupRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Creates a backup of an app.

        Description for Creates a backup of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Backup configuration. You can use the JSON response from the POST action as
         input here. Required.
        :type request: ~azure.mgmt.web.models.BackupRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def backup(
        self,
        resource_group_name: str,
        name: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Creates a backup of an app.

        Description for Creates a backup of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Backup configuration. You can use the JSON response from the POST action as
         input here. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def backup(
        self,
        resource_group_name: str,
        name: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Creates a backup of an app.

        Description for Creates a backup of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Backup configuration. You can use the JSON response from the POST action as
         input here. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def backup(
        self, resource_group_name: str, name: str, request: Union[_models.BackupRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.BackupItem:
        """Creates a backup of an app.

        Description for Creates a backup of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Backup configuration. You can use the JSON response from the POST action as
         input here. Is one of the following types: BackupRequest, JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.BackupRequest or JSON or IO[bytes]
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BackupItem] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_backup_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BackupItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_application_settings(
        self,
        resource_group_name: str,
        name: str,
        app_settings: _models.StringDictionary,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the application settings of an app.

        Description for Replaces the application settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param app_settings: Application settings of the app. Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_application_settings(
        self,
        resource_group_name: str,
        name: str,
        app_settings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the application settings of an app.

        Description for Replaces the application settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param app_settings: Application settings of the app. Required.
        :type app_settings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_application_settings(
        self,
        resource_group_name: str,
        name: str,
        app_settings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the application settings of an app.

        Description for Replaces the application settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param app_settings: Application settings of the app. Required.
        :type app_settings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_application_settings(
        self,
        resource_group_name: str,
        name: str,
        app_settings: Union[_models.StringDictionary, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the application settings of an app.

        Description for Replaces the application settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param app_settings: Application settings of the app. Is one of the following types:
         StringDictionary, JSON, IO[bytes] Required.
        :type app_settings: ~azure.mgmt.web.models.StringDictionary or JSON or IO[bytes]
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(app_settings, (IOBase, bytes)):
            _content = app_settings
        else:
            _content = json.dumps(app_settings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_application_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_application_settings(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.StringDictionary:
        """Gets the application settings of an app.

        Description for Gets the application settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        _request = build_web_apps_list_application_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_auth_settings(
        self,
        resource_group_name: str,
        name: str,
        site_auth_settings: _models.SiteAuthSettings,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettings:
        """Updates the Authentication / Authorization settings associated with web app.

        Description for Updates the Authentication / Authorization settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_auth_settings: Auth settings associated with web app. Required.
        :type site_auth_settings: ~azure.mgmt.web.models.SiteAuthSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettings. The SiteAuthSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_auth_settings(
        self,
        resource_group_name: str,
        name: str,
        site_auth_settings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettings:
        """Updates the Authentication / Authorization settings associated with web app.

        Description for Updates the Authentication / Authorization settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_auth_settings: Auth settings associated with web app. Required.
        :type site_auth_settings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettings. The SiteAuthSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_auth_settings(
        self,
        resource_group_name: str,
        name: str,
        site_auth_settings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettings:
        """Updates the Authentication / Authorization settings associated with web app.

        Description for Updates the Authentication / Authorization settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_auth_settings: Auth settings associated with web app. Required.
        :type site_auth_settings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettings. The SiteAuthSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_auth_settings(
        self,
        resource_group_name: str,
        name: str,
        site_auth_settings: Union[_models.SiteAuthSettings, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteAuthSettings:
        """Updates the Authentication / Authorization settings associated with web app.

        Description for Updates the Authentication / Authorization settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_auth_settings: Auth settings associated with web app. Is one of the following
         types: SiteAuthSettings, JSON, IO[bytes] Required.
        :type site_auth_settings: ~azure.mgmt.web.models.SiteAuthSettings or JSON or IO[bytes]
        :return: SiteAuthSettings. The SiteAuthSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteAuthSettings] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_auth_settings, (IOBase, bytes)):
            _content = site_auth_settings
        else:
            _content = json.dumps(site_auth_settings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_auth_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteAuthSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_auth_settings(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.SiteAuthSettings:
        """Gets the Authentication/Authorization settings of an app.

        Description for Gets the Authentication/Authorization settings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: SiteAuthSettings. The SiteAuthSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteAuthSettings] = kwargs.pop("cls", None)

        _request = build_web_apps_get_auth_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteAuthSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_azure_storage_accounts(
        self,
        resource_group_name: str,
        name: str,
        azure_storage_accounts: _models.AzureStoragePropertyDictionaryResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AzureStoragePropertyDictionaryResource:
        """Updates the Azure storage account configurations of an app.

        Description for Updates the Azure storage account configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param azure_storage_accounts: Azure storage accounts of the app. Required.
        :type azure_storage_accounts: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AzureStoragePropertyDictionaryResource. The AzureStoragePropertyDictionaryResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_azure_storage_accounts(
        self,
        resource_group_name: str,
        name: str,
        azure_storage_accounts: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AzureStoragePropertyDictionaryResource:
        """Updates the Azure storage account configurations of an app.

        Description for Updates the Azure storage account configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param azure_storage_accounts: Azure storage accounts of the app. Required.
        :type azure_storage_accounts: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AzureStoragePropertyDictionaryResource. The AzureStoragePropertyDictionaryResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_azure_storage_accounts(
        self,
        resource_group_name: str,
        name: str,
        azure_storage_accounts: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AzureStoragePropertyDictionaryResource:
        """Updates the Azure storage account configurations of an app.

        Description for Updates the Azure storage account configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param azure_storage_accounts: Azure storage accounts of the app. Required.
        :type azure_storage_accounts: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AzureStoragePropertyDictionaryResource. The AzureStoragePropertyDictionaryResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_azure_storage_accounts(
        self,
        resource_group_name: str,
        name: str,
        azure_storage_accounts: Union[_models.AzureStoragePropertyDictionaryResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.AzureStoragePropertyDictionaryResource:
        """Updates the Azure storage account configurations of an app.

        Description for Updates the Azure storage account configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param azure_storage_accounts: Azure storage accounts of the app. Is one of the following
         types: AzureStoragePropertyDictionaryResource, JSON, IO[bytes] Required.
        :type azure_storage_accounts: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource or
         JSON or IO[bytes]
        :return: AzureStoragePropertyDictionaryResource. The AzureStoragePropertyDictionaryResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AzureStoragePropertyDictionaryResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(azure_storage_accounts, (IOBase, bytes)):
            _content = azure_storage_accounts
        else:
            _content = json.dumps(azure_storage_accounts, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_azure_storage_accounts_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AzureStoragePropertyDictionaryResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_azure_storage_accounts(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.AzureStoragePropertyDictionaryResource:
        """Gets the Azure storage account configurations of an app.

        Description for Gets the Azure storage account configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: AzureStoragePropertyDictionaryResource. The AzureStoragePropertyDictionaryResource is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AzureStoragePropertyDictionaryResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AzureStoragePropertyDictionaryResource] = kwargs.pop("cls", None)

        _request = build_web_apps_list_azure_storage_accounts_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AzureStoragePropertyDictionaryResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_backup_configuration(
        self,
        resource_group_name: str,
        name: str,
        request: _models.BackupRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupRequest:
        """Updates the backup configuration of an app.

        Description for Updates the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Edited backup configuration. Required.
        :type request: ~azure.mgmt.web.models.BackupRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupRequest. The BackupRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_backup_configuration(
        self,
        resource_group_name: str,
        name: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupRequest:
        """Updates the backup configuration of an app.

        Description for Updates the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Edited backup configuration. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupRequest. The BackupRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_backup_configuration(
        self,
        resource_group_name: str,
        name: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupRequest:
        """Updates the backup configuration of an app.

        Description for Updates the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Edited backup configuration. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupRequest. The BackupRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_backup_configuration(
        self, resource_group_name: str, name: str, request: Union[_models.BackupRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.BackupRequest:
        """Updates the backup configuration of an app.

        Description for Updates the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Edited backup configuration. Is one of the following types: BackupRequest,
         JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.BackupRequest or JSON or IO[bytes]
        :return: BackupRequest. The BackupRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BackupRequest] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_backup_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BackupRequest, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_backup_configuration(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Deletes the backup configuration of an app.

        Description for Deletes the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_backup_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_backup_configuration(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.BackupRequest:
        """Gets the backup configuration of an app.

        Description for Gets the backup configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: BackupRequest. The BackupRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BackupRequest] = kwargs.pop("cls", None)

        _request = build_web_apps_get_backup_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BackupRequest, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_connection_strings(
        self,
        resource_group_name: str,
        name: str,
        connection_strings: _models.ConnectionStringDictionary,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConnectionStringDictionary:
        """Replaces the connection strings of an app.

        Description for Replaces the connection strings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_strings: Connection strings of the app or deployment slot. See example.
         Required.
        :type connection_strings: ~azure.mgmt.web.models.ConnectionStringDictionary
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionStringDictionary. The ConnectionStringDictionary is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ConnectionStringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_connection_strings(
        self,
        resource_group_name: str,
        name: str,
        connection_strings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConnectionStringDictionary:
        """Replaces the connection strings of an app.

        Description for Replaces the connection strings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_strings: Connection strings of the app or deployment slot. See example.
         Required.
        :type connection_strings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionStringDictionary. The ConnectionStringDictionary is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ConnectionStringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_connection_strings(
        self,
        resource_group_name: str,
        name: str,
        connection_strings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConnectionStringDictionary:
        """Replaces the connection strings of an app.

        Description for Replaces the connection strings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_strings: Connection strings of the app or deployment slot. See example.
         Required.
        :type connection_strings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionStringDictionary. The ConnectionStringDictionary is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ConnectionStringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_connection_strings(
        self,
        resource_group_name: str,
        name: str,
        connection_strings: Union[_models.ConnectionStringDictionary, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.ConnectionStringDictionary:
        """Replaces the connection strings of an app.

        Description for Replaces the connection strings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_strings: Connection strings of the app or deployment slot. See example. Is
         one of the following types: ConnectionStringDictionary, JSON, IO[bytes] Required.
        :type connection_strings: ~azure.mgmt.web.models.ConnectionStringDictionary or JSON or
         IO[bytes]
        :return: ConnectionStringDictionary. The ConnectionStringDictionary is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ConnectionStringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ConnectionStringDictionary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_strings, (IOBase, bytes)):
            _content = connection_strings
        else:
            _content = json.dumps(connection_strings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_connection_strings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConnectionStringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_connection_strings(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.ConnectionStringDictionary:
        """Gets the connection strings of an app.

        Description for Gets the connection strings of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: ConnectionStringDictionary. The ConnectionStringDictionary is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ConnectionStringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ConnectionStringDictionary] = kwargs.pop("cls", None)

        _request = build_web_apps_list_connection_strings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConnectionStringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_metadata(
        self,
        resource_group_name: str,
        name: str,
        metadata: _models.StringDictionary,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the metadata of an app.

        Description for Replaces the metadata of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param metadata: Edited metadata of the app or deployment slot. See example. Required.
        :type metadata: ~azure.mgmt.web.models.StringDictionary
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_metadata(
        self,
        resource_group_name: str,
        name: str,
        metadata: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the metadata of an app.

        Description for Replaces the metadata of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param metadata: Edited metadata of the app or deployment slot. See example. Required.
        :type metadata: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_metadata(
        self,
        resource_group_name: str,
        name: str,
        metadata: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the metadata of an app.

        Description for Replaces the metadata of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param metadata: Edited metadata of the app or deployment slot. See example. Required.
        :type metadata: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_metadata(
        self,
        resource_group_name: str,
        name: str,
        metadata: Union[_models.StringDictionary, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.StringDictionary:
        """Replaces the metadata of an app.

        Description for Replaces the metadata of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param metadata: Edited metadata of the app or deployment slot. See example. Is one of the
         following types: StringDictionary, JSON, IO[bytes] Required.
        :type metadata: ~azure.mgmt.web.models.StringDictionary or JSON or IO[bytes]
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(metadata, (IOBase, bytes)):
            _content = metadata
        else:
            _content = json.dumps(metadata, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_metadata_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_metadata(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.StringDictionary:
        """Gets the metadata of an app.

        Description for Gets the metadata of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        _request = build_web_apps_list_metadata_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _list_publishing_credentials_initial(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_list_publishing_credentials_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_list_publishing_credentials(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncLROPoller[_models.User]:
        """Gets the Git/FTP publishing credentials of an app.

        Description for Gets the Git/FTP publishing credentials of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An instance of AsyncLROPoller that returns User. The User is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.User]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.User] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._list_publishing_credentials_initial(
                resource_group_name=resource_group_name,
                name=name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            deserialized = _deserialize(_models.User, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.User].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.User](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update_site_push_settings(
        self,
        resource_group_name: str,
        name: str,
        push_settings: _models.PushSettings,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PushSettings:
        """Updates the Push settings associated with web app.

        Description for Updates the Push settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param push_settings: Push settings associated with web app. Required.
        :type push_settings: ~azure.mgmt.web.models.PushSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PushSettings. The PushSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PushSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_site_push_settings(
        self,
        resource_group_name: str,
        name: str,
        push_settings: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PushSettings:
        """Updates the Push settings associated with web app.

        Description for Updates the Push settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param push_settings: Push settings associated with web app. Required.
        :type push_settings: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PushSettings. The PushSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PushSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_site_push_settings(
        self,
        resource_group_name: str,
        name: str,
        push_settings: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PushSettings:
        """Updates the Push settings associated with web app.

        Description for Updates the Push settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param push_settings: Push settings associated with web app. Required.
        :type push_settings: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PushSettings. The PushSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PushSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_site_push_settings(
        self,
        resource_group_name: str,
        name: str,
        push_settings: Union[_models.PushSettings, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PushSettings:
        """Updates the Push settings associated with web app.

        Description for Updates the Push settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param push_settings: Push settings associated with web app. Is one of the following types:
         PushSettings, JSON, IO[bytes] Required.
        :type push_settings: ~azure.mgmt.web.models.PushSettings or JSON or IO[bytes]
        :return: PushSettings. The PushSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PushSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PushSettings] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(push_settings, (IOBase, bytes)):
            _content = push_settings
        else:
            _content = json.dumps(push_settings, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_site_push_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PushSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_site_push_settings(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.PushSettings:
        """Gets the Push settings associated with web app.

        Description for Gets the Push settings associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: PushSettings. The PushSettings is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PushSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PushSettings] = kwargs.pop("cls", None)

        _request = build_web_apps_list_site_push_settings_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PushSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_web_site_container_logs(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> Optional[AsyncIterator[bytes]]:
        """Gets the last lines of docker logs for the given site.

        Description for Gets the last lines of docker logs for the given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: AsyncIterator[bytes] or None
        :rtype: AsyncIterator[bytes] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[AsyncIterator[bytes]]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_web_site_container_logs_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_container_logs_zip(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> Optional[AsyncIterator[bytes]]:
        """Gets the ZIP archived docker log files for the given site.

        Description for Gets the ZIP archived docker log files for the given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: AsyncIterator[bytes] or None
        :rtype: AsyncIterator[bytes] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[AsyncIterator[bytes]]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_container_logs_zip_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def discover_backup(
        self,
        resource_group_name: str,
        name: str,
        request: _models.RestoreRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RestoreRequest:
        """Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to
        get information about the databases stored in a backup.

        Description for Discovers an existing app backup that can be restored from a blob in Azure
        storage. Use this to get information about the databases stored in a backup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: A RestoreRequest object that includes Azure storage URL and blog name for
         discovery of backup. Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RestoreRequest. The RestoreRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RestoreRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def discover_backup(
        self,
        resource_group_name: str,
        name: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RestoreRequest:
        """Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to
        get information about the databases stored in a backup.

        Description for Discovers an existing app backup that can be restored from a blob in Azure
        storage. Use this to get information about the databases stored in a backup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: A RestoreRequest object that includes Azure storage URL and blog name for
         discovery of backup. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RestoreRequest. The RestoreRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RestoreRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def discover_backup(
        self,
        resource_group_name: str,
        name: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RestoreRequest:
        """Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to
        get information about the databases stored in a backup.

        Description for Discovers an existing app backup that can be restored from a blob in Azure
        storage. Use this to get information about the databases stored in a backup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: A RestoreRequest object that includes Azure storage URL and blog name for
         discovery of backup. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RestoreRequest. The RestoreRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RestoreRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def discover_backup(
        self,
        resource_group_name: str,
        name: str,
        request: Union[_models.RestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.RestoreRequest:
        """Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to
        get information about the databases stored in a backup.

        Description for Discovers an existing app backup that can be restored from a blob in Azure
        storage. Use this to get information about the databases stored in a backup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: A RestoreRequest object that includes Azure storage URL and blog name for
         discovery of backup. Is one of the following types: RestoreRequest, JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest or JSON or IO[bytes]
        :return: RestoreRequest. The RestoreRequest is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RestoreRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RestoreRequest] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_discover_backup_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RestoreRequest, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_one_deploy_status(self, resource_group_name: str, name: str, **kwargs: Any) -> Any:
        """Invoke onedeploy status API /api/deployments and gets the deployment status for the site.

        Description for Invoke onedeploy status API /api/deployments and gets the deployment status for
        the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_web_apps_get_one_deploy_status_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Any, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def create_one_deploy_operation(self, resource_group_name: str, name: str, **kwargs: Any) -> Any:
        """Invoke the OneDeploy publish web app extension.

        Description for Invoke the OneDeploy publish web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_web_apps_create_one_deploy_operation_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Any, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_functions_admin_token(self, resource_group_name: str, name: str, **kwargs: Any) -> str:
        """Fetch a short lived token that can be exchanged for a master key.

        Description for Fetch a short lived token that can be exchanged for a master key.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[str] = kwargs.pop("cls", None)

        _request = build_web_apps_get_functions_admin_token_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(str, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_host_keys(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.HostKeys:
        """Get host secrets for a function app.

        Description for Get host secrets for a function app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: HostKeys. The HostKeys is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostKeys
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HostKeys] = kwargs.pop("cls", None)

        _request = build_web_apps_list_host_keys_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HostKeys, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_sync_status(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """This is to allow calling via powershell and ARM template.

        Description for This is to allow calling via powershell and ARM template.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_list_sync_status_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def sync_functions(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Syncs function trigger metadata to the management database.

        Description for Syncs function trigger metadata to the management database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_sync_functions_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_or_update_host_secret(
        self,
        resource_group_name: str,
        name: str,
        key_type: str,
        key_name: str,
        key: _models.KeyInfo,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a host level secret.

        Description for Add or update a host level secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param key_type: The type of host key. Required.
        :type key_type: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key: The key to create or update. Required.
        :type key: ~azure.mgmt.web.models.KeyInfo
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_host_secret(
        self,
        resource_group_name: str,
        name: str,
        key_type: str,
        key_name: str,
        key: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a host level secret.

        Description for Add or update a host level secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param key_type: The type of host key. Required.
        :type key_type: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key: The key to create or update. Required.
        :type key: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_host_secret(
        self,
        resource_group_name: str,
        name: str,
        key_type: str,
        key_name: str,
        key: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a host level secret.

        Description for Add or update a host level secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param key_type: The type of host key. Required.
        :type key_type: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key: The key to create or update. Required.
        :type key: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_host_secret(
        self,
        resource_group_name: str,
        name: str,
        key_type: str,
        key_name: str,
        key: Union[_models.KeyInfo, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a host level secret.

        Description for Add or update a host level secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param key_type: The type of host key. Required.
        :type key_type: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key: The key to create or update. Is one of the following types: KeyInfo, JSON,
         IO[bytes] Required.
        :type key: ~azure.mgmt.web.models.KeyInfo or JSON or IO[bytes]
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.KeyInfo] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(key, (IOBase, bytes)):
            _content = key
        else:
            _content = json.dumps(key, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_host_secret_request(
            resource_group_name=resource_group_name,
            name=name,
            key_type=key_type,
            key_name=key_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.KeyInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_host_secret(
        self, resource_group_name: str, name: str, key_type: str, key_name: str, **kwargs: Any
    ) -> None:
        """Delete a host level secret.

        Description for Delete a host level secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param key_type: The type of host key. Required.
        :type key_type: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_host_secret_request(
            resource_group_name=resource_group_name,
            name=name,
            key_type=key_type,
            key_name=key_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_hybrid_connections(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.HybridConnection:
        """Retrieves all Service Bus Hybrid Connections used by this Web App.

        Description for Retrieves all Service Bus Hybrid Connections used by this Web App.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HybridConnection] = kwargs.pop("cls", None)

        _request = build_web_apps_list_hybrid_connections_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HybridConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_relay_service_connections(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Gets hybrid connections configured for an app (or deployment slot, if specified).

        Description for Gets hybrid connections configured for an app (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RelayServiceConnectionEntity] = kwargs.pop("cls", None)

        _request = build_web_apps_list_relay_service_connections_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RelayServiceConnectionEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def is_cloneable(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.SiteCloneability:
        """Shows whether an app can be cloned to another resource group or subscription.

        Description for Shows whether an app can be cloned to another resource group or subscription.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: SiteCloneability. The SiteCloneability is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteCloneability
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteCloneability] = kwargs.pop("cls", None)

        _request = build_web_apps_is_cloneable_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteCloneability, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_site_backups(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.BackupItem"]:
        """Gets existing backups of an app.

        Description for Gets existing backups of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of BackupItem
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.BackupItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BackupItem]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_site_backups_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.BackupItem], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_sync_function_triggers(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.FunctionSecrets:
        """This is to allow calling via powershell and ARM template.

        Description for This is to allow calling via powershell and ARM template.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: FunctionSecrets. The FunctionSecrets is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.FunctionSecrets
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FunctionSecrets] = kwargs.pop("cls", None)

        _request = build_web_apps_list_sync_function_triggers_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FunctionSecrets, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def update_machine_key(self, resource_group_name: str, name: str, **kwargs: Any) -> Any:
        """Updates the machine key of an app.

        Updates the machine key of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_web_apps_update_machine_key_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Any, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _migrate_storage_initial(
        self,
        resource_group_name: str,
        name: str,
        migration_options: Union[_models.StorageMigrationOptions, JSON, IO[bytes]],
        *,
        subscription_name: str,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(migration_options, (IOBase, bytes)):
            _content = migration_options
        else:
            _content = json.dumps(migration_options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_migrate_storage_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            subscription_name=subscription_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_migrate_storage(
        self,
        resource_group_name: str,
        name: str,
        migration_options: _models.StorageMigrationOptions,
        *,
        subscription_name: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StorageMigrationResponse]:
        """Restores a web app.

        Description for Restores a web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param migration_options: Migration migrationOptions. Required.
        :type migration_options: ~azure.mgmt.web.models.StorageMigrationOptions
        :keyword subscription_name: Azure subscription. Required.
        :paramtype subscription_name: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StorageMigrationResponse. The
         StorageMigrationResponse is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StorageMigrationResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_migrate_storage(
        self,
        resource_group_name: str,
        name: str,
        migration_options: JSON,
        *,
        subscription_name: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StorageMigrationResponse]:
        """Restores a web app.

        Description for Restores a web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param migration_options: Migration migrationOptions. Required.
        :type migration_options: JSON
        :keyword subscription_name: Azure subscription. Required.
        :paramtype subscription_name: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StorageMigrationResponse. The
         StorageMigrationResponse is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StorageMigrationResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_migrate_storage(
        self,
        resource_group_name: str,
        name: str,
        migration_options: IO[bytes],
        *,
        subscription_name: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StorageMigrationResponse]:
        """Restores a web app.

        Description for Restores a web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param migration_options: Migration migrationOptions. Required.
        :type migration_options: IO[bytes]
        :keyword subscription_name: Azure subscription. Required.
        :paramtype subscription_name: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns StorageMigrationResponse. The
         StorageMigrationResponse is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StorageMigrationResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_migrate_storage(
        self,
        resource_group_name: str,
        name: str,
        migration_options: Union[_models.StorageMigrationOptions, JSON, IO[bytes]],
        *,
        subscription_name: str,
        **kwargs: Any
    ) -> AsyncLROPoller[_models.StorageMigrationResponse]:
        """Restores a web app.

        Description for Restores a web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param migration_options: Migration migrationOptions. Is one of the following types:
         StorageMigrationOptions, JSON, IO[bytes] Required.
        :type migration_options: ~azure.mgmt.web.models.StorageMigrationOptions or JSON or IO[bytes]
        :keyword subscription_name: Azure subscription. Required.
        :paramtype subscription_name: str
        :return: An instance of AsyncLROPoller that returns StorageMigrationResponse. The
         StorageMigrationResponse is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.StorageMigrationResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StorageMigrationResponse] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._migrate_storage_initial(
                resource_group_name=resource_group_name,
                name=name,
                migration_options=migration_options,
                subscription_name=subscription_name,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            deserialized = _deserialize(_models.StorageMigrationResponse, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.StorageMigrationResponse].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.StorageMigrationResponse](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _migrate_my_sql_initial(
        self,
        resource_group_name: str,
        name: str,
        migration_request_envelope: Union[_models.MigrateMySqlRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(migration_request_envelope, (IOBase, bytes)):
            _content = migration_request_envelope
        else:
            _content = json.dumps(migration_request_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_migrate_my_sql_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_migrate_my_sql(
        self,
        resource_group_name: str,
        name: str,
        migration_request_envelope: _models.MigrateMySqlRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Operation]:
        """Migrates a local (in-app) MySql database to a remote MySql database.

        Description for Migrates a local (in-app) MySql database to a remote MySql database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param migration_request_envelope: MySql migration options. Required.
        :type migration_request_envelope: ~azure.mgmt.web.models.MigrateMySqlRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Operation. The Operation is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Operation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_migrate_my_sql(
        self,
        resource_group_name: str,
        name: str,
        migration_request_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Operation]:
        """Migrates a local (in-app) MySql database to a remote MySql database.

        Description for Migrates a local (in-app) MySql database to a remote MySql database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param migration_request_envelope: MySql migration options. Required.
        :type migration_request_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Operation. The Operation is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Operation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_migrate_my_sql(
        self,
        resource_group_name: str,
        name: str,
        migration_request_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Operation]:
        """Migrates a local (in-app) MySql database to a remote MySql database.

        Description for Migrates a local (in-app) MySql database to a remote MySql database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param migration_request_envelope: MySql migration options. Required.
        :type migration_request_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Operation. The Operation is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Operation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_migrate_my_sql(
        self,
        resource_group_name: str,
        name: str,
        migration_request_envelope: Union[_models.MigrateMySqlRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Operation]:
        """Migrates a local (in-app) MySql database to a remote MySql database.

        Description for Migrates a local (in-app) MySql database to a remote MySql database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param migration_request_envelope: MySql migration options. Is one of the following types:
         MigrateMySqlRequest, JSON, IO[bytes] Required.
        :type migration_request_envelope: ~azure.mgmt.web.models.MigrateMySqlRequest or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns Operation. The Operation is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.Operation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._migrate_my_sql_initial(
                resource_group_name=resource_group_name,
                name=name,
                migration_request_envelope=migration_request_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            deserialized = _deserialize(_models.Operation, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.Operation].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.Operation](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def get_network_trace_operation(
        self, resource_group_name: str, name: str, operation_id: str, **kwargs: Any
    ) -> List[_models.NetworkTrace]:
        """Gets a named operation for a network trace capturing (or deployment slot, if specified).

        Description for Gets a named operation for a network trace capturing (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param operation_id: GUID of the operation. Required.
        :type operation_id: str
        :return: list of NetworkTrace
        :rtype: list[~azure.mgmt.web.models.NetworkTrace]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.NetworkTrace]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_network_trace_operation_request(
            resource_group_name=resource_group_name,
            name=name,
            operation_id=operation_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.NetworkTrace], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def start_web_site_network_trace(
        self,
        resource_group_name: str,
        name: str,
        *,
        duration_in_seconds: Optional[int] = None,
        max_frame_length: Optional[int] = None,
        sas_url: Optional[str] = None,
        **kwargs: Any
    ) -> str:
        """Start capturing network packets for the site (To be deprecated).

        Description for Start capturing network packets for the site (To be deprecated).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :keyword duration_in_seconds: The duration to keep capturing in seconds. Default value is None.
        :paramtype duration_in_seconds: int
        :keyword max_frame_length: The maximum frame length in bytes (Optional). Default value is None.
        :paramtype max_frame_length: int
        :keyword sas_url: The Blob URL to store capture file. Default value is None.
        :paramtype sas_url: str
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[str] = kwargs.pop("cls", None)

        _request = build_web_apps_start_web_site_network_trace_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            duration_in_seconds=duration_in_seconds,
            max_frame_length=max_frame_length,
            sas_url=sas_url,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(str, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _start_web_site_network_trace_operation_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        *,
        duration_in_seconds: Optional[int] = None,
        max_frame_length: Optional[int] = None,
        sas_url: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_start_web_site_network_trace_operation_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            duration_in_seconds=duration_in_seconds,
            max_frame_length=max_frame_length,
            sas_url=sas_url,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_start_web_site_network_trace_operation(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        *,
        duration_in_seconds: Optional[int] = None,
        max_frame_length: Optional[int] = None,
        sas_url: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Start capturing network packets for the site.

        Description for Start capturing network packets for the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :keyword duration_in_seconds: The duration to keep capturing in seconds. Default value is None.
        :paramtype duration_in_seconds: int
        :keyword max_frame_length: The maximum frame length in bytes (Optional). Default value is None.
        :paramtype max_frame_length: int
        :keyword sas_url: The Blob URL to store capture file. Default value is None.
        :paramtype sas_url: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._start_web_site_network_trace_operation_initial(
                resource_group_name=resource_group_name,
                name=name,
                duration_in_seconds=duration_in_seconds,
                max_frame_length=max_frame_length,
                sas_url=sas_url,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def stop_web_site_network_trace(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Stop ongoing capturing network packets for the site.

        Description for Stop ongoing capturing network packets for the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_stop_web_site_network_trace_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_network_traces(
        self, resource_group_name: str, name: str, operation_id: str, **kwargs: Any
    ) -> List[_models.NetworkTrace]:
        """Gets a named operation for a network trace capturing (or deployment slot, if specified).

        Description for Gets a named operation for a network trace capturing (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param operation_id: GUID of the operation. Required.
        :type operation_id: str
        :return: list of NetworkTrace
        :rtype: list[~azure.mgmt.web.models.NetworkTrace]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.NetworkTrace]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_network_traces_request(
            resource_group_name=resource_group_name,
            name=name,
            operation_id=operation_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.NetworkTrace], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_network_trace_operation_v2(
        self, resource_group_name: str, name: str, operation_id: str, **kwargs: Any
    ) -> List[_models.NetworkTrace]:
        """Gets a named operation for a network trace capturing (or deployment slot, if specified).

        Description for Gets a named operation for a network trace capturing (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param operation_id: GUID of the operation. Required.
        :type operation_id: str
        :return: list of NetworkTrace
        :rtype: list[~azure.mgmt.web.models.NetworkTrace]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.NetworkTrace]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_network_trace_operation_v2_request(
            resource_group_name=resource_group_name,
            name=name,
            operation_id=operation_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.NetworkTrace], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_network_traces_v2(
        self, resource_group_name: str, name: str, operation_id: str, **kwargs: Any
    ) -> List[_models.NetworkTrace]:
        """Gets a named operation for a network trace capturing (or deployment slot, if specified).

        Description for Gets a named operation for a network trace capturing (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param operation_id: GUID of the operation. Required.
        :type operation_id: str
        :return: list of NetworkTrace
        :rtype: list[~azure.mgmt.web.models.NetworkTrace]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.NetworkTrace]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_network_traces_v2_request(
            resource_group_name=resource_group_name,
            name=name,
            operation_id=operation_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.NetworkTrace], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def generate_new_site_publishing_password(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Generates a new publishing password for an app (or deployment slot, if specified).

        Description for Generates a new publishing password for an app (or deployment slot, if
        specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_generate_new_site_publishing_password_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_perf_mon_counters(
        self, resource_group_name: str, name: str, *, filter: Optional[str] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PerfMonResponse"]:
        """Gets perfmon counters for web app.

        Description for Gets perfmon counters for web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :keyword filter: Return only usages/metrics specified in the filter. Filter conforms to odata
         syntax. Example: $filter=(startTime eq 2014-01-01T00:00:00Z and endTime eq 2014-12-31T23:59:59Z
         and timeGrain eq duration'[Hour|Minute|Day]'. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of PerfMonResponse
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.PerfMonResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PerfMonResponse]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_perf_mon_counters_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PerfMonResponse], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_php_error_log_flag(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.SitePhpErrorLogFlag:
        """Gets web app's event logs.

        Description for Gets web app's event logs.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: SitePhpErrorLogFlag. The SitePhpErrorLogFlag is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SitePhpErrorLogFlag
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SitePhpErrorLogFlag] = kwargs.pop("cls", None)

        _request = build_web_apps_get_site_php_error_log_flag_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SitePhpErrorLogFlag, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_premier_add_ons(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.PremierAddOn:
        """Gets the premier add-ons of an app.

        Description for Gets the premier add-ons of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PremierAddOn] = kwargs.pop("cls", None)

        _request = build_web_apps_list_premier_add_ons_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PremierAddOn, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_private_link_resources(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.PrivateLinkResourcesWrapper:
        """Gets the private link resources.

        Description for Gets the private link resources.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: PrivateLinkResourcesWrapper. The PrivateLinkResourcesWrapper is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateLinkResourcesWrapper
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PrivateLinkResourcesWrapper] = kwargs.pop("cls", None)

        _request = build_web_apps_get_private_link_resources_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PrivateLinkResourcesWrapper, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def list_publishing_profile_xml_with_secrets(
        self,
        resource_group_name: str,
        name: str,
        publishing_profile_options: _models.CsmPublishingProfileOptions,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Gets the publishing profile for an app (or deployment slot, if specified).

        Description for Gets the publishing profile for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param publishing_profile_options: Specifies publishingProfileOptions for publishing profile.
         For example, use {" format": "FileZilla3"} to get a FileZilla publishing profile. Required.
        :type publishing_profile_options: ~azure.mgmt.web.models.CsmPublishingProfileOptions
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_publishing_profile_xml_with_secrets(
        self,
        resource_group_name: str,
        name: str,
        publishing_profile_options: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Gets the publishing profile for an app (or deployment slot, if specified).

        Description for Gets the publishing profile for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param publishing_profile_options: Specifies publishingProfileOptions for publishing profile.
         For example, use {" format": "FileZilla3"} to get a FileZilla publishing profile. Required.
        :type publishing_profile_options: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_publishing_profile_xml_with_secrets(
        self,
        resource_group_name: str,
        name: str,
        publishing_profile_options: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Gets the publishing profile for an app (or deployment slot, if specified).

        Description for Gets the publishing profile for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param publishing_profile_options: Specifies publishingProfileOptions for publishing profile.
         For example, use {" format": "FileZilla3"} to get a FileZilla publishing profile. Required.
        :type publishing_profile_options: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def list_publishing_profile_xml_with_secrets(
        self,
        resource_group_name: str,
        name: str,
        publishing_profile_options: Union[_models.CsmPublishingProfileOptions, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Gets the publishing profile for an app (or deployment slot, if specified).

        Description for Gets the publishing profile for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param publishing_profile_options: Specifies publishingProfileOptions for publishing profile.
         For example, use {" format": "FileZilla3"} to get a FileZilla publishing profile. Is one of the
         following types: CsmPublishingProfileOptions, JSON, IO[bytes] Required.
        :type publishing_profile_options: ~azure.mgmt.web.models.CsmPublishingProfileOptions or JSON or
         IO[bytes]
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(publishing_profile_options, (IOBase, bytes)):
            _content = publishing_profile_options
        else:
            _content = json.dumps(publishing_profile_options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_list_publishing_profile_xml_with_secrets_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def reset_production_slot_config(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Resets the configuration settings of the current slot if they were previously modified by
        calling the API with POST.

        Description for Resets the configuration settings of the current slot if they were previously
        modified by calling the API with POST.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_reset_production_slot_config_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def restart(
        self,
        resource_group_name: str,
        name: str,
        *,
        soft_restart: Optional[bool] = None,
        synchronous: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Restarts an app (or deployment slot, if specified).

        Description for Restarts an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :keyword soft_restart: Specify true to apply the configuration settings and restarts the app
         only if necessary. By default, the API always restarts and reprovisions the app. Default value
         is None.
        :paramtype soft_restart: bool
        :keyword synchronous: Specify true to block until the app is restarted. By default, it is set
         to false, and the API responds immediately (asynchronous). Default value is None.
        :paramtype synchronous: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_restart_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            soft_restart=soft_restart,
            synchronous=synchronous,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    async def _restore_from_backup_blob_initial(
        self,
        resource_group_name: str,
        name: str,
        request: Union[_models.RestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_restore_from_backup_blob_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_restore_from_backup_blob(
        self,
        resource_group_name: str,
        name: str,
        request: _models.RestoreRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores an app from a backup blob in Azure Storage.

        Description for Restores an app from a backup blob in Azure Storage.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Information on restore request . Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_from_backup_blob(
        self,
        resource_group_name: str,
        name: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores an app from a backup blob in Azure Storage.

        Description for Restores an app from a backup blob in Azure Storage.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Information on restore request . Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_from_backup_blob(
        self,
        resource_group_name: str,
        name: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores an app from a backup blob in Azure Storage.

        Description for Restores an app from a backup blob in Azure Storage.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Information on restore request . Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_restore_from_backup_blob(
        self,
        resource_group_name: str,
        name: str,
        request: Union[_models.RestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores an app from a backup blob in Azure Storage.

        Description for Restores an app from a backup blob in Azure Storage.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param request: Information on restore request . Is one of the following types: RestoreRequest,
         JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._restore_from_backup_blob_initial(
                resource_group_name=resource_group_name,
                name=name,
                request=request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    async def _restore_from_deleted_app_initial(
        self,
        resource_group_name: str,
        name: str,
        restore_request: Union[_models.DeletedAppRestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(restore_request, (IOBase, bytes)):
            _content = restore_request
        else:
            _content = json.dumps(restore_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_restore_from_deleted_app_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_restore_from_deleted_app(
        self,
        resource_group_name: str,
        name: str,
        restore_request: _models.DeletedAppRestoreRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a deleted web app to this web app.

        Description for Restores a deleted web app to this web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param restore_request: Deleted web app restore information. Required.
        :type restore_request: ~azure.mgmt.web.models.DeletedAppRestoreRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_from_deleted_app(
        self,
        resource_group_name: str,
        name: str,
        restore_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a deleted web app to this web app.

        Description for Restores a deleted web app to this web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param restore_request: Deleted web app restore information. Required.
        :type restore_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_from_deleted_app(
        self,
        resource_group_name: str,
        name: str,
        restore_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a deleted web app to this web app.

        Description for Restores a deleted web app to this web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param restore_request: Deleted web app restore information. Required.
        :type restore_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_restore_from_deleted_app(
        self,
        resource_group_name: str,
        name: str,
        restore_request: Union[_models.DeletedAppRestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a deleted web app to this web app.

        Description for Restores a deleted web app to this web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param restore_request: Deleted web app restore information. Is one of the following types:
         DeletedAppRestoreRequest, JSON, IO[bytes] Required.
        :type restore_request: ~azure.mgmt.web.models.DeletedAppRestoreRequest or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._restore_from_deleted_app_initial(
                resource_group_name=resource_group_name,
                name=name,
                restore_request=restore_request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    async def _restore_snapshot_initial(
        self,
        resource_group_name: str,
        name: str,
        restore_request: Union[_models.SnapshotRestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(restore_request, (IOBase, bytes)):
            _content = restore_request
        else:
            _content = json.dumps(restore_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_restore_snapshot_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_restore_snapshot(
        self,
        resource_group_name: str,
        name: str,
        restore_request: _models.SnapshotRestoreRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a web app from a snapshot.

        Description for Restores a web app from a snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param restore_request: Snapshot restore settings. Snapshot information can be obtained by
         calling GetDeletedSites or GetSiteSnapshots API. Required.
        :type restore_request: ~azure.mgmt.web.models.SnapshotRestoreRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_snapshot(
        self,
        resource_group_name: str,
        name: str,
        restore_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a web app from a snapshot.

        Description for Restores a web app from a snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param restore_request: Snapshot restore settings. Snapshot information can be obtained by
         calling GetDeletedSites or GetSiteSnapshots API. Required.
        :type restore_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_snapshot(
        self,
        resource_group_name: str,
        name: str,
        restore_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a web app from a snapshot.

        Description for Restores a web app from a snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param restore_request: Snapshot restore settings. Snapshot information can be obtained by
         calling GetDeletedSites or GetSiteSnapshots API. Required.
        :type restore_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_restore_snapshot(
        self,
        resource_group_name: str,
        name: str,
        restore_request: Union[_models.SnapshotRestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a web app from a snapshot.

        Description for Restores a web app from a snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param restore_request: Snapshot restore settings. Snapshot information can be obtained by
         calling GetDeletedSites or GetSiteSnapshots API. Is one of the following types:
         SnapshotRestoreRequest, JSON, IO[bytes] Required.
        :type restore_request: ~azure.mgmt.web.models.SnapshotRestoreRequest or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._restore_snapshot_initial(
                resource_group_name=resource_group_name,
                name=name,
                restore_request=restore_request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def list_slot_differences_from_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: _models.CsmSlotEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncItemPaged["_models.SlotDifference"]:
        """Get the difference in configuration settings between two web app slots.

        Description for Get the difference in configuration settings between two web app slots.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of SlotDifference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SlotDifference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def list_slot_differences_from_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncItemPaged["_models.SlotDifference"]:
        """Get the difference in configuration settings between two web app slots.

        Description for Get the difference in configuration settings between two web app slots.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of SlotDifference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SlotDifference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def list_slot_differences_from_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncItemPaged["_models.SlotDifference"]:
        """Get the difference in configuration settings between two web app slots.

        Description for Get the difference in configuration settings between two web app slots.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of SlotDifference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SlotDifference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def list_slot_differences_from_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: Union[_models.CsmSlotEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncItemPaged["_models.SlotDifference"]:
        """Get the difference in configuration settings between two web app slots.

        Description for Get the difference in configuration settings between two web app slots.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Is one of
         the following types: CsmSlotEntity, JSON, IO[bytes] Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity or JSON or IO[bytes]
        :return: An iterator like instance of SlotDifference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SlotDifference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.SlotDifference]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})
        content_type = content_type or "application/json"
        _content = None
        if isinstance(slot_swap_entity, (IOBase, bytes)):
            _content = slot_swap_entity
        else:
            _content = json.dumps(slot_swap_entity, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_slot_differences_from_production_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    content_type=content_type,
                    api_version=self._config.api_version,
                    content=_content,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SlotDifference], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _swap_slot_with_production_initial(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: Union[_models.CsmSlotEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(slot_swap_entity, (IOBase, bytes)):
            _content = slot_swap_entity
        else:
            _content = json.dumps(slot_swap_entity, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_swap_slot_with_production_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_swap_slot_with_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: _models.CsmSlotEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Swaps two deployment slots of an app.

        Description for Swaps two deployment slots of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_swap_slot_with_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Swaps two deployment slots of an app.

        Description for Swaps two deployment slots of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_swap_slot_with_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Swaps two deployment slots of an app.

        Description for Swaps two deployment slots of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Required.
        :type slot_swap_entity: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_swap_slot_with_production(
        self,
        resource_group_name: str,
        name: str,
        slot_swap_entity: Union[_models.CsmSlotEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Swaps two deployment slots of an app.

        Description for Swaps two deployment slots of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_swap_entity: JSON object that contains the target slot name. See example. Is one of
         the following types: CsmSlotEntity, JSON, IO[bytes] Required.
        :type slot_swap_entity: ~azure.mgmt.web.models.CsmSlotEntity or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._swap_slot_with_production_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot_swap_entity=slot_swap_entity,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_snapshots(self, resource_group_name: str, name: str, **kwargs: Any) -> AsyncItemPaged["_models.Snapshot"]:
        """Returns all Snapshots to the user.

        Description for Returns all Snapshots to the user.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of Snapshot
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Snapshot]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Snapshot]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_snapshots_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Snapshot], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_snapshots_from_dr_secondary(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.Snapshot"]:
        """Returns all Snapshots to the user from DRSecondary endpoint.

        Description for Returns all Snapshots to the user from DRSecondary endpoint.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of Snapshot
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Snapshot]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Snapshot]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_snapshots_from_dr_secondary_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Snapshot], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def start(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Starts an app (or deployment slot, if specified).

        Description for Starts an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_start_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    async def _start_network_trace_initial(
        self,
        resource_group_name: str,
        name: str,
        *,
        duration_in_seconds: Optional[int] = None,
        max_frame_length: Optional[int] = None,
        sas_url: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_start_network_trace_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            duration_in_seconds=duration_in_seconds,
            max_frame_length=max_frame_length,
            sas_url=sas_url,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_start_network_trace(
        self,
        resource_group_name: str,
        name: str,
        *,
        duration_in_seconds: Optional[int] = None,
        max_frame_length: Optional[int] = None,
        sas_url: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Start capturing network packets for the site.

        Description for Start capturing network packets for the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :keyword duration_in_seconds: The duration to keep capturing in seconds. Default value is None.
        :paramtype duration_in_seconds: int
        :keyword max_frame_length: The maximum frame length in bytes (Optional). Default value is None.
        :paramtype max_frame_length: int
        :keyword sas_url: The Blob URL to store capture file. Default value is None.
        :paramtype sas_url: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._start_network_trace_initial(
                resource_group_name=resource_group_name,
                name=name,
                duration_in_seconds=duration_in_seconds,
                max_frame_length=max_frame_length,
                sas_url=sas_url,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def stop(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Stops an app (or deployment slot, if specified).

        Description for Stops an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_stop_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def stop_network_trace(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Stop ongoing capturing network packets for the site.

        Description for Stop ongoing capturing network packets for the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_stop_network_trace_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def sync_repository(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Sync web app repository.

        Description for Sync web app repository.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_sync_repository_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def sync_function_triggers(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Syncs function trigger metadata to the management database.

        Description for Syncs function trigger metadata to the management database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_sync_function_triggers_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_usages(
        self, resource_group_name: str, name: str, *, filter: Optional[str] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.CsmUsageQuota"]:
        """Gets the quota usage information of an app (or deployment slot, if specified).

        Description for Gets the quota usage information of an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :keyword filter: Return only information specified in the filter (using OData syntax). For
         example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq
         2014-01-01T00:00:00Z and endTime eq 2014-12-31T23:59:59Z and timeGrain eq
         duration'[Hour|Minute|Day]'. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of CsmUsageQuota
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.CsmUsageQuota]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CsmUsageQuota]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_usages_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CsmUsageQuota], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def deploy_workflow_artifacts(
        self,
        resource_group_name: str,
        name: str,
        workflow_artifacts: Optional[_models.WorkflowArtifacts] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Creates the artifacts for web site, or a deployment slot.

        Description for Creates the artifacts for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param workflow_artifacts: Application settings and files of the workflow. Default value is
         None.
        :type workflow_artifacts: ~azure.mgmt.web.models.WorkflowArtifacts
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def deploy_workflow_artifacts(
        self,
        resource_group_name: str,
        name: str,
        workflow_artifacts: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Creates the artifacts for web site, or a deployment slot.

        Description for Creates the artifacts for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param workflow_artifacts: Application settings and files of the workflow. Default value is
         None.
        :type workflow_artifacts: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def deploy_workflow_artifacts(
        self,
        resource_group_name: str,
        name: str,
        workflow_artifacts: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Creates the artifacts for web site, or a deployment slot.

        Description for Creates the artifacts for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param workflow_artifacts: Application settings and files of the workflow. Default value is
         None.
        :type workflow_artifacts: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def deploy_workflow_artifacts(
        self,
        resource_group_name: str,
        name: str,
        workflow_artifacts: Optional[Union[_models.WorkflowArtifacts, JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """Creates the artifacts for web site, or a deployment slot.

        Description for Creates the artifacts for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param workflow_artifacts: Application settings and files of the workflow. Is one of the
         following types: WorkflowArtifacts, JSON, IO[bytes] Default value is None.
        :type workflow_artifacts: ~azure.mgmt.web.models.WorkflowArtifacts or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        content_type = content_type if workflow_artifacts else None
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json" if workflow_artifacts else None
        _content = None
        if isinstance(workflow_artifacts, (IOBase, bytes)):
            _content = workflow_artifacts
        else:
            if workflow_artifacts is not None:
                _content = json.dumps(workflow_artifacts, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_web_apps_deploy_workflow_artifacts_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_workflows_connections(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.WorkflowEnvelope:
        """Lists logic app's connections for web site, or a deployment slot.

        Lists logic app's connections for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: WorkflowEnvelope. The WorkflowEnvelope is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowEnvelope
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowEnvelope] = kwargs.pop("cls", None)

        _request = build_web_apps_list_workflows_connections_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowEnvelope, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_backup_status(
        self, resource_group_name: str, name: str, backup_id: str, **kwargs: Any
    ) -> _models.BackupItem:
        """Gets a backup of an app by its ID.

        Description for Gets a backup of an app by its ID.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BackupItem] = kwargs.pop("cls", None)

        _request = build_web_apps_get_backup_status_request(
            resource_group_name=resource_group_name,
            name=name,
            backup_id=backup_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BackupItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_backup(self, resource_group_name: str, name: str, backup_id: str, **kwargs: Any) -> None:
        """Deletes a backup of an app by its ID.

        Description for Deletes a backup of an app by its ID.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_backup_request(
            resource_group_name=resource_group_name,
            name=name,
            backup_id=backup_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_backups(self, resource_group_name: str, name: str, **kwargs: Any) -> AsyncItemPaged["_models.BackupItem"]:
        """Gets existing backups of an app.

        Description for Gets existing backups of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of BackupItem
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.BackupItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BackupItem]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_backups_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.BackupItem], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def list_backup_status_secrets(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        request: _models.BackupRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Gets status of a web app backup that may be in progress, including secrets associated with the
        backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
        backup if a new URL is passed in the request body.

        Description for Gets status of a web app backup that may be in progress, including secrets
        associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the
        SAS URL for the backup if a new URL is passed in the request body.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param request: Information on backup request. Required.
        :type request: ~azure.mgmt.web.models.BackupRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_backup_status_secrets(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Gets status of a web app backup that may be in progress, including secrets associated with the
        backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
        backup if a new URL is passed in the request body.

        Description for Gets status of a web app backup that may be in progress, including secrets
        associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the
        SAS URL for the backup if a new URL is passed in the request body.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param request: Information on backup request. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_backup_status_secrets(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Gets status of a web app backup that may be in progress, including secrets associated with the
        backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
        backup if a new URL is passed in the request body.

        Description for Gets status of a web app backup that may be in progress, including secrets
        associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the
        SAS URL for the backup if a new URL is passed in the request body.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param request: Information on backup request. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def list_backup_status_secrets(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        request: Union[_models.BackupRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.BackupItem:
        """Gets status of a web app backup that may be in progress, including secrets associated with the
        backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
        backup if a new URL is passed in the request body.

        Description for Gets status of a web app backup that may be in progress, including secrets
        associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the
        SAS URL for the backup if a new URL is passed in the request body.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param request: Information on backup request. Is one of the following types: BackupRequest,
         JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.BackupRequest or JSON or IO[bytes]
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BackupItem] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_list_backup_status_secrets_request(
            resource_group_name=resource_group_name,
            name=name,
            backup_id=backup_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BackupItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _restore_initial(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        request: Union[_models.RestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_restore_request(
            resource_group_name=resource_group_name,
            name=name,
            backup_id=backup_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_restore(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        request: _models.RestoreRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a specific backup to another app (or deployment slot, if specified).

        Description for Restores a specific backup to another app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param request: Information on restore request . Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a specific backup to another app (or deployment slot, if specified).

        Description for Restores a specific backup to another app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param request: Information on restore request . Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a specific backup to another app (or deployment slot, if specified).

        Description for Restores a specific backup to another app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param request: Information on restore request . Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_restore(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        request: Union[_models.RestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a specific backup to another app (or deployment slot, if specified).

        Description for Restores a specific backup to another app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param request: Information on restore request . Is one of the following types: RestoreRequest,
         JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._restore_initial(
                resource_group_name=resource_group_name,
                name=name,
                backup_id=backup_id,
                request=request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def get_backup_status_slot(
        self, resource_group_name: str, name: str, backup_id: str, slot: str, **kwargs: Any
    ) -> _models.BackupItem:
        """Gets a backup of an app by its ID.

        Description for Gets a backup of an app by its ID.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a backup
         of the production slot. Required.
        :type slot: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BackupItem] = kwargs.pop("cls", None)

        _request = build_web_apps_get_backup_status_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            backup_id=backup_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BackupItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_backup_slot(
        self, resource_group_name: str, name: str, backup_id: str, slot: str, **kwargs: Any
    ) -> None:
        """Deletes a backup of an app by its ID.

        Description for Deletes a backup of an app by its ID.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a backup
         of the production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_backup_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            backup_id=backup_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_backups_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.BackupItem"]:
        """Gets existing backups of an app.

        Description for Gets existing backups of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a backup
         of the production slot. Required.
        :type slot: str
        :return: An iterator like instance of BackupItem
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.BackupItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BackupItem]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_backups_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.BackupItem], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def list_backup_status_secrets_slot(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        slot: str,
        request: _models.BackupRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Gets status of a web app backup that may be in progress, including secrets associated with the
        backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
        backup if a new URL is passed in the request body.

        Description for Gets status of a web app backup that may be in progress, including secrets
        associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the
        SAS URL for the backup if a new URL is passed in the request body.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a backup
         of the production slot. Required.
        :type slot: str
        :param request: Information on backup request. Required.
        :type request: ~azure.mgmt.web.models.BackupRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_backup_status_secrets_slot(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        slot: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Gets status of a web app backup that may be in progress, including secrets associated with the
        backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
        backup if a new URL is passed in the request body.

        Description for Gets status of a web app backup that may be in progress, including secrets
        associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the
        SAS URL for the backup if a new URL is passed in the request body.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a backup
         of the production slot. Required.
        :type slot: str
        :param request: Information on backup request. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_backup_status_secrets_slot(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        slot: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BackupItem:
        """Gets status of a web app backup that may be in progress, including secrets associated with the
        backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
        backup if a new URL is passed in the request body.

        Description for Gets status of a web app backup that may be in progress, including secrets
        associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the
        SAS URL for the backup if a new URL is passed in the request body.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a backup
         of the production slot. Required.
        :type slot: str
        :param request: Information on backup request. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def list_backup_status_secrets_slot(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        slot: str,
        request: Union[_models.BackupRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.BackupItem:
        """Gets status of a web app backup that may be in progress, including secrets associated with the
        backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
        backup if a new URL is passed in the request body.

        Description for Gets status of a web app backup that may be in progress, including secrets
        associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the
        SAS URL for the backup if a new URL is passed in the request body.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a backup
         of the production slot. Required.
        :type slot: str
        :param request: Information on backup request. Is one of the following types: BackupRequest,
         JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.BackupRequest or JSON or IO[bytes]
        :return: BackupItem. The BackupItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.BackupItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BackupItem] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_list_backup_status_secrets_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            backup_id=backup_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BackupItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _restore_slot_initial(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        slot: str,
        request: Union[_models.RestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_restore_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            backup_id=backup_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_restore_slot(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        slot: str,
        request: _models.RestoreRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a specific backup to another app (or deployment slot, if specified).

        Description for Restores a specific backup to another app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a backup
         of the production slot. Required.
        :type slot: str
        :param request: Information on restore request . Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_slot(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        slot: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a specific backup to another app (or deployment slot, if specified).

        Description for Restores a specific backup to another app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a backup
         of the production slot. Required.
        :type slot: str
        :param request: Information on restore request . Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restore_slot(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        slot: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a specific backup to another app (or deployment slot, if specified).

        Description for Restores a specific backup to another app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a backup
         of the production slot. Required.
        :type slot: str
        :param request: Information on restore request . Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_restore_slot(
        self,
        resource_group_name: str,
        name: str,
        backup_id: str,
        slot: str,
        request: Union[_models.RestoreRequest, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Restores a specific backup to another app (or deployment slot, if specified).

        Description for Restores a specific backup to another app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param backup_id: ID of the backup. Required.
        :type backup_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a backup
         of the production slot. Required.
        :type slot: str
        :param request: Information on restore request . Is one of the following types: RestoreRequest,
         JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.RestoreRequest or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._restore_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                backup_id=backup_id,
                slot=slot,
                request=request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def get_ftp_allowed(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Returns whether FTP is allowed on the site or not.

        Description for Returns whether FTP is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CsmPublishingCredentialsPoliciesEntity] = kwargs.pop("cls", None)

        _request = build_web_apps_get_ftp_allowed_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CsmPublishingCredentialsPoliciesEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_ftp_allowed(
        self,
        resource_group_name: str,
        name: str,
        csm_publishing_access_policies_entity: _models.CsmPublishingCredentialsPoliciesEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether FTP is allowed on the site or not.

        Description for Updates whether FTP is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity:
         ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_ftp_allowed(
        self,
        resource_group_name: str,
        name: str,
        csm_publishing_access_policies_entity: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether FTP is allowed on the site or not.

        Description for Updates whether FTP is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_ftp_allowed(
        self,
        resource_group_name: str,
        name: str,
        csm_publishing_access_policies_entity: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether FTP is allowed on the site or not.

        Description for Updates whether FTP is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_ftp_allowed(
        self,
        resource_group_name: str,
        name: str,
        csm_publishing_access_policies_entity: Union[_models.CsmPublishingCredentialsPoliciesEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether FTP is allowed on the site or not.

        Description for Updates whether FTP is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param csm_publishing_access_policies_entity: Is one of the following types:
         CsmPublishingCredentialsPoliciesEntity, JSON, IO[bytes] Required.
        :type csm_publishing_access_policies_entity:
         ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity or JSON or IO[bytes]
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CsmPublishingCredentialsPoliciesEntity] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(csm_publishing_access_policies_entity, (IOBase, bytes)):
            _content = csm_publishing_access_policies_entity
        else:
            _content = json.dumps(csm_publishing_access_policies_entity, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_ftp_allowed_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CsmPublishingCredentialsPoliciesEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_basic_publishing_credentials_policies(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.CsmPublishingCredentialsPoliciesEntity"]:
        """Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given site.

        Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a
        given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of CsmPublishingCredentialsPoliciesEntity
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CsmPublishingCredentialsPoliciesEntity]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_basic_publishing_credentials_policies_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.CsmPublishingCredentialsPoliciesEntity], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_scm_allowed(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Returns whether Scm basic auth is allowed on the site or not.

        Description for Returns whether Scm basic auth is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CsmPublishingCredentialsPoliciesEntity] = kwargs.pop("cls", None)

        _request = build_web_apps_get_scm_allowed_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CsmPublishingCredentialsPoliciesEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_scm_allowed(
        self,
        resource_group_name: str,
        name: str,
        csm_publishing_access_policies_entity: _models.CsmPublishingCredentialsPoliciesEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether user publishing credentials are allowed on the site or not.

        Description for Updates whether user publishing credentials are allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity:
         ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_scm_allowed(
        self,
        resource_group_name: str,
        name: str,
        csm_publishing_access_policies_entity: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether user publishing credentials are allowed on the site or not.

        Description for Updates whether user publishing credentials are allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_scm_allowed(
        self,
        resource_group_name: str,
        name: str,
        csm_publishing_access_policies_entity: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether user publishing credentials are allowed on the site or not.

        Description for Updates whether user publishing credentials are allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_scm_allowed(
        self,
        resource_group_name: str,
        name: str,
        csm_publishing_access_policies_entity: Union[_models.CsmPublishingCredentialsPoliciesEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether user publishing credentials are allowed on the site or not.

        Description for Updates whether user publishing credentials are allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param csm_publishing_access_policies_entity: Is one of the following types:
         CsmPublishingCredentialsPoliciesEntity, JSON, IO[bytes] Required.
        :type csm_publishing_access_policies_entity:
         ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity or JSON or IO[bytes]
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CsmPublishingCredentialsPoliciesEntity] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(csm_publishing_access_policies_entity, (IOBase, bytes)):
            _content = csm_publishing_access_policies_entity
        else:
            _content = json.dumps(csm_publishing_access_policies_entity, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_scm_allowed_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CsmPublishingCredentialsPoliciesEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_ftp_allowed_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Returns whether FTP is allowed on the site or not.

        Description for Returns whether FTP is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CsmPublishingCredentialsPoliciesEntity] = kwargs.pop("cls", None)

        _request = build_web_apps_get_ftp_allowed_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CsmPublishingCredentialsPoliciesEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_ftp_allowed_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        csm_publishing_access_policies_entity: _models.CsmPublishingCredentialsPoliciesEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether FTP is allowed on the site or not.

        Description for Updates whether FTP is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity:
         ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_ftp_allowed_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        csm_publishing_access_policies_entity: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether FTP is allowed on the site or not.

        Description for Updates whether FTP is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_ftp_allowed_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        csm_publishing_access_policies_entity: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether FTP is allowed on the site or not.

        Description for Updates whether FTP is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_ftp_allowed_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        csm_publishing_access_policies_entity: Union[_models.CsmPublishingCredentialsPoliciesEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether FTP is allowed on the site or not.

        Description for Updates whether FTP is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :param csm_publishing_access_policies_entity: Is one of the following types:
         CsmPublishingCredentialsPoliciesEntity, JSON, IO[bytes] Required.
        :type csm_publishing_access_policies_entity:
         ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity or JSON or IO[bytes]
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CsmPublishingCredentialsPoliciesEntity] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(csm_publishing_access_policies_entity, (IOBase, bytes)):
            _content = csm_publishing_access_policies_entity
        else:
            _content = json.dumps(csm_publishing_access_policies_entity, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_ftp_allowed_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CsmPublishingCredentialsPoliciesEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_basic_publishing_credentials_policies_slot(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.CsmPublishingCredentialsPoliciesEntity"]:
        """Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given site.

        Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a
        given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :return: An iterator like instance of CsmPublishingCredentialsPoliciesEntity
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CsmPublishingCredentialsPoliciesEntity]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_basic_publishing_credentials_policies_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.CsmPublishingCredentialsPoliciesEntity], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_scm_allowed_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Returns whether Scm basic auth is allowed on the site or not.

        Description for Returns whether Scm basic auth is allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CsmPublishingCredentialsPoliciesEntity] = kwargs.pop("cls", None)

        _request = build_web_apps_get_scm_allowed_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CsmPublishingCredentialsPoliciesEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_scm_allowed_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        csm_publishing_access_policies_entity: _models.CsmPublishingCredentialsPoliciesEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether user publishing credentials are allowed on the site or not.

        Description for Updates whether user publishing credentials are allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity:
         ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_scm_allowed_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        csm_publishing_access_policies_entity: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether user publishing credentials are allowed on the site or not.

        Description for Updates whether user publishing credentials are allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_scm_allowed_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        csm_publishing_access_policies_entity: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether user publishing credentials are allowed on the site or not.

        Description for Updates whether user publishing credentials are allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :param csm_publishing_access_policies_entity: Required.
        :type csm_publishing_access_policies_entity: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_scm_allowed_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        csm_publishing_access_policies_entity: Union[_models.CsmPublishingCredentialsPoliciesEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.CsmPublishingCredentialsPoliciesEntity:
        """Updates whether user publishing credentials are allowed on the site or not.

        Description for Updates whether user publishing credentials are allowed on the site or not.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :param csm_publishing_access_policies_entity: Is one of the following types:
         CsmPublishingCredentialsPoliciesEntity, JSON, IO[bytes] Required.
        :type csm_publishing_access_policies_entity:
         ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity or JSON or IO[bytes]
        :return: CsmPublishingCredentialsPoliciesEntity. The CsmPublishingCredentialsPoliciesEntity is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.CsmPublishingCredentialsPoliciesEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CsmPublishingCredentialsPoliciesEntity] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(csm_publishing_access_policies_entity, (IOBase, bytes)):
            _content = csm_publishing_access_policies_entity
        else:
            _content = json.dumps(csm_publishing_access_policies_entity, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_scm_allowed_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CsmPublishingCredentialsPoliciesEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_auth_settings_v2_without_secrets(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Gets site's Authentication / Authorization settings for apps via the V2 format.

        Description for Gets site's Authentication / Authorization settings for apps via the V2 format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteAuthSettingsV2] = kwargs.pop("cls", None)

        _request = build_web_apps_get_auth_settings_v2_without_secrets_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteAuthSettingsV2, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_auth_settings_v2(
        self,
        resource_group_name: str,
        name: str,
        site_auth_settings_v2: _models.SiteAuthSettingsV2,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Updates site's Authentication / Authorization settings for apps via the V2 format.

        Description for Updates site's Authentication / Authorization settings for apps via the V2
        format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_auth_settings_v2: Auth settings associated with web app. Required.
        :type site_auth_settings_v2: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_auth_settings_v2(
        self,
        resource_group_name: str,
        name: str,
        site_auth_settings_v2: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Updates site's Authentication / Authorization settings for apps via the V2 format.

        Description for Updates site's Authentication / Authorization settings for apps via the V2
        format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_auth_settings_v2: Auth settings associated with web app. Required.
        :type site_auth_settings_v2: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_auth_settings_v2(
        self,
        resource_group_name: str,
        name: str,
        site_auth_settings_v2: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Updates site's Authentication / Authorization settings for apps via the V2 format.

        Description for Updates site's Authentication / Authorization settings for apps via the V2
        format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_auth_settings_v2: Auth settings associated with web app. Required.
        :type site_auth_settings_v2: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_auth_settings_v2(
        self,
        resource_group_name: str,
        name: str,
        site_auth_settings_v2: Union[_models.SiteAuthSettingsV2, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Updates site's Authentication / Authorization settings for apps via the V2 format.

        Description for Updates site's Authentication / Authorization settings for apps via the V2
        format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_auth_settings_v2: Auth settings associated with web app. Is one of the following
         types: SiteAuthSettingsV2, JSON, IO[bytes] Required.
        :type site_auth_settings_v2: ~azure.mgmt.web.models.SiteAuthSettingsV2 or JSON or IO[bytes]
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteAuthSettingsV2] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_auth_settings_v2, (IOBase, bytes)):
            _content = site_auth_settings_v2
        else:
            _content = json.dumps(site_auth_settings_v2, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_auth_settings_v2_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteAuthSettingsV2, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_auth_settings_v2(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Gets site's Authentication / Authorization settings for apps via the V2 format.

        Description for Gets site's Authentication / Authorization settings for apps via the V2 format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteAuthSettingsV2] = kwargs.pop("cls", None)

        _request = build_web_apps_get_auth_settings_v2_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteAuthSettingsV2, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_auth_settings_v2_without_secrets_slot(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Gets site's Authentication / Authorization settings for apps via the V2 format.

        Gets site's Authentication / Authorization settings for apps via the V2 format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         settings for the production slot. Required.
        :type slot: str
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteAuthSettingsV2] = kwargs.pop("cls", None)

        _request = build_web_apps_get_auth_settings_v2_without_secrets_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteAuthSettingsV2, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_auth_settings_v2_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_auth_settings_v2: _models.SiteAuthSettingsV2,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Updates site's Authentication / Authorization settings for apps via the V2 format.

        Description for Updates site's Authentication / Authorization settings for apps via the V2
        format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         settings for the production slot. Required.
        :type slot: str
        :param site_auth_settings_v2: Auth settings associated with web app. Required.
        :type site_auth_settings_v2: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_auth_settings_v2_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_auth_settings_v2: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Updates site's Authentication / Authorization settings for apps via the V2 format.

        Description for Updates site's Authentication / Authorization settings for apps via the V2
        format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         settings for the production slot. Required.
        :type slot: str
        :param site_auth_settings_v2: Auth settings associated with web app. Required.
        :type site_auth_settings_v2: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_auth_settings_v2_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_auth_settings_v2: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Updates site's Authentication / Authorization settings for apps via the V2 format.

        Description for Updates site's Authentication / Authorization settings for apps via the V2
        format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         settings for the production slot. Required.
        :type slot: str
        :param site_auth_settings_v2: Auth settings associated with web app. Required.
        :type site_auth_settings_v2: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_auth_settings_v2_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_auth_settings_v2: Union[_models.SiteAuthSettingsV2, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Updates site's Authentication / Authorization settings for apps via the V2 format.

        Description for Updates site's Authentication / Authorization settings for apps via the V2
        format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         settings for the production slot. Required.
        :type slot: str
        :param site_auth_settings_v2: Auth settings associated with web app. Is one of the following
         types: SiteAuthSettingsV2, JSON, IO[bytes] Required.
        :type site_auth_settings_v2: ~azure.mgmt.web.models.SiteAuthSettingsV2 or JSON or IO[bytes]
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteAuthSettingsV2] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_auth_settings_v2, (IOBase, bytes)):
            _content = site_auth_settings_v2
        else:
            _content = json.dumps(site_auth_settings_v2, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_auth_settings_v2_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteAuthSettingsV2, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_auth_settings_v2_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.SiteAuthSettingsV2:
        """Gets site's Authentication / Authorization settings for apps via the V2 format.

        Description for Gets site's Authentication / Authorization settings for apps via the V2 format.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         settings for the production slot. Required.
        :type slot: str
        :return: SiteAuthSettingsV2. The SiteAuthSettingsV2 is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteAuthSettingsV2
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteAuthSettingsV2] = kwargs.pop("cls", None)

        _request = build_web_apps_get_auth_settings_v2_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteAuthSettingsV2, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_app_setting_key_vault_reference(
        self, resource_group_name: str, name: str, app_setting_key: str, **kwargs: Any
    ) -> _models.ApiKVReference:
        """Gets the config reference and status of an app.

        Description for Gets the config reference and status of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param app_setting_key: App Setting key name. Required.
        :type app_setting_key: str
        :return: ApiKVReference. The ApiKVReference is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ApiKVReference
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ApiKVReference] = kwargs.pop("cls", None)

        _request = build_web_apps_get_app_setting_key_vault_reference_request(
            resource_group_name=resource_group_name,
            name=name,
            app_setting_key=app_setting_key,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ApiKVReference, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_app_settings_key_vault_references(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ApiKVReference"]:
        """Gets the config reference app settings and status of an app.

        Description for Gets the config reference app settings and status of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of ApiKVReference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ApiKVReference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ApiKVReference]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_get_app_settings_key_vault_references_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ApiKVReference], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_connection_string_key_vault_reference(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, connection_string_key: str, **kwargs: Any
    ) -> _models.ApiKVReference:
        """Gets the config reference and status of an app.

        Description for Gets the config reference and status of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_string_key: Required.
        :type connection_string_key: str
        :return: ApiKVReference. The ApiKVReference is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ApiKVReference
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ApiKVReference] = kwargs.pop("cls", None)

        _request = build_web_apps_get_site_connection_string_key_vault_reference_request(
            resource_group_name=resource_group_name,
            name=name,
            connection_string_key=connection_string_key,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ApiKVReference, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_site_connection_string_key_vault_references(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ApiKVReference"]:
        """Gets the config reference app settings and status of an app.

        Description for Gets the config reference app settings and status of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of ApiKVReference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ApiKVReference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ApiKVReference]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_get_site_connection_string_key_vault_references_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ApiKVReference], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_app_setting_key_vault_reference_slot(
        self, resource_group_name: str, name: str, app_setting_key: str, slot: str, **kwargs: Any
    ) -> _models.ApiKVReference:
        """Gets the config reference and status of an app.

        Description for Gets the config reference and status of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param app_setting_key: App Setting key name. Required.
        :type app_setting_key: str
        :param slot: Required.
        :type slot: str
        :return: ApiKVReference. The ApiKVReference is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ApiKVReference
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ApiKVReference] = kwargs.pop("cls", None)

        _request = build_web_apps_get_app_setting_key_vault_reference_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            app_setting_key=app_setting_key,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ApiKVReference, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_app_settings_key_vault_references_slot(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ApiKVReference"]:
        """Gets the config reference app settings and status of an app.

        Description for Gets the config reference app settings and status of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :return: An iterator like instance of ApiKVReference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ApiKVReference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ApiKVReference]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_get_app_settings_key_vault_references_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ApiKVReference], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_connection_string_key_vault_reference_slot(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, connection_string_key: str, slot: str, **kwargs: Any
    ) -> _models.ApiKVReference:
        """Gets the config reference and status of an app.

        Description for Gets the config reference and status of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_string_key: Required.
        :type connection_string_key: str
        :param slot: Required.
        :type slot: str
        :return: ApiKVReference. The ApiKVReference is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ApiKVReference
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ApiKVReference] = kwargs.pop("cls", None)

        _request = build_web_apps_get_site_connection_string_key_vault_reference_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            connection_string_key=connection_string_key,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ApiKVReference, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_site_connection_string_key_vault_references_slot(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ApiKVReference"]:
        """Gets the config reference app settings and status of an app.

        Description for Gets the config reference app settings and status of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Required.
        :type slot: str
        :return: An iterator like instance of ApiKVReference
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ApiKVReference]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ApiKVReference]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_get_site_connection_string_key_vault_references_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ApiKVReference], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_diagnostic_logs_configuration(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.SiteLogsConfig:
        """Gets the logging configuration of an app.

        Description for Gets the logging configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: SiteLogsConfig. The SiteLogsConfig is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteLogsConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteLogsConfig] = kwargs.pop("cls", None)

        _request = build_web_apps_get_diagnostic_logs_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteLogsConfig, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_diagnostic_logs_config(
        self,
        resource_group_name: str,
        name: str,
        site_logs_config: _models.SiteLogsConfig,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteLogsConfig:
        """Updates the logging configuration of an app.

        Description for Updates the logging configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_logs_config: A SiteLogsConfig JSON object that contains the logging configuration
         to change in the "properties"property. Required.
        :type site_logs_config: ~azure.mgmt.web.models.SiteLogsConfig
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteLogsConfig. The SiteLogsConfig is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteLogsConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_diagnostic_logs_config(
        self,
        resource_group_name: str,
        name: str,
        site_logs_config: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteLogsConfig:
        """Updates the logging configuration of an app.

        Description for Updates the logging configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_logs_config: A SiteLogsConfig JSON object that contains the logging configuration
         to change in the "properties"property. Required.
        :type site_logs_config: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteLogsConfig. The SiteLogsConfig is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteLogsConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_diagnostic_logs_config(
        self,
        resource_group_name: str,
        name: str,
        site_logs_config: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteLogsConfig:
        """Updates the logging configuration of an app.

        Description for Updates the logging configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_logs_config: A SiteLogsConfig JSON object that contains the logging configuration
         to change in the "properties"property. Required.
        :type site_logs_config: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteLogsConfig. The SiteLogsConfig is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteLogsConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_diagnostic_logs_config(
        self,
        resource_group_name: str,
        name: str,
        site_logs_config: Union[_models.SiteLogsConfig, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteLogsConfig:
        """Updates the logging configuration of an app.

        Description for Updates the logging configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_logs_config: A SiteLogsConfig JSON object that contains the logging configuration
         to change in the "properties"property. Is one of the following types: SiteLogsConfig, JSON,
         IO[bytes] Required.
        :type site_logs_config: ~azure.mgmt.web.models.SiteLogsConfig or JSON or IO[bytes]
        :return: SiteLogsConfig. The SiteLogsConfig is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteLogsConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteLogsConfig] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_logs_config, (IOBase, bytes)):
            _content = site_logs_config
        else:
            _content = json.dumps(site_logs_config, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_diagnostic_logs_config_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteLogsConfig, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_diagnostic_logs_configuration_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.SiteLogsConfig:
        """Gets the logging configuration of an app.

        Description for Gets the logging configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         logging configuration for the production slot. Required.
        :type slot: str
        :return: SiteLogsConfig. The SiteLogsConfig is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteLogsConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteLogsConfig] = kwargs.pop("cls", None)

        _request = build_web_apps_get_diagnostic_logs_configuration_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteLogsConfig, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_diagnostic_logs_config_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_logs_config: _models.SiteLogsConfig,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteLogsConfig:
        """Updates the logging configuration of an app.

        Description for Updates the logging configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         logging configuration for the production slot. Required.
        :type slot: str
        :param site_logs_config: A SiteLogsConfig JSON object that contains the logging configuration
         to change in the "properties"property. Required.
        :type site_logs_config: ~azure.mgmt.web.models.SiteLogsConfig
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteLogsConfig. The SiteLogsConfig is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteLogsConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_diagnostic_logs_config_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_logs_config: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteLogsConfig:
        """Updates the logging configuration of an app.

        Description for Updates the logging configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         logging configuration for the production slot. Required.
        :type slot: str
        :param site_logs_config: A SiteLogsConfig JSON object that contains the logging configuration
         to change in the "properties"property. Required.
        :type site_logs_config: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteLogsConfig. The SiteLogsConfig is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteLogsConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_diagnostic_logs_config_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_logs_config: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteLogsConfig:
        """Updates the logging configuration of an app.

        Description for Updates the logging configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         logging configuration for the production slot. Required.
        :type slot: str
        :param site_logs_config: A SiteLogsConfig JSON object that contains the logging configuration
         to change in the "properties"property. Required.
        :type site_logs_config: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteLogsConfig. The SiteLogsConfig is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteLogsConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_diagnostic_logs_config_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_logs_config: Union[_models.SiteLogsConfig, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteLogsConfig:
        """Updates the logging configuration of an app.

        Description for Updates the logging configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         logging configuration for the production slot. Required.
        :type slot: str
        :param site_logs_config: A SiteLogsConfig JSON object that contains the logging configuration
         to change in the "properties"property. Is one of the following types: SiteLogsConfig, JSON,
         IO[bytes] Required.
        :type site_logs_config: ~azure.mgmt.web.models.SiteLogsConfig or JSON or IO[bytes]
        :return: SiteLogsConfig. The SiteLogsConfig is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteLogsConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteLogsConfig] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_logs_config, (IOBase, bytes)):
            _content = site_logs_config
        else:
            _content = json.dumps(site_logs_config, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_diagnostic_logs_config_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteLogsConfig, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_slot_configuration_names(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.SlotConfigNamesResource:
        """Gets the names of app settings and connection strings that stick to the slot (not swapped).

        Description for Gets the names of app settings and connection strings that stick to the slot
        (not swapped).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: SlotConfigNamesResource. The SlotConfigNamesResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SlotConfigNamesResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SlotConfigNamesResource] = kwargs.pop("cls", None)

        _request = build_web_apps_list_slot_configuration_names_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SlotConfigNamesResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_slot_configuration_names(
        self,
        resource_group_name: str,
        name: str,
        slot_config_names: _models.SlotConfigNamesResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SlotConfigNamesResource:
        """Updates the names of application settings and connection string that remain with the slot
        during swap operation.

        Description for Updates the names of application settings and connection string that remain
        with the slot during swap operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_config_names: Names of application settings and connection strings. See example.
         Required.
        :type slot_config_names: ~azure.mgmt.web.models.SlotConfigNamesResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SlotConfigNamesResource. The SlotConfigNamesResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SlotConfigNamesResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_slot_configuration_names(
        self,
        resource_group_name: str,
        name: str,
        slot_config_names: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SlotConfigNamesResource:
        """Updates the names of application settings and connection string that remain with the slot
        during swap operation.

        Description for Updates the names of application settings and connection string that remain
        with the slot during swap operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_config_names: Names of application settings and connection strings. See example.
         Required.
        :type slot_config_names: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SlotConfigNamesResource. The SlotConfigNamesResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SlotConfigNamesResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_slot_configuration_names(
        self,
        resource_group_name: str,
        name: str,
        slot_config_names: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SlotConfigNamesResource:
        """Updates the names of application settings and connection string that remain with the slot
        during swap operation.

        Description for Updates the names of application settings and connection string that remain
        with the slot during swap operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_config_names: Names of application settings and connection strings. See example.
         Required.
        :type slot_config_names: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SlotConfigNamesResource. The SlotConfigNamesResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SlotConfigNamesResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_slot_configuration_names(
        self,
        resource_group_name: str,
        name: str,
        slot_config_names: Union[_models.SlotConfigNamesResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SlotConfigNamesResource:
        """Updates the names of application settings and connection string that remain with the slot
        during swap operation.

        Description for Updates the names of application settings and connection string that remain
        with the slot during swap operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot_config_names: Names of application settings and connection strings. See example. Is
         one of the following types: SlotConfigNamesResource, JSON, IO[bytes] Required.
        :type slot_config_names: ~azure.mgmt.web.models.SlotConfigNamesResource or JSON or IO[bytes]
        :return: SlotConfigNamesResource. The SlotConfigNamesResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SlotConfigNamesResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SlotConfigNamesResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(slot_config_names, (IOBase, bytes)):
            _content = slot_config_names
        else:
            _content = json.dumps(slot_config_names, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_slot_configuration_names_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SlotConfigNamesResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_configuration(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.SiteConfigResource:
        """Gets the configuration of an app, such as platform version and bitness, default documents,
        virtual applications, Always On, etc.

        Description for Gets the configuration of an app, such as platform version and bitness, default
        documents, virtual applications, Always On, etc.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteConfigResource] = kwargs.pop("cls", None)

        _request = build_web_apps_get_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteConfigResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_configuration(
        self,
        resource_group_name: str,
        name: str,
        site_config: _models.SiteConfigResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: ~azure.mgmt.web.models.SiteConfigResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_configuration(
        self,
        resource_group_name: str,
        name: str,
        site_config: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_configuration(
        self,
        resource_group_name: str,
        name: str,
        site_config: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_configuration(
        self,
        resource_group_name: str,
        name: str,
        site_config: Union[_models.SiteConfigResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_config: JSON representation of a SiteConfig object. See example. Is one of the
         following types: SiteConfigResource, JSON, IO[bytes] Required.
        :type site_config: ~azure.mgmt.web.models.SiteConfigResource or JSON or IO[bytes]
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteConfigResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_config, (IOBase, bytes)):
            _content = site_config
        else:
            _content = json.dumps(site_config, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteConfigResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_configuration(
        self,
        resource_group_name: str,
        name: str,
        site_config: _models.SiteConfigResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: ~azure.mgmt.web.models.SiteConfigResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_configuration(
        self,
        resource_group_name: str,
        name: str,
        site_config: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_configuration(
        self,
        resource_group_name: str,
        name: str,
        site_config: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_configuration(
        self,
        resource_group_name: str,
        name: str,
        site_config: Union[_models.SiteConfigResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_config: JSON representation of a SiteConfig object. See example. Is one of the
         following types: SiteConfigResource, JSON, IO[bytes] Required.
        :type site_config: ~azure.mgmt.web.models.SiteConfigResource or JSON or IO[bytes]
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteConfigResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_config, (IOBase, bytes)):
            _content = site_config
        else:
            _content = json.dumps(site_config, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_configuration_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteConfigResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_configuration_snapshot_info(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.SiteConfigurationSnapshotInfo"]:
        """Gets a list of web app configuration snapshots identifiers. Each element of the list contains a
        timestamp and the ID of the snapshot.

        Description for Gets a list of web app configuration snapshots identifiers. Each element of the
        list contains a timestamp and the ID of the snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of SiteConfigurationSnapshotInfo
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SiteConfigurationSnapshotInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SiteConfigurationSnapshotInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_configuration_snapshot_info_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SiteConfigurationSnapshotInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_configuration_snapshot(
        self, resource_group_name: str, name: str, snapshot_id: str, **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Gets a snapshot of the configuration of an app at a previous point in time.

        Description for Gets a snapshot of the configuration of an app at a previous point in time.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param snapshot_id: The ID of the snapshot to read. Required.
        :type snapshot_id: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteConfigResource] = kwargs.pop("cls", None)

        _request = build_web_apps_get_configuration_snapshot_request(
            resource_group_name=resource_group_name,
            name=name,
            snapshot_id=snapshot_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteConfigResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_configurations(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.SiteConfigResource"]:
        """List the configurations of an app.

        Description for List the configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of SiteConfigResource
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SiteConfigResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SiteConfigResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_configurations_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SiteConfigResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def recover_site_configuration_snapshot(
        self, resource_group_name: str, name: str, snapshot_id: str, **kwargs: Any
    ) -> None:
        """Reverts the configuration of an app to a previous snapshot.

        Description for Reverts the configuration of an app to a previous snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param snapshot_id: The ID of the snapshot to read. Required.
        :type snapshot_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_recover_site_configuration_snapshot_request(
            resource_group_name=resource_group_name,
            name=name,
            snapshot_id=snapshot_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_configuration_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Gets the configuration of an app, such as platform version and bitness, default documents,
        virtual applications, Always On, etc.

        Description for Gets the configuration of an app, such as platform version and bitness, default
        documents, virtual applications, Always On, etc.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteConfigResource] = kwargs.pop("cls", None)

        _request = build_web_apps_get_configuration_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteConfigResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_config: _models.SiteConfigResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: ~azure.mgmt.web.models.SiteConfigResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_config: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_config: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_config: Union[_models.SiteConfigResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :param site_config: JSON representation of a SiteConfig object. See example. Is one of the
         following types: SiteConfigResource, JSON, IO[bytes] Required.
        :type site_config: ~azure.mgmt.web.models.SiteConfigResource or JSON or IO[bytes]
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteConfigResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_config, (IOBase, bytes)):
            _content = site_config
        else:
            _content = json.dumps(site_config, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_configuration_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteConfigResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_config: _models.SiteConfigResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: ~azure.mgmt.web.models.SiteConfigResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_config: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_config: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :param site_config: JSON representation of a SiteConfig object. See example. Required.
        :type site_config: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_configuration_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_config: Union[_models.SiteConfigResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Updates the configuration of an app.

        Description for Updates the configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :param site_config: JSON representation of a SiteConfig object. See example. Is one of the
         following types: SiteConfigResource, JSON, IO[bytes] Required.
        :type site_config: ~azure.mgmt.web.models.SiteConfigResource or JSON or IO[bytes]
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteConfigResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_config, (IOBase, bytes)):
            _content = site_config
        else:
            _content = json.dumps(site_config, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_configuration_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteConfigResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_configuration_snapshot_info_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.SiteConfigurationSnapshotInfo"]:
        """Gets a list of web app configuration snapshots identifiers. Each element of the list contains a
        timestamp and the ID of the snapshot.

        Description for Gets a list of web app configuration snapshots identifiers. Each element of the
        list contains a timestamp and the ID of the snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of SiteConfigurationSnapshotInfo
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SiteConfigurationSnapshotInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SiteConfigurationSnapshotInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_configuration_snapshot_info_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SiteConfigurationSnapshotInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_configuration_snapshot_slot(
        self, resource_group_name: str, name: str, snapshot_id: str, slot: str, **kwargs: Any
    ) -> _models.SiteConfigResource:
        """Gets a snapshot of the configuration of an app at a previous point in time.

        Description for Gets a snapshot of the configuration of an app at a previous point in time.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param snapshot_id: The ID of the snapshot to read. Required.
        :type snapshot_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :return: SiteConfigResource. The SiteConfigResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteConfigResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteConfigResource] = kwargs.pop("cls", None)

        _request = build_web_apps_get_configuration_snapshot_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            snapshot_id=snapshot_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteConfigResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_configurations_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.SiteConfigResource"]:
        """List the configurations of an app.

        Description for List the configurations of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of SiteConfigResource
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SiteConfigResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SiteConfigResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_configurations_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SiteConfigResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def recover_site_configuration_snapshot_slot(
        self, resource_group_name: str, name: str, snapshot_id: str, slot: str, **kwargs: Any
    ) -> None:
        """Reverts the configuration of an app to a previous snapshot.

        Description for Reverts the configuration of an app to a previous snapshot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param snapshot_id: The ID of the snapshot to read. Required.
        :type snapshot_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will return
         configuration for the production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_recover_site_configuration_snapshot_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            snapshot_id=snapshot_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_continuous_web_job(
        self, resource_group_name: str, name: str, web_job_name: str, **kwargs: Any
    ) -> _models.ContinuousWebJob:
        """Gets a continuous web job by its ID for an app, or a deployment slot.

        Description for Gets a continuous web job by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :return: ContinuousWebJob. The ContinuousWebJob is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ContinuousWebJob
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ContinuousWebJob] = kwargs.pop("cls", None)

        _request = build_web_apps_get_continuous_web_job_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ContinuousWebJob, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_continuous_web_job(
        self, resource_group_name: str, name: str, web_job_name: str, **kwargs: Any
    ) -> None:
        """Delete a continuous web job by its ID for an app, or a deployment slot.

        Description for Delete a continuous web job by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_continuous_web_job_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_continuous_web_jobs(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ContinuousWebJob"]:
        """List continuous web jobs for an app, or a deployment slot.

        Description for List continuous web jobs for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :return: An iterator like instance of ContinuousWebJob
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ContinuousWebJob]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ContinuousWebJob]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_continuous_web_jobs_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ContinuousWebJob], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def start_continuous_web_job(
        self, resource_group_name: str, name: str, web_job_name: str, **kwargs: Any
    ) -> None:
        """Start a continuous web job for an app, or a deployment slot.

        Description for Start a continuous web job for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_start_continuous_web_job_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def stop_continuous_web_job(
        self, resource_group_name: str, name: str, web_job_name: str, **kwargs: Any
    ) -> None:
        """Stop a continuous web job for an app, or a deployment slot.

        Description for Stop a continuous web job for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_stop_continuous_web_job_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_continuous_web_job_slot(
        self, resource_group_name: str, name: str, web_job_name: str, slot: str, **kwargs: Any
    ) -> _models.ContinuousWebJob:
        """Gets a continuous web job by its ID for an app, or a deployment slot.

        Description for Gets a continuous web job by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API deletes a
         deployment for the production slot. Required.
        :type slot: str
        :return: ContinuousWebJob. The ContinuousWebJob is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ContinuousWebJob
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ContinuousWebJob] = kwargs.pop("cls", None)

        _request = build_web_apps_get_continuous_web_job_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ContinuousWebJob, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_continuous_web_job_slot(
        self, resource_group_name: str, name: str, web_job_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Delete a continuous web job by its ID for an app, or a deployment slot.

        Description for Delete a continuous web job by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API deletes a
         deployment for the production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_continuous_web_job_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_continuous_web_jobs_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ContinuousWebJob"]:
        """List continuous web jobs for an app, or a deployment slot.

        Description for List continuous web jobs for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API deletes a
         deployment for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of ContinuousWebJob
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ContinuousWebJob]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ContinuousWebJob]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_continuous_web_jobs_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ContinuousWebJob], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def start_continuous_web_job_slot(
        self, resource_group_name: str, name: str, web_job_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Start a continuous web job for an app, or a deployment slot.

        Description for Start a continuous web job for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API deletes a
         deployment for the production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_start_continuous_web_job_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def stop_continuous_web_job_slot(
        self, resource_group_name: str, name: str, web_job_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Stop a continuous web job for an app, or a deployment slot.

        Description for Stop a continuous web job for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API deletes a
         deployment for the production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_stop_continuous_web_job_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    async def _get_production_site_deployment_status_initial(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, deployment_status_id: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_production_site_deployment_status_request(
            resource_group_name=resource_group_name,
            name=name,
            deployment_status_id=deployment_status_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_get_production_site_deployment_status(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, deployment_status_id: str, **kwargs: Any
    ) -> AsyncLROPoller[_models.CsmDeploymentStatus]:
        """Gets the deployment status for an app (or deployment slot, if specified).

        Gets the deployment status for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param deployment_status_id: GUID of the deployment operation. Required.
        :type deployment_status_id: str
        :return: An instance of AsyncLROPoller that returns CsmDeploymentStatus. The
         CsmDeploymentStatus is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.CsmDeploymentStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CsmDeploymentStatus] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._get_production_site_deployment_status_initial(
                resource_group_name=resource_group_name,
                name=name,
                deployment_status_id=deployment_status_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.CsmDeploymentStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.CsmDeploymentStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.CsmDeploymentStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def list_production_site_deployment_statuses(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.CsmDeploymentStatus"]:
        """List deployment statuses for an app (or deployment slot, if specified).

        List deployment statuses for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of CsmDeploymentStatus
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.CsmDeploymentStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CsmDeploymentStatus]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_production_site_deployment_statuses_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CsmDeploymentStatus], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _get_slot_site_deployment_status_slot_initial(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, slot: str, deployment_status_id: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_slot_site_deployment_status_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            deployment_status_id=deployment_status_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_get_slot_site_deployment_status_slot(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, slot: str, deployment_status_id: str, **kwargs: Any
    ) -> AsyncLROPoller[_models.CsmDeploymentStatus]:
        """Gets the deployment status for an app (or deployment slot, if specified).

        Gets the deployment status for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         deployment status for the production slot. Required.
        :type slot: str
        :param deployment_status_id: GUID of the deployment operation. Required.
        :type deployment_status_id: str
        :return: An instance of AsyncLROPoller that returns CsmDeploymentStatus. The
         CsmDeploymentStatus is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.CsmDeploymentStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CsmDeploymentStatus] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._get_slot_site_deployment_status_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                deployment_status_id=deployment_status_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.CsmDeploymentStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.CsmDeploymentStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.CsmDeploymentStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def list_slot_site_deployment_statuses_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.CsmDeploymentStatus"]:
        """List deployment statuses for an app (or deployment slot, if specified).

        List deployment statuses for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         deployment status for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of CsmDeploymentStatus
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.CsmDeploymentStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CsmDeploymentStatus]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_slot_site_deployment_statuses_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CsmDeploymentStatus], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_deployment(self, resource_group_name: str, name: str, id: str, **kwargs: Any) -> _models.Deployment:
        """Get a deployment by its ID for an app, or a deployment slot.

        Description for Get a deployment by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Deployment] = kwargs.pop("cls", None)

        _request = build_web_apps_get_deployment_request(
            resource_group_name=resource_group_name,
            name=name,
            id=id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Deployment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_deployment(
        self,
        resource_group_name: str,
        name: str,
        id: str,
        deployment: _models.Deployment,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Deployment:
        """Create a deployment for an app, or a deployment slot.

        Description for Create a deployment for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :param deployment: Deployment details. Required.
        :type deployment: ~azure.mgmt.web.models.Deployment
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_deployment(
        self,
        resource_group_name: str,
        name: str,
        id: str,
        deployment: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Deployment:
        """Create a deployment for an app, or a deployment slot.

        Description for Create a deployment for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :param deployment: Deployment details. Required.
        :type deployment: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_deployment(
        self,
        resource_group_name: str,
        name: str,
        id: str,
        deployment: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Deployment:
        """Create a deployment for an app, or a deployment slot.

        Description for Create a deployment for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :param deployment: Deployment details. Required.
        :type deployment: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_deployment(
        self,
        resource_group_name: str,
        name: str,
        id: str,
        deployment: Union[_models.Deployment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Deployment:
        """Create a deployment for an app, or a deployment slot.

        Description for Create a deployment for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :param deployment: Deployment details. Is one of the following types: Deployment, JSON,
         IO[bytes] Required.
        :type deployment: ~azure.mgmt.web.models.Deployment or JSON or IO[bytes]
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Deployment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(deployment, (IOBase, bytes)):
            _content = deployment
        else:
            _content = json.dumps(deployment, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_deployment_request(
            resource_group_name=resource_group_name,
            name=name,
            id=id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Deployment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_deployment(self, resource_group_name: str, name: str, id: str, **kwargs: Any) -> None:
        """Delete a deployment by its ID for an app, or a deployment slot.

        Description for Delete a deployment by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_deployment_request(
            resource_group_name=resource_group_name,
            name=name,
            id=id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_deployments(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.Deployment"]:
        """List deployments for an app, or a deployment slot.

        Description for List deployments for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of Deployment
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Deployment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Deployment]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_deployments_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Deployment], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_deployment_log(
        self, resource_group_name: str, name: str, id: str, **kwargs: Any
    ) -> _models.Deployment:
        """List deployment log for specific deployment for an app, or a deployment slot.

        Description for List deployment log for specific deployment for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Deployment] = kwargs.pop("cls", None)

        _request = build_web_apps_list_deployment_log_request(
            resource_group_name=resource_group_name,
            name=name,
            id=id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Deployment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_deployment_slot(
        self, resource_group_name: str, name: str, id: str, slot: str, **kwargs: Any
    ) -> _models.Deployment:
        """Get a deployment by its ID for an app, or a deployment slot.

        Description for Get a deployment by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API gets a deployment
         for the production slot. Required.
        :type slot: str
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Deployment] = kwargs.pop("cls", None)

        _request = build_web_apps_get_deployment_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            id=id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Deployment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_deployment_slot(
        self,
        resource_group_name: str,
        name: str,
        id: str,
        slot: str,
        deployment: _models.Deployment,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Deployment:
        """Create a deployment for an app, or a deployment slot.

        Description for Create a deployment for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API gets a deployment
         for the production slot. Required.
        :type slot: str
        :param deployment: Deployment details. Required.
        :type deployment: ~azure.mgmt.web.models.Deployment
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_deployment_slot(
        self,
        resource_group_name: str,
        name: str,
        id: str,
        slot: str,
        deployment: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Deployment:
        """Create a deployment for an app, or a deployment slot.

        Description for Create a deployment for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API gets a deployment
         for the production slot. Required.
        :type slot: str
        :param deployment: Deployment details. Required.
        :type deployment: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_deployment_slot(
        self,
        resource_group_name: str,
        name: str,
        id: str,
        slot: str,
        deployment: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Deployment:
        """Create a deployment for an app, or a deployment slot.

        Description for Create a deployment for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API gets a deployment
         for the production slot. Required.
        :type slot: str
        :param deployment: Deployment details. Required.
        :type deployment: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_deployment_slot(
        self,
        resource_group_name: str,
        name: str,
        id: str,
        slot: str,
        deployment: Union[_models.Deployment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Deployment:
        """Create a deployment for an app, or a deployment slot.

        Description for Create a deployment for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API gets a deployment
         for the production slot. Required.
        :type slot: str
        :param deployment: Deployment details. Is one of the following types: Deployment, JSON,
         IO[bytes] Required.
        :type deployment: ~azure.mgmt.web.models.Deployment or JSON or IO[bytes]
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Deployment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(deployment, (IOBase, bytes)):
            _content = deployment
        else:
            _content = json.dumps(deployment, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_deployment_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            id=id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Deployment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_deployment_slot(
        self, resource_group_name: str, name: str, id: str, slot: str, **kwargs: Any
    ) -> None:
        """Delete a deployment by its ID for an app, or a deployment slot.

        Description for Delete a deployment by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API gets a deployment
         for the production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_deployment_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            id=id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_deployments_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.Deployment"]:
        """List deployments for an app, or a deployment slot.

        Description for List deployments for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API gets a deployment
         for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of Deployment
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Deployment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Deployment]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_deployments_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Deployment], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_deployment_log_slot(
        self, resource_group_name: str, name: str, id: str, slot: str, **kwargs: Any
    ) -> _models.Deployment:
        """List deployment log for specific deployment for an app, or a deployment slot.

        Description for List deployment log for specific deployment for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param id: Deployment ID. Required.
        :type id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API gets a deployment
         for the production slot. Required.
        :type slot: str
        :return: Deployment. The Deployment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Deployment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Deployment] = kwargs.pop("cls", None)

        _request = build_web_apps_list_deployment_log_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            id=id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Deployment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_domain_ownership_identifier(
        self, resource_group_name: str, name: str, domain_ownership_identifier_name: str, **kwargs: Any
    ) -> _models.Identifier:
        """Get domain ownership identifier for web app.

        Description for Get domain ownership identifier for web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Identifier] = kwargs.pop("cls", None)

        _request = build_web_apps_get_domain_ownership_identifier_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_ownership_identifier_name=domain_ownership_identifier_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Identifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_domain_ownership_identifier(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        domain_ownership_identifier: _models.Identifier,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: ~azure.mgmt.web.models.Identifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_domain_ownership_identifier(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        domain_ownership_identifier: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_domain_ownership_identifier(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        domain_ownership_identifier: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_domain_ownership_identifier(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        domain_ownership_identifier: Union[_models.Identifier, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Is one of the following types: Identifier, JSON, IO[bytes] Required.
        :type domain_ownership_identifier: ~azure.mgmt.web.models.Identifier or JSON or IO[bytes]
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Identifier] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(domain_ownership_identifier, (IOBase, bytes)):
            _content = domain_ownership_identifier
        else:
            _content = json.dumps(domain_ownership_identifier, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_domain_ownership_identifier_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_ownership_identifier_name=domain_ownership_identifier_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Identifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_domain_ownership_identifier(
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        domain_ownership_identifier: _models.Identifier,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: ~azure.mgmt.web.models.Identifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_domain_ownership_identifier(
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        domain_ownership_identifier: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_domain_ownership_identifier(
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        domain_ownership_identifier: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_domain_ownership_identifier(
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        domain_ownership_identifier: Union[_models.Identifier, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Is one of the following types: Identifier, JSON, IO[bytes] Required.
        :type domain_ownership_identifier: ~azure.mgmt.web.models.Identifier or JSON or IO[bytes]
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Identifier] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(domain_ownership_identifier, (IOBase, bytes)):
            _content = domain_ownership_identifier
        else:
            _content = json.dumps(domain_ownership_identifier, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_domain_ownership_identifier_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_ownership_identifier_name=domain_ownership_identifier_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Identifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_domain_ownership_identifier(
        self, resource_group_name: str, name: str, domain_ownership_identifier_name: str, **kwargs: Any
    ) -> None:
        """Deletes a domain ownership identifier for a web app.

        Description for Deletes a domain ownership identifier for a web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_domain_ownership_identifier_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_ownership_identifier_name=domain_ownership_identifier_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_domain_ownership_identifiers(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.Identifier"]:
        """Lists ownership identifiers for domain associated with web app.

        Description for Lists ownership identifiers for domain associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of Identifier
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Identifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Identifier]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_domain_ownership_identifiers_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Identifier], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_domain_ownership_identifier_slot(
        self, resource_group_name: str, name: str, domain_ownership_identifier_name: str, slot: str, **kwargs: Any
    ) -> _models.Identifier:
        """Get domain ownership identifier for web app.

        Description for Get domain ownership identifier for web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will delete the
         binding for the production slot. Required.
        :type slot: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Identifier] = kwargs.pop("cls", None)

        _request = build_web_apps_get_domain_ownership_identifier_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_ownership_identifier_name=domain_ownership_identifier_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Identifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_domain_ownership_identifier_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        slot: str,
        domain_ownership_identifier: _models.Identifier,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will delete the
         binding for the production slot. Required.
        :type slot: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: ~azure.mgmt.web.models.Identifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_domain_ownership_identifier_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        slot: str,
        domain_ownership_identifier: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will delete the
         binding for the production slot. Required.
        :type slot: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_domain_ownership_identifier_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        slot: str,
        domain_ownership_identifier: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will delete the
         binding for the production slot. Required.
        :type slot: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_domain_ownership_identifier_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        slot: str,
        domain_ownership_identifier: Union[_models.Identifier, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will delete the
         binding for the production slot. Required.
        :type slot: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Is one of the following types: Identifier, JSON, IO[bytes] Required.
        :type domain_ownership_identifier: ~azure.mgmt.web.models.Identifier or JSON or IO[bytes]
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Identifier] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(domain_ownership_identifier, (IOBase, bytes)):
            _content = domain_ownership_identifier
        else:
            _content = json.dumps(domain_ownership_identifier, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_domain_ownership_identifier_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_ownership_identifier_name=domain_ownership_identifier_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Identifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_domain_ownership_identifier_slot(
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        slot: str,
        domain_ownership_identifier: _models.Identifier,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will delete the
         binding for the production slot. Required.
        :type slot: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: ~azure.mgmt.web.models.Identifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_domain_ownership_identifier_slot(
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        slot: str,
        domain_ownership_identifier: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will delete the
         binding for the production slot. Required.
        :type slot: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_domain_ownership_identifier_slot(
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        slot: str,
        domain_ownership_identifier: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will delete the
         binding for the production slot. Required.
        :type slot: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_domain_ownership_identifier_slot(
        self,
        resource_group_name: str,
        name: str,
        domain_ownership_identifier_name: str,
        slot: str,
        domain_ownership_identifier: Union[_models.Identifier, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Identifier:
        """Creates a domain ownership identifier for web app, or updates an existing ownership identifier.

        Description for Creates a domain ownership identifier for web app, or updates an existing
        ownership identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will delete the
         binding for the production slot. Required.
        :type slot: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Is one of the following types: Identifier, JSON, IO[bytes] Required.
        :type domain_ownership_identifier: ~azure.mgmt.web.models.Identifier or JSON or IO[bytes]
        :return: Identifier. The Identifier is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Identifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Identifier] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(domain_ownership_identifier, (IOBase, bytes)):
            _content = domain_ownership_identifier
        else:
            _content = json.dumps(domain_ownership_identifier, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_domain_ownership_identifier_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_ownership_identifier_name=domain_ownership_identifier_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Identifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_domain_ownership_identifier_slot(
        self, resource_group_name: str, name: str, domain_ownership_identifier_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Deletes a domain ownership identifier for a web app.

        Description for Deletes a domain ownership identifier for a web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param domain_ownership_identifier_name: Name of domain ownership identifier. Required.
        :type domain_ownership_identifier_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will delete the
         binding for the production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_domain_ownership_identifier_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            domain_ownership_identifier_name=domain_ownership_identifier_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_domain_ownership_identifiers_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.Identifier"]:
        """Lists ownership identifiers for domain associated with web app.

        Description for Lists ownership identifiers for domain associated with web app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will delete the
         binding for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of Identifier
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Identifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Identifier]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_domain_ownership_identifiers_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Identifier], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_ms_deploy_status(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.MSDeployStatus:
        """Get the status of the last MSDeploy operation.

        Description for Get the status of the last MSDeploy operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :return: MSDeployStatus. The MSDeployStatus is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.MSDeployStatus
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MSDeployStatus] = kwargs.pop("cls", None)

        _request = build_web_apps_get_ms_deploy_status_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MSDeployStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_ms_deploy_operation_initial(
        self, resource_group_name: str, name: str, ms_deploy: Union[_models.MSDeploy, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(ms_deploy, (IOBase, bytes)):
            _content = ms_deploy
        else:
            _content = json.dumps(ms_deploy, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_ms_deploy_operation_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_ms_deploy_operation(
        self,
        resource_group_name: str,
        name: str,
        ms_deploy: _models.MSDeploy,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: ~azure.mgmt.web.models.MSDeploy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_ms_deploy_operation(
        self,
        resource_group_name: str,
        name: str,
        ms_deploy: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_ms_deploy_operation(
        self,
        resource_group_name: str,
        name: str,
        ms_deploy: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_ms_deploy_operation(
        self, resource_group_name: str, name: str, ms_deploy: Union[_models.MSDeploy, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param ms_deploy: Details of MSDeploy operation. Is one of the following types: MSDeploy, JSON,
         IO[bytes] Required.
        :type ms_deploy: ~azure.mgmt.web.models.MSDeploy or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MSDeployStatus] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_ms_deploy_operation_initial(
                resource_group_name=resource_group_name,
                name=name,
                ms_deploy=ms_deploy,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(_models.MSDeployStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.MSDeployStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.MSDeployStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def get_ms_deploy_log(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.MSDeployLog:
        """Get the MSDeploy Log for the last MSDeploy operation.

        Description for Get the MSDeploy Log for the last MSDeploy operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :return: MSDeployLog. The MSDeployLog is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.MSDeployLog
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MSDeployLog] = kwargs.pop("cls", None)

        _request = build_web_apps_get_ms_deploy_log_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MSDeployLog, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_instance_ms_deploy_status(
        self, resource_group_name: str, name: str, instance_id: str, **kwargs: Any
    ) -> _models.MSDeployStatus:
        """Get the status of the last MSDeploy operation.

        Description for Get the status of the last MSDeploy operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :return: MSDeployStatus. The MSDeployStatus is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.MSDeployStatus
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MSDeployStatus] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_ms_deploy_status_request(
            resource_group_name=resource_group_name,
            name=name,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MSDeployStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_instance_ms_deploy_operation_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        instance_id: str,
        ms_deploy: Union[_models.MSDeploy, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(ms_deploy, (IOBase, bytes)):
            _content = ms_deploy
        else:
            _content = json.dumps(ms_deploy, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_instance_ms_deploy_operation_request(
            resource_group_name=resource_group_name,
            name=name,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_instance_ms_deploy_operation(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        instance_id: str,
        ms_deploy: _models.MSDeploy,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: ~azure.mgmt.web.models.MSDeploy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_instance_ms_deploy_operation(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        instance_id: str,
        ms_deploy: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_instance_ms_deploy_operation(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        instance_id: str,
        ms_deploy: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_instance_ms_deploy_operation(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        instance_id: str,
        ms_deploy: Union[_models.MSDeploy, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :param ms_deploy: Details of MSDeploy operation. Is one of the following types: MSDeploy, JSON,
         IO[bytes] Required.
        :type ms_deploy: ~azure.mgmt.web.models.MSDeploy or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MSDeployStatus] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_instance_ms_deploy_operation_initial(
                resource_group_name=resource_group_name,
                name=name,
                instance_id=instance_id,
                ms_deploy=ms_deploy,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(_models.MSDeployStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.MSDeployStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.MSDeployStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def get_instance_ms_deploy_log(
        self, resource_group_name: str, name: str, instance_id: str, **kwargs: Any
    ) -> _models.MSDeployLog:
        """Get the MSDeploy Log for the last MSDeploy operation.

        Description for Get the MSDeploy Log for the last MSDeploy operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :return: MSDeployLog. The MSDeployLog is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.MSDeployLog
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MSDeployLog] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_ms_deploy_log_request(
            resource_group_name=resource_group_name,
            name=name,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MSDeployLog, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_ms_deploy_status_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.MSDeployStatus:
        """Get the status of the last MSDeploy operation.

        Description for Get the status of the last MSDeploy operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :return: MSDeployStatus. The MSDeployStatus is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.MSDeployStatus
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MSDeployStatus] = kwargs.pop("cls", None)

        _request = build_web_apps_get_ms_deploy_status_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MSDeployStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_ms_deploy_operation_slot_initial(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        ms_deploy: Union[_models.MSDeploy, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(ms_deploy, (IOBase, bytes)):
            _content = ms_deploy
        else:
            _content = json.dumps(ms_deploy, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_ms_deploy_operation_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_ms_deploy_operation_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        ms_deploy: _models.MSDeploy,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: ~azure.mgmt.web.models.MSDeploy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_ms_deploy_operation_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        ms_deploy: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_ms_deploy_operation_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        ms_deploy: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_ms_deploy_operation_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        ms_deploy: Union[_models.MSDeploy, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :param ms_deploy: Details of MSDeploy operation. Is one of the following types: MSDeploy, JSON,
         IO[bytes] Required.
        :type ms_deploy: ~azure.mgmt.web.models.MSDeploy or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MSDeployStatus] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_ms_deploy_operation_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                ms_deploy=ms_deploy,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(_models.MSDeployStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.MSDeployStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.MSDeployStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def get_ms_deploy_log_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.MSDeployLog:
        """Get the MSDeploy Log for the last MSDeploy operation.

        Description for Get the MSDeploy Log for the last MSDeploy operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :return: MSDeployLog. The MSDeployLog is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.MSDeployLog
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MSDeployLog] = kwargs.pop("cls", None)

        _request = build_web_apps_get_ms_deploy_log_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MSDeployLog, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_instance_ms_deploy_status_slot(
        self, resource_group_name: str, name: str, slot: str, instance_id: str, **kwargs: Any
    ) -> _models.MSDeployStatus:
        """Get the status of the last MSDeploy operation.

        Description for Get the status of the last MSDeploy operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :return: MSDeployStatus. The MSDeployStatus is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.MSDeployStatus
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MSDeployStatus] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_ms_deploy_status_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MSDeployStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_instance_ms_deploy_operation_slot_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        instance_id: str,
        ms_deploy: Union[_models.MSDeploy, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(ms_deploy, (IOBase, bytes)):
            _content = ms_deploy
        else:
            _content = json.dumps(ms_deploy, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_instance_ms_deploy_operation_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_instance_ms_deploy_operation_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        instance_id: str,
        ms_deploy: _models.MSDeploy,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: ~azure.mgmt.web.models.MSDeploy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_instance_ms_deploy_operation_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        instance_id: str,
        ms_deploy: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_instance_ms_deploy_operation_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        instance_id: str,
        ms_deploy: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :param ms_deploy: Details of MSDeploy operation. Required.
        :type ms_deploy: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_instance_ms_deploy_operation_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        instance_id: str,
        ms_deploy: Union[_models.MSDeploy, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.MSDeployStatus]:
        """Invoke the MSDeploy web app extension.

        Description for Invoke the MSDeploy web app extension.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :param ms_deploy: Details of MSDeploy operation. Is one of the following types: MSDeploy, JSON,
         IO[bytes] Required.
        :type ms_deploy: ~azure.mgmt.web.models.MSDeploy or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns MSDeployStatus. The MSDeployStatus is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.MSDeployStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MSDeployStatus] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_instance_ms_deploy_operation_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                instance_id=instance_id,
                ms_deploy=ms_deploy,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(_models.MSDeployStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.MSDeployStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.MSDeployStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def get_instance_ms_deploy_log_slot(
        self, resource_group_name: str, name: str, slot: str, instance_id: str, **kwargs: Any
    ) -> _models.MSDeployLog:
        """Get the MSDeploy Log for the last MSDeploy operation.

        Description for Get the MSDeploy Log for the last MSDeploy operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :param instance_id: ID of web app instance. Required.
        :type instance_id: str
        :return: MSDeployLog. The MSDeployLog is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.MSDeployLog
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MSDeployLog] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_ms_deploy_log_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MSDeployLog, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_function(
        self, resource_group_name: str, name: str, function_name: str, **kwargs: Any
    ) -> _models.FunctionEnvelope:
        """Get function information by its ID for web site, or a deployment slot.

        Description for Get function information by its ID for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :return: FunctionEnvelope. The FunctionEnvelope is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.FunctionEnvelope
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FunctionEnvelope] = kwargs.pop("cls", None)

        _request = build_web_apps_get_function_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FunctionEnvelope, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_function_initial(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        function_envelope: Union[_models.FunctionEnvelope, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(function_envelope, (IOBase, bytes)):
            _content = function_envelope
        else:
            _content = json.dumps(function_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_function_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_function(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        function_envelope: _models.FunctionEnvelope,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.FunctionEnvelope]:
        """Create function for web site, or a deployment slot.

        Description for Create function for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :param function_envelope: Function details. Required.
        :type function_envelope: ~azure.mgmt.web.models.FunctionEnvelope
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns FunctionEnvelope. The FunctionEnvelope is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.FunctionEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_function(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        function_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.FunctionEnvelope]:
        """Create function for web site, or a deployment slot.

        Description for Create function for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :param function_envelope: Function details. Required.
        :type function_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns FunctionEnvelope. The FunctionEnvelope is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.FunctionEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_function(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        function_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.FunctionEnvelope]:
        """Create function for web site, or a deployment slot.

        Description for Create function for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :param function_envelope: Function details. Required.
        :type function_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns FunctionEnvelope. The FunctionEnvelope is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.FunctionEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_function(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        function_envelope: Union[_models.FunctionEnvelope, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.FunctionEnvelope]:
        """Create function for web site, or a deployment slot.

        Description for Create function for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :param function_envelope: Function details. Is one of the following types: FunctionEnvelope,
         JSON, IO[bytes] Required.
        :type function_envelope: ~azure.mgmt.web.models.FunctionEnvelope or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns FunctionEnvelope. The FunctionEnvelope is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.FunctionEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FunctionEnvelope] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_function_initial(
                resource_group_name=resource_group_name,
                name=name,
                function_name=function_name,
                function_envelope=function_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(_models.FunctionEnvelope, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.FunctionEnvelope].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.FunctionEnvelope](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def delete_function(self, resource_group_name: str, name: str, function_name: str, **kwargs: Any) -> None:
        """Delete a function for web site, or a deployment slot.

        Description for Delete a function for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_function_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_functions(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.FunctionEnvelope"]:
        """List the functions for a web site, or a deployment slot.

        Description for List the functions for a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :return: An iterator like instance of FunctionEnvelope
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.FunctionEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.FunctionEnvelope]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_functions_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.FunctionEnvelope], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def create_or_update_function_secret(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        key_name: str,
        key: _models.KeyInfo,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a function secret.

        Description for Add or update a function secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param function_name: Required.
        :type function_name: str
        :param key_name: Required.
        :type key_name: str
        :param key: The key to create or update. Required.
        :type key: ~azure.mgmt.web.models.KeyInfo
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_function_secret(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        key_name: str,
        key: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a function secret.

        Description for Add or update a function secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param function_name: Required.
        :type function_name: str
        :param key_name: Required.
        :type key_name: str
        :param key: The key to create or update. Required.
        :type key: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_function_secret(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        key_name: str,
        key: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a function secret.

        Description for Add or update a function secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param function_name: Required.
        :type function_name: str
        :param key_name: Required.
        :type key_name: str
        :param key: The key to create or update. Required.
        :type key: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_function_secret(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        key_name: str,
        key: Union[_models.KeyInfo, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a function secret.

        Description for Add or update a function secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param function_name: Required.
        :type function_name: str
        :param key_name: Required.
        :type key_name: str
        :param key: The key to create or update. Is one of the following types: KeyInfo, JSON,
         IO[bytes] Required.
        :type key: ~azure.mgmt.web.models.KeyInfo or JSON or IO[bytes]
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.KeyInfo] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(key, (IOBase, bytes)):
            _content = key
        else:
            _content = json.dumps(key, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_function_secret_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            key_name=key_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.KeyInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_function_secret(
        self, resource_group_name: str, name: str, function_name: str, key_name: str, **kwargs: Any
    ) -> None:
        """Delete a function secret.

        Description for Delete a function secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param function_name: Required.
        :type function_name: str
        :param key_name: Required.
        :type key_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_function_secret_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            key_name=key_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_function_keys(
        self, resource_group_name: str, name: str, function_name: str, **kwargs: Any
    ) -> _models.StringDictionary:
        """Get function keys for a function in a web site, or a deployment slot.

        Description for Get function keys for a function in a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        _request = build_web_apps_list_function_keys_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_function_secrets(
        self, resource_group_name: str, name: str, function_name: str, **kwargs: Any
    ) -> _models.FunctionSecrets:
        """Get function secrets for a function in a web site, or a deployment slot.

        Description for Get function secrets for a function in a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :return: FunctionSecrets. The FunctionSecrets is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.FunctionSecrets
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FunctionSecrets] = kwargs.pop("cls", None)

        _request = build_web_apps_list_function_secrets_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FunctionSecrets, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_instance_function_slot(
        self, resource_group_name: str, name: str, function_name: str, slot: str, **kwargs: Any
    ) -> _models.FunctionEnvelope:
        """Get function information by its ID for web site, or a deployment slot.

        Description for Get function information by its ID for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :param slot: Name of the deployment slot. Required.
        :type slot: str
        :return: FunctionEnvelope. The FunctionEnvelope is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.FunctionEnvelope
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FunctionEnvelope] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_function_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FunctionEnvelope, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_instance_function_slot_initial(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        slot: str,
        function_envelope: Union[_models.FunctionEnvelope, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(function_envelope, (IOBase, bytes)):
            _content = function_envelope
        else:
            _content = json.dumps(function_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_instance_function_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_instance_function_slot(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        slot: str,
        function_envelope: _models.FunctionEnvelope,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.FunctionEnvelope]:
        """Create function for web site, or a deployment slot.

        Description for Create function for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :param slot: Name of the deployment slot. Required.
        :type slot: str
        :param function_envelope: Function details. Required.
        :type function_envelope: ~azure.mgmt.web.models.FunctionEnvelope
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns FunctionEnvelope. The FunctionEnvelope is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.FunctionEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_instance_function_slot(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        slot: str,
        function_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.FunctionEnvelope]:
        """Create function for web site, or a deployment slot.

        Description for Create function for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :param slot: Name of the deployment slot. Required.
        :type slot: str
        :param function_envelope: Function details. Required.
        :type function_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns FunctionEnvelope. The FunctionEnvelope is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.FunctionEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_instance_function_slot(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        slot: str,
        function_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.FunctionEnvelope]:
        """Create function for web site, or a deployment slot.

        Description for Create function for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :param slot: Name of the deployment slot. Required.
        :type slot: str
        :param function_envelope: Function details. Required.
        :type function_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns FunctionEnvelope. The FunctionEnvelope is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.FunctionEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_instance_function_slot(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        slot: str,
        function_envelope: Union[_models.FunctionEnvelope, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.FunctionEnvelope]:
        """Create function for web site, or a deployment slot.

        Description for Create function for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :param slot: Name of the deployment slot. Required.
        :type slot: str
        :param function_envelope: Function details. Is one of the following types: FunctionEnvelope,
         JSON, IO[bytes] Required.
        :type function_envelope: ~azure.mgmt.web.models.FunctionEnvelope or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns FunctionEnvelope. The FunctionEnvelope is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.FunctionEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FunctionEnvelope] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_instance_function_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                function_name=function_name,
                slot=slot,
                function_envelope=function_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(_models.FunctionEnvelope, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.FunctionEnvelope].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.FunctionEnvelope](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def delete_instance_function_slot(
        self, resource_group_name: str, name: str, function_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Delete a function for web site, or a deployment slot.

        Description for Delete a function for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :param slot: Name of the deployment slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_instance_function_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_instance_functions_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.FunctionEnvelope"]:
        """List the functions for a web site, or a deployment slot.

        Description for List the functions for a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param slot: Name of the deployment slot. Required.
        :type slot: str
        :return: An iterator like instance of FunctionEnvelope
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.FunctionEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.FunctionEnvelope]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_instance_functions_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.FunctionEnvelope], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def create_or_update_function_secret_slot(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        key_name: str,
        slot: str,
        key: _models.KeyInfo,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a function secret.

        Description for Add or update a function secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param function_name: Required.
        :type function_name: str
        :param key_name: Required.
        :type key_name: str
        :param slot: Required.
        :type slot: str
        :param key: The key to create or update. Required.
        :type key: ~azure.mgmt.web.models.KeyInfo
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_function_secret_slot(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        key_name: str,
        slot: str,
        key: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a function secret.

        Description for Add or update a function secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param function_name: Required.
        :type function_name: str
        :param key_name: Required.
        :type key_name: str
        :param slot: Required.
        :type slot: str
        :param key: The key to create or update. Required.
        :type key: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_function_secret_slot(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        key_name: str,
        slot: str,
        key: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a function secret.

        Description for Add or update a function secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param function_name: Required.
        :type function_name: str
        :param key_name: Required.
        :type key_name: str
        :param slot: Required.
        :type slot: str
        :param key: The key to create or update. Required.
        :type key: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_function_secret_slot(
        self,
        resource_group_name: str,
        name: str,
        function_name: str,
        key_name: str,
        slot: str,
        key: Union[_models.KeyInfo, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.KeyInfo:
        """Add or update a function secret.

        Description for Add or update a function secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param function_name: Required.
        :type function_name: str
        :param key_name: Required.
        :type key_name: str
        :param slot: Required.
        :type slot: str
        :param key: The key to create or update. Is one of the following types: KeyInfo, JSON,
         IO[bytes] Required.
        :type key: ~azure.mgmt.web.models.KeyInfo or JSON or IO[bytes]
        :return: KeyInfo. The KeyInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KeyInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.KeyInfo] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(key, (IOBase, bytes)):
            _content = key
        else:
            _content = json.dumps(key, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_function_secret_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            key_name=key_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.KeyInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_function_secret_slot(
        self, resource_group_name: str, name: str, function_name: str, key_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Delete a function secret.

        Description for Delete a function secret.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param function_name: Required.
        :type function_name: str
        :param key_name: Required.
        :type key_name: str
        :param slot: Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_function_secret_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            key_name=key_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_function_keys_slot(
        self, resource_group_name: str, name: str, function_name: str, slot: str, **kwargs: Any
    ) -> _models.StringDictionary:
        """Get function keys for a function in a web site, or a deployment slot.

        Description for Get function keys for a function in a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Required.
        :type name: str
        :param function_name: Required.
        :type function_name: str
        :param slot: Required.
        :type slot: str
        :return: StringDictionary. The StringDictionary is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.StringDictionary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StringDictionary] = kwargs.pop("cls", None)

        _request = build_web_apps_list_function_keys_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StringDictionary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_function_secrets_slot(
        self, resource_group_name: str, name: str, function_name: str, slot: str, **kwargs: Any
    ) -> _models.FunctionSecrets:
        """Get function secrets for a function in a web site, or a deployment slot.

        Description for Get function secrets for a function in a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param function_name: Function name. Required.
        :type function_name: str
        :param slot: Name of the deployment slot. Required.
        :type slot: str
        :return: FunctionSecrets. The FunctionSecrets is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.FunctionSecrets
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FunctionSecrets] = kwargs.pop("cls", None)

        _request = build_web_apps_list_function_secrets_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            function_name=function_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FunctionSecrets, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_host_name_binding(
        self, resource_group_name: str, name: str, host_name: str, **kwargs: Any
    ) -> _models.HostNameBinding:
        """Get the named hostname binding for an app (or deployment slot, if specified).

        Description for Get the named hostname binding for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :return: HostNameBinding. The HostNameBinding is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostNameBinding
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HostNameBinding] = kwargs.pop("cls", None)

        _request = build_web_apps_get_host_name_binding_request(
            resource_group_name=resource_group_name,
            name=name,
            host_name=host_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HostNameBinding, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_host_name_binding(
        self,
        resource_group_name: str,
        name: str,
        host_name: str,
        host_name_binding: _models.HostNameBinding,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HostNameBinding:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :param host_name_binding: Binding details. This is the JSON representation of a HostNameBinding
         object. Required.
        :type host_name_binding: ~azure.mgmt.web.models.HostNameBinding
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HostNameBinding. The HostNameBinding is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostNameBinding
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_host_name_binding(
        self,
        resource_group_name: str,
        name: str,
        host_name: str,
        host_name_binding: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HostNameBinding:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :param host_name_binding: Binding details. This is the JSON representation of a HostNameBinding
         object. Required.
        :type host_name_binding: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HostNameBinding. The HostNameBinding is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostNameBinding
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_host_name_binding(
        self,
        resource_group_name: str,
        name: str,
        host_name: str,
        host_name_binding: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HostNameBinding:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :param host_name_binding: Binding details. This is the JSON representation of a HostNameBinding
         object. Required.
        :type host_name_binding: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HostNameBinding. The HostNameBinding is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostNameBinding
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_host_name_binding(
        self,
        resource_group_name: str,
        name: str,
        host_name: str,
        host_name_binding: Union[_models.HostNameBinding, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.HostNameBinding:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :param host_name_binding: Binding details. This is the JSON representation of a HostNameBinding
         object. Is one of the following types: HostNameBinding, JSON, IO[bytes] Required.
        :type host_name_binding: ~azure.mgmt.web.models.HostNameBinding or JSON or IO[bytes]
        :return: HostNameBinding. The HostNameBinding is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostNameBinding
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.HostNameBinding] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(host_name_binding, (IOBase, bytes)):
            _content = host_name_binding
        else:
            _content = json.dumps(host_name_binding, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_host_name_binding_request(
            resource_group_name=resource_group_name,
            name=name,
            host_name=host_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HostNameBinding, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_host_name_binding(
        self, resource_group_name: str, name: str, host_name: str, **kwargs: Any
    ) -> None:
        """Deletes a hostname binding for an app.

        Description for Deletes a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_host_name_binding_request(
            resource_group_name=resource_group_name,
            name=name,
            host_name=host_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_host_name_bindings(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.HostNameBinding"]:
        """Get hostname bindings for an app or a deployment slot.

        Description for Get hostname bindings for an app or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of HostNameBinding
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.HostNameBinding]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.HostNameBinding]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_host_name_bindings_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.HostNameBinding], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_host_name_binding_slot(
        self, resource_group_name: str, name: str, slot: str, host_name: str, **kwargs: Any
    ) -> _models.HostNameBinding:
        """Get the named hostname binding for an app (or deployment slot, if specified).

        Description for Get the named hostname binding for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :return: HostNameBinding. The HostNameBinding is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostNameBinding
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HostNameBinding] = kwargs.pop("cls", None)

        _request = build_web_apps_get_host_name_binding_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            host_name=host_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HostNameBinding, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_host_name_binding_slot(
        self,
        resource_group_name: str,
        name: str,
        host_name: str,
        slot: str,
        host_name_binding: _models.HostNameBinding,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HostNameBinding:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param host_name_binding: Binding details. This is the JSON representation of a HostNameBinding
         object. Required.
        :type host_name_binding: ~azure.mgmt.web.models.HostNameBinding
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HostNameBinding. The HostNameBinding is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostNameBinding
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_host_name_binding_slot(
        self,
        resource_group_name: str,
        name: str,
        host_name: str,
        slot: str,
        host_name_binding: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HostNameBinding:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param host_name_binding: Binding details. This is the JSON representation of a HostNameBinding
         object. Required.
        :type host_name_binding: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HostNameBinding. The HostNameBinding is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostNameBinding
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_host_name_binding_slot(
        self,
        resource_group_name: str,
        name: str,
        host_name: str,
        slot: str,
        host_name_binding: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HostNameBinding:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param host_name_binding: Binding details. This is the JSON representation of a HostNameBinding
         object. Required.
        :type host_name_binding: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HostNameBinding. The HostNameBinding is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostNameBinding
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_host_name_binding_slot(
        self,
        resource_group_name: str,
        name: str,
        host_name: str,
        slot: str,
        host_name_binding: Union[_models.HostNameBinding, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.HostNameBinding:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param host_name_binding: Binding details. This is the JSON representation of a HostNameBinding
         object. Is one of the following types: HostNameBinding, JSON, IO[bytes] Required.
        :type host_name_binding: ~azure.mgmt.web.models.HostNameBinding or JSON or IO[bytes]
        :return: HostNameBinding. The HostNameBinding is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HostNameBinding
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.HostNameBinding] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(host_name_binding, (IOBase, bytes)):
            _content = host_name_binding
        else:
            _content = json.dumps(host_name_binding, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_host_name_binding_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            host_name=host_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HostNameBinding, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_host_name_binding_slot(
        self, resource_group_name: str, name: str, slot: str, host_name: str, **kwargs: Any
    ) -> None:
        """Deletes a hostname binding for an app.

        Description for Deletes a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param host_name: Hostname in the hostname binding. Required.
        :type host_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_host_name_binding_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            host_name=host_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_host_name_bindings_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.HostNameBinding"]:
        """Get hostname bindings for an app or a deployment slot.

        Description for Get hostname bindings for an app or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of HostNameBinding
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.HostNameBinding]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.HostNameBinding]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_host_name_bindings_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.HostNameBinding], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_relay_service_connection(
        self, resource_group_name: str, name: str, entity_name: str, **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Gets a hybrid connection configuration by its name.

        Description for Gets a hybrid connection configuration by its name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RelayServiceConnectionEntity] = kwargs.pop("cls", None)

        _request = build_web_apps_get_relay_service_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            entity_name=entity_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RelayServiceConnectionEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_relay_service_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        connection_envelope: _models.RelayServiceConnectionEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_relay_service_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_relay_service_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_relay_service_connection(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        connection_envelope: Union[_models.RelayServiceConnectionEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param connection_envelope: Details of the hybrid connection configuration. Is one of the
         following types: RelayServiceConnectionEntity, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.RelayServiceConnectionEntity or JSON or
         IO[bytes]
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RelayServiceConnectionEntity] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_relay_service_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            entity_name=entity_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RelayServiceConnectionEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_relay_service_connection(
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        connection_envelope: _models.RelayServiceConnectionEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_relay_service_connection(
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_relay_service_connection(
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_relay_service_connection(
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        connection_envelope: Union[_models.RelayServiceConnectionEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param connection_envelope: Details of the hybrid connection configuration. Is one of the
         following types: RelayServiceConnectionEntity, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.RelayServiceConnectionEntity or JSON or
         IO[bytes]
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RelayServiceConnectionEntity] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_relay_service_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            entity_name=entity_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RelayServiceConnectionEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_relay_service_connection(
        self, resource_group_name: str, name: str, entity_name: str, **kwargs: Any
    ) -> None:
        """Deletes a relay service connection by its name.

        Description for Deletes a relay service connection by its name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_relay_service_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            entity_name=entity_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_relay_service_connection_slot(
        self, resource_group_name: str, name: str, entity_name: str, slot: str, **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Gets a hybrid connection configuration by its name.

        Description for Gets a hybrid connection configuration by its name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a hybrid
         connection for the production slot. Required.
        :type slot: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RelayServiceConnectionEntity] = kwargs.pop("cls", None)

        _request = build_web_apps_get_relay_service_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            entity_name=entity_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RelayServiceConnectionEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_relay_service_connection_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        slot: str,
        connection_envelope: _models.RelayServiceConnectionEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a hybrid
         connection for the production slot. Required.
        :type slot: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_relay_service_connection_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        slot: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a hybrid
         connection for the production slot. Required.
        :type slot: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_relay_service_connection_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        slot: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a hybrid
         connection for the production slot. Required.
        :type slot: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_relay_service_connection_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        slot: str,
        connection_envelope: Union[_models.RelayServiceConnectionEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a hybrid
         connection for the production slot. Required.
        :type slot: str
        :param connection_envelope: Details of the hybrid connection configuration. Is one of the
         following types: RelayServiceConnectionEntity, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.RelayServiceConnectionEntity or JSON or
         IO[bytes]
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RelayServiceConnectionEntity] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_relay_service_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            entity_name=entity_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RelayServiceConnectionEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_relay_service_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        slot: str,
        connection_envelope: _models.RelayServiceConnectionEntity,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a hybrid
         connection for the production slot. Required.
        :type slot: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_relay_service_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        slot: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a hybrid
         connection for the production slot. Required.
        :type slot: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_relay_service_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        slot: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a hybrid
         connection for the production slot. Required.
        :type slot: str
        :param connection_envelope: Details of the hybrid connection configuration. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_relay_service_connection_slot(
        self,
        resource_group_name: str,
        name: str,
        entity_name: str,
        slot: str,
        connection_envelope: Union[_models.RelayServiceConnectionEntity, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.RelayServiceConnectionEntity:
        """Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).

        Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
        (PATCH).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a hybrid
         connection for the production slot. Required.
        :type slot: str
        :param connection_envelope: Details of the hybrid connection configuration. Is one of the
         following types: RelayServiceConnectionEntity, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.RelayServiceConnectionEntity or JSON or
         IO[bytes]
        :return: RelayServiceConnectionEntity. The RelayServiceConnectionEntity is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RelayServiceConnectionEntity] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_relay_service_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            entity_name=entity_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RelayServiceConnectionEntity, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_relay_service_connection_slot(
        self, resource_group_name: str, name: str, entity_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Deletes a relay service connection by its name.

        Description for Deletes a relay service connection by its name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param entity_name: Name of the hybrid connection. Required.
        :type entity_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a hybrid
         connection for the production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_relay_service_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            entity_name=entity_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_instance_info(
        self, resource_group_name: str, name: str, instance_id: str, **kwargs: Any
    ) -> _models.WebSiteInstanceStatus:
        """Gets all scale-out instances of an app.

        Description for Gets all scale-out instances of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param instance_id: Required.
        :type instance_id: str
        :return: WebSiteInstanceStatus. The WebSiteInstanceStatus is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WebSiteInstanceStatus
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WebSiteInstanceStatus] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_info_request(
            resource_group_name=resource_group_name,
            name=name,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WebSiteInstanceStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_instance_identifiers(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.WebSiteInstanceStatus"]:
        """Gets all scale-out instances of an app.

        Description for Gets all scale-out instances of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of WebSiteInstanceStatus
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WebSiteInstanceStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WebSiteInstanceStatus]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_instance_identifiers_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WebSiteInstanceStatus], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_instance_info_slot(
        self, resource_group_name: str, name: str, instance_id: str, slot: str, **kwargs: Any
    ) -> _models.WebSiteInstanceStatus:
        """Gets all scale-out instances of an app.

        Description for Gets all scale-out instances of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param instance_id: Required.
        :type instance_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API gets the
         production slot instances. Required.
        :type slot: str
        :return: WebSiteInstanceStatus. The WebSiteInstanceStatus is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WebSiteInstanceStatus
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WebSiteInstanceStatus] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_info_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            instance_id=instance_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WebSiteInstanceStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_instance_identifiers_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.WebSiteInstanceStatus"]:
        """Gets all scale-out instances of an app.

        Description for Gets all scale-out instances of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API gets the
         production slot instances. Required.
        :type slot: str
        :return: An iterator like instance of WebSiteInstanceStatus
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WebSiteInstanceStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WebSiteInstanceStatus]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_instance_identifiers_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WebSiteInstanceStatus], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_instance_process(
        self, resource_group_name: str, name: str, process_id: str, instance_id: str, **kwargs: Any
    ) -> _models.ProcessInfo:
        """Get process information by its ID for a specific scaled-out instance in a web site.

        Description for Get process information by its ID for a specific scaled-out instance in a web
        site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: ProcessInfo. The ProcessInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ProcessInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProcessInfo] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_process_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ProcessInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_instance_process(
        self, resource_group_name: str, name: str, process_id: str, instance_id: str, **kwargs: Any
    ) -> None:
        """Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out
        instance in a web site.

        Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
        scaled-out instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_instance_process_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_instance_processes(
        self, resource_group_name: str, name: str, instance_id: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessInfo"]:
        """Get list of processes for a web site, or a deployment slot, or for a specific scaled-out
        instance in a web site.

        Description for Get list of processes for a web site, or a deployment slot, or for a specific
        scaled-out instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: An iterator like instance of ProcessInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_instance_processes_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_instance_process_dump(
        self, resource_group_name: str, name: str, process_id: str, instance_id: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.

        Description for Get a memory dump of a process by its ID for a specific scaled-out instance in
        a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_process_dump_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_instance_process_threads(
        self, resource_group_name: str, name: str, process_id: str, instance_id: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessThreadInfo"]:
        """List the threads in a process by its ID for a specific scaled-out instance in a web site.

        Description for List the threads in a process by its ID for a specific scaled-out instance in a
        web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: An iterator like instance of ProcessThreadInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessThreadInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessThreadInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_instance_process_threads_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    process_id=process_id,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessThreadInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_process(
        self, resource_group_name: str, name: str, process_id: str, **kwargs: Any
    ) -> _models.ProcessInfo:
        """Get process information by its ID for a specific scaled-out instance in a web site.

        Description for Get process information by its ID for a specific scaled-out instance in a web
        site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :return: ProcessInfo. The ProcessInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ProcessInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProcessInfo] = kwargs.pop("cls", None)

        _request = build_web_apps_get_process_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ProcessInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_process(self, resource_group_name: str, name: str, process_id: str, **kwargs: Any) -> None:
        """Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out
        instance in a web site.

        Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
        scaled-out instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_process_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_processes(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessInfo"]:
        """Get list of processes for a web site, or a deployment slot, or for a specific scaled-out
        instance in a web site.

        Description for Get list of processes for a web site, or a deployment slot, or for a specific
        scaled-out instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :return: An iterator like instance of ProcessInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_processes_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_process_dump(
        self, resource_group_name: str, name: str, process_id: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.

        Description for Get a memory dump of a process by its ID for a specific scaled-out instance in
        a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_process_dump_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_process_threads(
        self, resource_group_name: str, name: str, process_id: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessThreadInfo"]:
        """List the threads in a process by its ID for a specific scaled-out instance in a web site.

        Description for List the threads in a process by its ID for a specific scaled-out instance in a
        web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :return: An iterator like instance of ProcessThreadInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessThreadInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessThreadInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_process_threads_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    process_id=process_id,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessThreadInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_instance_process_slot(
        self, resource_group_name: str, name: str, process_id: str, slot: str, instance_id: str, **kwargs: Any
    ) -> _models.ProcessInfo:
        """Get process information by its ID for a specific scaled-out instance in a web site.

        Description for Get process information by its ID for a specific scaled-out instance in a web
        site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: ProcessInfo. The ProcessInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ProcessInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProcessInfo] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_process_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            slot=slot,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ProcessInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_instance_process_slot(
        self, resource_group_name: str, name: str, process_id: str, slot: str, instance_id: str, **kwargs: Any
    ) -> None:
        """Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out
        instance in a web site.

        Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
        scaled-out instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_instance_process_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            slot=slot,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_instance_processes_slot(
        self, resource_group_name: str, name: str, slot: str, instance_id: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessInfo"]:
        """Get list of processes for a web site, or a deployment slot, or for a specific scaled-out
        instance in a web site.

        Description for Get list of processes for a web site, or a deployment slot, or for a specific
        scaled-out instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: An iterator like instance of ProcessInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_instance_processes_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_instance_process_dump_slot(
        self, resource_group_name: str, name: str, process_id: str, slot: str, instance_id: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.

        Description for Get a memory dump of a process by its ID for a specific scaled-out instance in
        a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_process_dump_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            slot=slot,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_instance_process_threads_slot(
        self, resource_group_name: str, name: str, process_id: str, slot: str, instance_id: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessThreadInfo"]:
        """List the threads in a process by its ID for a specific scaled-out instance in a web site.

        Description for List the threads in a process by its ID for a specific scaled-out instance in a
        web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: An iterator like instance of ProcessThreadInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessThreadInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessThreadInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_instance_process_threads_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    process_id=process_id,
                    slot=slot,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessThreadInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_process_slot(
        self, resource_group_name: str, name: str, process_id: str, slot: str, **kwargs: Any
    ) -> _models.ProcessInfo:
        """Get process information by its ID for a specific scaled-out instance in a web site.

        Description for Get process information by its ID for a specific scaled-out instance in a web
        site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :return: ProcessInfo. The ProcessInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ProcessInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProcessInfo] = kwargs.pop("cls", None)

        _request = build_web_apps_get_process_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ProcessInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_process_slot(
        self, resource_group_name: str, name: str, process_id: str, slot: str, **kwargs: Any
    ) -> None:
        """Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out
        instance in a web site.

        Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
        scaled-out instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_process_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_processes_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessInfo"]:
        """Get list of processes for a web site, or a deployment slot, or for a specific scaled-out
        instance in a web site.

        Description for Get list of processes for a web site, or a deployment slot, or for a specific
        scaled-out instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of ProcessInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_processes_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_process_dump_slot(
        self, resource_group_name: str, name: str, process_id: str, slot: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.

        Description for Get a memory dump of a process by its ID for a specific scaled-out instance in
        a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_get_process_dump_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_process_threads_slot(
        self, resource_group_name: str, name: str, process_id: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessThreadInfo"]:
        """List the threads in a process by its ID for a specific scaled-out instance in a web site.

        Description for List the threads in a process by its ID for a specific scaled-out instance in a
        web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of ProcessThreadInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessThreadInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessThreadInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_process_threads_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    process_id=process_id,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessThreadInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_instance_process_module(
        self, resource_group_name: str, name: str, process_id: str, base_address: str, instance_id: str, **kwargs: Any
    ) -> _models.ProcessModuleInfo:
        """Get process information by its ID for a specific scaled-out instance in a web site.

        Description for Get process information by its ID for a specific scaled-out instance in a web
        site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param base_address: Module base address. Required.
        :type base_address: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: ProcessModuleInfo. The ProcessModuleInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ProcessModuleInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProcessModuleInfo] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_process_module_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            base_address=base_address,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ProcessModuleInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_instance_process_modules(
        self, resource_group_name: str, name: str, process_id: str, instance_id: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessModuleInfo"]:
        """List module information for a process by its ID for a specific scaled-out instance in a web
        site.

        Description for List module information for a process by its ID for a specific scaled-out
        instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: An iterator like instance of ProcessModuleInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessModuleInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessModuleInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_instance_process_modules_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    process_id=process_id,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessModuleInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_process_module(
        self, resource_group_name: str, name: str, process_id: str, base_address: str, **kwargs: Any
    ) -> _models.ProcessModuleInfo:
        """Get process information by its ID for a specific scaled-out instance in a web site.

        Description for Get process information by its ID for a specific scaled-out instance in a web
        site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param base_address: Module base address. Required.
        :type base_address: str
        :return: ProcessModuleInfo. The ProcessModuleInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ProcessModuleInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProcessModuleInfo] = kwargs.pop("cls", None)

        _request = build_web_apps_get_process_module_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            base_address=base_address,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ProcessModuleInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_process_modules(
        self, resource_group_name: str, name: str, process_id: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessModuleInfo"]:
        """List module information for a process by its ID for a specific scaled-out instance in a web
        site.

        Description for List module information for a process by its ID for a specific scaled-out
        instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :return: An iterator like instance of ProcessModuleInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessModuleInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessModuleInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_process_modules_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    process_id=process_id,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessModuleInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_instance_process_module_slot(
        self,
        resource_group_name: str,
        name: str,
        process_id: str,
        base_address: str,
        slot: str,
        instance_id: str,
        **kwargs: Any
    ) -> _models.ProcessModuleInfo:
        """Get process information by its ID for a specific scaled-out instance in a web site.

        Description for Get process information by its ID for a specific scaled-out instance in a web
        site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param base_address: Module base address. Required.
        :type base_address: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: ProcessModuleInfo. The ProcessModuleInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ProcessModuleInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProcessModuleInfo] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_process_module_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            base_address=base_address,
            slot=slot,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ProcessModuleInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_instance_process_modules_slot(
        self, resource_group_name: str, name: str, process_id: str, slot: str, instance_id: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessModuleInfo"]:
        """List module information for a process by its ID for a specific scaled-out instance in a web
        site.

        Description for List module information for a process by its ID for a specific scaled-out
        instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :param instance_id: ID of a specific scaled-out instance. This is the value of the name
         property in the JSON response from "GET api/sites/{siteName}/instances". Required.
        :type instance_id: str
        :return: An iterator like instance of ProcessModuleInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessModuleInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessModuleInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_instance_process_modules_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    process_id=process_id,
                    slot=slot,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessModuleInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_process_module_slot(
        self, resource_group_name: str, name: str, process_id: str, base_address: str, slot: str, **kwargs: Any
    ) -> _models.ProcessModuleInfo:
        """Get process information by its ID for a specific scaled-out instance in a web site.

        Description for Get process information by its ID for a specific scaled-out instance in a web
        site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param base_address: Module base address. Required.
        :type base_address: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :return: ProcessModuleInfo. The ProcessModuleInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ProcessModuleInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProcessModuleInfo] = kwargs.pop("cls", None)

        _request = build_web_apps_get_process_module_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            process_id=process_id,
            base_address=base_address,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ProcessModuleInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_process_modules_slot(
        self, resource_group_name: str, name: str, process_id: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ProcessModuleInfo"]:
        """List module information for a process by its ID for a specific scaled-out instance in a web
        site.

        Description for List module information for a process by its ID for a specific scaled-out
        instance in a web site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param process_id: PID. Required.
        :type process_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of ProcessModuleInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ProcessModuleInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProcessModuleInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_process_modules_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    process_id=process_id,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ProcessModuleInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_migrate_my_sql_status(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.MigrateMySqlStatus:
        """Returns the status of MySql in app migration, if one is active, and whether or not MySql in app
        is enabled.

        Description for Returns the status of MySql in app migration, if one is active, and whether or
        not MySql in app is enabled.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :return: MigrateMySqlStatus. The MigrateMySqlStatus is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.MigrateMySqlStatus
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MigrateMySqlStatus] = kwargs.pop("cls", None)

        _request = build_web_apps_get_migrate_my_sql_status_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MigrateMySqlStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_migrate_my_sql_status_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.MigrateMySqlStatus:
        """Returns the status of MySql in app migration, if one is active, and whether or not MySql in app
        is enabled.

        Description for Returns the status of MySql in app migration, if one is active, and whether or
        not MySql in app is enabled.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of the deployment slot. Required.
        :type slot: str
        :return: MigrateMySqlStatus. The MigrateMySqlStatus is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.MigrateMySqlStatus
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MigrateMySqlStatus] = kwargs.pop("cls", None)

        _request = build_web_apps_get_migrate_my_sql_status_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MigrateMySqlStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_swift_virtual_network_connection(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Gets a Swift Virtual Network connection.

        Description for Gets a Swift Virtual Network connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SwiftVirtualNetwork] = kwargs.pop("cls", None)

        _request = build_web_apps_get_swift_virtual_network_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SwiftVirtualNetwork, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_swift_virtual_network_connection_with_check(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        connection_envelope: _models.SwiftVirtualNetwork,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_swift_virtual_network_connection_with_check(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_swift_virtual_network_connection_with_check(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_swift_virtual_network_connection_with_check(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        connection_envelope: Union[_models.SwiftVirtualNetwork, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example. Is one
         of the following types: SwiftVirtualNetwork, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.SwiftVirtualNetwork or JSON or IO[bytes]
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SwiftVirtualNetwork] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_swift_virtual_network_connection_with_check_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SwiftVirtualNetwork, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_swift_virtual_network_connection_with_check(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        connection_envelope: _models.SwiftVirtualNetwork,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_swift_virtual_network_connection_with_check(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_swift_virtual_network_connection_with_check(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_swift_virtual_network_connection_with_check(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        connection_envelope: Union[_models.SwiftVirtualNetwork, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param connection_envelope: Properties of the Virtual Network connection. See example. Is one
         of the following types: SwiftVirtualNetwork, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.SwiftVirtualNetwork or JSON or IO[bytes]
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SwiftVirtualNetwork] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_swift_virtual_network_connection_with_check_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SwiftVirtualNetwork, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_swift_virtual_network(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Deletes a Swift Virtual Network connection from an app (or deployment slot).

        Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_swift_virtual_network_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_swift_virtual_network_connection_slot(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Gets a Swift Virtual Network connection.

        Description for Gets a Swift Virtual Network connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SwiftVirtualNetwork] = kwargs.pop("cls", None)

        _request = build_web_apps_get_swift_virtual_network_connection_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SwiftVirtualNetwork, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_swift_virtual_network_connection_with_check_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_envelope: _models.SwiftVirtualNetwork,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_swift_virtual_network_connection_with_check_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_swift_virtual_network_connection_with_check_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_swift_virtual_network_connection_with_check_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_envelope: Union[_models.SwiftVirtualNetwork, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example. Is one
         of the following types: SwiftVirtualNetwork, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.SwiftVirtualNetwork or JSON or IO[bytes]
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SwiftVirtualNetwork] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_swift_virtual_network_connection_with_check_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SwiftVirtualNetwork, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_swift_virtual_network_connection_with_check_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_envelope: _models.SwiftVirtualNetwork,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_swift_virtual_network_connection_with_check_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_swift_virtual_network_connection_with_check_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example.
         Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_swift_virtual_network_connection_with_check_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        connection_envelope: Union[_models.SwiftVirtualNetwork, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SwiftVirtualNetwork:
        """Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported" is true
        when doing a GET against this resource, and 2) that the target Subnet has already been
        delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        Description for Integrates this Web App with a Virtual Network. This requires that 1)
        "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet
        has already been delegated, and is not
        in use by another App Service Plan other than the one this App is in.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :param connection_envelope: Properties of the Virtual Network connection. See example. Is one
         of the following types: SwiftVirtualNetwork, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.SwiftVirtualNetwork or JSON or IO[bytes]
        :return: SwiftVirtualNetwork. The SwiftVirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SwiftVirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SwiftVirtualNetwork] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_swift_virtual_network_connection_with_check_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SwiftVirtualNetwork, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_swift_virtual_network_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> None:
        """Deletes a Swift Virtual Network connection from an app (or deployment slot).

        Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get a
         gateway for the production slot's Virtual Network. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_swift_virtual_network_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_network_features(
        self, resource_group_name: str, name: str, view: str, **kwargs: Any
    ) -> _models.NetworkFeatures:
        """Gets all network features used by the app (or deployment slot, if specified).

        Description for Gets all network features used by the app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param view: The type of view. Only "summary" is supported at this time. Required.
        :type view: str
        :return: NetworkFeatures. The NetworkFeatures is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.NetworkFeatures
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.NetworkFeatures] = kwargs.pop("cls", None)

        _request = build_web_apps_list_network_features_request(
            resource_group_name=resource_group_name,
            name=name,
            view=view,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.NetworkFeatures, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_network_features_slot(
        self, resource_group_name: str, name: str, view: str, slot: str, **kwargs: Any
    ) -> _models.NetworkFeatures:
        """Gets all network features used by the app (or deployment slot, if specified).

        Description for Gets all network features used by the app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param view: The type of view. Only "summary" is supported at this time. Required.
        :type view: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get network
         features for the production slot. Required.
        :type slot: str
        :return: NetworkFeatures. The NetworkFeatures is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.NetworkFeatures
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.NetworkFeatures] = kwargs.pop("cls", None)

        _request = build_web_apps_list_network_features_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            view=view,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.NetworkFeatures, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_premier_add_on(
        self, resource_group_name: str, name: str, premier_add_on_name: str, **kwargs: Any
    ) -> _models.PremierAddOn:
        """Gets a named add-on of an app.

        Description for Gets a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PremierAddOn] = kwargs.pop("cls", None)

        _request = build_web_apps_get_premier_add_on_request(
            resource_group_name=resource_group_name,
            name=name,
            premier_add_on_name=premier_add_on_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PremierAddOn, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def add_premier_add_on(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        premier_add_on: _models.PremierAddOn,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: ~azure.mgmt.web.models.PremierAddOn
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_premier_add_on(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        premier_add_on: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_premier_add_on(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        premier_add_on: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_premier_add_on(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        premier_add_on: Union[_models.PremierAddOn, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Is one of the
         following types: PremierAddOn, JSON, IO[bytes] Required.
        :type premier_add_on: ~azure.mgmt.web.models.PremierAddOn or JSON or IO[bytes]
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PremierAddOn] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(premier_add_on, (IOBase, bytes)):
            _content = premier_add_on
        else:
            _content = json.dumps(premier_add_on, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_add_premier_add_on_request(
            resource_group_name=resource_group_name,
            name=name,
            premier_add_on_name=premier_add_on_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PremierAddOn, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_premier_add_on(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        premier_add_on: _models.PremierAddOnPatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: ~azure.mgmt.web.models.PremierAddOnPatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_premier_add_on(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        premier_add_on: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_premier_add_on(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        premier_add_on: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_premier_add_on(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        premier_add_on: Union[_models.PremierAddOnPatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Is one of the
         following types: PremierAddOnPatchResource, JSON, IO[bytes] Required.
        :type premier_add_on: ~azure.mgmt.web.models.PremierAddOnPatchResource or JSON or IO[bytes]
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PremierAddOn] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(premier_add_on, (IOBase, bytes)):
            _content = premier_add_on
        else:
            _content = json.dumps(premier_add_on, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_premier_add_on_request(
            resource_group_name=resource_group_name,
            name=name,
            premier_add_on_name=premier_add_on_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PremierAddOn, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_premier_add_on(
        self, resource_group_name: str, name: str, premier_add_on_name: str, **kwargs: Any
    ) -> None:
        """Delete a premier add-on from an app.

        Description for Delete a premier add-on from an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_premier_add_on_request(
            resource_group_name=resource_group_name,
            name=name,
            premier_add_on_name=premier_add_on_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_premier_add_on_slot(
        self, resource_group_name: str, name: str, premier_add_on_name: str, slot: str, **kwargs: Any
    ) -> _models.PremierAddOn:
        """Gets a named add-on of an app.

        Description for Gets a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named add-on for the production slot. Required.
        :type slot: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PremierAddOn] = kwargs.pop("cls", None)

        _request = build_web_apps_get_premier_add_on_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            premier_add_on_name=premier_add_on_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PremierAddOn, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def add_premier_add_on_slot(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        slot: str,
        premier_add_on: _models.PremierAddOn,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named add-on for the production slot. Required.
        :type slot: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: ~azure.mgmt.web.models.PremierAddOn
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_premier_add_on_slot(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        slot: str,
        premier_add_on: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named add-on for the production slot. Required.
        :type slot: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_premier_add_on_slot(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        slot: str,
        premier_add_on: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named add-on for the production slot. Required.
        :type slot: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_premier_add_on_slot(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        slot: str,
        premier_add_on: Union[_models.PremierAddOn, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named add-on for the production slot. Required.
        :type slot: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Is one of the
         following types: PremierAddOn, JSON, IO[bytes] Required.
        :type premier_add_on: ~azure.mgmt.web.models.PremierAddOn or JSON or IO[bytes]
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PremierAddOn] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(premier_add_on, (IOBase, bytes)):
            _content = premier_add_on
        else:
            _content = json.dumps(premier_add_on, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_add_premier_add_on_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            premier_add_on_name=premier_add_on_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PremierAddOn, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_premier_add_on_slot(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        slot: str,
        premier_add_on: _models.PremierAddOnPatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named add-on for the production slot. Required.
        :type slot: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: ~azure.mgmt.web.models.PremierAddOnPatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_premier_add_on_slot(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        slot: str,
        premier_add_on: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named add-on for the production slot. Required.
        :type slot: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_premier_add_on_slot(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        slot: str,
        premier_add_on: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named add-on for the production slot. Required.
        :type slot: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Required.
        :type premier_add_on: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_premier_add_on_slot(
        self,
        resource_group_name: str,
        name: str,
        premier_add_on_name: str,
        slot: str,
        premier_add_on: Union[_models.PremierAddOnPatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PremierAddOn:
        """Updates a named add-on of an app.

        Description for Updates a named add-on of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named add-on for the production slot. Required.
        :type slot: str
        :param premier_add_on: A JSON representation of the edited premier add-on. Is one of the
         following types: PremierAddOnPatchResource, JSON, IO[bytes] Required.
        :type premier_add_on: ~azure.mgmt.web.models.PremierAddOnPatchResource or JSON or IO[bytes]
        :return: PremierAddOn. The PremierAddOn is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PremierAddOn
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PremierAddOn] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(premier_add_on, (IOBase, bytes)):
            _content = premier_add_on
        else:
            _content = json.dumps(premier_add_on, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_premier_add_on_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            premier_add_on_name=premier_add_on_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PremierAddOn, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_premier_add_on_slot(
        self, resource_group_name: str, name: str, premier_add_on_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Delete a premier add-on from an app.

        Description for Delete a premier add-on from an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param premier_add_on_name: Add-on name. Required.
        :type premier_add_on_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         named add-on for the production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_premier_add_on_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            premier_add_on_name=premier_add_on_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_private_access(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.PrivateAccess:
        """Gets data around private site access enablement and authorized Virtual Networks that can access
        the site.

        Description for Gets data around private site access enablement and authorized Virtual Networks
        that can access the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :return: PrivateAccess. The PrivateAccess is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateAccess
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PrivateAccess] = kwargs.pop("cls", None)

        _request = build_web_apps_get_private_access_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PrivateAccess, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def put_private_access_vnet(
        self,
        resource_group_name: str,
        name: str,
        access: _models.PrivateAccess,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PrivateAccess:
        """Sets data around private site access enablement and authorized Virtual Networks that can access
        the site.

        Description for Sets data around private site access enablement and authorized Virtual Networks
        that can access the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param access: The information for the private access. Required.
        :type access: ~azure.mgmt.web.models.PrivateAccess
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PrivateAccess. The PrivateAccess is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateAccess
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def put_private_access_vnet(
        self,
        resource_group_name: str,
        name: str,
        access: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PrivateAccess:
        """Sets data around private site access enablement and authorized Virtual Networks that can access
        the site.

        Description for Sets data around private site access enablement and authorized Virtual Networks
        that can access the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param access: The information for the private access. Required.
        :type access: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PrivateAccess. The PrivateAccess is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateAccess
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def put_private_access_vnet(
        self,
        resource_group_name: str,
        name: str,
        access: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PrivateAccess:
        """Sets data around private site access enablement and authorized Virtual Networks that can access
        the site.

        Description for Sets data around private site access enablement and authorized Virtual Networks
        that can access the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param access: The information for the private access. Required.
        :type access: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PrivateAccess. The PrivateAccess is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateAccess
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def put_private_access_vnet(
        self, resource_group_name: str, name: str, access: Union[_models.PrivateAccess, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.PrivateAccess:
        """Sets data around private site access enablement and authorized Virtual Networks that can access
        the site.

        Description for Sets data around private site access enablement and authorized Virtual Networks
        that can access the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param access: The information for the private access. Is one of the following types:
         PrivateAccess, JSON, IO[bytes] Required.
        :type access: ~azure.mgmt.web.models.PrivateAccess or JSON or IO[bytes]
        :return: PrivateAccess. The PrivateAccess is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateAccess
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PrivateAccess] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(access, (IOBase, bytes)):
            _content = access
        else:
            _content = json.dumps(access, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_put_private_access_vnet_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PrivateAccess, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_private_access_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.PrivateAccess:
        """Gets data around private site access enablement and authorized Virtual Networks that can access
        the site.

        Description for Gets data around private site access enablement and authorized Virtual Networks
        that can access the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :return: PrivateAccess. The PrivateAccess is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateAccess
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PrivateAccess] = kwargs.pop("cls", None)

        _request = build_web_apps_get_private_access_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PrivateAccess, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def put_private_access_vnet_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        access: _models.PrivateAccess,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PrivateAccess:
        """Sets data around private site access enablement and authorized Virtual Networks that can access
        the site.

        Description for Sets data around private site access enablement and authorized Virtual Networks
        that can access the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param access: The information for the private access. Required.
        :type access: ~azure.mgmt.web.models.PrivateAccess
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PrivateAccess. The PrivateAccess is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateAccess
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def put_private_access_vnet_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        access: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PrivateAccess:
        """Sets data around private site access enablement and authorized Virtual Networks that can access
        the site.

        Description for Sets data around private site access enablement and authorized Virtual Networks
        that can access the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param access: The information for the private access. Required.
        :type access: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PrivateAccess. The PrivateAccess is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateAccess
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def put_private_access_vnet_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        access: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PrivateAccess:
        """Sets data around private site access enablement and authorized Virtual Networks that can access
        the site.

        Description for Sets data around private site access enablement and authorized Virtual Networks
        that can access the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param access: The information for the private access. Required.
        :type access: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PrivateAccess. The PrivateAccess is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateAccess
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def put_private_access_vnet_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        access: Union[_models.PrivateAccess, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PrivateAccess:
        """Sets data around private site access enablement and authorized Virtual Networks that can access
        the site.

        Description for Sets data around private site access enablement and authorized Virtual Networks
        that can access the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: The name of the web app. Required.
        :type name: str
        :param slot: The name of the slot for the web app. Required.
        :type slot: str
        :param access: The information for the private access. Is one of the following types:
         PrivateAccess, JSON, IO[bytes] Required.
        :type access: ~azure.mgmt.web.models.PrivateAccess or JSON or IO[bytes]
        :return: PrivateAccess. The PrivateAccess is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PrivateAccess
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PrivateAccess] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(access, (IOBase, bytes)):
            _content = access
        else:
            _content = json.dumps(access, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_put_private_access_vnet_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PrivateAccess, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_public_certificate(
        self, resource_group_name: str, name: str, public_certificate_name: str, **kwargs: Any
    ) -> _models.PublicCertificate:
        """Get the named public certificate for an app (or deployment slot, if specified).

        Description for Get the named public certificate for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :return: PublicCertificate. The PublicCertificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PublicCertificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PublicCertificate] = kwargs.pop("cls", None)

        _request = build_web_apps_get_public_certificate_request(
            resource_group_name=resource_group_name,
            name=name,
            public_certificate_name=public_certificate_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PublicCertificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_public_certificate(
        self,
        resource_group_name: str,
        name: str,
        public_certificate_name: str,
        public_certificate: _models.PublicCertificate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PublicCertificate:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :param public_certificate: Public certificate details. This is the JSON representation of a
         PublicCertificate object. Required.
        :type public_certificate: ~azure.mgmt.web.models.PublicCertificate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PublicCertificate. The PublicCertificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PublicCertificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_public_certificate(
        self,
        resource_group_name: str,
        name: str,
        public_certificate_name: str,
        public_certificate: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PublicCertificate:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :param public_certificate: Public certificate details. This is the JSON representation of a
         PublicCertificate object. Required.
        :type public_certificate: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PublicCertificate. The PublicCertificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PublicCertificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_public_certificate(
        self,
        resource_group_name: str,
        name: str,
        public_certificate_name: str,
        public_certificate: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PublicCertificate:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :param public_certificate: Public certificate details. This is the JSON representation of a
         PublicCertificate object. Required.
        :type public_certificate: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PublicCertificate. The PublicCertificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PublicCertificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_public_certificate(
        self,
        resource_group_name: str,
        name: str,
        public_certificate_name: str,
        public_certificate: Union[_models.PublicCertificate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PublicCertificate:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :param public_certificate: Public certificate details. This is the JSON representation of a
         PublicCertificate object. Is one of the following types: PublicCertificate, JSON, IO[bytes]
         Required.
        :type public_certificate: ~azure.mgmt.web.models.PublicCertificate or JSON or IO[bytes]
        :return: PublicCertificate. The PublicCertificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PublicCertificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PublicCertificate] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(public_certificate, (IOBase, bytes)):
            _content = public_certificate
        else:
            _content = json.dumps(public_certificate, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_public_certificate_request(
            resource_group_name=resource_group_name,
            name=name,
            public_certificate_name=public_certificate_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PublicCertificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_public_certificate(
        self, resource_group_name: str, name: str, public_certificate_name: str, **kwargs: Any
    ) -> None:
        """Deletes a hostname binding for an app.

        Description for Deletes a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_public_certificate_request(
            resource_group_name=resource_group_name,
            name=name,
            public_certificate_name=public_certificate_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_public_certificates(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.PublicCertificate"]:
        """Get public certificates for an app or a deployment slot.

        Description for Get public certificates for an app or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of PublicCertificate
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.PublicCertificate]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PublicCertificate]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_public_certificates_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PublicCertificate], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_public_certificate_slot(
        self, resource_group_name: str, name: str, slot: str, public_certificate_name: str, **kwargs: Any
    ) -> _models.PublicCertificate:
        """Get the named public certificate for an app (or deployment slot, if specified).

        Description for Get the named public certificate for an app (or deployment slot, if specified).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :return: PublicCertificate. The PublicCertificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PublicCertificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PublicCertificate] = kwargs.pop("cls", None)

        _request = build_web_apps_get_public_certificate_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            public_certificate_name=public_certificate_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PublicCertificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_public_certificate_slot(
        self,
        resource_group_name: str,
        name: str,
        public_certificate_name: str,
        slot: str,
        public_certificate: _models.PublicCertificate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PublicCertificate:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param public_certificate: Public certificate details. This is the JSON representation of a
         PublicCertificate object. Required.
        :type public_certificate: ~azure.mgmt.web.models.PublicCertificate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PublicCertificate. The PublicCertificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PublicCertificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_public_certificate_slot(
        self,
        resource_group_name: str,
        name: str,
        public_certificate_name: str,
        slot: str,
        public_certificate: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PublicCertificate:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param public_certificate: Public certificate details. This is the JSON representation of a
         PublicCertificate object. Required.
        :type public_certificate: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PublicCertificate. The PublicCertificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PublicCertificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_public_certificate_slot(
        self,
        resource_group_name: str,
        name: str,
        public_certificate_name: str,
        slot: str,
        public_certificate: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PublicCertificate:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param public_certificate: Public certificate details. This is the JSON representation of a
         PublicCertificate object. Required.
        :type public_certificate: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PublicCertificate. The PublicCertificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PublicCertificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_public_certificate_slot(
        self,
        resource_group_name: str,
        name: str,
        public_certificate_name: str,
        slot: str,
        public_certificate: Union[_models.PublicCertificate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PublicCertificate:
        """Creates a hostname binding for an app.

        Description for Creates a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param public_certificate: Public certificate details. This is the JSON representation of a
         PublicCertificate object. Is one of the following types: PublicCertificate, JSON, IO[bytes]
         Required.
        :type public_certificate: ~azure.mgmt.web.models.PublicCertificate or JSON or IO[bytes]
        :return: PublicCertificate. The PublicCertificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.PublicCertificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PublicCertificate] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(public_certificate, (IOBase, bytes)):
            _content = public_certificate
        else:
            _content = json.dumps(public_certificate, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_public_certificate_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            public_certificate_name=public_certificate_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PublicCertificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_public_certificate_slot(
        self, resource_group_name: str, name: str, slot: str, public_certificate_name: str, **kwargs: Any
    ) -> None:
        """Deletes a hostname binding for an app.

        Description for Deletes a hostname binding for an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :param public_certificate_name: Public certificate name. Required.
        :type public_certificate_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_public_certificate_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            public_certificate_name=public_certificate_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_public_certificates_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.PublicCertificate"]:
        """Get public certificates for an app or a deployment slot.

        Description for Get public certificates for an app or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API the named binding
         for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of PublicCertificate
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.PublicCertificate]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PublicCertificate]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_public_certificates_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PublicCertificate], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_container(
        self, resource_group_name: str, name: str, container_name: str, **kwargs: Any
    ) -> _models.SiteContainer:
        """Gets a site container of a site, or a deployment slot.

        Gets a site container of a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :return: SiteContainer. The SiteContainer is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteContainer
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteContainer] = kwargs.pop("cls", None)

        _request = build_web_apps_get_site_container_request(
            resource_group_name=resource_group_name,
            name=name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteContainer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_site_container(
        self,
        resource_group_name: str,
        name: str,
        container_name: str,
        request: _models.SiteContainer,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteContainer:
        """Creates or Updates a site container for a site, or a deployment slot.

        Creates or Updates a site container for a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :param request: Container Entity. Required.
        :type request: ~azure.mgmt.web.models.SiteContainer
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteContainer. The SiteContainer is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteContainer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_site_container(
        self,
        resource_group_name: str,
        name: str,
        container_name: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteContainer:
        """Creates or Updates a site container for a site, or a deployment slot.

        Creates or Updates a site container for a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :param request: Container Entity. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteContainer. The SiteContainer is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteContainer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_site_container(
        self,
        resource_group_name: str,
        name: str,
        container_name: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteContainer:
        """Creates or Updates a site container for a site, or a deployment slot.

        Creates or Updates a site container for a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :param request: Container Entity. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteContainer. The SiteContainer is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteContainer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_site_container(
        self,
        resource_group_name: str,
        name: str,
        container_name: str,
        request: Union[_models.SiteContainer, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteContainer:
        """Creates or Updates a site container for a site, or a deployment slot.

        Creates or Updates a site container for a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :param request: Container Entity. Is one of the following types: SiteContainer, JSON, IO[bytes]
         Required.
        :type request: ~azure.mgmt.web.models.SiteContainer or JSON or IO[bytes]
        :return: SiteContainer. The SiteContainer is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteContainer
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteContainer] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_site_container_request(
            resource_group_name=resource_group_name,
            name=name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteContainer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_site_container(
        self, resource_group_name: str, name: str, container_name: str, **kwargs: Any
    ) -> None:
        """Deletes a site container for a site, or a deployment slot.

        Deletes a site container for a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_site_container_request(
            resource_group_name=resource_group_name,
            name=name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_site_containers(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.SiteContainer"]:
        """Lists all the site containers of a site, or a deployment slot.

        Lists all the site containers of a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: An iterator like instance of SiteContainer
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SiteContainer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SiteContainer]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_site_containers_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SiteContainer], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_container_slot(
        self, resource_group_name: str, name: str, slot: str, container_name: str, **kwargs: Any
    ) -> _models.SiteContainer:
        """Gets a site container of a site, or a deployment slot.

        Gets a site container of a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the Site
         Container for the production slot. Required.
        :type slot: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :return: SiteContainer. The SiteContainer is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteContainer
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteContainer] = kwargs.pop("cls", None)

        _request = build_web_apps_get_site_container_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteContainer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_site_container_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        container_name: str,
        request: _models.SiteContainer,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteContainer:
        """Creates or Updates a site container for a site, or a deployment slot.

        Creates or Updates a site container for a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the Site
         Container for the production slot. Required.
        :type slot: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :param request: Container Entity. Required.
        :type request: ~azure.mgmt.web.models.SiteContainer
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteContainer. The SiteContainer is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteContainer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_site_container_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        container_name: str,
        request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteContainer:
        """Creates or Updates a site container for a site, or a deployment slot.

        Creates or Updates a site container for a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the Site
         Container for the production slot. Required.
        :type slot: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :param request: Container Entity. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteContainer. The SiteContainer is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteContainer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_site_container_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        container_name: str,
        request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteContainer:
        """Creates or Updates a site container for a site, or a deployment slot.

        Creates or Updates a site container for a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the Site
         Container for the production slot. Required.
        :type slot: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :param request: Container Entity. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteContainer. The SiteContainer is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteContainer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_site_container_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        container_name: str,
        request: Union[_models.SiteContainer, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteContainer:
        """Creates or Updates a site container for a site, or a deployment slot.

        Creates or Updates a site container for a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the Site
         Container for the production slot. Required.
        :type slot: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :param request: Container Entity. Is one of the following types: SiteContainer, JSON, IO[bytes]
         Required.
        :type request: ~azure.mgmt.web.models.SiteContainer or JSON or IO[bytes]
        :return: SiteContainer. The SiteContainer is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteContainer
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteContainer] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_site_container_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteContainer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_site_container_slot(
        self, resource_group_name: str, name: str, slot: str, container_name: str, **kwargs: Any
    ) -> None:
        """Deletes a site container for a site, or a deployment slot.

        Deletes a site container for a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the Site
         Container for the production slot. Required.
        :type slot: str
        :param container_name: Site Container Name. Required.
        :type container_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_site_container_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_site_containers_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.SiteContainer"]:
        """Lists all the site containers of a site, or a deployment slot.

        Lists all the site containers of a site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the Site
         Container for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of SiteContainer
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SiteContainer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SiteContainer]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_site_containers_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SiteContainer], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_extension(
        self, resource_group_name: str, name: str, site_extension_id: str, **kwargs: Any
    ) -> _models.SiteExtensionInfo:
        """Get site extension information by its ID for a web site, or a deployment slot.

        Description for Get site extension information by its ID for a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param site_extension_id: Site extension name. Required.
        :type site_extension_id: str
        :return: SiteExtensionInfo. The SiteExtensionInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteExtensionInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteExtensionInfo] = kwargs.pop("cls", None)

        _request = build_web_apps_get_site_extension_request(
            resource_group_name=resource_group_name,
            name=name,
            site_extension_id=site_extension_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteExtensionInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _install_site_extension_initial(
        self, resource_group_name: str, name: str, site_extension_id: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_install_site_extension_request(
            resource_group_name=resource_group_name,
            name=name,
            site_extension_id=site_extension_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_install_site_extension(
        self, resource_group_name: str, name: str, site_extension_id: str, **kwargs: Any
    ) -> AsyncLROPoller[_models.SiteExtensionInfo]:
        """Install site extension on a web site, or a deployment slot.

        Description for Install site extension on a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param site_extension_id: Site extension name. Required.
        :type site_extension_id: str
        :return: An instance of AsyncLROPoller that returns SiteExtensionInfo. The SiteExtensionInfo is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.SiteExtensionInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteExtensionInfo] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._install_site_extension_initial(
                resource_group_name=resource_group_name,
                name=name,
                site_extension_id=site_extension_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.SiteExtensionInfo, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.SiteExtensionInfo].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.SiteExtensionInfo](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def delete_site_extension(
        self, resource_group_name: str, name: str, site_extension_id: str, **kwargs: Any
    ) -> None:
        """Remove a site extension from a web site, or a deployment slot.

        Description for Remove a site extension from a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param site_extension_id: Site extension name. Required.
        :type site_extension_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_site_extension_request(
            resource_group_name=resource_group_name,
            name=name,
            site_extension_id=site_extension_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_site_extensions(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.SiteExtensionInfo"]:
        """Get list of siteextensions for a web site, or a deployment slot.

        Description for Get list of siteextensions for a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :return: An iterator like instance of SiteExtensionInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SiteExtensionInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SiteExtensionInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_site_extensions_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SiteExtensionInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_extension_slot(
        self, resource_group_name: str, name: str, site_extension_id: str, slot: str, **kwargs: Any
    ) -> _models.SiteExtensionInfo:
        """Get site extension information by its ID for a web site, or a deployment slot.

        Description for Get site extension information by its ID for a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param site_extension_id: Site extension name. Required.
        :type site_extension_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API uses the
         production slot. Required.
        :type slot: str
        :return: SiteExtensionInfo. The SiteExtensionInfo is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteExtensionInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteExtensionInfo] = kwargs.pop("cls", None)

        _request = build_web_apps_get_site_extension_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            site_extension_id=site_extension_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteExtensionInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _install_site_extension_slot_initial(
        self, resource_group_name: str, name: str, site_extension_id: str, slot: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_web_apps_install_site_extension_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            site_extension_id=site_extension_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_install_site_extension_slot(
        self, resource_group_name: str, name: str, site_extension_id: str, slot: str, **kwargs: Any
    ) -> AsyncLROPoller[_models.SiteExtensionInfo]:
        """Install site extension on a web site, or a deployment slot.

        Description for Install site extension on a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param site_extension_id: Site extension name. Required.
        :type site_extension_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API uses the
         production slot. Required.
        :type slot: str
        :return: An instance of AsyncLROPoller that returns SiteExtensionInfo. The SiteExtensionInfo is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.SiteExtensionInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteExtensionInfo] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._install_site_extension_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                site_extension_id=site_extension_id,
                slot=slot,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.SiteExtensionInfo, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.SiteExtensionInfo].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.SiteExtensionInfo](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def delete_site_extension_slot(
        self, resource_group_name: str, name: str, site_extension_id: str, slot: str, **kwargs: Any
    ) -> None:
        """Remove a site extension from a web site, or a deployment slot.

        Description for Remove a site extension from a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param site_extension_id: Site extension name. Required.
        :type site_extension_id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API uses the
         production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_site_extension_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            site_extension_id=site_extension_id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_site_extensions_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.SiteExtensionInfo"]:
        """Get list of siteextensions for a web site, or a deployment slot.

        Description for Get list of siteextensions for a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API uses the
         production slot. Required.
        :type slot: str
        :return: An iterator like instance of SiteExtensionInfo
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SiteExtensionInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SiteExtensionInfo]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_site_extensions_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SiteExtensionInfo], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_source_control_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.SiteSourceControl:
        """Gets the source control configuration of an app.

        Description for Gets the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         source control configuration for the production slot. Required.
        :type slot: str
        :return: SiteSourceControl. The SiteSourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteSourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteSourceControl] = kwargs.pop("cls", None)

        _request = build_web_apps_get_source_control_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteSourceControl, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_source_control_slot_initial(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_source_control: Union[_models.SiteSourceControl, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_source_control, (IOBase, bytes)):
            _content = site_source_control
        else:
            _content = json.dumps(site_source_control, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_source_control_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update_source_control_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_source_control: _models.SiteSourceControl,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SiteSourceControl]:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         source control configuration for the production slot. Required.
        :type slot: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: ~azure.mgmt.web.models.SiteSourceControl
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SiteSourceControl. The SiteSourceControl is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.SiteSourceControl]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_source_control_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_source_control: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SiteSourceControl]:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         source control configuration for the production slot. Required.
        :type slot: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SiteSourceControl. The SiteSourceControl is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.SiteSourceControl]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_source_control_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_source_control: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SiteSourceControl]:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         source control configuration for the production slot. Required.
        :type slot: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SiteSourceControl. The SiteSourceControl is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.SiteSourceControl]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update_source_control_slot(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_source_control: Union[_models.SiteSourceControl, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SiteSourceControl]:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         source control configuration for the production slot. Required.
        :type slot: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example. Is
         one of the following types: SiteSourceControl, JSON, IO[bytes] Required.
        :type site_source_control: ~azure.mgmt.web.models.SiteSourceControl or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns SiteSourceControl. The SiteSourceControl is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.SiteSourceControl]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteSourceControl] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_source_control_slot_initial(
                resource_group_name=resource_group_name,
                name=name,
                slot=slot,
                site_source_control=site_source_control,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.SiteSourceControl, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.SiteSourceControl].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.SiteSourceControl](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update_source_control_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_source_control: _models.SiteSourceControl,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteSourceControl:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         source control configuration for the production slot. Required.
        :type slot: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: ~azure.mgmt.web.models.SiteSourceControl
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteSourceControl. The SiteSourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteSourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_source_control_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_source_control: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteSourceControl:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         source control configuration for the production slot. Required.
        :type slot: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteSourceControl. The SiteSourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteSourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_source_control_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_source_control: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteSourceControl:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         source control configuration for the production slot. Required.
        :type slot: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteSourceControl. The SiteSourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteSourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_source_control_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        site_source_control: Union[_models.SiteSourceControl, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteSourceControl:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         source control configuration for the production slot. Required.
        :type slot: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example. Is
         one of the following types: SiteSourceControl, JSON, IO[bytes] Required.
        :type site_source_control: ~azure.mgmt.web.models.SiteSourceControl or JSON or IO[bytes]
        :return: SiteSourceControl. The SiteSourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteSourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteSourceControl] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_source_control, (IOBase, bytes)):
            _content = site_source_control
        else:
            _content = json.dumps(site_source_control, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_source_control_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteSourceControl, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_source_control_slot(
        self, resource_group_name: str, name: str, slot: str, *, additional_flags: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Deletes the source control configuration of an app.

        Description for Deletes the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will get the
         source control configuration for the production slot. Required.
        :type slot: str
        :keyword additional_flags: Default value is None.
        :paramtype additional_flags: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_source_control_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            additional_flags=additional_flags,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_source_control(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.SiteSourceControl:
        """Gets the source control configuration of an app.

        Description for Gets the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :return: SiteSourceControl. The SiteSourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteSourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SiteSourceControl] = kwargs.pop("cls", None)

        _request = build_web_apps_get_source_control_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteSourceControl, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_source_control_initial(
        self,
        resource_group_name: str,
        name: str,
        site_source_control: Union[_models.SiteSourceControl, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_source_control, (IOBase, bytes)):
            _content = site_source_control
        else:
            _content = json.dumps(site_source_control, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_create_or_update_source_control_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update_source_control(
        self,
        resource_group_name: str,
        name: str,
        site_source_control: _models.SiteSourceControl,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SiteSourceControl]:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: ~azure.mgmt.web.models.SiteSourceControl
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SiteSourceControl. The SiteSourceControl is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.SiteSourceControl]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_source_control(
        self,
        resource_group_name: str,
        name: str,
        site_source_control: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SiteSourceControl]:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SiteSourceControl. The SiteSourceControl is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.SiteSourceControl]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update_source_control(
        self,
        resource_group_name: str,
        name: str,
        site_source_control: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SiteSourceControl]:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SiteSourceControl. The SiteSourceControl is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.SiteSourceControl]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update_source_control(
        self,
        resource_group_name: str,
        name: str,
        site_source_control: Union[_models.SiteSourceControl, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SiteSourceControl]:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example. Is
         one of the following types: SiteSourceControl, JSON, IO[bytes] Required.
        :type site_source_control: ~azure.mgmt.web.models.SiteSourceControl or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns SiteSourceControl. The SiteSourceControl is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.SiteSourceControl]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteSourceControl] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_source_control_initial(
                resource_group_name=resource_group_name,
                name=name,
                site_source_control=site_source_control,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.SiteSourceControl, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.SiteSourceControl].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.SiteSourceControl](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update_source_control(
        self,
        resource_group_name: str,
        name: str,
        site_source_control: _models.SiteSourceControl,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteSourceControl:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: ~azure.mgmt.web.models.SiteSourceControl
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteSourceControl. The SiteSourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteSourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_source_control(
        self,
        resource_group_name: str,
        name: str,
        site_source_control: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteSourceControl:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteSourceControl. The SiteSourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteSourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_source_control(
        self,
        resource_group_name: str,
        name: str,
        site_source_control: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SiteSourceControl:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example.
         Required.
        :type site_source_control: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SiteSourceControl. The SiteSourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteSourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_source_control(
        self,
        resource_group_name: str,
        name: str,
        site_source_control: Union[_models.SiteSourceControl, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.SiteSourceControl:
        """Updates the source control configuration of an app.

        Description for Updates the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :param site_source_control: JSON representation of a SiteSourceControl object. See example. Is
         one of the following types: SiteSourceControl, JSON, IO[bytes] Required.
        :type site_source_control: ~azure.mgmt.web.models.SiteSourceControl or JSON or IO[bytes]
        :return: SiteSourceControl. The SiteSourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SiteSourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SiteSourceControl] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(site_source_control, (IOBase, bytes)):
            _content = site_source_control
        else:
            _content = json.dumps(site_source_control, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_apps_update_source_control_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SiteSourceControl, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_source_control(
        self, resource_group_name: str, name: str, *, additional_flags: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Deletes the source control configuration of an app.

        Description for Deletes the source control configuration of an app.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the app. Required.
        :type name: str
        :keyword additional_flags: Default value is None.
        :paramtype additional_flags: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_source_control_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            additional_flags=additional_flags,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_triggered_web_job_slot(
        self, resource_group_name: str, name: str, web_job_name: str, slot: str, **kwargs: Any
    ) -> _models.TriggeredWebJob:
        """Gets a triggered web job by its ID for an app, or a deployment slot.

        Description for Gets a triggered web job by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API uses the
         production slot. Required.
        :type slot: str
        :return: TriggeredWebJob. The TriggeredWebJob is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.TriggeredWebJob
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TriggeredWebJob] = kwargs.pop("cls", None)

        _request = build_web_apps_get_triggered_web_job_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TriggeredWebJob, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_triggered_web_job_slot(
        self, resource_group_name: str, name: str, web_job_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Delete a triggered web job by its ID for an app, or a deployment slot.

        Description for Delete a triggered web job by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API uses the
         production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_triggered_web_job_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_triggered_web_jobs_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.TriggeredWebJob"]:
        """List triggered web jobs for an app, or a deployment slot.

        Description for List triggered web jobs for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API uses the
         production slot. Required.
        :type slot: str
        :return: An iterator like instance of TriggeredWebJob
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.TriggeredWebJob]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.TriggeredWebJob]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_triggered_web_jobs_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.TriggeredWebJob], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def run_triggered_web_job_slot(
        self, resource_group_name: str, name: str, web_job_name: str, slot: str, **kwargs: Any
    ) -> None:
        """Run a triggered web job for an app, or a deployment slot.

        Description for Run a triggered web job for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API uses the
         production slot. Required.
        :type slot: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_run_triggered_web_job_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_triggered_web_job(
        self, resource_group_name: str, name: str, web_job_name: str, **kwargs: Any
    ) -> _models.TriggeredWebJob:
        """Gets a triggered web job by its ID for an app, or a deployment slot.

        Description for Gets a triggered web job by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :return: TriggeredWebJob. The TriggeredWebJob is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.TriggeredWebJob
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TriggeredWebJob] = kwargs.pop("cls", None)

        _request = build_web_apps_get_triggered_web_job_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TriggeredWebJob, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_triggered_web_job(
        self, resource_group_name: str, name: str, web_job_name: str, **kwargs: Any
    ) -> None:
        """Delete a triggered web job by its ID for an app, or a deployment slot.

        Description for Delete a triggered web job by its ID for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_delete_triggered_web_job_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_triggered_web_jobs(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.TriggeredWebJob"]:
        """List triggered web jobs for an app, or a deployment slot.

        Description for List triggered web jobs for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :return: An iterator like instance of TriggeredWebJob
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.TriggeredWebJob]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.TriggeredWebJob]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_triggered_web_jobs_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.TriggeredWebJob], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def run_triggered_web_job(
        self, resource_group_name: str, name: str, web_job_name: str, **kwargs: Any
    ) -> None:
        """Run a triggered web job for an app, or a deployment slot.

        Description for Run a triggered web job for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_web_apps_run_triggered_web_job_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_triggered_web_job_history_slot(
        self, resource_group_name: str, name: str, web_job_name: str, id: str, slot: str, **kwargs: Any
    ) -> _models.TriggeredJobHistory:
        """Gets a triggered web job's history by its ID for an app, , or a deployment slot.

        Description for Gets a triggered web job's history by its ID for an app, , or a deployment
        slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :param id: History ID. Required.
        :type id: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API uses the
         production slot. Required.
        :type slot: str
        :return: TriggeredJobHistory. The TriggeredJobHistory is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.TriggeredJobHistory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TriggeredJobHistory] = kwargs.pop("cls", None)

        _request = build_web_apps_get_triggered_web_job_history_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            id=id,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TriggeredJobHistory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_triggered_web_job_history_slot(
        self, resource_group_name: str, name: str, web_job_name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.TriggeredJobHistory"]:
        """List a triggered web job's history for an app, or a deployment slot.

        Description for List a triggered web job's history for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API uses the
         production slot. Required.
        :type slot: str
        :return: An iterator like instance of TriggeredJobHistory
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.TriggeredJobHistory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.TriggeredJobHistory]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_triggered_web_job_history_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    web_job_name=web_job_name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.TriggeredJobHistory], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_triggered_web_job_history(
        self, resource_group_name: str, name: str, web_job_name: str, id: str, **kwargs: Any
    ) -> _models.TriggeredJobHistory:
        """Gets a triggered web job's history by its ID for an app, , or a deployment slot.

        Description for Gets a triggered web job's history by its ID for an app, , or a deployment
        slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :param id: History ID. Required.
        :type id: str
        :return: TriggeredJobHistory. The TriggeredJobHistory is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.TriggeredJobHistory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TriggeredJobHistory] = kwargs.pop("cls", None)

        _request = build_web_apps_get_triggered_web_job_history_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            id=id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TriggeredJobHistory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_triggered_web_job_history(
        self, resource_group_name: str, name: str, web_job_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.TriggeredJobHistory"]:
        """List a triggered web job's history for an app, or a deployment slot.

        Description for List a triggered web job's history for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of Web Job. Required.
        :type web_job_name: str
        :return: An iterator like instance of TriggeredJobHistory
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.TriggeredJobHistory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.TriggeredJobHistory]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_triggered_web_job_history_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    web_job_name=web_job_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.TriggeredJobHistory], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_web_job_slot(
        self, resource_group_name: str, name: str, web_job_name: str, slot: str, **kwargs: Any
    ) -> _models.WebJob:
        """Get webjob information for an app, or a deployment slot.

        Description for Get webjob information for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of the web job. Required.
        :type web_job_name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :return: WebJob. The WebJob is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WebJob
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WebJob] = kwargs.pop("cls", None)

        _request = build_web_apps_get_web_job_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WebJob, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_web_jobs_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.WebJob"]:
        """List webjobs for an app, or a deployment slot.

        Description for List webjobs for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API returns
         deployments for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of WebJob
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WebJob]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WebJob]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_web_jobs_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WebJob], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_web_job(
        self, resource_group_name: str, name: str, web_job_name: str, **kwargs: Any
    ) -> _models.WebJob:
        """Get webjob information for an app, or a deployment slot.

        Description for Get webjob information for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param web_job_name: Name of the web job. Required.
        :type web_job_name: str
        :return: WebJob. The WebJob is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WebJob
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WebJob] = kwargs.pop("cls", None)

        _request = build_web_apps_get_web_job_request(
            resource_group_name=resource_group_name,
            name=name,
            web_job_name=web_job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WebJob, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_web_jobs(self, resource_group_name: str, name: str, **kwargs: Any) -> AsyncItemPaged["_models.WebJob"]:
        """List webjobs for an app, or a deployment slot.

        Description for List webjobs for an app, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :return: An iterator like instance of WebJob
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WebJob]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WebJob]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_web_jobs_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WebJob], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_instance_workflow_slot(
        self, resource_group_name: str, name: str, slot: str, workflow_name: str, **kwargs: Any
    ) -> _models.WorkflowEnvelope:
        """Get workflow information by its ID for web site, or a deployment slot.

        Get workflow information by its ID for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param slot: Name of the deployment slot. Required.
        :type slot: str
        :param workflow_name: Workflow name. Required.
        :type workflow_name: str
        :return: WorkflowEnvelope. The WorkflowEnvelope is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowEnvelope
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowEnvelope] = kwargs.pop("cls", None)

        _request = build_web_apps_get_instance_workflow_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            workflow_name=workflow_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowEnvelope, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_instance_workflows_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.WorkflowEnvelope"]:
        """List the workflows for a web site, or a deployment slot.

        List the workflows for a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param slot: Name of the deployment slot. Required.
        :type slot: str
        :return: An iterator like instance of WorkflowEnvelope
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WorkflowEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkflowEnvelope]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_instance_workflows_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkflowEnvelope], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_workflow(
        self, resource_group_name: str, name: str, workflow_name: str, **kwargs: Any
    ) -> _models.WorkflowEnvelope:
        """Get workflow information by its ID for web site, or a deployment slot.

        Get workflow information by its ID for web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: Workflow name. Required.
        :type workflow_name: str
        :return: WorkflowEnvelope. The WorkflowEnvelope is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowEnvelope
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowEnvelope] = kwargs.pop("cls", None)

        _request = build_web_apps_get_workflow_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowEnvelope, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_workflows(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.WorkflowEnvelope"]:
        """List the workflows for a web site, or a deployment slot.

        List the workflows for a web site, or a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :return: An iterator like instance of WorkflowEnvelope
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WorkflowEnvelope]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkflowEnvelope]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_apps_list_workflows_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkflowEnvelope], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class AppServicePlansOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`app_service_plans` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_server_farm_rdp_password(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.ServerFarmRdpDetails:
        """Get the RDP password for an IsCustomMode ServerFarm.

        Description for Get the RDP password for an IsCustomMode ServerFarm.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :return: ServerFarmRdpDetails. The ServerFarmRdpDetails is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ServerFarmRdpDetails
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ServerFarmRdpDetails] = kwargs.pop("cls", None)

        _request = build_app_service_plans_get_server_farm_rdp_password_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ServerFarmRdpDetails, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def recycle_managed_instance_worker(
        self, resource_group_name: str, name: str, worker_name: str, **kwargs: Any
    ) -> _models.Operation:
        """Recycles a managed instance worker machine.

        Description for Recycles a managed instance worker machine.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: App Service plan. Required.
        :type name: str
        :param worker_name: Name of worker machine, which typically starts with RD. Required.
        :type worker_name: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        _request = build_app_service_plans_recycle_managed_instance_worker_request(
            resource_group_name=resource_group_name,
            name=name,
            worker_name=worker_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_server_farm_instance_details(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.ServerFarmInstanceDetails:
        """Get the instance details for an app service plan.

        Description for Get the instance details for an app service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :return: ServerFarmInstanceDetails. The ServerFarmInstanceDetails is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ServerFarmInstanceDetails
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ServerFarmInstanceDetails] = kwargs.pop("cls", None)

        _request = build_app_service_plans_get_server_farm_instance_details_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ServerFarmInstanceDetails, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.AppServicePlan:
        """Get an App Service plan.

        Description for Get an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :return: AppServicePlan. The AppServicePlan is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AppServicePlan
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AppServicePlan] = kwargs.pop("cls", None)

        _request = build_app_service_plans_get_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AppServicePlan, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        name: str,
        app_service_plan: Union[_models.AppServicePlan, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(app_service_plan, (IOBase, bytes)):
            _content = app_service_plan
        else:
            _content = json.dumps(app_service_plan, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_plans_create_or_update_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        app_service_plan: _models.AppServicePlan,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AppServicePlan]:
        """Creates or updates an App Service Plan.

        Description for Creates or updates an App Service Plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param app_service_plan: Details of the App Service plan. Required.
        :type app_service_plan: ~azure.mgmt.web.models.AppServicePlan
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns AppServicePlan. The AppServicePlan is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.AppServicePlan]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        app_service_plan: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AppServicePlan]:
        """Creates or updates an App Service Plan.

        Description for Creates or updates an App Service Plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param app_service_plan: Details of the App Service plan. Required.
        :type app_service_plan: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns AppServicePlan. The AppServicePlan is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.AppServicePlan]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        app_service_plan: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AppServicePlan]:
        """Creates or updates an App Service Plan.

        Description for Creates or updates an App Service Plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param app_service_plan: Details of the App Service plan. Required.
        :type app_service_plan: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns AppServicePlan. The AppServicePlan is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.AppServicePlan]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        app_service_plan: Union[_models.AppServicePlan, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AppServicePlan]:
        """Creates or updates an App Service Plan.

        Description for Creates or updates an App Service Plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param app_service_plan: Details of the App Service plan. Is one of the following types:
         AppServicePlan, JSON, IO[bytes] Required.
        :type app_service_plan: ~azure.mgmt.web.models.AppServicePlan or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns AppServicePlan. The AppServicePlan is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.AppServicePlan]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AppServicePlan] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                name=name,
                app_service_plan=app_service_plan,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.AppServicePlan, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.AppServicePlan].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.AppServicePlan](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        app_service_plan: _models.AppServicePlanPatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AppServicePlan:
        """Creates or updates an App Service Plan.

        Description for Creates or updates an App Service Plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param app_service_plan: Details of the App Service plan. Required.
        :type app_service_plan: ~azure.mgmt.web.models.AppServicePlanPatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AppServicePlan. The AppServicePlan is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AppServicePlan
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        app_service_plan: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AppServicePlan:
        """Creates or updates an App Service Plan.

        Description for Creates or updates an App Service Plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param app_service_plan: Details of the App Service plan. Required.
        :type app_service_plan: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AppServicePlan. The AppServicePlan is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AppServicePlan
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        app_service_plan: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AppServicePlan:
        """Creates or updates an App Service Plan.

        Description for Creates or updates an App Service Plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param app_service_plan: Details of the App Service plan. Required.
        :type app_service_plan: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AppServicePlan. The AppServicePlan is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AppServicePlan
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        name: str,
        app_service_plan: Union[_models.AppServicePlanPatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.AppServicePlan:
        """Creates or updates an App Service Plan.

        Description for Creates or updates an App Service Plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param app_service_plan: Details of the App Service plan. Is one of the following types:
         AppServicePlanPatchResource, JSON, IO[bytes] Required.
        :type app_service_plan: ~azure.mgmt.web.models.AppServicePlanPatchResource or JSON or IO[bytes]
        :return: AppServicePlan. The AppServicePlan is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AppServicePlan
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AppServicePlan] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(app_service_plan, (IOBase, bytes)):
            _content = app_service_plan
        else:
            _content = json.dumps(app_service_plan, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_plans_update_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AppServicePlan, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Delete an App Service plan.

        Description for Delete an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_app_service_plans_delete_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_by_resource_group(
        self, resource_group_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.AppServicePlan"]:
        """Get all App Service plans in a resource group.

        Description for Get all App Service plans in a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of AppServicePlan
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.AppServicePlan]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AppServicePlan]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_plans_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AppServicePlan], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list(self, *, detailed: Optional[bool] = None, **kwargs: Any) -> AsyncItemPaged["_models.AppServicePlan"]:
        """Get all App Service plans for a subscription.

        Description for Get all App Service plans for a subscription.

        :keyword detailed: Specify <code>true</code> to return all App Service plan properties. The
         default is <code>false</code>, which returns a subset of the properties.
         Retrieval of all properties may increase the API latency. Default value is None.
        :paramtype detailed: bool
        :return: An iterator like instance of AppServicePlan
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.AppServicePlan]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AppServicePlan]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_plans_list_request(
                    subscription_id=self._config.subscription_id,
                    detailed=detailed,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AppServicePlan], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_capabilities(self, resource_group_name: str, name: str, **kwargs: Any) -> List[_models.Capability]:
        """List all capabilities of an App Service plan.

        Description for List all capabilities of an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :return: list of Capability
        :rtype: list[~azure.mgmt.web.models.Capability]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Capability]] = kwargs.pop("cls", None)

        _request = build_app_service_plans_list_capabilities_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.Capability], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_hybrid_connections(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.HybridConnection"]:
        """Retrieve all Hybrid Connections in use in an App Service plan.

        Description for Retrieve all Hybrid Connections in use in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :return: An iterator like instance of HybridConnection
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.HybridConnection]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.HybridConnection]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_plans_list_hybrid_connections_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.HybridConnection], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def restart_web_apps(
        self, resource_group_name: str, name: str, *, soft_restart: Optional[bool] = None, **kwargs: Any
    ) -> None:
        """Restart all apps in an App Service plan.

        Description for Restart all apps in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :keyword soft_restart: Specify <code>true</code> to perform a soft restart, applies the
         configuration settings and restarts the apps if necessary. The default is <code>false</code>,
         which always restarts and reprovisions the apps. Default value is None.
        :paramtype soft_restart: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_app_service_plans_restart_web_apps_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            soft_restart=soft_restart,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_web_apps(
        self,
        resource_group_name: str,
        name: str,
        *,
        skip_token: Optional[str] = None,
        filter: Optional[str] = None,
        top: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.Site"]:
        """Get all apps associated with an App Service plan.

        Description for Get all apps associated with an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :keyword skip_token: Skip to a web app in the list of webapps associated with app service plan.
         If specified, the resulting list will contain web apps starting from (including) the skipToken.
         Otherwise, the resulting list contains web apps from the start of the list. Default value is
         None.
        :paramtype skip_token: str
        :keyword filter: Supported filter: $filter=state eq running. Returns only web apps that are
         currently running. Default value is None.
        :paramtype filter: str
        :keyword top: List page size. If specified, results are paged. Default value is None.
        :paramtype top: str
        :return: An iterator like instance of Site
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Site]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Site]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_plans_list_web_apps_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    skip_token=skip_token,
                    filter=filter,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Site], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_server_farm_skus(self, resource_group_name: str, name: str, **kwargs: Any) -> Any:
        """Gets all selectable SKUs for a given App Service Plan.

        Description for Gets all selectable SKUs for a given App Service Plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_app_service_plans_get_server_farm_skus_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Any, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_usages(
        self, resource_group_name: str, name: str, *, filter: Optional[str] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.CsmUsageQuota"]:
        """Gets server farm usage information.

        Description for Gets server farm usage information.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :keyword filter: Return only usages/metrics specified in the filter. Filter conforms to odata
         syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2'). Default value is
         None.
        :paramtype filter: str
        :return: An iterator like instance of CsmUsageQuota
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.CsmUsageQuota]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CsmUsageQuota]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_plans_list_usages_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CsmUsageQuota], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def reboot_worker(self, resource_group_name: str, name: str, worker_name: str, **kwargs: Any) -> None:
        """Reboot a worker machine in an App Service plan.

        Description for Reboot a worker machine in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: App Service plan. Required.
        :type name: str
        :param worker_name: Name of worker machine, which typically starts with RD. Required.
        :type worker_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_app_service_plans_reboot_worker_request(
            resource_group_name=resource_group_name,
            name=name,
            worker_name=worker_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_hybrid_connection(
        self, resource_group_name: str, name: str, namespace_name: str, relay_name: str, **kwargs: Any
    ) -> _models.HybridConnection:
        """Retrieve a Hybrid Connection in use in an App Service plan.

        Description for Retrieve a Hybrid Connection in use in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param namespace_name: Name of the Service Bus namespace. Required.
        :type namespace_name: str
        :param relay_name: Name of the Service Bus relay. Required.
        :type relay_name: str
        :return: HybridConnection. The HybridConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HybridConnection] = kwargs.pop("cls", None)

        _request = build_app_service_plans_get_hybrid_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            namespace_name=namespace_name,
            relay_name=relay_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HybridConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_hybrid_connection(
        self, resource_group_name: str, name: str, namespace_name: str, relay_name: str, **kwargs: Any
    ) -> None:
        """Delete a Hybrid Connection in use in an App Service plan.

        Description for Delete a Hybrid Connection in use in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param namespace_name: Name of the Service Bus namespace. Required.
        :type namespace_name: str
        :param relay_name: Name of the Service Bus relay. Required.
        :type relay_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_app_service_plans_delete_hybrid_connection_request(
            resource_group_name=resource_group_name,
            name=name,
            namespace_name=namespace_name,
            relay_name=relay_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_hybrid_connection_keys(
        self, resource_group_name: str, name: str, namespace_name: str, relay_name: str, **kwargs: Any
    ) -> _models.HybridConnectionKey:
        """Get the send key name and value of a Hybrid Connection.

        Description for Get the send key name and value of a Hybrid Connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param namespace_name: Name of the Service Bus namespace. Required.
        :type namespace_name: str
        :param relay_name: Name of the Service Bus relay. Required.
        :type relay_name: str
        :return: HybridConnectionKey. The HybridConnectionKey is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnectionKey
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HybridConnectionKey] = kwargs.pop("cls", None)

        _request = build_app_service_plans_list_hybrid_connection_keys_request(
            resource_group_name=resource_group_name,
            name=name,
            namespace_name=namespace_name,
            relay_name=relay_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HybridConnectionKey, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_web_apps_by_hybrid_connection(
        self, resource_group_name: str, name: str, namespace_name: str, relay_name: str, **kwargs: Any
    ) -> AsyncItemPaged[str]:
        """Get all apps that use a Hybrid Connection in an App Service Plan.

        Description for Get all apps that use a Hybrid Connection in an App Service Plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param namespace_name: Name of the Service Bus namespace. Required.
        :type namespace_name: str
        :param relay_name: Name of the Service Bus relay. Required.
        :type relay_name: str
        :return: An iterator like instance of str
        :rtype: ~azure.core.async_paging.AsyncItemPaged[str]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[str]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_app_service_plans_list_web_apps_by_hybrid_connection_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    namespace_name=namespace_name,
                    relay_name=relay_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[str], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_hybrid_connection_plan_limit(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> _models.HybridConnectionLimits:
        """Get the maximum number of Hybrid Connections allowed in an App Service plan.

        Description for Get the maximum number of Hybrid Connections allowed in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :return: HybridConnectionLimits. The HybridConnectionLimits is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.HybridConnectionLimits
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HybridConnectionLimits] = kwargs.pop("cls", None)

        _request = build_app_service_plans_get_hybrid_connection_plan_limit_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HybridConnectionLimits, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_vnet_from_server_farm(
        self, resource_group_name: str, name: str, vnet_name: str, **kwargs: Any
    ) -> _models.VnetInfoResource:
        """Get a Virtual Network associated with an App Service plan.

        Description for Get a Virtual Network associated with an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :return: VnetInfoResource. The VnetInfoResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetInfoResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VnetInfoResource] = kwargs.pop("cls", None)

        _request = build_app_service_plans_get_vnet_from_server_farm_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetInfoResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_vnets(self, resource_group_name: str, name: str, **kwargs: Any) -> List[_models.VnetInfoResource]:
        """Get all Virtual Networks associated with an App Service plan.

        Description for Get all Virtual Networks associated with an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :return: list of VnetInfoResource
        :rtype: list[~azure.mgmt.web.models.VnetInfoResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VnetInfoResource]] = kwargs.pop("cls", None)

        _request = build_app_service_plans_list_vnets_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.VnetInfoResource], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_vnet_gateway(
        self, resource_group_name: str, name: str, vnet_name: str, gateway_name: str, **kwargs: Any
    ) -> _models.VnetGateway:
        """Get a Virtual Network gateway.

        Description for Get a Virtual Network gateway.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Only the 'primary' gateway is supported. Required.
        :type gateway_name: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VnetGateway] = kwargs.pop("cls", None)

        _request = build_app_service_plans_get_vnet_gateway_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            gateway_name=gateway_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetGateway, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_vnet_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: _models.VnetGateway,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Update a Virtual Network gateway.

        Description for Update a Virtual Network gateway.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Only the 'primary' gateway is supported. Required.
        :type gateway_name: str
        :param connection_envelope: Definition of the gateway. Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetGateway
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Update a Virtual Network gateway.

        Description for Update a Virtual Network gateway.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Only the 'primary' gateway is supported. Required.
        :type gateway_name: str
        :param connection_envelope: Definition of the gateway. Required.
        :type connection_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Update a Virtual Network gateway.

        Description for Update a Virtual Network gateway.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Only the 'primary' gateway is supported. Required.
        :type gateway_name: str
        :param connection_envelope: Definition of the gateway. Required.
        :type connection_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_vnet_gateway(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        gateway_name: str,
        connection_envelope: Union[_models.VnetGateway, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.VnetGateway:
        """Update a Virtual Network gateway.

        Description for Update a Virtual Network gateway.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param gateway_name: Name of the gateway. Only the 'primary' gateway is supported. Required.
        :type gateway_name: str
        :param connection_envelope: Definition of the gateway. Is one of the following types:
         VnetGateway, JSON, IO[bytes] Required.
        :type connection_envelope: ~azure.mgmt.web.models.VnetGateway or JSON or IO[bytes]
        :return: VnetGateway. The VnetGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetGateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetGateway] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(connection_envelope, (IOBase, bytes)):
            _content = connection_envelope
        else:
            _content = json.dumps(connection_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_plans_update_vnet_gateway_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            gateway_name=gateway_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetGateway, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_route_for_vnet(
        self, resource_group_name: str, name: str, vnet_name: str, route_name: str, **kwargs: Any
    ) -> List[_models.VnetRoute]:
        """Get a Virtual Network route in an App Service plan.

        Description for Get a Virtual Network route in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param route_name: Name of the Virtual Network route. Required.
        :type route_name: str
        :return: list of VnetRoute
        :rtype: list[~azure.mgmt.web.models.VnetRoute]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VnetRoute]] = kwargs.pop("cls", None)

        _request = build_app_service_plans_get_route_for_vnet_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            route_name=route_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.VnetRoute], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_vnet_route(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        route_name: str,
        route: _models.VnetRoute,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetRoute:
        """Create or update a Virtual Network route in an App Service plan.

        Description for Create or update a Virtual Network route in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param route_name: Name of the Virtual Network route. Required.
        :type route_name: str
        :param route: Definition of the Virtual Network route. Required.
        :type route: ~azure.mgmt.web.models.VnetRoute
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetRoute. The VnetRoute is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetRoute
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_vnet_route(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        route_name: str,
        route: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetRoute:
        """Create or update a Virtual Network route in an App Service plan.

        Description for Create or update a Virtual Network route in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param route_name: Name of the Virtual Network route. Required.
        :type route_name: str
        :param route: Definition of the Virtual Network route. Required.
        :type route: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetRoute. The VnetRoute is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetRoute
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_vnet_route(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        route_name: str,
        route: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetRoute:
        """Create or update a Virtual Network route in an App Service plan.

        Description for Create or update a Virtual Network route in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param route_name: Name of the Virtual Network route. Required.
        :type route_name: str
        :param route: Definition of the Virtual Network route. Required.
        :type route: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetRoute. The VnetRoute is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetRoute
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_vnet_route(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        route_name: str,
        route: Union[_models.VnetRoute, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.VnetRoute:
        """Create or update a Virtual Network route in an App Service plan.

        Description for Create or update a Virtual Network route in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param route_name: Name of the Virtual Network route. Required.
        :type route_name: str
        :param route: Definition of the Virtual Network route. Is one of the following types:
         VnetRoute, JSON, IO[bytes] Required.
        :type route: ~azure.mgmt.web.models.VnetRoute or JSON or IO[bytes]
        :return: VnetRoute. The VnetRoute is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetRoute
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetRoute] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(route, (IOBase, bytes)):
            _content = route
        else:
            _content = json.dumps(route, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_plans_create_or_update_vnet_route_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            route_name=route_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetRoute, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_vnet_route(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        route_name: str,
        route: _models.VnetRoute,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetRoute:
        """Create or update a Virtual Network route in an App Service plan.

        Description for Create or update a Virtual Network route in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param route_name: Name of the Virtual Network route. Required.
        :type route_name: str
        :param route: Definition of the Virtual Network route. Required.
        :type route: ~azure.mgmt.web.models.VnetRoute
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetRoute. The VnetRoute is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetRoute
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_route(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        route_name: str,
        route: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetRoute:
        """Create or update a Virtual Network route in an App Service plan.

        Description for Create or update a Virtual Network route in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param route_name: Name of the Virtual Network route. Required.
        :type route_name: str
        :param route: Definition of the Virtual Network route. Required.
        :type route: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetRoute. The VnetRoute is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetRoute
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_vnet_route(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        route_name: str,
        route: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VnetRoute:
        """Create or update a Virtual Network route in an App Service plan.

        Description for Create or update a Virtual Network route in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param route_name: Name of the Virtual Network route. Required.
        :type route_name: str
        :param route: Definition of the Virtual Network route. Required.
        :type route: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetRoute. The VnetRoute is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetRoute
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_vnet_route(
        self,
        resource_group_name: str,
        name: str,
        vnet_name: str,
        route_name: str,
        route: Union[_models.VnetRoute, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.VnetRoute:
        """Create or update a Virtual Network route in an App Service plan.

        Description for Create or update a Virtual Network route in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param route_name: Name of the Virtual Network route. Required.
        :type route_name: str
        :param route: Definition of the Virtual Network route. Is one of the following types:
         VnetRoute, JSON, IO[bytes] Required.
        :type route: ~azure.mgmt.web.models.VnetRoute or JSON or IO[bytes]
        :return: VnetRoute. The VnetRoute is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetRoute
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetRoute] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(route, (IOBase, bytes)):
            _content = route
        else:
            _content = json.dumps(route, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_app_service_plans_update_vnet_route_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            route_name=route_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetRoute, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_vnet_route(
        self, resource_group_name: str, name: str, vnet_name: str, route_name: str, **kwargs: Any
    ) -> None:
        """Delete a Virtual Network route in an App Service plan.

        Description for Delete a Virtual Network route in an App Service plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :param route_name: Name of the Virtual Network route. Required.
        :type route_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_app_service_plans_delete_vnet_route_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            route_name=route_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_routes_for_vnet(
        self, resource_group_name: str, name: str, vnet_name: str, **kwargs: Any
    ) -> List[_models.VnetRoute]:
        """Get all routes that are associated with a Virtual Network in an App Service plan.

        Description for Get all routes that are associated with a Virtual Network in an App Service
        plan.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the App Service plan. Required.
        :type name: str
        :param vnet_name: Name of the Virtual Network. Required.
        :type vnet_name: str
        :return: list of VnetRoute
        :rtype: list[~azure.mgmt.web.models.VnetRoute]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VnetRoute]] = kwargs.pop("cls", None)

        _request = build_app_service_plans_list_routes_for_vnet_request(
            resource_group_name=resource_group_name,
            name=name,
            vnet_name=vnet_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.VnetRoute], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class CertificatesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`certificates` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.Certificate:
        """Get a certificate.

        Description for Get a certificate.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the certificate. Required.
        :type name: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Certificate] = kwargs.pop("cls", None)

        _request = build_certificates_get_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Certificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        name: str,
        certificate_envelope: _models.Certificate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate.

        Description for Create or update a certificate.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the certificate. Required.
        :type name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: ~azure.mgmt.web.models.Certificate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        name: str,
        certificate_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate.

        Description for Create or update a certificate.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the certificate. Required.
        :type name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        name: str,
        certificate_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate.

        Description for Create or update a certificate.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the certificate. Required.
        :type name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        resource_group_name: str,
        name: str,
        certificate_envelope: Union[_models.Certificate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate.

        Description for Create or update a certificate.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the certificate. Required.
        :type name: str
        :param certificate_envelope: Details of certificate, if it exists already. Is one of the
         following types: Certificate, JSON, IO[bytes] Required.
        :type certificate_envelope: ~azure.mgmt.web.models.Certificate or JSON or IO[bytes]
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Certificate] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(certificate_envelope, (IOBase, bytes)):
            _content = certificate_envelope
        else:
            _content = json.dumps(certificate_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_certificates_create_or_update_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Certificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        certificate_envelope: _models.CertificatePatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate.

        Description for Create or update a certificate.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the certificate. Required.
        :type name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: ~azure.mgmt.web.models.CertificatePatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        certificate_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate.

        Description for Create or update a certificate.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the certificate. Required.
        :type name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        certificate_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate.

        Description for Create or update a certificate.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the certificate. Required.
        :type name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        name: str,
        certificate_envelope: Union[_models.CertificatePatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate.

        Description for Create or update a certificate.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the certificate. Required.
        :type name: str
        :param certificate_envelope: Details of certificate, if it exists already. Is one of the
         following types: CertificatePatchResource, JSON, IO[bytes] Required.
        :type certificate_envelope: ~azure.mgmt.web.models.CertificatePatchResource or JSON or
         IO[bytes]
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Certificate] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(certificate_envelope, (IOBase, bytes)):
            _content = certificate_envelope
        else:
            _content = json.dumps(certificate_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_certificates_update_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Certificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, resource_group_name: str, name: str, **kwargs: Any) -> None:
        """Delete a certificate.

        Description for Delete a certificate.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the certificate. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_certificates_delete_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncItemPaged["_models.Certificate"]:
        """Get all certificates in a resource group.

        Description for Get all certificates in a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of Certificate
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Certificate]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Certificate]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_certificates_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Certificate], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list(self, *, filter: Optional[str] = None, **kwargs: Any) -> AsyncItemPaged["_models.Certificate"]:
        """Get all certificates for a subscription.

        Description for Get all certificates for a subscription.

        :keyword filter: Return only information specified in the filter (using OData syntax). For
         example: $filter=KeyVaultId eq 'KeyVaultId'. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of Certificate
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Certificate]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Certificate]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_certificates_list_request(
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Certificate], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class SiteCertificatesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`site_certificates` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, name: str, certificate_name: str, **kwargs: Any
    ) -> _models.Certificate:
        """Get a certificate belonging to a given site.

        Get a certificate belonging to a given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Certificate] = kwargs.pop("cls", None)

        _request = build_site_certificates_get_request(
            resource_group_name=resource_group_name,
            name=name,
            certificate_name=certificate_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Certificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        name: str,
        certificate_name: str,
        certificate_envelope: _models.Certificate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate under a given site.

        Create or update a certificate under a given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: ~azure.mgmt.web.models.Certificate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        name: str,
        certificate_name: str,
        certificate_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate under a given site.

        Create or update a certificate under a given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        name: str,
        certificate_name: str,
        certificate_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate under a given site.

        Create or update a certificate under a given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        resource_group_name: str,
        name: str,
        certificate_name: str,
        certificate_envelope: Union[_models.Certificate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate under a given site.

        Create or update a certificate under a given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Is one of the
         following types: Certificate, JSON, IO[bytes] Required.
        :type certificate_envelope: ~azure.mgmt.web.models.Certificate or JSON or IO[bytes]
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Certificate] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(certificate_envelope, (IOBase, bytes)):
            _content = certificate_envelope
        else:
            _content = json.dumps(certificate_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_site_certificates_create_or_update_request(
            resource_group_name=resource_group_name,
            name=name,
            certificate_name=certificate_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Certificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        certificate_name: str,
        certificate_envelope: _models.CertificatePatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate under a given site.

        Create or update a certificate under a given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: ~azure.mgmt.web.models.CertificatePatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        certificate_name: str,
        certificate_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate under a given site.

        Create or update a certificate under a given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        certificate_name: str,
        certificate_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate under a given site.

        Create or update a certificate under a given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        name: str,
        certificate_name: str,
        certificate_envelope: Union[_models.CertificatePatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate under a given site.

        Create or update a certificate under a given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Is one of the
         following types: CertificatePatchResource, JSON, IO[bytes] Required.
        :type certificate_envelope: ~azure.mgmt.web.models.CertificatePatchResource or JSON or
         IO[bytes]
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Certificate] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(certificate_envelope, (IOBase, bytes)):
            _content = certificate_envelope
        else:
            _content = json.dumps(certificate_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_site_certificates_update_request(
            resource_group_name=resource_group_name,
            name=name,
            certificate_name=certificate_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Certificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, resource_group_name: str, name: str, certificate_name: str, **kwargs: Any) -> None:
        """Delete a certificate from the site.

        Delete a certificate from the site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_site_certificates_delete_request(
            resource_group_name=resource_group_name,
            name=name,
            certificate_name=certificate_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list(self, resource_group_name: str, name: str, **kwargs: Any) -> AsyncItemPaged["_models.Certificate"]:
        """Get all certificates in a resource group under a site.

        Get all certificates in a resource group under a site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :return: An iterator like instance of Certificate
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Certificate]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Certificate]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_site_certificates_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Certificate], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_slot(
        self, resource_group_name: str, name: str, slot: str, certificate_name: str, **kwargs: Any
    ) -> _models.Certificate:
        """Get a certificate for a given site and deployment slot.

        Get a certificate for a given site and deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will create a
         binding for the production slot. Required.
        :type slot: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Certificate] = kwargs.pop("cls", None)

        _request = build_site_certificates_get_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            certificate_name=certificate_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Certificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        certificate_name: str,
        certificate_envelope: _models.Certificate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate in a given site and deployment slot.

        Create or update a certificate in a given site and deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will create a
         binding for the production slot. Required.
        :type slot: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: ~azure.mgmt.web.models.Certificate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        certificate_name: str,
        certificate_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate in a given site and deployment slot.

        Create or update a certificate in a given site and deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will create a
         binding for the production slot. Required.
        :type slot: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        certificate_name: str,
        certificate_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate in a given site and deployment slot.

        Create or update a certificate in a given site and deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will create a
         binding for the production slot. Required.
        :type slot: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        certificate_name: str,
        certificate_envelope: Union[_models.Certificate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate in a given site and deployment slot.

        Create or update a certificate in a given site and deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will create a
         binding for the production slot. Required.
        :type slot: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Is one of the
         following types: Certificate, JSON, IO[bytes] Required.
        :type certificate_envelope: ~azure.mgmt.web.models.Certificate or JSON or IO[bytes]
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Certificate] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(certificate_envelope, (IOBase, bytes)):
            _content = certificate_envelope
        else:
            _content = json.dumps(certificate_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_site_certificates_create_or_update_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            certificate_name=certificate_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Certificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        certificate_name: str,
        certificate_envelope: _models.CertificatePatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate for a site and deployment slot.

        Create or update a certificate for a site and deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will create a
         binding for the production slot. Required.
        :type slot: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: ~azure.mgmt.web.models.CertificatePatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        certificate_name: str,
        certificate_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate for a site and deployment slot.

        Create or update a certificate for a site and deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will create a
         binding for the production slot. Required.
        :type slot: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        certificate_name: str,
        certificate_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate for a site and deployment slot.

        Create or update a certificate for a site and deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will create a
         binding for the production slot. Required.
        :type slot: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Required.
        :type certificate_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_slot(
        self,
        resource_group_name: str,
        name: str,
        slot: str,
        certificate_name: str,
        certificate_envelope: Union[_models.CertificatePatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Certificate:
        """Create or update a certificate for a site and deployment slot.

        Create or update a certificate for a site and deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will create a
         binding for the production slot. Required.
        :type slot: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :param certificate_envelope: Details of certificate, if it exists already. Is one of the
         following types: CertificatePatchResource, JSON, IO[bytes] Required.
        :type certificate_envelope: ~azure.mgmt.web.models.CertificatePatchResource or JSON or
         IO[bytes]
        :return: Certificate. The Certificate is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Certificate] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(certificate_envelope, (IOBase, bytes)):
            _content = certificate_envelope
        else:
            _content = json.dumps(certificate_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_site_certificates_update_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            certificate_name=certificate_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Certificate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_slot(
        self, resource_group_name: str, name: str, slot: str, certificate_name: str, **kwargs: Any
    ) -> None:
        """Delete a certificate for a given site and deployment slot.

        Delete a certificate for a given site and deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will create a
         binding for the production slot. Required.
        :type slot: str
        :param certificate_name: Name of the certificate. Required.
        :type certificate_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_site_certificates_delete_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            certificate_name=certificate_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.Certificate"]:
        """Get all certificates in a resource group for a given site and a deployment slot.

        Get all certificates in a resource group for a given site and a deployment slot.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the site. Required.
        :type name: str
        :param slot: Name of the deployment slot. If a slot is not specified, the API will create a
         binding for the production slot. Required.
        :type slot: str
        :return: An iterator like instance of Certificate
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Certificate]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Certificate]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_site_certificates_list_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Certificate], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class GlobalOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`global_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_deleted_web_app(self, deleted_site_id: str, **kwargs: Any) -> _models.DeletedSite:
        """Get deleted app for a subscription.

        Description for Get deleted app for a subscription.

        :param deleted_site_id: The numeric ID of the deleted app, e.g. 12345. Required.
        :type deleted_site_id: str
        :return: DeletedSite. The DeletedSite is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DeletedSite
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DeletedSite] = kwargs.pop("cls", None)

        _request = build_global_operations_get_deleted_web_app_request(
            deleted_site_id=deleted_site_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DeletedSite, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_deleted_web_app_snapshots(self, deleted_site_id: str, **kwargs: Any) -> List[_models.Snapshot]:
        """Get all deleted apps for a subscription.

        Description for Get all deleted apps for a subscription.

        :param deleted_site_id: The numeric ID of the deleted app, e.g. 12345. Required.
        :type deleted_site_id: str
        :return: list of Snapshot
        :rtype: list[~azure.mgmt.web.models.Snapshot]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Snapshot]] = kwargs.pop("cls", None)

        _request = build_global_operations_get_deleted_web_app_snapshots_request(
            deleted_site_id=deleted_site_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.Snapshot], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_subscription_operation_with_async_response(  # pylint: disable=name-too-long
        self, location: str, operation_id: str, **kwargs: Any
    ) -> None:
        """Gets an operation in a subscription and given region.

        Description for Gets an operation in a subscription and given region.

        :param location: The name of the Azure region. Required.
        :type location: str
        :param operation_id: Operation Id. Required.
        :type operation_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_global_operations_get_subscription_operation_with_async_response_request(
            location=location,
            operation_id=operation_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class DiagnosticsOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`diagnostics` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_site_detector_response(
        self,
        resource_group_name: str,
        site_name: str,
        detector_name: str,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        time_grain: Optional[str] = None,
        **kwargs: Any
    ) -> _models.DetectorResponse:
        """Get site detector response.

        Description for Get site detector response.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param detector_name: Detector Resource Name. Required.
        :type detector_name: str
        :keyword start_time: Start Time. Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: End Time. Default value is None.
        :paramtype end_time: ~datetime.datetime
        :keyword time_grain: Time Grain. Default value is None.
        :paramtype time_grain: str
        :return: DetectorResponse. The DetectorResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DetectorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DetectorResponse] = kwargs.pop("cls", None)

        _request = build_diagnostics_get_site_detector_response_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            detector_name=detector_name,
            subscription_id=self._config.subscription_id,
            start_time=start_time,
            end_time=end_time,
            time_grain=time_grain,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DetectorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_site_detector_responses(
        self, resource_group_name: str, site_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DetectorResponse"]:
        """List Site Detector Responses.

        Description for List Site Detector Responses.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :return: An iterator like instance of DetectorResponse
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DetectorResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DetectorResponse]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_diagnostics_list_site_detector_responses_request(
                    resource_group_name=resource_group_name,
                    site_name=site_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DetectorResponse], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_hosting_environment_detector_response(  # pylint: disable=name-too-long
        self,
        resource_group_name: str,
        name: str,
        detector_name: str,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        time_grain: Optional[str] = None,
        **kwargs: Any
    ) -> _models.DetectorResponse:
        """Get Hosting Environment Detector Response.

        Description for Get Hosting Environment Detector Response.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: App Service Environment Name. Required.
        :type name: str
        :param detector_name: Detector Resource Name. Required.
        :type detector_name: str
        :keyword start_time: Start Time. Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: End Time. Default value is None.
        :paramtype end_time: ~datetime.datetime
        :keyword time_grain: Time Grain. Default value is None.
        :paramtype time_grain: str
        :return: DetectorResponse. The DetectorResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DetectorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DetectorResponse] = kwargs.pop("cls", None)

        _request = build_diagnostics_get_hosting_environment_detector_response_request(
            resource_group_name=resource_group_name,
            name=name,
            detector_name=detector_name,
            subscription_id=self._config.subscription_id,
            start_time=start_time,
            end_time=end_time,
            time_grain=time_grain,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DetectorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_hosting_environment_detector_responses(  # pylint: disable=name-too-long
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DetectorResponse"]:
        """List Hosting Environment Detector Responses.

        Description for List Hosting Environment Detector Responses.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: App Service Environment Name. Required.
        :type name: str
        :return: An iterator like instance of DetectorResponse
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DetectorResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DetectorResponse]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_diagnostics_list_hosting_environment_detector_responses_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DetectorResponse], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_detector_response_slot(
        self,
        resource_group_name: str,
        site_name: str,
        detector_name: str,
        slot: str,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        time_grain: Optional[str] = None,
        **kwargs: Any
    ) -> _models.DetectorResponse:
        """Get site detector response.

        Description for Get site detector response.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param detector_name: Detector Resource Name. Required.
        :type detector_name: str
        :param slot: Slot Name. Required.
        :type slot: str
        :keyword start_time: Start Time. Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: End Time. Default value is None.
        :paramtype end_time: ~datetime.datetime
        :keyword time_grain: Time Grain. Default value is None.
        :paramtype time_grain: str
        :return: DetectorResponse. The DetectorResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DetectorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DetectorResponse] = kwargs.pop("cls", None)

        _request = build_diagnostics_get_site_detector_response_slot_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            detector_name=detector_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            start_time=start_time,
            end_time=end_time,
            time_grain=time_grain,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DetectorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_site_detector_responses_slot(
        self, resource_group_name: str, site_name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DetectorResponse"]:
        """List Site Detector Responses.

        Description for List Site Detector Responses.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param slot: Slot Name. Required.
        :type slot: str
        :return: An iterator like instance of DetectorResponse
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DetectorResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DetectorResponse]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_diagnostics_list_site_detector_responses_slot_request(
                    resource_group_name=resource_group_name,
                    site_name=site_name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DetectorResponse], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_diagnostic_category(
        self, resource_group_name: str, site_name: str, diagnostic_category: str, **kwargs: Any
    ) -> _models.DiagnosticCategory:
        """Get Diagnostics Category.

        Description for Get Diagnostics Category.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :return: DiagnosticCategory. The DiagnosticCategory is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DiagnosticCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DiagnosticCategory] = kwargs.pop("cls", None)

        _request = build_diagnostics_get_site_diagnostic_category_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            diagnostic_category=diagnostic_category,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DiagnosticCategory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_site_diagnostic_categories(
        self, resource_group_name: str, site_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DiagnosticCategory"]:
        """Get Diagnostics Categories.

        Description for Get Diagnostics Categories.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :return: An iterator like instance of DiagnosticCategory
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DiagnosticCategory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DiagnosticCategory]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_diagnostics_list_site_diagnostic_categories_request(
                    resource_group_name=resource_group_name,
                    site_name=site_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DiagnosticCategory], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_diagnostic_category_slot(
        self, resource_group_name: str, site_name: str, diagnostic_category: str, slot: str, **kwargs: Any
    ) -> _models.DiagnosticCategory:
        """Get Diagnostics Category.

        Description for Get Diagnostics Category.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :param slot: Slot Name. Required.
        :type slot: str
        :return: DiagnosticCategory. The DiagnosticCategory is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DiagnosticCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DiagnosticCategory] = kwargs.pop("cls", None)

        _request = build_diagnostics_get_site_diagnostic_category_slot_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            diagnostic_category=diagnostic_category,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DiagnosticCategory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_site_diagnostic_categories_slot(
        self, resource_group_name: str, site_name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DiagnosticCategory"]:
        """Get Diagnostics Categories.

        Description for Get Diagnostics Categories.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param slot: Slot Name. Required.
        :type slot: str
        :return: An iterator like instance of DiagnosticCategory
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DiagnosticCategory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DiagnosticCategory]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_diagnostics_list_site_diagnostic_categories_slot_request(
                    resource_group_name=resource_group_name,
                    site_name=site_name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DiagnosticCategory], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_site_analysis(
        self, resource_group_name: str, site_name: str, diagnostic_category: str, analysis_name: str, **kwargs: Any
    ) -> _models.AnalysisDefinition:
        """Get Site Analysis.

        Description for Get Site Analysis.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :param analysis_name: Analysis Name. Required.
        :type analysis_name: str
        :return: AnalysisDefinition. The AnalysisDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AnalysisDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AnalysisDefinition] = kwargs.pop("cls", None)

        _request = build_diagnostics_get_site_analysis_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            diagnostic_category=diagnostic_category,
            analysis_name=analysis_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AnalysisDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_site_analyses(
        self, resource_group_name: str, site_name: str, diagnostic_category: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.AnalysisDefinition"]:
        """Get Site Analyses.

        Description for Get Site Analyses.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :return: An iterator like instance of AnalysisDefinition
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.AnalysisDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AnalysisDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_diagnostics_list_site_analyses_request(
                    resource_group_name=resource_group_name,
                    site_name=site_name,
                    diagnostic_category=diagnostic_category,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AnalysisDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def execute_site_analysis(
        self,
        resource_group_name: str,
        site_name: str,
        diagnostic_category: str,
        analysis_name: str,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        time_grain: Optional[str] = None,
        **kwargs: Any
    ) -> _models.DiagnosticAnalysis:
        """Execute Analysis.

        Description for Execute Analysis.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :param analysis_name: Analysis Name. Required.
        :type analysis_name: str
        :keyword start_time: Start Time. Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: End Time. Default value is None.
        :paramtype end_time: ~datetime.datetime
        :keyword time_grain: Time Grain. Default value is None.
        :paramtype time_grain: str
        :return: DiagnosticAnalysis. The DiagnosticAnalysis is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DiagnosticAnalysis
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DiagnosticAnalysis] = kwargs.pop("cls", None)

        _request = build_diagnostics_execute_site_analysis_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            diagnostic_category=diagnostic_category,
            analysis_name=analysis_name,
            subscription_id=self._config.subscription_id,
            start_time=start_time,
            end_time=end_time,
            time_grain=time_grain,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DiagnosticAnalysis, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_site_analysis_slot(
        self,
        resource_group_name: str,
        site_name: str,
        diagnostic_category: str,
        analysis_name: str,
        slot: str,
        **kwargs: Any
    ) -> _models.AnalysisDefinition:
        """Get Site Analysis.

        Description for Get Site Analysis.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :param analysis_name: Analysis Name. Required.
        :type analysis_name: str
        :param slot: Slot - optional. Required.
        :type slot: str
        :return: AnalysisDefinition. The AnalysisDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.AnalysisDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AnalysisDefinition] = kwargs.pop("cls", None)

        _request = build_diagnostics_get_site_analysis_slot_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            diagnostic_category=diagnostic_category,
            analysis_name=analysis_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AnalysisDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_site_analyses_slot(
        self, resource_group_name: str, site_name: str, diagnostic_category: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.AnalysisDefinition"]:
        """Get Site Analyses.

        Description for Get Site Analyses.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :param slot: Slot - optional. Required.
        :type slot: str
        :return: An iterator like instance of AnalysisDefinition
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.AnalysisDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AnalysisDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_diagnostics_list_site_analyses_slot_request(
                    resource_group_name=resource_group_name,
                    site_name=site_name,
                    diagnostic_category=diagnostic_category,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AnalysisDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def execute_site_analysis_slot(
        self,
        resource_group_name: str,
        site_name: str,
        diagnostic_category: str,
        analysis_name: str,
        slot: str,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        time_grain: Optional[str] = None,
        **kwargs: Any
    ) -> _models.DiagnosticAnalysis:
        """Execute Analysis.

        Description for Execute Analysis.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :param analysis_name: Analysis Name. Required.
        :type analysis_name: str
        :param slot: Slot - optional. Required.
        :type slot: str
        :keyword start_time: Start Time. Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: End Time. Default value is None.
        :paramtype end_time: ~datetime.datetime
        :keyword time_grain: Time Grain. Default value is None.
        :paramtype time_grain: str
        :return: DiagnosticAnalysis. The DiagnosticAnalysis is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DiagnosticAnalysis
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DiagnosticAnalysis] = kwargs.pop("cls", None)

        _request = build_diagnostics_execute_site_analysis_slot_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            diagnostic_category=diagnostic_category,
            analysis_name=analysis_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            start_time=start_time,
            end_time=end_time,
            time_grain=time_grain,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DiagnosticAnalysis, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_site_detector(
        self, resource_group_name: str, site_name: str, diagnostic_category: str, detector_name: str, **kwargs: Any
    ) -> _models.DetectorDefinitionResource:
        """Get Detector.

        Description for Get Detector.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :param detector_name: Detector Name. Required.
        :type detector_name: str
        :return: DetectorDefinitionResource. The DetectorDefinitionResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.DetectorDefinitionResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DetectorDefinitionResource] = kwargs.pop("cls", None)

        _request = build_diagnostics_get_site_detector_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            diagnostic_category=diagnostic_category,
            detector_name=detector_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DetectorDefinitionResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_site_detectors(
        self, resource_group_name: str, site_name: str, diagnostic_category: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DetectorDefinitionResource"]:
        """Get Detectors.

        Description for Get Detectors.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :return: An iterator like instance of DetectorDefinitionResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DetectorDefinitionResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DetectorDefinitionResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_diagnostics_list_site_detectors_request(
                    resource_group_name=resource_group_name,
                    site_name=site_name,
                    diagnostic_category=diagnostic_category,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DetectorDefinitionResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def execute_site_detector(
        self,
        resource_group_name: str,
        site_name: str,
        detector_name: str,
        diagnostic_category: str,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        time_grain: Optional[str] = None,
        **kwargs: Any
    ) -> _models.DiagnosticDetectorResponse:
        """Execute Detector.

        Description for Execute Detector.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param detector_name: Detector Name. Required.
        :type detector_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :keyword start_time: Start Time. Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: End Time. Default value is None.
        :paramtype end_time: ~datetime.datetime
        :keyword time_grain: Time Grain. Default value is None.
        :paramtype time_grain: str
        :return: DiagnosticDetectorResponse. The DiagnosticDetectorResponse is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.DiagnosticDetectorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DiagnosticDetectorResponse] = kwargs.pop("cls", None)

        _request = build_diagnostics_execute_site_detector_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            detector_name=detector_name,
            diagnostic_category=diagnostic_category,
            subscription_id=self._config.subscription_id,
            start_time=start_time,
            end_time=end_time,
            time_grain=time_grain,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DiagnosticDetectorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_site_detector_slot(
        self,
        resource_group_name: str,
        site_name: str,
        diagnostic_category: str,
        detector_name: str,
        slot: str,
        **kwargs: Any
    ) -> _models.DetectorDefinitionResource:
        """Get Detector.

        Description for Get Detector.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :param detector_name: Detector Name. Required.
        :type detector_name: str
        :param slot: Slot Name. Required.
        :type slot: str
        :return: DetectorDefinitionResource. The DetectorDefinitionResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.DetectorDefinitionResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DetectorDefinitionResource] = kwargs.pop("cls", None)

        _request = build_diagnostics_get_site_detector_slot_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            diagnostic_category=diagnostic_category,
            detector_name=detector_name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DetectorDefinitionResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_site_detectors_slot(
        self, resource_group_name: str, site_name: str, diagnostic_category: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DetectorDefinitionResource"]:
        """Get Detectors.

        Description for Get Detectors.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :param slot: Slot Name. Required.
        :type slot: str
        :return: An iterator like instance of DetectorDefinitionResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DetectorDefinitionResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DetectorDefinitionResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_diagnostics_list_site_detectors_slot_request(
                    resource_group_name=resource_group_name,
                    site_name=site_name,
                    diagnostic_category=diagnostic_category,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DetectorDefinitionResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def execute_site_detector_slot(
        self,
        resource_group_name: str,
        site_name: str,
        detector_name: str,
        diagnostic_category: str,
        slot: str,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        time_grain: Optional[str] = None,
        **kwargs: Any
    ) -> _models.DiagnosticDetectorResponse:
        """Execute Detector.

        Description for Execute Detector.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param site_name: Site Name. Required.
        :type site_name: str
        :param detector_name: Detector Name. Required.
        :type detector_name: str
        :param diagnostic_category: Diagnostic Category. Required.
        :type diagnostic_category: str
        :param slot: Slot Name. Required.
        :type slot: str
        :keyword start_time: Start Time. Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: End Time. Default value is None.
        :paramtype end_time: ~datetime.datetime
        :keyword time_grain: Time Grain. Default value is None.
        :paramtype time_grain: str
        :return: DiagnosticDetectorResponse. The DiagnosticDetectorResponse is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.DiagnosticDetectorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DiagnosticDetectorResponse] = kwargs.pop("cls", None)

        _request = build_diagnostics_execute_site_detector_slot_request(
            resource_group_name=resource_group_name,
            site_name=site_name,
            detector_name=detector_name,
            diagnostic_category=diagnostic_category,
            slot=slot,
            subscription_id=self._config.subscription_id,
            start_time=start_time,
            end_time=end_time,
            time_grain=time_grain,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DiagnosticDetectorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class KubeEnvironmentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`kube_environments` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.KubeEnvironment:
        """Get the properties of a Kubernetes Environment.

        Description for Get the properties of a Kubernetes Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the Kubernetes Environment. Required.
        :type name: str
        :return: KubeEnvironment. The KubeEnvironment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KubeEnvironment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.KubeEnvironment] = kwargs.pop("cls", None)

        _request = build_kube_environments_get_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.KubeEnvironment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        name: str,
        kube_environment_envelope: Union[_models.KubeEnvironment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(kube_environment_envelope, (IOBase, bytes)):
            _content = kube_environment_envelope
        else:
            _content = json.dumps(kube_environment_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_kube_environments_create_or_update_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        kube_environment_envelope: _models.KubeEnvironment,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.KubeEnvironment]:
        """Creates or updates a Kubernetes Environment.

        Description for Creates or updates a Kubernetes Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the Kubernetes Environment. Required.
        :type name: str
        :param kube_environment_envelope: Configuration details of the Kubernetes Environment.
         Required.
        :type kube_environment_envelope: ~azure.mgmt.web.models.KubeEnvironment
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns KubeEnvironment. The KubeEnvironment is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.KubeEnvironment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        kube_environment_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.KubeEnvironment]:
        """Creates or updates a Kubernetes Environment.

        Description for Creates or updates a Kubernetes Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the Kubernetes Environment. Required.
        :type name: str
        :param kube_environment_envelope: Configuration details of the Kubernetes Environment.
         Required.
        :type kube_environment_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns KubeEnvironment. The KubeEnvironment is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.KubeEnvironment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        kube_environment_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.KubeEnvironment]:
        """Creates or updates a Kubernetes Environment.

        Description for Creates or updates a Kubernetes Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the Kubernetes Environment. Required.
        :type name: str
        :param kube_environment_envelope: Configuration details of the Kubernetes Environment.
         Required.
        :type kube_environment_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns KubeEnvironment. The KubeEnvironment is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.KubeEnvironment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        name: str,
        kube_environment_envelope: Union[_models.KubeEnvironment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.KubeEnvironment]:
        """Creates or updates a Kubernetes Environment.

        Description for Creates or updates a Kubernetes Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the Kubernetes Environment. Required.
        :type name: str
        :param kube_environment_envelope: Configuration details of the Kubernetes Environment. Is one
         of the following types: KubeEnvironment, JSON, IO[bytes] Required.
        :type kube_environment_envelope: ~azure.mgmt.web.models.KubeEnvironment or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns KubeEnvironment. The KubeEnvironment is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.web.models.KubeEnvironment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.KubeEnvironment] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                name=name,
                kube_environment_envelope=kube_environment_envelope,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.KubeEnvironment, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.KubeEnvironment].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.KubeEnvironment](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        kube_environment_envelope: _models.KubeEnvironmentPatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KubeEnvironment:
        """Creates or updates a Kubernetes Environment.

        Description for Creates or updates a Kubernetes Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the Kubernetes Environment. Required.
        :type name: str
        :param kube_environment_envelope: Configuration details of the Kubernetes Environment.
         Required.
        :type kube_environment_envelope: ~azure.mgmt.web.models.KubeEnvironmentPatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KubeEnvironment. The KubeEnvironment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KubeEnvironment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        kube_environment_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KubeEnvironment:
        """Creates or updates a Kubernetes Environment.

        Description for Creates or updates a Kubernetes Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the Kubernetes Environment. Required.
        :type name: str
        :param kube_environment_envelope: Configuration details of the Kubernetes Environment.
         Required.
        :type kube_environment_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KubeEnvironment. The KubeEnvironment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KubeEnvironment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        name: str,
        kube_environment_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.KubeEnvironment:
        """Creates or updates a Kubernetes Environment.

        Description for Creates or updates a Kubernetes Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the Kubernetes Environment. Required.
        :type name: str
        :param kube_environment_envelope: Configuration details of the Kubernetes Environment.
         Required.
        :type kube_environment_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: KubeEnvironment. The KubeEnvironment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KubeEnvironment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        name: str,
        kube_environment_envelope: Union[_models.KubeEnvironmentPatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.KubeEnvironment:
        """Creates or updates a Kubernetes Environment.

        Description for Creates or updates a Kubernetes Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the Kubernetes Environment. Required.
        :type name: str
        :param kube_environment_envelope: Configuration details of the Kubernetes Environment. Is one
         of the following types: KubeEnvironmentPatchResource, JSON, IO[bytes] Required.
        :type kube_environment_envelope: ~azure.mgmt.web.models.KubeEnvironmentPatchResource or JSON or
         IO[bytes]
        :return: KubeEnvironment. The KubeEnvironment is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.KubeEnvironment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.KubeEnvironment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(kube_environment_envelope, (IOBase, bytes)):
            _content = kube_environment_envelope
        else:
            _content = json.dumps(kube_environment_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_kube_environments_update_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.KubeEnvironment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _delete_initial(self, resource_group_name: str, name: str, **kwargs: Any) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_kube_environments_delete_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_delete(self, resource_group_name: str, name: str, **kwargs: Any) -> AsyncLROPoller[None]:
        """Delete a Kubernetes Environment.

        Description for Delete a Kubernetes Environment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of the Kubernetes Environment. Required.
        :type name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(
                resource_group_name=resource_group_name,
                name=name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_by_resource_group(
        self, resource_group_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.KubeEnvironment"]:
        """Get all the Kubernetes Environments in a resource group.

        Description for Get all the Kubernetes Environments in a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of KubeEnvironment
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.KubeEnvironment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.KubeEnvironment]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_kube_environments_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.KubeEnvironment], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> AsyncItemPaged["_models.KubeEnvironment"]:
        """Get all Kubernetes Environments for a subscription.

        Description for Get all Kubernetes Environments for a subscription.

        :return: An iterator like instance of KubeEnvironment
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.KubeEnvironment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.KubeEnvironment]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_kube_environments_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.KubeEnvironment], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class WorkflowRunsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`workflow_runs` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, name: str, workflow_name: str, run_name: str, **kwargs: Any
    ) -> _models.WorkflowRun:
        """Gets a workflow run.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :return: WorkflowRun. The WorkflowRun is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowRun
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowRun] = kwargs.pop("cls", None)

        _request = build_workflow_runs_get_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            run_name=run_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowRun, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        *,
        top: Optional[int] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.WorkflowRun"]:
        """Gets a list of workflow runs.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :keyword top: The number of items to be included in the result. Default value is None.
        :paramtype top: int
        :keyword filter: The filter to apply on the operation. Options for filters include: Status,
         StartTime, and ClientTrackingId. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of WorkflowRun
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WorkflowRun]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkflowRun]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workflow_runs_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    workflow_name=workflow_name,
                    subscription_id=self._config.subscription_id,
                    top=top,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkflowRun], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def cancel(
        self, resource_group_name: str, name: str, workflow_name: str, run_name: str, **kwargs: Any
    ) -> None:
        """Cancels a workflow run.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workflow_runs_cancel_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            run_name=run_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class WorkflowRunActionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`workflow_run_actions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, name: str, workflow_name: str, run_name: str, action_name: str, **kwargs: Any
    ) -> _models.WorkflowRunAction:
        """Gets a workflow run action.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :param action_name: The workflow action name. Required.
        :type action_name: str
        :return: WorkflowRunAction. The WorkflowRunAction is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowRunAction
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowRunAction] = kwargs.pop("cls", None)

        _request = build_workflow_run_actions_get_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            run_name=run_name,
            action_name=action_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowRunAction, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        run_name: str,
        *,
        top: Optional[int] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.WorkflowRunAction"]:
        """Gets a list of workflow run actions.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :keyword top: The number of items to be included in the result. Default value is None.
        :paramtype top: int
        :keyword filter: The filter to apply on the operation. Options for filters include: Status.
         Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of WorkflowRunAction
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WorkflowRunAction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkflowRunAction]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workflow_run_actions_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    workflow_name=workflow_name,
                    run_name=run_name,
                    subscription_id=self._config.subscription_id,
                    top=top,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkflowRunAction], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_expression_traces(
        self, resource_group_name: str, name: str, workflow_name: str, run_name: str, action_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ExpressionRoot"]:
        """Lists a workflow run expression trace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :param action_name: The workflow action name. Required.
        :type action_name: str
        :return: An iterator like instance of ExpressionRoot
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ExpressionRoot]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ExpressionRoot]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workflow_run_actions_list_expression_traces_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    workflow_name=workflow_name,
                    run_name=run_name,
                    action_name=action_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ExpressionRoot], deserialized.get("inputs", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class WorkflowRunActionScopeRepetitionsOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`workflow_run_action_scope_repetitions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        run_name: str,
        action_name: str,
        repetition_name: str,
        **kwargs: Any
    ) -> _models.WorkflowRunActionRepetitionDefinition:
        """Get a workflow run action scoped repetition.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :param action_name: The workflow action name. Required.
        :type action_name: str
        :param repetition_name: The workflow repetition. Required.
        :type repetition_name: str
        :return: WorkflowRunActionRepetitionDefinition. The WorkflowRunActionRepetitionDefinition is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowRunActionRepetitionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowRunActionRepetitionDefinition] = kwargs.pop("cls", None)

        _request = build_workflow_run_action_scope_repetitions_get_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            run_name=run_name,
            action_name=action_name,
            repetition_name=repetition_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowRunActionRepetitionDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(
        self, resource_group_name: str, name: str, workflow_name: str, run_name: str, action_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.WorkflowRunActionRepetitionDefinition"]:
        """List the workflow run action scoped repetitions.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :param action_name: The workflow action name. Required.
        :type action_name: str
        :return: An iterator like instance of WorkflowRunActionRepetitionDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WorkflowRunActionRepetitionDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkflowRunActionRepetitionDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workflow_run_action_scope_repetitions_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    workflow_name=workflow_name,
                    run_name=run_name,
                    action_name=action_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.WorkflowRunActionRepetitionDefinition], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class WorkflowTriggersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`workflow_triggers` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, name: str, workflow_name: str, trigger_name: str, **kwargs: Any
    ) -> _models.WorkflowTrigger:
        """Gets a workflow trigger.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param trigger_name: The workflow trigger name. Required.
        :type trigger_name: str
        :return: WorkflowTrigger. The WorkflowTrigger is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowTrigger
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowTrigger] = kwargs.pop("cls", None)

        _request = build_workflow_triggers_get_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            trigger_name=trigger_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowTrigger, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        *,
        top: Optional[int] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.WorkflowTrigger"]:
        """Gets a list of workflow triggers.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :keyword top: The number of items to be included in the result. Default value is None.
        :paramtype top: int
        :keyword filter: The filter to apply on the operation. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of WorkflowTrigger
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WorkflowTrigger]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkflowTrigger]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workflow_triggers_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    workflow_name=workflow_name,
                    subscription_id=self._config.subscription_id,
                    top=top,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkflowTrigger], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_callback_url(
        self, resource_group_name: str, name: str, workflow_name: str, trigger_name: str, **kwargs: Any
    ) -> _models.WorkflowTriggerCallbackUrl:
        """Get the callback URL for a workflow trigger.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param trigger_name: The workflow trigger name. Required.
        :type trigger_name: str
        :return: WorkflowTriggerCallbackUrl. The WorkflowTriggerCallbackUrl is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowTriggerCallbackUrl
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowTriggerCallbackUrl] = kwargs.pop("cls", None)

        _request = build_workflow_triggers_list_callback_url_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            trigger_name=trigger_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowTriggerCallbackUrl, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _run_initial(
        self, resource_group_name: str, name: str, workflow_name: str, trigger_name: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_workflow_triggers_run_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            trigger_name=trigger_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_run(
        self, resource_group_name: str, name: str, workflow_name: str, trigger_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Runs a workflow trigger.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param trigger_name: The workflow trigger name. Required.
        :type trigger_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._run_initial(
                resource_group_name=resource_group_name,
                name=name,
                workflow_name=workflow_name,
                trigger_name=trigger_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def get_schema_json(
        self, resource_group_name: str, name: str, workflow_name: str, trigger_name: str, **kwargs: Any
    ) -> _models.JsonSchema:
        """Get the trigger schema as JSON.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param trigger_name: The workflow trigger name. Required.
        :type trigger_name: str
        :return: JsonSchema. The JsonSchema is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.JsonSchema
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.JsonSchema] = kwargs.pop("cls", None)

        _request = build_workflow_triggers_get_schema_json_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            trigger_name=trigger_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.JsonSchema, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class WorkflowTriggerHistoriesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`workflow_trigger_histories` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        trigger_name: str,
        history_name: str,
        **kwargs: Any
    ) -> _models.WorkflowTriggerHistory:
        """Gets a workflow trigger history.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param trigger_name: The workflow trigger name. Required.
        :type trigger_name: str
        :param history_name: The workflow trigger history name. Corresponds to the run name for
         triggers that resulted in a run. Required.
        :type history_name: str
        :return: WorkflowTriggerHistory. The WorkflowTriggerHistory is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowTriggerHistory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowTriggerHistory] = kwargs.pop("cls", None)

        _request = build_workflow_trigger_histories_get_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            trigger_name=trigger_name,
            history_name=history_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowTriggerHistory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        trigger_name: str,
        *,
        top: Optional[int] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.WorkflowTriggerHistory"]:
        """Gets a list of workflow trigger histories.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param trigger_name: The workflow trigger name. Required.
        :type trigger_name: str
        :keyword top: The number of items to be included in the result. Default value is None.
        :paramtype top: int
        :keyword filter: The filter to apply on the operation. Options for filters include: Status,
         StartTime, and ClientTrackingId. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of WorkflowTriggerHistory
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WorkflowTriggerHistory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkflowTriggerHistory]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workflow_trigger_histories_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    workflow_name=workflow_name,
                    trigger_name=trigger_name,
                    subscription_id=self._config.subscription_id,
                    top=top,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkflowTriggerHistory], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _resubmit_initial(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        trigger_name: str,
        history_name: str,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_workflow_trigger_histories_resubmit_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            trigger_name=trigger_name,
            history_name=history_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_resubmit(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        trigger_name: str,
        history_name: str,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Resubmits a workflow run based on the trigger history.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param trigger_name: The workflow trigger name. Required.
        :type trigger_name: str
        :param history_name: The workflow trigger history name. Corresponds to the run name for
         triggers that resulted in a run. Required.
        :type history_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._resubmit_initial(
                resource_group_name=resource_group_name,
                name=name,
                workflow_name=workflow_name,
                trigger_name=trigger_name,
                history_name=history_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class WorkflowVersionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`workflow_versions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, name: str, workflow_name: str, version_id: str, **kwargs: Any
    ) -> _models.WorkflowVersion:
        """Gets a workflow version.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param version_id: The workflow versionId. Required.
        :type version_id: str
        :return: WorkflowVersion. The WorkflowVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowVersion] = kwargs.pop("cls", None)

        _request = build_workflow_versions_get_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            version_id=version_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowVersion, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(
        self, resource_group_name: str, name: str, workflow_name: str, *, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.WorkflowVersion"]:
        """Gets a list of workflow versions.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :keyword top: The number of items to be included in the result. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of WorkflowVersion
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WorkflowVersion]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkflowVersion]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workflow_versions_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    workflow_name=workflow_name,
                    subscription_id=self._config.subscription_id,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkflowVersion], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class ProviderOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`provider` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_operations(self, **kwargs: Any) -> AsyncItemPaged["_models.CsmOperationDescription"]:
        """Gets all available operations for the Microsoft.Web resource provider. Also exposes resource
        metric definitions.

        Description for Gets all available operations for the Microsoft.Web resource provider. Also
        exposes resource metric definitions.

        :return: An iterator like instance of CsmOperationDescription
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.CsmOperationDescription]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CsmOperationDescription]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_provider_list_operations_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CsmOperationDescription], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def get_available_stacks(
        self, *, os_type_selected: Optional[Union[str, _models.ProviderOsTypeSelected]] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.ApplicationStackResource"]:
        """Get available application frameworks and their versions.

        Description for Get available application frameworks and their versions.

        :keyword os_type_selected: Known values are: "Windows", "Linux", "WindowsFunctions",
         "LinuxFunctions", and "All". Default value is None.
        :paramtype os_type_selected: str or ~azure.mgmt.web.models.ProviderOsTypeSelected
        :return: An iterator like instance of ApplicationStackResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ApplicationStackResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ApplicationStackResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_provider_get_available_stacks_request(
                    os_type_selected=os_type_selected,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ApplicationStackResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def get_function_app_stacks(
        self, *, stack_os_type: Optional[Union[str, _models.ProviderStackOsType]] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.FunctionAppStack"]:
        """Get available Function app frameworks and their versions.

        Description for Get available Function app frameworks and their versions.

        :keyword stack_os_type: Stack OS Type. Known values are: "Windows", "Linux", and "All". Default
         value is None.
        :paramtype stack_os_type: str or ~azure.mgmt.web.models.ProviderStackOsType
        :return: An iterator like instance of FunctionAppStack
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.FunctionAppStack]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.FunctionAppStack]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_provider_get_function_app_stacks_request(
                    stack_os_type=stack_os_type,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.FunctionAppStack], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def get_function_app_stacks_for_location(
        self, location: str, *, stack_os_type: Optional[Union[str, _models.ProviderStackOsType]] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.FunctionAppStack"]:
        """Get available Function app frameworks and their versions for location.

        Description for Get available Function app frameworks and their versions for location.

        :param location: The location name. Required.
        :type location: str
        :keyword stack_os_type: Stack OS Type. Known values are: "Windows", "Linux", and "All". Default
         value is None.
        :paramtype stack_os_type: str or ~azure.mgmt.web.models.ProviderStackOsType
        :return: An iterator like instance of FunctionAppStack
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.FunctionAppStack]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.FunctionAppStack]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_provider_get_function_app_stacks_for_location_request(
                    location=location,
                    stack_os_type=stack_os_type,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.FunctionAppStack], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def get_web_app_stacks_for_location(
        self, location: str, *, stack_os_type: Optional[Union[str, _models.ProviderStackOsType]] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.WebAppStack"]:
        """Get available Web app frameworks and their versions for location.

        Description for Get available Web app frameworks and their versions for location.

        :param location: The location name. Required.
        :type location: str
        :keyword stack_os_type: Stack OS Type. Known values are: "Windows", "Linux", and "All". Default
         value is None.
        :paramtype stack_os_type: str or ~azure.mgmt.web.models.ProviderStackOsType
        :return: An iterator like instance of WebAppStack
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WebAppStack]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WebAppStack]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_provider_get_web_app_stacks_for_location_request(
                    location=location,
                    stack_os_type=stack_os_type,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WebAppStack], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def get_web_app_stacks(
        self, *, stack_os_type: Optional[Union[str, _models.ProviderStackOsType]] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.WebAppStack"]:
        """Get available Web app frameworks and their versions.

        Description for Get available Web app frameworks and their versions.

        :keyword stack_os_type: Stack OS Type. Known values are: "Windows", "Linux", and "All". Default
         value is None.
        :paramtype stack_os_type: str or ~azure.mgmt.web.models.ProviderStackOsType
        :return: An iterator like instance of WebAppStack
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WebAppStack]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WebAppStack]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_provider_get_web_app_stacks_request(
                    stack_os_type=stack_os_type,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WebAppStack], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def get_available_stacks_on_prem(
        self, *, os_type_selected: Optional[Union[str, _models.ProviderOsTypeSelected]] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.ApplicationStackResource"]:
        """Get available application frameworks and their versions.

        Description for Get available application frameworks and their versions.

        :keyword os_type_selected: Known values are: "Windows", "Linux", "WindowsFunctions",
         "LinuxFunctions", and "All". Default value is None.
        :paramtype os_type_selected: str or ~azure.mgmt.web.models.ProviderOsTypeSelected
        :return: An iterator like instance of ApplicationStackResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ApplicationStackResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ApplicationStackResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_provider_get_available_stacks_on_prem_request(
                    subscription_id=self._config.subscription_id,
                    os_type_selected=os_type_selected,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ApplicationStackResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class DeletedWebAppsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`deleted_web_apps` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_deleted_web_app_by_location(
        self, location: str, deleted_site_id: str, **kwargs: Any
    ) -> _models.DeletedSite:
        """Get deleted app for a subscription at location.

        Description for Get deleted app for a subscription at location.

        :param location: The location name. Required.
        :type location: str
        :param deleted_site_id: The numeric ID of the deleted app, e.g. 12345. Required.
        :type deleted_site_id: str
        :return: DeletedSite. The DeletedSite is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DeletedSite
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DeletedSite] = kwargs.pop("cls", None)

        _request = build_deleted_web_apps_get_deleted_web_app_by_location_request(
            location=location,
            deleted_site_id=deleted_site_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DeletedSite, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_by_location(self, location: str, **kwargs: Any) -> AsyncItemPaged["_models.DeletedSite"]:
        """Get all deleted apps for a subscription at location.

        Description for Get all deleted apps for a subscription at location.

        :param location: The location name. Required.
        :type location: str
        :return: An iterator like instance of DeletedSite
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DeletedSite]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DeletedSite]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_deleted_web_apps_list_by_location_request(
                    location=location,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DeletedSite], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncItemPaged["_models.DeletedSite"]:
        """Get all deleted apps for a subscription.

        Description for Get all deleted apps for a subscription.

        :return: An iterator like instance of DeletedSite
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.DeletedSite]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DeletedSite]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_deleted_web_apps_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DeletedSite], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class ResourceHealthMetadataOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`resource_health_metadata` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_by_site(self, resource_group_name: str, name: str, **kwargs: Any) -> _models.ResourceHealthMetadata:
        """Gets the category of ResourceHealthMetadata to use for the given site.

        Description for Gets the category of ResourceHealthMetadata to use for the given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :return: ResourceHealthMetadata. The ResourceHealthMetadata is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ResourceHealthMetadata
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ResourceHealthMetadata] = kwargs.pop("cls", None)

        _request = build_resource_health_metadata_get_by_site_request(
            resource_group_name=resource_group_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ResourceHealthMetadata, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_by_site(
        self, resource_group_name: str, name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ResourceHealthMetadata"]:
        """Gets the category of ResourceHealthMetadata to use for the given site as a collection.

        Description for Gets the category of ResourceHealthMetadata to use for the given site as a
        collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :return: An iterator like instance of ResourceHealthMetadata
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ResourceHealthMetadata]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ResourceHealthMetadata]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_resource_health_metadata_list_by_site_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ResourceHealthMetadata], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_by_site_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> _models.ResourceHealthMetadata:
        """Gets the category of ResourceHealthMetadata to use for the given site.

        Description for Gets the category of ResourceHealthMetadata to use for the given site.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :return: ResourceHealthMetadata. The ResourceHealthMetadata is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ResourceHealthMetadata
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ResourceHealthMetadata] = kwargs.pop("cls", None)

        _request = build_resource_health_metadata_get_by_site_slot_request(
            resource_group_name=resource_group_name,
            name=name,
            slot=slot,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ResourceHealthMetadata, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_by_site_slot(
        self, resource_group_name: str, name: str, slot: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ResourceHealthMetadata"]:
        """Gets the category of ResourceHealthMetadata to use for the given site as a collection.

        Description for Gets the category of ResourceHealthMetadata to use for the given site as a
        collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Name of web app. Required.
        :type name: str
        :param slot: Name of web app slot. If not specified then will default to production slot.
         Required.
        :type slot: str
        :return: An iterator like instance of ResourceHealthMetadata
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ResourceHealthMetadata]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ResourceHealthMetadata]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_resource_health_metadata_list_by_site_slot_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    slot=slot,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ResourceHealthMetadata], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncItemPaged["_models.ResourceHealthMetadata"]:
        """List all ResourceHealthMetadata for all sites in the subscription.

        Description for List all ResourceHealthMetadata for all sites in the subscription.

        :return: An iterator like instance of ResourceHealthMetadata
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ResourceHealthMetadata]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ResourceHealthMetadata]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_resource_health_metadata_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ResourceHealthMetadata], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(
        self, resource_group_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.ResourceHealthMetadata"]:
        """List all ResourceHealthMetadata for all sites in the resource group in the subscription.

        Description for List all ResourceHealthMetadata for all sites in the resource group in the
        subscription.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of ResourceHealthMetadata
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ResourceHealthMetadata]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ResourceHealthMetadata]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_resource_health_metadata_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ResourceHealthMetadata], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class WorkflowsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`workflows` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def regenerate_access_key(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        key_type: _models.RegenerateActionParameter,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Regenerates the callback URL access key for request triggers.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param key_type: The access key type. Required.
        :type key_type: ~azure.mgmt.web.models.RegenerateActionParameter
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def regenerate_access_key(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        key_type: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Regenerates the callback URL access key for request triggers.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param key_type: The access key type. Required.
        :type key_type: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def regenerate_access_key(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        key_type: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Regenerates the callback URL access key for request triggers.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param key_type: The access key type. Required.
        :type key_type: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def regenerate_access_key(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        key_type: Union[_models.RegenerateActionParameter, JSON, IO[bytes]],
        **kwargs: Any
    ) -> None:
        """Regenerates the callback URL access key for request triggers.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param key_type: The access key type. Is one of the following types: RegenerateActionParameter,
         JSON, IO[bytes] Required.
        :type key_type: ~azure.mgmt.web.models.RegenerateActionParameter or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(key_type, (IOBase, bytes)):
            _content = key_type
        else:
            _content = json.dumps(key_type, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workflows_regenerate_access_key_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def validate(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        validate: _models.Workflow,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Validates the workflow definition.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param validate: The workflow. Required.
        :type validate: ~azure.mgmt.web.models.Workflow
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def validate(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        validate: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Validates the workflow definition.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param validate: The workflow. Required.
        :type validate: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def validate(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        validate: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Validates the workflow definition.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param validate: The workflow. Required.
        :type validate: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def validate(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        validate: Union[_models.Workflow, JSON, IO[bytes]],
        **kwargs: Any
    ) -> None:
        """Validates the workflow definition.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param validate: The workflow. Is one of the following types: Workflow, JSON, IO[bytes]
         Required.
        :type validate: ~azure.mgmt.web.models.Workflow or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(validate, (IOBase, bytes)):
            _content = validate
        else:
            _content = json.dumps(validate, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workflows_validate_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class WorkflowRunActionRepetitionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`workflow_run_action_repetitions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        run_name: str,
        action_name: str,
        repetition_name: str,
        **kwargs: Any
    ) -> _models.WorkflowRunActionRepetitionDefinition:
        """Get a workflow run action repetition.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :param action_name: The workflow action name. Required.
        :type action_name: str
        :param repetition_name: The workflow repetition. Required.
        :type repetition_name: str
        :return: WorkflowRunActionRepetitionDefinition. The WorkflowRunActionRepetitionDefinition is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.WorkflowRunActionRepetitionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkflowRunActionRepetitionDefinition] = kwargs.pop("cls", None)

        _request = build_workflow_run_action_repetitions_get_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            run_name=run_name,
            action_name=action_name,
            repetition_name=repetition_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkflowRunActionRepetitionDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(
        self, resource_group_name: str, name: str, workflow_name: str, run_name: str, action_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.WorkflowRunActionRepetitionDefinition"]:
        """Get all of a workflow run action repetitions.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :param action_name: The workflow action name. Required.
        :type action_name: str
        :return: An iterator like instance of WorkflowRunActionRepetitionDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.WorkflowRunActionRepetitionDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkflowRunActionRepetitionDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workflow_run_action_repetitions_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    workflow_name=workflow_name,
                    run_name=run_name,
                    action_name=action_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(
                List[_models.WorkflowRunActionRepetitionDefinition], deserialized.get("value", [])
            )
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_expression_traces(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        run_name: str,
        action_name: str,
        repetition_name: str,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.ExpressionRoot"]:
        """Lists a workflow run expression trace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :param action_name: The workflow action name. Required.
        :type action_name: str
        :param repetition_name: The workflow repetition. Required.
        :type repetition_name: str
        :return: An iterator like instance of ExpressionRoot
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.ExpressionRoot]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ExpressionRoot]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workflow_run_action_repetitions_list_expression_traces_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    workflow_name=workflow_name,
                    run_name=run_name,
                    action_name=action_name,
                    repetition_name=repetition_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ExpressionRoot], deserialized.get("inputs", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class WorkflowRunActionRepetitionsRequestHistoriesOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`workflow_run_action_repetitions_request_histories` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        run_name: str,
        action_name: str,
        repetition_name: str,
        request_history_name: str,
        **kwargs: Any
    ) -> _models.RequestHistory:
        """Gets a workflow run repetition request history.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :param action_name: The workflow action name. Required.
        :type action_name: str
        :param repetition_name: The workflow repetition. Required.
        :type repetition_name: str
        :param request_history_name: The workflow repetition. Required.
        :type request_history_name: str
        :return: RequestHistory. The RequestHistory is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.RequestHistory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestHistory] = kwargs.pop("cls", None)

        _request = build_workflow_run_action_repetitions_request_histories_get_request(
            resource_group_name=resource_group_name,
            name=name,
            workflow_name=workflow_name,
            run_name=run_name,
            action_name=action_name,
            repetition_name=repetition_name,
            request_history_name=request_history_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestHistory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(
        self,
        resource_group_name: str,
        name: str,
        workflow_name: str,
        run_name: str,
        action_name: str,
        repetition_name: str,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.RequestHistory"]:
        """List a workflow run repetition request history.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param name: Site name. Required.
        :type name: str
        :param workflow_name: The workflow name. Required.
        :type workflow_name: str
        :param run_name: The workflow run name. Required.
        :type run_name: str
        :param action_name: The workflow action name. Required.
        :type action_name: str
        :param repetition_name: The workflow repetition. Required.
        :type repetition_name: str
        :return: An iterator like instance of RequestHistory
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.RequestHistory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.RequestHistory]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workflow_run_action_repetitions_request_histories_list_request(
                    resource_group_name=resource_group_name,
                    name=name,
                    workflow_name=workflow_name,
                    run_name=run_name,
                    action_name=action_name,
                    repetition_name=repetition_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.RequestHistory], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class GetUsagesInLocationOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.web.aio.WebSiteManagementClient`'s
        :attr:`get_usages_in_location` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: WebSiteManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, location: str, **kwargs: Any) -> AsyncItemPaged["_models.CsmUsageQuota"]:
        """Lists subscription core usages for all skus used in a location, for a given type of quota.

        List usages in cores for all skus used by a subscription in a given location, for a specific
        quota type.

        :param location: The location name. Required.
        :type location: str
        :return: An iterator like instance of CsmUsageQuota
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.CsmUsageQuota]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CsmUsageQuota]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_get_usages_in_location_list_request(
                    location=location,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CsmUsageQuota], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class _WebSiteManagementClientOperationsMixin(
    ClientMixinABC[AsyncPipelineClient[HttpRequest, AsyncHttpResponse], WebSiteManagementClientConfiguration]
):

    @overload
    async def validate_move(
        self,
        resource_group_name: str,
        move_resource_envelope: _models.CsmMoveResourceEnvelope,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Validate whether a resource can be moved.

        Description for Validate whether a resource can be moved.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param move_resource_envelope: Object that represents the resource to move. Required.
        :type move_resource_envelope: ~azure.mgmt.web.models.CsmMoveResourceEnvelope
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def validate_move(
        self,
        resource_group_name: str,
        move_resource_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Validate whether a resource can be moved.

        Description for Validate whether a resource can be moved.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param move_resource_envelope: Object that represents the resource to move. Required.
        :type move_resource_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def validate_move(
        self,
        resource_group_name: str,
        move_resource_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Validate whether a resource can be moved.

        Description for Validate whether a resource can be moved.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param move_resource_envelope: Object that represents the resource to move. Required.
        :type move_resource_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def validate_move(
        self,
        resource_group_name: str,
        move_resource_envelope: Union[_models.CsmMoveResourceEnvelope, JSON, IO[bytes]],
        **kwargs: Any
    ) -> None:
        """Validate whether a resource can be moved.

        Description for Validate whether a resource can be moved.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param move_resource_envelope: Object that represents the resource to move. Is one of the
         following types: CsmMoveResourceEnvelope, JSON, IO[bytes] Required.
        :type move_resource_envelope: ~azure.mgmt.web.models.CsmMoveResourceEnvelope or JSON or
         IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(move_resource_envelope, (IOBase, bytes)):
            _content = move_resource_envelope
        else:
            _content = json.dumps(move_resource_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_site_management_validate_move_request(
            resource_group_name=resource_group_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def validate(
        self,
        resource_group_name: str,
        validate_request: _models.ValidateRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ValidateResponse:
        """Validate if a resource can be created.

        Description for Validate if a resource can be created.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param validate_request: Request with the resources to validate. Required.
        :type validate_request: ~azure.mgmt.web.models.ValidateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ValidateResponse. The ValidateResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ValidateResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def validate(
        self, resource_group_name: str, validate_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ValidateResponse:
        """Validate if a resource can be created.

        Description for Validate if a resource can be created.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param validate_request: Request with the resources to validate. Required.
        :type validate_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ValidateResponse. The ValidateResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ValidateResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def validate(
        self,
        resource_group_name: str,
        validate_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ValidateResponse:
        """Validate if a resource can be created.

        Description for Validate if a resource can be created.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param validate_request: Request with the resources to validate. Required.
        :type validate_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ValidateResponse. The ValidateResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ValidateResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def validate(
        self, resource_group_name: str, validate_request: Union[_models.ValidateRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.ValidateResponse:
        """Validate if a resource can be created.

        Description for Validate if a resource can be created.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param validate_request: Request with the resources to validate. Is one of the following types:
         ValidateRequest, JSON, IO[bytes] Required.
        :type validate_request: ~azure.mgmt.web.models.ValidateRequest or JSON or IO[bytes]
        :return: ValidateResponse. The ValidateResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.ValidateResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ValidateResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(validate_request, (IOBase, bytes)):
            _content = validate_request
        else:
            _content = json.dumps(validate_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_site_management_validate_request(
            resource_group_name=resource_group_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ValidateResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_subscription_deployment_locations(self, **kwargs: Any) -> _models.DeploymentLocations:
        """Gets list of available geo regions plus ministamps.

        Description for Gets list of available geo regions plus ministamps.

        :return: DeploymentLocations. The DeploymentLocations is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.DeploymentLocations
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DeploymentLocations] = kwargs.pop("cls", None)

        _request = build_web_site_management_get_subscription_deployment_locations_request(
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DeploymentLocations, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_ase_regions(self, **kwargs: Any) -> AsyncItemPaged["_models.AseRegion"]:
        """Get a list of available ASE regions and its supported Skus.

        Description for get a list of available ASE regions and its supported Skus.

        :return: An iterator like instance of AseRegion
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.AseRegion]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AseRegion]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_site_management_list_ase_regions_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AseRegion], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_billing_meters(
        self, *, billing_location: Optional[str] = None, os_type: Optional[str] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.BillingMeter"]:
        """Gets a list of meters for a given location.

        Description for Gets a list of meters for a given location.

        :keyword billing_location: Azure Location of billable resource. Default value is None.
        :paramtype billing_location: str
        :keyword os_type: App Service OS type meters used for. Default value is None.
        :paramtype os_type: str
        :return: An iterator like instance of BillingMeter
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.BillingMeter]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BillingMeter]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_site_management_list_billing_meters_request(
                    subscription_id=self._config.subscription_id,
                    billing_location=billing_location,
                    os_type=os_type,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.BillingMeter], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def check_name_availability(
        self, request: _models.ResourceNameAvailabilityRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ResourceNameAvailability:
        """Check if a resource name is available.

        Description for Check if a resource name is available.

        :param request: The request body. Required.
        :type request: ~azure.mgmt.web.models.ResourceNameAvailabilityRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ResourceNameAvailability. The ResourceNameAvailability is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ResourceNameAvailability
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def check_name_availability(
        self, request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ResourceNameAvailability:
        """Check if a resource name is available.

        Description for Check if a resource name is available.

        :param request: The request body. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ResourceNameAvailability. The ResourceNameAvailability is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ResourceNameAvailability
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def check_name_availability(
        self, request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ResourceNameAvailability:
        """Check if a resource name is available.

        Description for Check if a resource name is available.

        :param request: The request body. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ResourceNameAvailability. The ResourceNameAvailability is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ResourceNameAvailability
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def check_name_availability(
        self, request: Union[_models.ResourceNameAvailabilityRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.ResourceNameAvailability:
        """Check if a resource name is available.

        Description for Check if a resource name is available.

        :param request: The request body. Is one of the following types:
         ResourceNameAvailabilityRequest, JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.ResourceNameAvailabilityRequest or JSON or IO[bytes]
        :return: ResourceNameAvailability. The ResourceNameAvailability is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.ResourceNameAvailability
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ResourceNameAvailability] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_site_management_check_name_availability_request(
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ResourceNameAvailability, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_custom_host_name_sites(
        self, *, hostname: Optional[str] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.CustomHostnameSites"]:
        """Get custom hostnames under this subscription.

        Get custom hostnames under this subscription.

        :keyword hostname: Specific hostname. Default value is None.
        :paramtype hostname: str
        :return: An iterator like instance of CustomHostnameSites
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.CustomHostnameSites]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CustomHostnameSites]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_site_management_list_custom_host_name_sites_request(
                    subscription_id=self._config.subscription_id,
                    hostname=hostname,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CustomHostnameSites], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_geo_regions(
        self,
        *,
        sku: Optional[Union[str, _models.SkuName]] = None,
        linux_workers_enabled: Optional[bool] = None,
        xenon_workers_enabled: Optional[bool] = None,
        linux_dynamic_workers_enabled: Optional[bool] = None,
        custom_mode_workers_enabled: Optional[bool] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.GeoRegion"]:
        """Get a list of available geographical regions.

        Description for Get a list of available geographical regions.

        :keyword sku: Name of SKU used to filter the regions. Known values are: "Free", "Shared",
         "Basic", "Standard", "Premium", "Dynamic", "Isolated", "IsolatedV2", "PremiumV2", "PremiumV3",
         "PremiumContainer", "ElasticPremium", "ElasticIsolated", and "FlexConsumption". Default value
         is None.
        :paramtype sku: str or ~azure.mgmt.web.models.SkuName
        :keyword linux_workers_enabled: Specify <code>true</code> if you want to filter to only regions
         that support Linux workers. Default value is None.
        :paramtype linux_workers_enabled: bool
        :keyword xenon_workers_enabled: Specify <code>true</code> if you want to filter to only regions
         that support Xenon workers. Default value is None.
        :paramtype xenon_workers_enabled: bool
        :keyword linux_dynamic_workers_enabled: Specify <code>true</code> if you want to filter to only
         regions that support Linux Consumption Workers. Default value is None.
        :paramtype linux_dynamic_workers_enabled: bool
        :keyword custom_mode_workers_enabled: Specify <code>true</code> if you want to filter to only
         regions that support App Service Plans with <code>IsCustomMode</code> set to <code>true</code>.
         Default value is None.
        :paramtype custom_mode_workers_enabled: bool
        :return: An iterator like instance of GeoRegion
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.GeoRegion]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.GeoRegion]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_site_management_list_geo_regions_request(
                    subscription_id=self._config.subscription_id,
                    sku=sku,
                    linux_workers_enabled=linux_workers_enabled,
                    xenon_workers_enabled=xenon_workers_enabled,
                    linux_dynamic_workers_enabled=linux_dynamic_workers_enabled,
                    custom_mode_workers_enabled=custom_mode_workers_enabled,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.GeoRegion], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    def list_site_identifiers_assigned_to_host_name(  # pylint: disable=name-too-long
        self, name_identifier: _models.NameIdentifier, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncItemPaged["_models.Identifier"]:
        """List all apps that are assigned to a hostname.

        Description for List all apps that are assigned to a hostname.

        :param name_identifier: The request body. Required.
        :type name_identifier: ~azure.mgmt.web.models.NameIdentifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of Identifier
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Identifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def list_site_identifiers_assigned_to_host_name(  # pylint: disable=name-too-long
        self, name_identifier: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncItemPaged["_models.Identifier"]:
        """List all apps that are assigned to a hostname.

        Description for List all apps that are assigned to a hostname.

        :param name_identifier: The request body. Required.
        :type name_identifier: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of Identifier
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Identifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def list_site_identifiers_assigned_to_host_name(  # pylint: disable=name-too-long
        self, name_identifier: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncItemPaged["_models.Identifier"]:
        """List all apps that are assigned to a hostname.

        Description for List all apps that are assigned to a hostname.

        :param name_identifier: The request body. Required.
        :type name_identifier: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of Identifier
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Identifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def list_site_identifiers_assigned_to_host_name(  # pylint: disable=name-too-long
        self, name_identifier: Union[_models.NameIdentifier, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncItemPaged["_models.Identifier"]:
        """List all apps that are assigned to a hostname.

        Description for List all apps that are assigned to a hostname.

        :param name_identifier: The request body. Is one of the following types: NameIdentifier, JSON,
         IO[bytes] Required.
        :type name_identifier: ~azure.mgmt.web.models.NameIdentifier or JSON or IO[bytes]
        :return: An iterator like instance of Identifier
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.Identifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.Identifier]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})
        content_type = content_type or "application/json"
        _content = None
        if isinstance(name_identifier, (IOBase, bytes)):
            _content = name_identifier
        else:
            _content = json.dumps(name_identifier, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_site_management_list_site_identifiers_assigned_to_host_name_request(
                    subscription_id=self._config.subscription_id,
                    content_type=content_type,
                    api_version=self._config.api_version,
                    content=_content,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Identifier], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def regional_check_name_availability(
        self,
        location: str,
        request: _models.DnlResourceNameAvailabilityRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DnlResourceNameAvailability:
        """Check if a resource name is available for DNL sites.

        Check if a resource name is available for DNL sites.

        :param location: The location name. Required.
        :type location: str
        :param request: The request body. Required.
        :type request: ~azure.mgmt.web.models.DnlResourceNameAvailabilityRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DnlResourceNameAvailability. The DnlResourceNameAvailability is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.DnlResourceNameAvailability
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def regional_check_name_availability(
        self, location: str, request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DnlResourceNameAvailability:
        """Check if a resource name is available for DNL sites.

        Check if a resource name is available for DNL sites.

        :param location: The location name. Required.
        :type location: str
        :param request: The request body. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DnlResourceNameAvailability. The DnlResourceNameAvailability is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.DnlResourceNameAvailability
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def regional_check_name_availability(
        self, location: str, request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DnlResourceNameAvailability:
        """Check if a resource name is available for DNL sites.

        Check if a resource name is available for DNL sites.

        :param location: The location name. Required.
        :type location: str
        :param request: The request body. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DnlResourceNameAvailability. The DnlResourceNameAvailability is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.DnlResourceNameAvailability
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def regional_check_name_availability(
        self, location: str, request: Union[_models.DnlResourceNameAvailabilityRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.DnlResourceNameAvailability:
        """Check if a resource name is available for DNL sites.

        Check if a resource name is available for DNL sites.

        :param location: The location name. Required.
        :type location: str
        :param request: The request body. Is one of the following types:
         DnlResourceNameAvailabilityRequest, JSON, IO[bytes] Required.
        :type request: ~azure.mgmt.web.models.DnlResourceNameAvailabilityRequest or JSON or IO[bytes]
        :return: DnlResourceNameAvailability. The DnlResourceNameAvailability is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.DnlResourceNameAvailability
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DnlResourceNameAvailability] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_site_management_regional_check_name_availability_request(
            location=location,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DnlResourceNameAvailability, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_premier_add_on_offers(self, **kwargs: Any) -> AsyncItemPaged["_models.PremierAddOnOffer"]:
        """List all premier add-on offers.

        Description for List all premier add-on offers.

        :return: An iterator like instance of PremierAddOnOffer
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.PremierAddOnOffer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PremierAddOnOffer]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_site_management_list_premier_add_on_offers_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PremierAddOnOffer], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_skus(self, **kwargs: Any) -> _models.SkuInfos:
        """List all SKUs.

        Description for List all SKUs.

        :return: SkuInfos. The SkuInfos is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SkuInfos
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SkuInfos] = kwargs.pop("cls", None)

        _request = build_web_site_management_list_skus_request(
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SkuInfos, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def verify_hosting_environment_vnet(
        self, parameters: _models.VnetParameters, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VnetValidationFailureDetails:
        """Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
        Security Group rules.

        Description for Verifies if this VNET is compatible with an App Service Environment by
        analyzing the Network Security Group rules.

        :param parameters: The request body. Required.
        :type parameters: ~azure.mgmt.web.models.VnetParameters
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetValidationFailureDetails. The VnetValidationFailureDetails is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetValidationFailureDetails
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def verify_hosting_environment_vnet(
        self, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VnetValidationFailureDetails:
        """Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
        Security Group rules.

        Description for Verifies if this VNET is compatible with an App Service Environment by
        analyzing the Network Security Group rules.

        :param parameters: The request body. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetValidationFailureDetails. The VnetValidationFailureDetails is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetValidationFailureDetails
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def verify_hosting_environment_vnet(
        self, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VnetValidationFailureDetails:
        """Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
        Security Group rules.

        Description for Verifies if this VNET is compatible with an App Service Environment by
        analyzing the Network Security Group rules.

        :param parameters: The request body. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VnetValidationFailureDetails. The VnetValidationFailureDetails is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetValidationFailureDetails
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def verify_hosting_environment_vnet(
        self, parameters: Union[_models.VnetParameters, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.VnetValidationFailureDetails:
        """Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
        Security Group rules.

        Description for Verifies if this VNET is compatible with an App Service Environment by
        analyzing the Network Security Group rules.

        :param parameters: The request body. Is one of the following types: VnetParameters, JSON,
         IO[bytes] Required.
        :type parameters: ~azure.mgmt.web.models.VnetParameters or JSON or IO[bytes]
        :return: VnetValidationFailureDetails. The VnetValidationFailureDetails is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.web.models.VnetValidationFailureDetails
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VnetValidationFailureDetails] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_site_management_verify_hosting_environment_vnet_request(
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VnetValidationFailureDetails, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def move(
        self,
        resource_group_name: str,
        move_resource_envelope: _models.CsmMoveResourceEnvelope,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Move resources between resource groups.

        Description for Move resources between resource groups.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param move_resource_envelope: Object that represents the resource to move. Required.
        :type move_resource_envelope: ~azure.mgmt.web.models.CsmMoveResourceEnvelope
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def move(
        self,
        resource_group_name: str,
        move_resource_envelope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Move resources between resource groups.

        Description for Move resources between resource groups.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param move_resource_envelope: Object that represents the resource to move. Required.
        :type move_resource_envelope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def move(
        self,
        resource_group_name: str,
        move_resource_envelope: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Move resources between resource groups.

        Description for Move resources between resource groups.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param move_resource_envelope: Object that represents the resource to move. Required.
        :type move_resource_envelope: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def move(
        self,
        resource_group_name: str,
        move_resource_envelope: Union[_models.CsmMoveResourceEnvelope, JSON, IO[bytes]],
        **kwargs: Any
    ) -> None:
        """Move resources between resource groups.

        Description for Move resources between resource groups.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param move_resource_envelope: Object that represents the resource to move. Is one of the
         following types: CsmMoveResourceEnvelope, JSON, IO[bytes] Required.
        :type move_resource_envelope: ~azure.mgmt.web.models.CsmMoveResourceEnvelope or JSON or
         IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(move_resource_envelope, (IOBase, bytes)):
            _content = move_resource_envelope
        else:
            _content = json.dumps(move_resource_envelope, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_site_management_move_request(
            resource_group_name=resource_group_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_publishing_user(self, **kwargs: Any) -> _models.User:
        """Gets publishing user.

        Description for Gets publishing user.

        :return: User. The User is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.User] = kwargs.pop("cls", None)

        _request = build_web_site_management_get_publishing_user_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.User, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_publishing_user(
        self, user_details: _models.User, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.User:
        """Updates publishing user.

        Description for Updates publishing user.

        :param user_details: Details of publishing user. Required.
        :type user_details: ~azure.mgmt.web.models.User
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: User. The User is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_publishing_user(
        self, user_details: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.User:
        """Updates publishing user.

        Description for Updates publishing user.

        :param user_details: Details of publishing user. Required.
        :type user_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: User. The User is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_publishing_user(
        self, user_details: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.User:
        """Updates publishing user.

        Description for Updates publishing user.

        :param user_details: Details of publishing user. Required.
        :type user_details: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: User. The User is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_publishing_user(
        self, user_details: Union[_models.User, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.User:
        """Updates publishing user.

        Description for Updates publishing user.

        :param user_details: Details of publishing user. Is one of the following types: User, JSON,
         IO[bytes] Required.
        :type user_details: ~azure.mgmt.web.models.User or JSON or IO[bytes]
        :return: User. The User is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.User] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(user_details, (IOBase, bytes)):
            _content = user_details
        else:
            _content = json.dumps(user_details, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_site_management_update_publishing_user_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.User, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_source_control(self, source_control_type: str, **kwargs: Any) -> _models.SourceControl:
        """Gets source control token.

        Description for Gets source control token.

        :param source_control_type: Type of source control. Required.
        :type source_control_type: str
        :return: SourceControl. The SourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SourceControl] = kwargs.pop("cls", None)

        _request = build_web_site_management_get_source_control_request(
            source_control_type=source_control_type,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SourceControl, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_source_control(
        self,
        source_control_type: str,
        request_message: _models.SourceControl,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SourceControl:
        """Updates source control token.

        Description for Updates source control token.

        :param source_control_type: Type of source control. Required.
        :type source_control_type: str
        :param request_message: Source control token information. Required.
        :type request_message: ~azure.mgmt.web.models.SourceControl
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SourceControl. The SourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_source_control(
        self, source_control_type: str, request_message: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SourceControl:
        """Updates source control token.

        Description for Updates source control token.

        :param source_control_type: Type of source control. Required.
        :type source_control_type: str
        :param request_message: Source control token information. Required.
        :type request_message: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SourceControl. The SourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_source_control(
        self,
        source_control_type: str,
        request_message: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SourceControl:
        """Updates source control token.

        Description for Updates source control token.

        :param source_control_type: Type of source control. Required.
        :type source_control_type: str
        :param request_message: Source control token information. Required.
        :type request_message: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SourceControl. The SourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_source_control(
        self, source_control_type: str, request_message: Union[_models.SourceControl, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SourceControl:
        """Updates source control token.

        Description for Updates source control token.

        :param source_control_type: Type of source control. Required.
        :type source_control_type: str
        :param request_message: Source control token information. Is one of the following types:
         SourceControl, JSON, IO[bytes] Required.
        :type request_message: ~azure.mgmt.web.models.SourceControl or JSON or IO[bytes]
        :return: SourceControl. The SourceControl is compatible with MutableMapping
        :rtype: ~azure.mgmt.web.models.SourceControl
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SourceControl] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request_message, (IOBase, bytes)):
            _content = request_message
        else:
            _content = json.dumps(request_message, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_web_site_management_update_source_control_request(
            source_control_type=source_control_type,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SourceControl, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_source_controls(self, **kwargs: Any) -> AsyncItemPaged["_models.SourceControl"]:
        """Gets the source controls available for Azure websites.

        Description for Gets the source controls available for Azure websites.

        :return: An iterator like instance of SourceControl
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.web.models.SourceControl]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SourceControl]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_web_site_management_list_source_controls_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SourceControl], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)
