# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, Iterable, List, Optional, Type, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .. import models as _models
from .._model_base import SdkJSONEncoder, _deserialize
from .._serialization import Serializer

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.DeviceRegistry/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_operation_status_get_request(
    location: str, operation_id: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/locations/{location}/operationStatuses/{operationId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "location": _SERIALIZER.url("location", location, "str"),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_get_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "assetName": _SERIALIZER.url("asset_name", asset_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_create_or_replace_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "assetName": _SERIALIZER.url("asset_name", asset_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_update_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "assetName": _SERIALIZER.url("asset_name", asset_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_delete_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "assetName": _SERIALIZER.url("asset_name", asset_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets"
    )
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_list_by_subscription_request(  # pylint: disable=name-too-long
    subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/assets"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_get_request(  # pylint: disable=name-too-long
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "assetEndpointProfileName": _SERIALIZER.url("asset_endpoint_profile_name", asset_endpoint_profile_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_create_or_replace_request(  # pylint: disable=name-too-long
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "assetEndpointProfileName": _SERIALIZER.url("asset_endpoint_profile_name", asset_endpoint_profile_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "assetEndpointProfileName": _SERIALIZER.url("asset_endpoint_profile_name", asset_endpoint_profile_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_delete_request(  # pylint: disable=name-too-long
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "assetEndpointProfileName": _SERIALIZER.url("asset_endpoint_profile_name", asset_endpoint_profile_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_list_by_subscription_request(  # pylint: disable=name-too-long
    subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.DeviceRegistryMgmtClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
        # pylint: disable=line-too-long
        """List the operations for the provider.

        :return: An iterator like instance of Operation
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.deviceregistry.models.Operation]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actionType": "str",  # Optional. Enum. Indicates the action type. "Internal"
                      refers to actions that are for internal only APIs. "Internal"
                    "display": {
                        "description": "str",  # Optional. The short, localized friendly
                          description of the operation; suitable for tool tips and detailed views.
                        "operation": "str",  # Optional. The concise, localized friendly name
                          for the operation; suitable for dropdowns. E.g. "Create or Update Virtual
                          Machine", "Restart Virtual Machine".
                        "provider": "str",  # Optional. The localized friendly form of the
                          resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft
                          Compute".
                        "resource": "str"  # Optional. The localized friendly name of the
                          resource type related to this operation. E.g. "Virtual Machines" or "Job
                          Schedule Collections".
                    },
                    "isDataAction": bool,  # Optional. Whether the operation applies to
                      data-plane. This is "true" for data-plane operations and "false" for Azure
                      Resource Manager/control-plane operations.
                    "name": "str",  # Optional. The name of the operation, as per Resource-Based
                      Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write",
                      "Microsoft.Compute/virtualMachines/capture/action".
                    "origin": "str"  # Optional. The intended executor of the operation; as in
                      Resource Based Access Control (RBAC) and audit logs UX. Default value is
                      "user,system". Known values are: "user", "system", and "user,system".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Operation]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Operation], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class OperationStatusOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.DeviceRegistryMgmtClient`'s
        :attr:`operation_status` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, location: str, operation_id: str, **kwargs: Any) -> _models.OperationStatusResult:
        """Returns the current status of an async operation.

        :param location: The location name. Required.
        :type location: str
        :param operation_id: The ID of an ongoing async operation. Required.
        :type operation_id: str
        :return: OperationStatusResult. The OperationStatusResult is compatible with MutableMapping
        :rtype: ~azure.mgmt.deviceregistry.models.OperationStatusResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "operations": [
                        ...
                    ],
                    "status": "str",  # Operation status. Required.
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the operation.
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "id": "str",  # Optional. Fully qualified ID for the async operation.
                    "name": "str",  # Optional. Name of the async operation.
                    "percentComplete": 0,  # Optional. Percent of the operation that is complete.
                    "startTime": "2020-02-20 00:00:00"  # Optional. The start time of the
                      operation.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.OperationStatusResult] = kwargs.pop("cls", None)

        _request = build_operation_status_get_request(
            location=location,
            operation_id=operation_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OperationStatusResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class AssetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.DeviceRegistryMgmtClient`'s
        :attr:`assets` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, resource_group_name: str, asset_name: str, **kwargs: Any) -> _models.Asset:
        # pylint: disable=line-too-long
        """Get a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :return: Asset. The Asset is compatible with MutableMapping
        :rtype: ~azure.mgmt.deviceregistry.models.Asset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Asset] = kwargs.pop("cls", None)

        _request = build_assets_get_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Asset, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_replace_initial(
        self, resource_group_name: str, asset_name: str, resource: Union[_models.Asset, JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_assets_create_or_replace_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_name: str,
        resource: _models.Asset,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Asset]:
        # pylint: disable=line-too-long
        """Create a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.deviceregistry.models.Asset
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Asset. The Asset is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.Asset]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Asset]:
        # pylint: disable=line-too-long
        """Create a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Asset. The Asset is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.Asset]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Asset]:
        # pylint: disable=line-too-long
        """Create a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Asset. The Asset is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.Asset]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self, resource_group_name: str, asset_name: str, resource: Union[_models.Asset, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.Asset]:
        # pylint: disable=line-too-long
        """Create a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Is one of the following types: Asset, JSON,
         IO[bytes] Required.
        :type resource: ~azure.mgmt.deviceregistry.models.Asset or JSON or IO[bytes]
        :return: An instance of LROPoller that returns Asset. The Asset is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.Asset]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Asset] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                asset_name=asset_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.Asset, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.Asset].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.Asset](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _update_initial(
        self,
        resource_group_name: str,
        asset_name: str,
        properties: Union[_models.AssetUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _content = json.dumps(properties, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_assets_update_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_name: str,
        properties: _models.AssetUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Asset]:
        # pylint: disable=line-too-long
        """Update a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: ~azure.mgmt.deviceregistry.models.AssetUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Asset. The Asset is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.Asset]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Asset]:
        # pylint: disable=line-too-long
        """Update a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Asset. The Asset is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.Asset]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_name: str,
        properties: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Asset]:
        # pylint: disable=line-too-long
        """Update a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Asset. The Asset is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.Asset]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        asset_name: str,
        properties: Union[_models.AssetUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.Asset]:
        # pylint: disable=line-too-long
        """Update a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Is one of the following types:
         AssetUpdate, JSON, IO[bytes] Required.
        :type properties: ~azure.mgmt.deviceregistry.models.AssetUpdate or JSON or IO[bytes]
        :return: An instance of LROPoller that returns Asset. The Asset is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.Asset]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Asset] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                asset_name=asset_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.Asset, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.Asset].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.Asset](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, asset_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_assets_delete_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(self, resource_group_name: str, asset_name: str, **kwargs: Any) -> LROPoller[None]:
        """Delete a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                asset_name=asset_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.Asset"]:
        # pylint: disable=line-too-long
        """List Asset resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of Asset
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.deviceregistry.models.Asset]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Asset]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_assets_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Asset], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.Asset"]:
        # pylint: disable=line-too-long
        """List Asset resources by subscription ID.

        :return: An iterator like instance of Asset
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.deviceregistry.models.Asset]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "assetEndpointProfileUri": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must have the format
                          <ModuleCR.metadata.namespace>/<ModuleCR.metadata.name>. Required.
                        "assetType": "str",  # Optional. Resource path to asset type (model)
                          definition.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "dataPoints": [
                            {
                                "dataSource": "str",  # The address of the source of
                                  the data in the asset (e.g. URL) so that a client can access the data
                                  source on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "dataPointConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the data point. For OPC UA, this
                                  could include configuration like, publishingInterval,
                                  samplingInterval, and queueSize.
                                "name": "str",  # Optional. The name of the data
                                  point.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the data point should be mapped to OpenTelemetry. Known values
                                  are: "none", "counter", "gauge", "histogram", and "log".
                            }
                        ],
                        "defaultDataPointsConfiguration": "str",  # Optional.
                          Protocol-specific default configuration for all data points. Each data point
                          can have its own configuration that overrides the default settings here. This
                          assumes that each asset instance has one protocol.
                        "defaultEventsConfiguration": "str",  # Optional. Protocol-specific
                          default configuration for all events. Each event can have its own
                          configuration that overrides the default settings here. This assumes that
                          each asset instance has one protocol.
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "capabilityId": "str",  # Optional. The path to the
                                  type definition of the capability (e.g. DTMI, OPC UA information
                                  model node id, etc.), for example
                                  dtmi:com:example:Robot:_contents:__prop1;1.
                                "eventConfiguration": "str",  # Optional.
                                  Protocol-specific configuration for the event. For OPC UA, this could
                                  include configuration like, publishingInterval, samplingInterval, and
                                  queueSize.
                                "name": "str",  # Optional. The name of the event.
                                "observabilityMode": "str"  # Optional. An indication
                                  of how the event should be mapped to OpenTelemetry. Known values are:
                                  "none" and "log".
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Asset]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_assets_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Asset], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class AssetEndpointProfilesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.DeviceRegistryMgmtClient`'s
        :attr:`asset_endpoint_profiles` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self, resource_group_name: str, asset_endpoint_profile_name: str, **kwargs: Any
    ) -> _models.AssetEndpointProfile:
        # pylint: disable=line-too-long
        """Get a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :return: AssetEndpointProfile. The AssetEndpointProfile is compatible with MutableMapping
        :rtype: ~azure.mgmt.deviceregistry.models.AssetEndpointProfile
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AssetEndpointProfile] = kwargs.pop("cls", None)

        _request = build_asset_endpoint_profiles_get_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AssetEndpointProfile, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_replace_initial(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        resource: Union[_models.AssetEndpointProfile, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_asset_endpoint_profiles_create_or_replace_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        resource: _models.AssetEndpointProfile,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AssetEndpointProfile]:
        # pylint: disable=line-too-long
        """Create a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.deviceregistry.models.AssetEndpointProfile
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AssetEndpointProfile. The AssetEndpointProfile
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.AssetEndpointProfile]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AssetEndpointProfile]:
        # pylint: disable=line-too-long
        """Create a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AssetEndpointProfile. The AssetEndpointProfile
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.AssetEndpointProfile]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AssetEndpointProfile]:
        # pylint: disable=line-too-long
        """Create a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AssetEndpointProfile. The AssetEndpointProfile
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.AssetEndpointProfile]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        resource: Union[_models.AssetEndpointProfile, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.AssetEndpointProfile]:
        # pylint: disable=line-too-long
        """Create a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Is one of the following types:
         AssetEndpointProfile, JSON, IO[bytes] Required.
        :type resource: ~azure.mgmt.deviceregistry.models.AssetEndpointProfile or JSON or IO[bytes]
        :return: An instance of LROPoller that returns AssetEndpointProfile. The AssetEndpointProfile
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.AssetEndpointProfile]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AssetEndpointProfile] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                asset_endpoint_profile_name=asset_endpoint_profile_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.AssetEndpointProfile, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.AssetEndpointProfile].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.AssetEndpointProfile](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _update_initial(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        properties: Union[_models.AssetEndpointProfileUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _content = json.dumps(properties, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_asset_endpoint_profiles_update_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        properties: _models.AssetEndpointProfileUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AssetEndpointProfile]:
        # pylint: disable=line-too-long
        """Update a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: ~azure.mgmt.deviceregistry.models.AssetEndpointProfileUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AssetEndpointProfile. The AssetEndpointProfile
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.AssetEndpointProfile]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "targetAddress": "str",  # Optional. The local valid URI specifying
                          the network address/DNS name of a southbound device. The scheme part of the
                          targetAddress URI specifies the type of the device. The
                          additionalConfiguration field holds further connector type specific
                          configuration.
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AssetEndpointProfile]:
        # pylint: disable=line-too-long
        """Update a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AssetEndpointProfile. The AssetEndpointProfile
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.AssetEndpointProfile]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        properties: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AssetEndpointProfile]:
        # pylint: disable=line-too-long
        """Update a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AssetEndpointProfile. The AssetEndpointProfile
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.AssetEndpointProfile]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        properties: Union[_models.AssetEndpointProfileUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.AssetEndpointProfile]:
        # pylint: disable=line-too-long
        """Update a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Is one of the following types:
         AssetEndpointProfileUpdate, JSON, IO[bytes] Required.
        :type properties: ~azure.mgmt.deviceregistry.models.AssetEndpointProfileUpdate or JSON or
         IO[bytes]
        :return: An instance of LROPoller that returns AssetEndpointProfile. The AssetEndpointProfile
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.deviceregistry.models.AssetEndpointProfile]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "targetAddress": "str",  # Optional. The local valid URI specifying
                          the network address/DNS name of a southbound device. The scheme part of the
                          targetAddress URI specifies the type of the device. The
                          additionalConfiguration field holds further connector type specific
                          configuration.
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AssetEndpointProfile] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                asset_endpoint_profile_name=asset_endpoint_profile_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.AssetEndpointProfile, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.AssetEndpointProfile].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.AssetEndpointProfile](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, asset_endpoint_profile_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_asset_endpoint_profiles_delete_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, asset_endpoint_profile_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                asset_endpoint_profile_name=asset_endpoint_profile_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_by_resource_group(
        self, resource_group_name: str, **kwargs: Any
    ) -> Iterable["_models.AssetEndpointProfile"]:
        # pylint: disable=line-too-long
        """List AssetEndpointProfile resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of AssetEndpointProfile
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.deviceregistry.models.AssetEndpointProfile]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AssetEndpointProfile]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_asset_endpoint_profiles_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AssetEndpointProfile], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.AssetEndpointProfile"]:
        # pylint: disable=line-too-long
        """List AssetEndpointProfile resources by subscription ID.

        :return: An iterator like instance of AssetEndpointProfile
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.deviceregistry.models.AssetEndpointProfile]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                      Required.
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "type": "str",  # The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                      Required.
                    "properties": {
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Contains connectivity
                          type specific further configuration (e.g. OPC UA, Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", and
                          "Accepted".
                        "transportAuthentication": {
                            "ownCertificates": [
                                {
                                    "certPasswordReference": "str",  # Optional.
                                      Secret Reference Name (Pfx or Pem password).
                                    "certSecretReference": "str",  # Optional.
                                      Secret Reference name (cert and private key).
                                    "certThumbprint": "str"  # Optional.
                                      Certificate thumbprint.
                                }
                            ]
                        },
                        "userAuthentication": {
                            "mode": "str",  # Defines the mode to authenticate the user
                              of the client at the server. Required. Known values are: "Anonymous",
                              "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordReference": "str",  # A reference to secret
                                  containing the password. Required.
                                "usernameReference": "str"  # A reference to secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateReference": "str"  # A reference to
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AssetEndpointProfile]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_asset_endpoint_profiles_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AssetEndpointProfile], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)
