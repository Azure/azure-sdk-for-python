# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, overload

from azure.core import MatchConditions
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceModifiedError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import AzureJSONEncoder, _deserialize
from ..._operations._operations import (
    build_text_translation_find_sentence_boundaries_request,
    build_text_translation_get_languages_request,
    build_text_translation_lookup_dictionary_entries_request,
    build_text_translation_lookup_dictionary_examples_request,
    build_text_translation_translate_request,
    build_text_translation_transliterate_request,
)
from .._vendor import TextTranslationClientMixinABC

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class TextTranslationClientOperationsMixin(TextTranslationClientMixinABC):
    @distributed_trace_async
    async def get_languages(
        self,
        *,
        client_trace_id: Optional[str] = None,
        scope: Optional[str] = None,
        accept_language: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.GetLanguagesResult:
        """Gets the set of languages currently supported by other operations of the Translator.

        Gets the set of languages currently supported by other operations of the Translator.

        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword scope: A comma-separated list of names defining the group of languages to return.
         Allowed group names are: ``translation``\ , ``transliteration`` and ``dictionary``.
         If no scope is given, then all groups are returned, which is equivalent to passing
         ``scope=translation,transliteration,dictionary``. To decide which set of supported languages
         is appropriate for your scenario, see the description of the `response object
         <#response-body>`_. Default value is None.
        :paramtype scope: str
        :keyword accept_language: The language to use for user interface strings. Some of the fields in
         the response are names of languages or
         names of regions. Use this parameter to define the language in which these names are returned.
         The language is specified by providing a well-formed BCP 47 language tag. For instance, use
         the value ``fr``
         to request names in French or use the value ``zh-Hant`` to request names in Chinese
         Traditional.
         Names are provided in the English language when a target language is not specified or when
         localization
         is not available. Default value is None.
        :paramtype accept_language: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GetLanguagesResult. The GetLanguagesResult is compatible with MutableMapping
        :rtype: ~azure.ai.translation.text.models.GetLanguagesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GetLanguagesResult] = kwargs.pop("cls", None)

        _request = build_text_translation_get_languages_request(
            client_trace_id=client_trace_id,
            scope=scope,
            accept_language=accept_language,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["X-RequestId"] = self._deserialize("str", response.headers.get("X-RequestId"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GetLanguagesResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def translate(
        self,
        request_body: List[_models.InputTextItem],
        *,
        to: List[str],
        client_trace_id: Optional[str] = None,
        from_parameter: Optional[str] = None,
        text_type: Optional[Union[str, _models.TextType]] = None,
        category: Optional[str] = None,
        profanity_action: Optional[Union[str, _models.ProfanityAction]] = None,
        profanity_marker: Optional[Union[str, _models.ProfanityMarker]] = None,
        include_alignment: Optional[bool] = None,
        include_sentence_length: Optional[bool] = None,
        suggested_from: Optional[str] = None,
        from_script: Optional[str] = None,
        to_script: Optional[str] = None,
        allow_fallback: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.TranslatedTextItem]:
        """Translate Text.

        Translate Text.

        :param request_body: Defines the content of the request. Required.
        :type request_body: list[~azure.ai.translation.text.models.InputTextItem]
        :keyword to: Specifies the language of the output text. The target language must be one of the
         supported languages included
         in the translation scope. For example, use to=de to translate to German.
         It's possible to translate to multiple languages simultaneously by repeating the parameter in
         the query string.
         For example, use to=de&to=it to translate to German and Italian. Required.
        :paramtype to: list[str]
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword from_parameter: Specifies the language of the input text. Find which languages are
         available to translate from by
         looking up supported languages using the translation scope. If the from parameter isn't
         specified,
         automatic language detection is applied to determine the source language.

         You must use the from parameter rather than autodetection when using the dynamic dictionary
         feature.
         Note: the dynamic dictionary feature is case-sensitive. Default value is None.
        :paramtype from_parameter: str
        :keyword text_type: Defines whether the text being translated is plain text or HTML text. Any
         HTML needs to be a well-formed,
         complete element. Possible values are: plain (default) or html. Known values are: "Plain" and
         "Html". Default value is None.
        :paramtype text_type: str or ~azure.ai.translation.text.models.TextType
        :keyword category: A string specifying the category (domain) of the translation. This parameter
         is used to get translations
         from a customized system built with Custom Translator. Add the Category ID from your Custom
         Translator
         project details to this parameter to use your deployed customized system. Default value is:
         general. Default value is None.
        :paramtype category: str
        :keyword profanity_action: Specifies how profanities should be treated in translations.
         Possible values are: NoAction (default), Marked or Deleted. Known values are: "NoAction",
         "Marked", and "Deleted". Default value is None.
        :paramtype profanity_action: str or ~azure.ai.translation.text.models.ProfanityAction
        :keyword profanity_marker: Specifies how profanities should be marked in translations.
         Possible values are: Asterisk (default) or Tag. Known values are: "Asterisk" and "Tag".
         Default value is None.
        :paramtype profanity_marker: str or ~azure.ai.translation.text.models.ProfanityMarker
        :keyword include_alignment: Specifies whether to include alignment projection from source text
         to translated text.
         Possible values are: true or false (default). Default value is None.
        :paramtype include_alignment: bool
        :keyword include_sentence_length: Specifies whether to include sentence boundaries for the
         input text and the translated text.
         Possible values are: true or false (default). Default value is None.
        :paramtype include_sentence_length: bool
        :keyword suggested_from: Specifies a fallback language if the language of the input text can't
         be identified.
         Language autodetection is applied when the from parameter is omitted. If detection fails,
         the suggestedFrom language will be assumed. Default value is None.
        :paramtype suggested_from: str
        :keyword from_script: Specifies the script of the input text. Default value is None.
        :paramtype from_script: str
        :keyword to_script: Specifies the script of the translated text. Default value is None.
        :paramtype to_script: str
        :keyword allow_fallback: Specifies that the service is allowed to fall back to a general system
         when a custom system doesn't exist.
         Possible values are: true (default) or false.

         allowFallback=false specifies that the translation should only use systems trained for the
         category specified
         by the request. If a translation for language X to language Y requires chaining through a
         pivot language E,
         then all the systems in the chain (X → E and E → Y) will need to be custom and have the same
         category.
         If no system is found with the specific category, the request will return a 400 status code.
         allowFallback=true
         specifies that the service is allowed to fall back to a general system when a custom system
         doesn't exist. Default value is None.
        :paramtype allow_fallback: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of TranslatedTextItem
        :rtype: list[~azure.ai.translation.text.models.TranslatedTextItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def translate(
        self,
        request_body: IO,
        *,
        to: List[str],
        client_trace_id: Optional[str] = None,
        from_parameter: Optional[str] = None,
        text_type: Optional[Union[str, _models.TextType]] = None,
        category: Optional[str] = None,
        profanity_action: Optional[Union[str, _models.ProfanityAction]] = None,
        profanity_marker: Optional[Union[str, _models.ProfanityMarker]] = None,
        include_alignment: Optional[bool] = None,
        include_sentence_length: Optional[bool] = None,
        suggested_from: Optional[str] = None,
        from_script: Optional[str] = None,
        to_script: Optional[str] = None,
        allow_fallback: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.TranslatedTextItem]:
        """Translate Text.

        Translate Text.

        :param request_body: Defines the content of the request. Required.
        :type request_body: IO
        :keyword to: Specifies the language of the output text. The target language must be one of the
         supported languages included
         in the translation scope. For example, use to=de to translate to German.
         It's possible to translate to multiple languages simultaneously by repeating the parameter in
         the query string.
         For example, use to=de&to=it to translate to German and Italian. Required.
        :paramtype to: list[str]
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword from_parameter: Specifies the language of the input text. Find which languages are
         available to translate from by
         looking up supported languages using the translation scope. If the from parameter isn't
         specified,
         automatic language detection is applied to determine the source language.

         You must use the from parameter rather than autodetection when using the dynamic dictionary
         feature.
         Note: the dynamic dictionary feature is case-sensitive. Default value is None.
        :paramtype from_parameter: str
        :keyword text_type: Defines whether the text being translated is plain text or HTML text. Any
         HTML needs to be a well-formed,
         complete element. Possible values are: plain (default) or html. Known values are: "Plain" and
         "Html". Default value is None.
        :paramtype text_type: str or ~azure.ai.translation.text.models.TextType
        :keyword category: A string specifying the category (domain) of the translation. This parameter
         is used to get translations
         from a customized system built with Custom Translator. Add the Category ID from your Custom
         Translator
         project details to this parameter to use your deployed customized system. Default value is:
         general. Default value is None.
        :paramtype category: str
        :keyword profanity_action: Specifies how profanities should be treated in translations.
         Possible values are: NoAction (default), Marked or Deleted. Known values are: "NoAction",
         "Marked", and "Deleted". Default value is None.
        :paramtype profanity_action: str or ~azure.ai.translation.text.models.ProfanityAction
        :keyword profanity_marker: Specifies how profanities should be marked in translations.
         Possible values are: Asterisk (default) or Tag. Known values are: "Asterisk" and "Tag".
         Default value is None.
        :paramtype profanity_marker: str or ~azure.ai.translation.text.models.ProfanityMarker
        :keyword include_alignment: Specifies whether to include alignment projection from source text
         to translated text.
         Possible values are: true or false (default). Default value is None.
        :paramtype include_alignment: bool
        :keyword include_sentence_length: Specifies whether to include sentence boundaries for the
         input text and the translated text.
         Possible values are: true or false (default). Default value is None.
        :paramtype include_sentence_length: bool
        :keyword suggested_from: Specifies a fallback language if the language of the input text can't
         be identified.
         Language autodetection is applied when the from parameter is omitted. If detection fails,
         the suggestedFrom language will be assumed. Default value is None.
        :paramtype suggested_from: str
        :keyword from_script: Specifies the script of the input text. Default value is None.
        :paramtype from_script: str
        :keyword to_script: Specifies the script of the translated text. Default value is None.
        :paramtype to_script: str
        :keyword allow_fallback: Specifies that the service is allowed to fall back to a general system
         when a custom system doesn't exist.
         Possible values are: true (default) or false.

         allowFallback=false specifies that the translation should only use systems trained for the
         category specified
         by the request. If a translation for language X to language Y requires chaining through a
         pivot language E,
         then all the systems in the chain (X → E and E → Y) will need to be custom and have the same
         category.
         If no system is found with the specific category, the request will return a 400 status code.
         allowFallback=true
         specifies that the service is allowed to fall back to a general system when a custom system
         doesn't exist. Default value is None.
        :paramtype allow_fallback: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of TranslatedTextItem
        :rtype: list[~azure.ai.translation.text.models.TranslatedTextItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def translate(
        self,
        request_body: Union[List[_models.InputTextItem], IO],
        *,
        to: List[str],
        client_trace_id: Optional[str] = None,
        from_parameter: Optional[str] = None,
        text_type: Optional[Union[str, _models.TextType]] = None,
        category: Optional[str] = None,
        profanity_action: Optional[Union[str, _models.ProfanityAction]] = None,
        profanity_marker: Optional[Union[str, _models.ProfanityMarker]] = None,
        include_alignment: Optional[bool] = None,
        include_sentence_length: Optional[bool] = None,
        suggested_from: Optional[str] = None,
        from_script: Optional[str] = None,
        to_script: Optional[str] = None,
        allow_fallback: Optional[bool] = None,
        **kwargs: Any
    ) -> List[_models.TranslatedTextItem]:
        """Translate Text.

        Translate Text.

        :param request_body: Defines the content of the request. Is either a [InputTextItem] type or a
         IO type. Required.
        :type request_body: list[~azure.ai.translation.text.models.InputTextItem] or IO
        :keyword to: Specifies the language of the output text. The target language must be one of the
         supported languages included
         in the translation scope. For example, use to=de to translate to German.
         It's possible to translate to multiple languages simultaneously by repeating the parameter in
         the query string.
         For example, use to=de&to=it to translate to German and Italian. Required.
        :paramtype to: list[str]
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword from_parameter: Specifies the language of the input text. Find which languages are
         available to translate from by
         looking up supported languages using the translation scope. If the from parameter isn't
         specified,
         automatic language detection is applied to determine the source language.

         You must use the from parameter rather than autodetection when using the dynamic dictionary
         feature.
         Note: the dynamic dictionary feature is case-sensitive. Default value is None.
        :paramtype from_parameter: str
        :keyword text_type: Defines whether the text being translated is plain text or HTML text. Any
         HTML needs to be a well-formed,
         complete element. Possible values are: plain (default) or html. Known values are: "Plain" and
         "Html". Default value is None.
        :paramtype text_type: str or ~azure.ai.translation.text.models.TextType
        :keyword category: A string specifying the category (domain) of the translation. This parameter
         is used to get translations
         from a customized system built with Custom Translator. Add the Category ID from your Custom
         Translator
         project details to this parameter to use your deployed customized system. Default value is:
         general. Default value is None.
        :paramtype category: str
        :keyword profanity_action: Specifies how profanities should be treated in translations.
         Possible values are: NoAction (default), Marked or Deleted. Known values are: "NoAction",
         "Marked", and "Deleted". Default value is None.
        :paramtype profanity_action: str or ~azure.ai.translation.text.models.ProfanityAction
        :keyword profanity_marker: Specifies how profanities should be marked in translations.
         Possible values are: Asterisk (default) or Tag. Known values are: "Asterisk" and "Tag".
         Default value is None.
        :paramtype profanity_marker: str or ~azure.ai.translation.text.models.ProfanityMarker
        :keyword include_alignment: Specifies whether to include alignment projection from source text
         to translated text.
         Possible values are: true or false (default). Default value is None.
        :paramtype include_alignment: bool
        :keyword include_sentence_length: Specifies whether to include sentence boundaries for the
         input text and the translated text.
         Possible values are: true or false (default). Default value is None.
        :paramtype include_sentence_length: bool
        :keyword suggested_from: Specifies a fallback language if the language of the input text can't
         be identified.
         Language autodetection is applied when the from parameter is omitted. If detection fails,
         the suggestedFrom language will be assumed. Default value is None.
        :paramtype suggested_from: str
        :keyword from_script: Specifies the script of the input text. Default value is None.
        :paramtype from_script: str
        :keyword to_script: Specifies the script of the translated text. Default value is None.
        :paramtype to_script: str
        :keyword allow_fallback: Specifies that the service is allowed to fall back to a general system
         when a custom system doesn't exist.
         Possible values are: true (default) or false.

         allowFallback=false specifies that the translation should only use systems trained for the
         category specified
         by the request. If a translation for language X to language Y requires chaining through a
         pivot language E,
         then all the systems in the chain (X → E and E → Y) will need to be custom and have the same
         category.
         If no system is found with the specific category, the request will return a 400 status code.
         allowFallback=true
         specifies that the service is allowed to fall back to a general system when a custom system
         doesn't exist. Default value is None.
        :paramtype allow_fallback: bool
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of TranslatedTextItem
        :rtype: list[~azure.ai.translation.text.models.TranslatedTextItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.TranslatedTextItem]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request_body, (IOBase, bytes)):
            _content = request_body
        else:
            _content = json.dumps(request_body, cls=AzureJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_text_translation_translate_request(
            to=to,
            client_trace_id=client_trace_id,
            from_parameter=from_parameter,
            text_type=text_type,
            category=category,
            profanity_action=profanity_action,
            profanity_marker=profanity_marker,
            include_alignment=include_alignment,
            include_sentence_length=include_sentence_length,
            suggested_from=suggested_from,
            from_script=from_script,
            to_script=to_script,
            allow_fallback=allow_fallback,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["X-RequestId"] = self._deserialize("str", response.headers.get("X-RequestId"))
        response_headers["x-mt-system"] = self._deserialize("str", response.headers.get("x-mt-system"))
        response_headers["x-metered-usage"] = self._deserialize("int", response.headers.get("x-metered-usage"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.TranslatedTextItem], response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def transliterate(
        self,
        request_body: List[_models.InputTextItem],
        *,
        language: str,
        from_script: str,
        to_script: str,
        client_trace_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.TransliteratedText]:
        """Transliterate Text.

        Transliterate Text.

        :param request_body: Defines the content of the request. Required.
        :type request_body: list[~azure.ai.translation.text.models.InputTextItem]
        :keyword language: Specifies the language of the text to convert from one script to another.
         Possible languages are listed in the transliteration scope obtained by querying the service
         for its supported languages. Required.
        :paramtype language: str
        :keyword from_script: Specifies the script used by the input text. Look up supported languages
         using the transliteration scope,
         to find input scripts available for the selected language. Required.
        :paramtype from_script: str
        :keyword to_script: Specifies the output script. Look up supported languages using the
         transliteration scope, to find output
         scripts available for the selected combination of input language and input script. Required.
        :paramtype to_script: str
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of TransliteratedText
        :rtype: list[~azure.ai.translation.text.models.TransliteratedText]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def transliterate(
        self,
        request_body: IO,
        *,
        language: str,
        from_script: str,
        to_script: str,
        client_trace_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.TransliteratedText]:
        """Transliterate Text.

        Transliterate Text.

        :param request_body: Defines the content of the request. Required.
        :type request_body: IO
        :keyword language: Specifies the language of the text to convert from one script to another.
         Possible languages are listed in the transliteration scope obtained by querying the service
         for its supported languages. Required.
        :paramtype language: str
        :keyword from_script: Specifies the script used by the input text. Look up supported languages
         using the transliteration scope,
         to find input scripts available for the selected language. Required.
        :paramtype from_script: str
        :keyword to_script: Specifies the output script. Look up supported languages using the
         transliteration scope, to find output
         scripts available for the selected combination of input language and input script. Required.
        :paramtype to_script: str
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of TransliteratedText
        :rtype: list[~azure.ai.translation.text.models.TransliteratedText]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def transliterate(
        self,
        request_body: Union[List[_models.InputTextItem], IO],
        *,
        language: str,
        from_script: str,
        to_script: str,
        client_trace_id: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.TransliteratedText]:
        """Transliterate Text.

        Transliterate Text.

        :param request_body: Defines the content of the request. Is either a [InputTextItem] type or a
         IO type. Required.
        :type request_body: list[~azure.ai.translation.text.models.InputTextItem] or IO
        :keyword language: Specifies the language of the text to convert from one script to another.
         Possible languages are listed in the transliteration scope obtained by querying the service
         for its supported languages. Required.
        :paramtype language: str
        :keyword from_script: Specifies the script used by the input text. Look up supported languages
         using the transliteration scope,
         to find input scripts available for the selected language. Required.
        :paramtype from_script: str
        :keyword to_script: Specifies the output script. Look up supported languages using the
         transliteration scope, to find output
         scripts available for the selected combination of input language and input script. Required.
        :paramtype to_script: str
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of TransliteratedText
        :rtype: list[~azure.ai.translation.text.models.TransliteratedText]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.TransliteratedText]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request_body, (IOBase, bytes)):
            _content = request_body
        else:
            _content = json.dumps(request_body, cls=AzureJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_text_translation_transliterate_request(
            language=language,
            from_script=from_script,
            to_script=to_script,
            client_trace_id=client_trace_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["X-RequestId"] = self._deserialize("str", response.headers.get("X-RequestId"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.TransliteratedText], response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def find_sentence_boundaries(
        self,
        request_body: List[_models.InputTextItem],
        *,
        client_trace_id: Optional[str] = None,
        language: Optional[str] = None,
        script: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.BreakSentenceItem]:
        """Find Sentence Boundaries.

        Find Sentence Boundaries.

        :param request_body: Defines the content of the request. Required.
        :type request_body: list[~azure.ai.translation.text.models.InputTextItem]
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword language: Language tag identifying the language of the input text.
         If a code isn't specified, automatic language detection will be applied. Default value is
         None.
        :paramtype language: str
        :keyword script: Script tag identifying the script used by the input text.
         If a script isn't specified, the default script of the language will be assumed. Default value
         is None.
        :paramtype script: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of BreakSentenceItem
        :rtype: list[~azure.ai.translation.text.models.BreakSentenceItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def find_sentence_boundaries(
        self,
        request_body: IO,
        *,
        client_trace_id: Optional[str] = None,
        language: Optional[str] = None,
        script: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.BreakSentenceItem]:
        """Find Sentence Boundaries.

        Find Sentence Boundaries.

        :param request_body: Defines the content of the request. Required.
        :type request_body: IO
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword language: Language tag identifying the language of the input text.
         If a code isn't specified, automatic language detection will be applied. Default value is
         None.
        :paramtype language: str
        :keyword script: Script tag identifying the script used by the input text.
         If a script isn't specified, the default script of the language will be assumed. Default value
         is None.
        :paramtype script: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of BreakSentenceItem
        :rtype: list[~azure.ai.translation.text.models.BreakSentenceItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def find_sentence_boundaries(
        self,
        request_body: Union[List[_models.InputTextItem], IO],
        *,
        client_trace_id: Optional[str] = None,
        language: Optional[str] = None,
        script: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.BreakSentenceItem]:
        """Find Sentence Boundaries.

        Find Sentence Boundaries.

        :param request_body: Defines the content of the request. Is either a [InputTextItem] type or a
         IO type. Required.
        :type request_body: list[~azure.ai.translation.text.models.InputTextItem] or IO
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword language: Language tag identifying the language of the input text.
         If a code isn't specified, automatic language detection will be applied. Default value is
         None.
        :paramtype language: str
        :keyword script: Script tag identifying the script used by the input text.
         If a script isn't specified, the default script of the language will be assumed. Default value
         is None.
        :paramtype script: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of BreakSentenceItem
        :rtype: list[~azure.ai.translation.text.models.BreakSentenceItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.BreakSentenceItem]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request_body, (IOBase, bytes)):
            _content = request_body
        else:
            _content = json.dumps(request_body, cls=AzureJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_text_translation_find_sentence_boundaries_request(
            client_trace_id=client_trace_id,
            language=language,
            script=script,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["X-RequestId"] = self._deserialize("str", response.headers.get("X-RequestId"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.BreakSentenceItem], response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def lookup_dictionary_entries(
        self,
        request_body: List[_models.InputTextItem],
        *,
        from_parameter: str,
        to: str,
        client_trace_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.DictionaryLookupItem]:
        """Lookup Dictionary Entries.

        Lookup Dictionary Entries.

        :param request_body: Defines the content of the request. Required.
        :type request_body: list[~azure.ai.translation.text.models.InputTextItem]
        :keyword from_parameter: Specifies the language of the input text.
         The source language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype from_parameter: str
        :keyword to: Specifies the language of the output text.
         The target language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype to: str
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of DictionaryLookupItem
        :rtype: list[~azure.ai.translation.text.models.DictionaryLookupItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def lookup_dictionary_entries(
        self,
        request_body: IO,
        *,
        from_parameter: str,
        to: str,
        client_trace_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.DictionaryLookupItem]:
        """Lookup Dictionary Entries.

        Lookup Dictionary Entries.

        :param request_body: Defines the content of the request. Required.
        :type request_body: IO
        :keyword from_parameter: Specifies the language of the input text.
         The source language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype from_parameter: str
        :keyword to: Specifies the language of the output text.
         The target language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype to: str
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of DictionaryLookupItem
        :rtype: list[~azure.ai.translation.text.models.DictionaryLookupItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def lookup_dictionary_entries(
        self,
        request_body: Union[List[_models.InputTextItem], IO],
        *,
        from_parameter: str,
        to: str,
        client_trace_id: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.DictionaryLookupItem]:
        """Lookup Dictionary Entries.

        Lookup Dictionary Entries.

        :param request_body: Defines the content of the request. Is either a [InputTextItem] type or a
         IO type. Required.
        :type request_body: list[~azure.ai.translation.text.models.InputTextItem] or IO
        :keyword from_parameter: Specifies the language of the input text.
         The source language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype from_parameter: str
        :keyword to: Specifies the language of the output text.
         The target language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype to: str
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of DictionaryLookupItem
        :rtype: list[~azure.ai.translation.text.models.DictionaryLookupItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.DictionaryLookupItem]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request_body, (IOBase, bytes)):
            _content = request_body
        else:
            _content = json.dumps(request_body, cls=AzureJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_text_translation_lookup_dictionary_entries_request(
            from_parameter=from_parameter,
            to=to,
            client_trace_id=client_trace_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["X-RequestId"] = self._deserialize("str", response.headers.get("X-RequestId"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.DictionaryLookupItem], response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def lookup_dictionary_examples(
        self,
        request_body: List[_models.DictionaryExampleTextItem],
        *,
        from_parameter: str,
        to: str,
        client_trace_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.DictionaryExampleItem]:
        """Lookup Dictionary Examples.

        Lookup Dictionary Examples.

        :param request_body: Defines the content of the request. Required.
        :type request_body: list[~azure.ai.translation.text.models.DictionaryExampleTextItem]
        :keyword from_parameter: Specifies the language of the input text.
         The source language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype from_parameter: str
        :keyword to: Specifies the language of the output text.
         The target language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype to: str
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of DictionaryExampleItem
        :rtype: list[~azure.ai.translation.text.models.DictionaryExampleItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def lookup_dictionary_examples(
        self,
        request_body: IO,
        *,
        from_parameter: str,
        to: str,
        client_trace_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.DictionaryExampleItem]:
        """Lookup Dictionary Examples.

        Lookup Dictionary Examples.

        :param request_body: Defines the content of the request. Required.
        :type request_body: IO
        :keyword from_parameter: Specifies the language of the input text.
         The source language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype from_parameter: str
        :keyword to: Specifies the language of the output text.
         The target language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype to: str
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of DictionaryExampleItem
        :rtype: list[~azure.ai.translation.text.models.DictionaryExampleItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def lookup_dictionary_examples(
        self,
        request_body: Union[List[_models.DictionaryExampleTextItem], IO],
        *,
        from_parameter: str,
        to: str,
        client_trace_id: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.DictionaryExampleItem]:
        """Lookup Dictionary Examples.

        Lookup Dictionary Examples.

        :param request_body: Defines the content of the request. Is either a
         [DictionaryExampleTextItem] type or a IO type. Required.
        :type request_body: list[~azure.ai.translation.text.models.DictionaryExampleTextItem] or IO
        :keyword from_parameter: Specifies the language of the input text.
         The source language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype from_parameter: str
        :keyword to: Specifies the language of the output text.
         The target language must be one of the supported languages included in the dictionary scope.
         Required.
        :paramtype to: str
        :keyword client_trace_id: A client-generated GUID to uniquely identify the request. Default
         value is None.
        :paramtype client_trace_id: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of DictionaryExampleItem
        :rtype: list[~azure.ai.translation.text.models.DictionaryExampleItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.DictionaryExampleItem]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request_body, (IOBase, bytes)):
            _content = request_body
        else:
            _content = json.dumps(request_body, cls=AzureJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_text_translation_lookup_dictionary_examples_request(
            from_parameter=from_parameter,
            to=to,
            client_trace_id=client_trace_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["X-RequestId"] = self._deserialize("str", response.headers.get("X-RequestId"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.DictionaryExampleItem], response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore
