# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
from typing import Dict, List, Optional, Union

from azure.core.exceptions import HttpResponseError
import msrest.serialization

from ._azure_media_services_enums import *


class AccessControl(msrest.serialization.Model):
    """AccessControl.

    :param default_action: The behavior for IP access control in Key Delivery. Possible values
     include: "Allow", "Deny".
    :type default_action: str or ~azure.mgmt.media.models.DefaultAction
    :param ip_allow_list: The IP allow list for access control in Key Delivery. If the default
     action is set to 'Allow', the IP allow list must be empty.
    :type ip_allow_list: list[str]
    """

    _attribute_map = {
        'default_action': {'key': 'defaultAction', 'type': 'str'},
        'ip_allow_list': {'key': 'ipAllowList', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        default_action: Optional[Union[str, "DefaultAction"]] = None,
        ip_allow_list: Optional[List[str]] = None,
        **kwargs
    ):
        super(AccessControl, self).__init__(**kwargs)
        self.default_action = default_action
        self.ip_allow_list = ip_allow_list


class AccountEncryption(msrest.serialization.Model):
    """AccountEncryption.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of key used to encrypt the Account Key. Possible values
     include: "SystemKey", "CustomerKey".
    :type type: str or ~azure.mgmt.media.models.AccountEncryptionKeyType
    :param key_vault_properties: The properties of the key used to encrypt the account.
    :type key_vault_properties: ~azure.mgmt.media.models.KeyVaultProperties
    :param identity: The Key Vault identity.
    :type identity: ~azure.mgmt.media.models.ResourceIdentity
    :ivar status: The current status of the Key Vault mapping.
    :vartype status: str
    """

    _validation = {
        'type': {'required': True},
        'status': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'key_vault_properties': {'key': 'keyVaultProperties', 'type': 'KeyVaultProperties'},
        'identity': {'key': 'identity', 'type': 'ResourceIdentity'},
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: Union[str, "AccountEncryptionKeyType"],
        key_vault_properties: Optional["KeyVaultProperties"] = None,
        identity: Optional["ResourceIdentity"] = None,
        **kwargs
    ):
        super(AccountEncryption, self).__init__(**kwargs)
        self.type = type
        self.key_vault_properties = key_vault_properties
        self.identity = identity
        self.status = None


class Resource(msrest.serialization.Model):
    """Common fields that are returned in the response for all Azure Resource Manager resources.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None


class ProxyResource(Resource):
    """The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a location.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ProxyResource, self).__init__(**kwargs)


class AccountFilter(ProxyResource):
    """An Account Filter.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: The system metadata relating to this resource.
    :vartype system_data: ~azure.mgmt.media.models.SystemData
    :param presentation_time_range: The presentation time range.
    :type presentation_time_range: ~azure.mgmt.media.models.PresentationTimeRange
    :param first_quality: The first quality.
    :type first_quality: ~azure.mgmt.media.models.FirstQuality
    :param tracks: The tracks selection conditions.
    :type tracks: list[~azure.mgmt.media.models.FilterTrackSelection]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'presentation_time_range': {'key': 'properties.presentationTimeRange', 'type': 'PresentationTimeRange'},
        'first_quality': {'key': 'properties.firstQuality', 'type': 'FirstQuality'},
        'tracks': {'key': 'properties.tracks', 'type': '[FilterTrackSelection]'},
    }

    def __init__(
        self,
        *,
        presentation_time_range: Optional["PresentationTimeRange"] = None,
        first_quality: Optional["FirstQuality"] = None,
        tracks: Optional[List["FilterTrackSelection"]] = None,
        **kwargs
    ):
        super(AccountFilter, self).__init__(**kwargs)
        self.system_data = None
        self.presentation_time_range = presentation_time_range
        self.first_quality = first_quality
        self.tracks = tracks


class AccountFilterCollection(msrest.serialization.Model):
    """A collection of AccountFilter items.

    :param value: A collection of AccountFilter items.
    :type value: list[~azure.mgmt.media.models.AccountFilter]
    :param odata_next_link: A link to the next page of the collection (when the collection contains
     too many results to return in one response).
    :type odata_next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[AccountFilter]'},
        'odata_next_link': {'key': '@odata\\.nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["AccountFilter"]] = None,
        odata_next_link: Optional[str] = None,
        **kwargs
    ):
        super(AccountFilterCollection, self).__init__(**kwargs)
        self.value = value
        self.odata_next_link = odata_next_link


class AkamaiAccessControl(msrest.serialization.Model):
    """Akamai access control.

    :param akamai_signature_header_authentication_key_list: authentication key list.
    :type akamai_signature_header_authentication_key_list:
     list[~azure.mgmt.media.models.AkamaiSignatureHeaderAuthenticationKey]
    """

    _attribute_map = {
        'akamai_signature_header_authentication_key_list': {'key': 'akamaiSignatureHeaderAuthenticationKeyList', 'type': '[AkamaiSignatureHeaderAuthenticationKey]'},
    }

    def __init__(
        self,
        *,
        akamai_signature_header_authentication_key_list: Optional[List["AkamaiSignatureHeaderAuthenticationKey"]] = None,
        **kwargs
    ):
        super(AkamaiAccessControl, self).__init__(**kwargs)
        self.akamai_signature_header_authentication_key_list = akamai_signature_header_authentication_key_list


class AkamaiSignatureHeaderAuthenticationKey(msrest.serialization.Model):
    """Akamai Signature Header authentication key.

    :param identifier: identifier of the key.
    :type identifier: str
    :param base64_key: authentication key.
    :type base64_key: str
    :param expiration: The expiration time of the authentication key.
    :type expiration: ~datetime.datetime
    """

    _attribute_map = {
        'identifier': {'key': 'identifier', 'type': 'str'},
        'base64_key': {'key': 'base64Key', 'type': 'str'},
        'expiration': {'key': 'expiration', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        base64_key: Optional[str] = None,
        expiration: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(AkamaiSignatureHeaderAuthenticationKey, self).__init__(**kwargs)
        self.identifier = identifier
        self.base64_key = base64_key
        self.expiration = expiration


class Asset(ProxyResource):
    """An Asset.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: The system metadata relating to this resource.
    :vartype system_data: ~azure.mgmt.media.models.SystemData
    :ivar asset_id: The Asset ID.
    :vartype asset_id: str
    :ivar created: The creation date of the Asset.
    :vartype created: ~datetime.datetime
    :ivar last_modified: The last modified date of the Asset.
    :vartype last_modified: ~datetime.datetime
    :param alternate_id: The alternate ID of the Asset.
    :type alternate_id: str
    :param description: The Asset description.
    :type description: str
    :param container: The name of the asset blob container.
    :type container: str
    :param storage_account_name: The name of the storage account.
    :type storage_account_name: str
    :ivar storage_encryption_format: The Asset encryption format. One of None or
     MediaStorageEncryption. Possible values include: "None", "MediaStorageClientEncryption".
    :vartype storage_encryption_format: str or
     ~azure.mgmt.media.models.AssetStorageEncryptionFormat
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'asset_id': {'readonly': True},
        'created': {'readonly': True},
        'last_modified': {'readonly': True},
        'storage_encryption_format': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'asset_id': {'key': 'properties.assetId', 'type': 'str'},
        'created': {'key': 'properties.created', 'type': 'iso-8601'},
        'last_modified': {'key': 'properties.lastModified', 'type': 'iso-8601'},
        'alternate_id': {'key': 'properties.alternateId', 'type': 'str'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'container': {'key': 'properties.container', 'type': 'str'},
        'storage_account_name': {'key': 'properties.storageAccountName', 'type': 'str'},
        'storage_encryption_format': {'key': 'properties.storageEncryptionFormat', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        alternate_id: Optional[str] = None,
        description: Optional[str] = None,
        container: Optional[str] = None,
        storage_account_name: Optional[str] = None,
        **kwargs
    ):
        super(Asset, self).__init__(**kwargs)
        self.system_data = None
        self.asset_id = None
        self.created = None
        self.last_modified = None
        self.alternate_id = alternate_id
        self.description = description
        self.container = container
        self.storage_account_name = storage_account_name
        self.storage_encryption_format = None


class AssetCollection(msrest.serialization.Model):
    """A collection of Asset items.

    :param value: A collection of Asset items.
    :type value: list[~azure.mgmt.media.models.Asset]
    :param odata_next_link: A link to the next page of the collection (when the collection contains
     too many results to return in one response).
    :type odata_next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Asset]'},
        'odata_next_link': {'key': '@odata\\.nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["Asset"]] = None,
        odata_next_link: Optional[str] = None,
        **kwargs
    ):
        super(AssetCollection, self).__init__(**kwargs)
        self.value = value
        self.odata_next_link = odata_next_link


class AssetContainerSas(msrest.serialization.Model):
    """The Asset Storage container SAS URLs.

    :param asset_container_sas_urls: The list of Asset container SAS URLs.
    :type asset_container_sas_urls: list[str]
    """

    _attribute_map = {
        'asset_container_sas_urls': {'key': 'assetContainerSasUrls', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        asset_container_sas_urls: Optional[List[str]] = None,
        **kwargs
    ):
        super(AssetContainerSas, self).__init__(**kwargs)
        self.asset_container_sas_urls = asset_container_sas_urls


class AssetFileEncryptionMetadata(msrest.serialization.Model):
    """The Asset File Storage encryption metadata.

    All required parameters must be populated in order to send to Azure.

    :param initialization_vector: The Asset File initialization vector.
    :type initialization_vector: str
    :param asset_file_name: The Asset File name.
    :type asset_file_name: str
    :param asset_file_id: Required. The Asset File Id.
    :type asset_file_id: str
    """

    _validation = {
        'asset_file_id': {'required': True},
    }

    _attribute_map = {
        'initialization_vector': {'key': 'initializationVector', 'type': 'str'},
        'asset_file_name': {'key': 'assetFileName', 'type': 'str'},
        'asset_file_id': {'key': 'assetFileId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        asset_file_id: str,
        initialization_vector: Optional[str] = None,
        asset_file_name: Optional[str] = None,
        **kwargs
    ):
        super(AssetFileEncryptionMetadata, self).__init__(**kwargs)
        self.initialization_vector = initialization_vector
        self.asset_file_name = asset_file_name
        self.asset_file_id = asset_file_id


class AssetFilter(ProxyResource):
    """An Asset Filter.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: The system metadata relating to this resource.
    :vartype system_data: ~azure.mgmt.media.models.SystemData
    :param presentation_time_range: The presentation time range.
    :type presentation_time_range: ~azure.mgmt.media.models.PresentationTimeRange
    :param first_quality: The first quality.
    :type first_quality: ~azure.mgmt.media.models.FirstQuality
    :param tracks: The tracks selection conditions.
    :type tracks: list[~azure.mgmt.media.models.FilterTrackSelection]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'presentation_time_range': {'key': 'properties.presentationTimeRange', 'type': 'PresentationTimeRange'},
        'first_quality': {'key': 'properties.firstQuality', 'type': 'FirstQuality'},
        'tracks': {'key': 'properties.tracks', 'type': '[FilterTrackSelection]'},
    }

    def __init__(
        self,
        *,
        presentation_time_range: Optional["PresentationTimeRange"] = None,
        first_quality: Optional["FirstQuality"] = None,
        tracks: Optional[List["FilterTrackSelection"]] = None,
        **kwargs
    ):
        super(AssetFilter, self).__init__(**kwargs)
        self.system_data = None
        self.presentation_time_range = presentation_time_range
        self.first_quality = first_quality
        self.tracks = tracks


class AssetFilterCollection(msrest.serialization.Model):
    """A collection of AssetFilter items.

    :param value: A collection of AssetFilter items.
    :type value: list[~azure.mgmt.media.models.AssetFilter]
    :param odata_next_link: A link to the next page of the collection (when the collection contains
     too many results to return in one response).
    :type odata_next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[AssetFilter]'},
        'odata_next_link': {'key': '@odata\\.nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["AssetFilter"]] = None,
        odata_next_link: Optional[str] = None,
        **kwargs
    ):
        super(AssetFilterCollection, self).__init__(**kwargs)
        self.value = value
        self.odata_next_link = odata_next_link


class AssetStreamingLocator(msrest.serialization.Model):
    """Properties of the Streaming Locator.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: Streaming Locator name.
    :vartype name: str
    :ivar asset_name: Asset Name.
    :vartype asset_name: str
    :ivar created: The creation time of the Streaming Locator.
    :vartype created: ~datetime.datetime
    :ivar start_time: The start time of the Streaming Locator.
    :vartype start_time: ~datetime.datetime
    :ivar end_time: The end time of the Streaming Locator.
    :vartype end_time: ~datetime.datetime
    :ivar streaming_locator_id: StreamingLocatorId of the Streaming Locator.
    :vartype streaming_locator_id: str
    :ivar streaming_policy_name: Name of the Streaming Policy used by this Streaming Locator.
    :vartype streaming_policy_name: str
    :ivar default_content_key_policy_name: Name of the default ContentKeyPolicy used by this
     Streaming Locator.
    :vartype default_content_key_policy_name: str
    """

    _validation = {
        'name': {'readonly': True},
        'asset_name': {'readonly': True},
        'created': {'readonly': True},
        'start_time': {'readonly': True},
        'end_time': {'readonly': True},
        'streaming_locator_id': {'readonly': True},
        'streaming_policy_name': {'readonly': True},
        'default_content_key_policy_name': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'asset_name': {'key': 'assetName', 'type': 'str'},
        'created': {'key': 'created', 'type': 'iso-8601'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
        'streaming_locator_id': {'key': 'streamingLocatorId', 'type': 'str'},
        'streaming_policy_name': {'key': 'streamingPolicyName', 'type': 'str'},
        'default_content_key_policy_name': {'key': 'defaultContentKeyPolicyName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AssetStreamingLocator, self).__init__(**kwargs)
        self.name = None
        self.asset_name = None
        self.created = None
        self.start_time = None
        self.end_time = None
        self.streaming_locator_id = None
        self.streaming_policy_name = None
        self.default_content_key_policy_name = None


class CbcsDrmConfiguration(msrest.serialization.Model):
    """Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy.

    :param fair_play: FairPlay configurations.
    :type fair_play: ~azure.mgmt.media.models.StreamingPolicyFairPlayConfiguration
    :param play_ready: PlayReady configurations.
    :type play_ready: ~azure.mgmt.media.models.StreamingPolicyPlayReadyConfiguration
    :param widevine: Widevine configurations.
    :type widevine: ~azure.mgmt.media.models.StreamingPolicyWidevineConfiguration
    """

    _attribute_map = {
        'fair_play': {'key': 'fairPlay', 'type': 'StreamingPolicyFairPlayConfiguration'},
        'play_ready': {'key': 'playReady', 'type': 'StreamingPolicyPlayReadyConfiguration'},
        'widevine': {'key': 'widevine', 'type': 'StreamingPolicyWidevineConfiguration'},
    }

    def __init__(
        self,
        *,
        fair_play: Optional["StreamingPolicyFairPlayConfiguration"] = None,
        play_ready: Optional["StreamingPolicyPlayReadyConfiguration"] = None,
        widevine: Optional["StreamingPolicyWidevineConfiguration"] = None,
        **kwargs
    ):
        super(CbcsDrmConfiguration, self).__init__(**kwargs)
        self.fair_play = fair_play
        self.play_ready = play_ready
        self.widevine = widevine


class CencDrmConfiguration(msrest.serialization.Model):
    """Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy.

    :param play_ready: PlayReady configurations.
    :type play_ready: ~azure.mgmt.media.models.StreamingPolicyPlayReadyConfiguration
    :param widevine: Widevine configurations.
    :type widevine: ~azure.mgmt.media.models.StreamingPolicyWidevineConfiguration
    """

    _attribute_map = {
        'play_ready': {'key': 'playReady', 'type': 'StreamingPolicyPlayReadyConfiguration'},
        'widevine': {'key': 'widevine', 'type': 'StreamingPolicyWidevineConfiguration'},
    }

    def __init__(
        self,
        *,
        play_ready: Optional["StreamingPolicyPlayReadyConfiguration"] = None,
        widevine: Optional["StreamingPolicyWidevineConfiguration"] = None,
        **kwargs
    ):
        super(CencDrmConfiguration, self).__init__(**kwargs)
        self.play_ready = play_ready
        self.widevine = widevine


class CheckNameAvailabilityInput(msrest.serialization.Model):
    """The input to the check name availability request.

    :param name: The account name.
    :type name: str
    :param type: The account type. For a Media Services account, this should be 'MediaServices'.
    :type type: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        type: Optional[str] = None,
        **kwargs
    ):
        super(CheckNameAvailabilityInput, self).__init__(**kwargs)
        self.name = name
        self.type = type


class CommonEncryptionCbcs(msrest.serialization.Model):
    """Class for CommonEncryptionCbcs encryption scheme.

    :param enabled_protocols: Representing supported protocols.
    :type enabled_protocols: ~azure.mgmt.media.models.EnabledProtocols
    :param clear_tracks: Representing which tracks should not be encrypted.
    :type clear_tracks: list[~azure.mgmt.media.models.TrackSelection]
    :param content_keys: Representing default content key for each encryption scheme and separate
     content keys for specific tracks.
    :type content_keys: ~azure.mgmt.media.models.StreamingPolicyContentKeys
    :param drm: Configuration of DRMs for current encryption scheme.
    :type drm: ~azure.mgmt.media.models.CbcsDrmConfiguration
    """

    _attribute_map = {
        'enabled_protocols': {'key': 'enabledProtocols', 'type': 'EnabledProtocols'},
        'clear_tracks': {'key': 'clearTracks', 'type': '[TrackSelection]'},
        'content_keys': {'key': 'contentKeys', 'type': 'StreamingPolicyContentKeys'},
        'drm': {'key': 'drm', 'type': 'CbcsDrmConfiguration'},
    }

    def __init__(
        self,
        *,
        enabled_protocols: Optional["EnabledProtocols"] = None,
        clear_tracks: Optional[List["TrackSelection"]] = None,
        content_keys: Optional["StreamingPolicyContentKeys"] = None,
        drm: Optional["CbcsDrmConfiguration"] = None,
        **kwargs
    ):
        super(CommonEncryptionCbcs, self).__init__(**kwargs)
        self.enabled_protocols = enabled_protocols
        self.clear_tracks = clear_tracks
        self.content_keys = content_keys
        self.drm = drm


class CommonEncryptionCenc(msrest.serialization.Model):
    """Class for envelope encryption scheme.

    :param enabled_protocols: Representing supported protocols.
    :type enabled_protocols: ~azure.mgmt.media.models.EnabledProtocols
    :param clear_tracks: Representing which tracks should not be encrypted.
    :type clear_tracks: list[~azure.mgmt.media.models.TrackSelection]
    :param content_keys: Representing default content key for each encryption scheme and separate
     content keys for specific tracks.
    :type content_keys: ~azure.mgmt.media.models.StreamingPolicyContentKeys
    :param drm: Configuration of DRMs for CommonEncryptionCenc encryption scheme.
    :type drm: ~azure.mgmt.media.models.CencDrmConfiguration
    """

    _attribute_map = {
        'enabled_protocols': {'key': 'enabledProtocols', 'type': 'EnabledProtocols'},
        'clear_tracks': {'key': 'clearTracks', 'type': '[TrackSelection]'},
        'content_keys': {'key': 'contentKeys', 'type': 'StreamingPolicyContentKeys'},
        'drm': {'key': 'drm', 'type': 'CencDrmConfiguration'},
    }

    def __init__(
        self,
        *,
        enabled_protocols: Optional["EnabledProtocols"] = None,
        clear_tracks: Optional[List["TrackSelection"]] = None,
        content_keys: Optional["StreamingPolicyContentKeys"] = None,
        drm: Optional["CencDrmConfiguration"] = None,
        **kwargs
    ):
        super(CommonEncryptionCenc, self).__init__(**kwargs)
        self.enabled_protocols = enabled_protocols
        self.clear_tracks = clear_tracks
        self.content_keys = content_keys
        self.drm = drm


class ContentKeyPolicy(ProxyResource):
    """A Content Key Policy resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: The system metadata relating to this resource.
    :vartype system_data: ~azure.mgmt.media.models.SystemData
    :ivar policy_id: The legacy Policy ID.
    :vartype policy_id: str
    :ivar created: The creation date of the Policy.
    :vartype created: ~datetime.datetime
    :ivar last_modified: The last modified date of the Policy.
    :vartype last_modified: ~datetime.datetime
    :param description: A description for the Policy.
    :type description: str
    :param options: The Key Policy options.
    :type options: list[~azure.mgmt.media.models.ContentKeyPolicyOption]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'policy_id': {'readonly': True},
        'created': {'readonly': True},
        'last_modified': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'policy_id': {'key': 'properties.policyId', 'type': 'str'},
        'created': {'key': 'properties.created', 'type': 'iso-8601'},
        'last_modified': {'key': 'properties.lastModified', 'type': 'iso-8601'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'options': {'key': 'properties.options', 'type': '[ContentKeyPolicyOption]'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        options: Optional[List["ContentKeyPolicyOption"]] = None,
        **kwargs
    ):
        super(ContentKeyPolicy, self).__init__(**kwargs)
        self.system_data = None
        self.policy_id = None
        self.created = None
        self.last_modified = None
        self.description = description
        self.options = options


class ContentKeyPolicyConfiguration(msrest.serialization.Model):
    """Base class for Content Key Policy configuration. A derived class must be used to create a configuration.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ContentKeyPolicyClearKeyConfiguration, ContentKeyPolicyFairPlayConfiguration, ContentKeyPolicyPlayReadyConfiguration, ContentKeyPolicyUnknownConfiguration, ContentKeyPolicyWidevineConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
    }

    _subtype_map = {
        'odata_type': {'#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration': 'ContentKeyPolicyClearKeyConfiguration', '#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration': 'ContentKeyPolicyFairPlayConfiguration', '#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration': 'ContentKeyPolicyPlayReadyConfiguration', '#Microsoft.Media.ContentKeyPolicyUnknownConfiguration': 'ContentKeyPolicyUnknownConfiguration', '#Microsoft.Media.ContentKeyPolicyWidevineConfiguration': 'ContentKeyPolicyWidevineConfiguration'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContentKeyPolicyConfiguration, self).__init__(**kwargs)
        self.odata_type = None  # type: Optional[str]


class ContentKeyPolicyClearKeyConfiguration(ContentKeyPolicyConfiguration):
    """Represents a configuration for non-DRM keys.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContentKeyPolicyClearKeyConfiguration, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration'  # type: str


class ContentKeyPolicyCollection(msrest.serialization.Model):
    """A collection of ContentKeyPolicy items.

    :param value: A collection of ContentKeyPolicy items.
    :type value: list[~azure.mgmt.media.models.ContentKeyPolicy]
    :param odata_next_link: A link to the next page of the collection (when the collection contains
     too many results to return in one response).
    :type odata_next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ContentKeyPolicy]'},
        'odata_next_link': {'key': '@odata\\.nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["ContentKeyPolicy"]] = None,
        odata_next_link: Optional[str] = None,
        **kwargs
    ):
        super(ContentKeyPolicyCollection, self).__init__(**kwargs)
        self.value = value
        self.odata_next_link = odata_next_link


class ContentKeyPolicyFairPlayConfiguration(ContentKeyPolicyConfiguration):
    """Specifies a configuration for FairPlay licenses.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    :param ask: Required. The key that must be used as FairPlay Application Secret key.
    :type ask: bytearray
    :param fair_play_pfx_password: Required. The password encrypting FairPlay certificate in PKCS
     12 (pfx) format.
    :type fair_play_pfx_password: str
    :param fair_play_pfx: Required. The Base64 representation of FairPlay certificate in PKCS 12
     (pfx) format (including private key).
    :type fair_play_pfx: str
    :param rental_and_lease_key_type: Required. The rental and lease key type. Possible values
     include: "Unknown", "Undefined", "DualExpiry", "PersistentUnlimited", "PersistentLimited".
    :type rental_and_lease_key_type: str or
     ~azure.mgmt.media.models.ContentKeyPolicyFairPlayRentalAndLeaseKeyType
    :param rental_duration: Required. The rental duration. Must be greater than or equal to 0.
    :type rental_duration: long
    :param offline_rental_configuration: Offline rental policy.
    :type offline_rental_configuration:
     ~azure.mgmt.media.models.ContentKeyPolicyFairPlayOfflineRentalConfiguration
    """

    _validation = {
        'odata_type': {'required': True},
        'ask': {'required': True},
        'fair_play_pfx_password': {'required': True},
        'fair_play_pfx': {'required': True},
        'rental_and_lease_key_type': {'required': True},
        'rental_duration': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
        'ask': {'key': 'ask', 'type': 'bytearray'},
        'fair_play_pfx_password': {'key': 'fairPlayPfxPassword', 'type': 'str'},
        'fair_play_pfx': {'key': 'fairPlayPfx', 'type': 'str'},
        'rental_and_lease_key_type': {'key': 'rentalAndLeaseKeyType', 'type': 'str'},
        'rental_duration': {'key': 'rentalDuration', 'type': 'long'},
        'offline_rental_configuration': {'key': 'offlineRentalConfiguration', 'type': 'ContentKeyPolicyFairPlayOfflineRentalConfiguration'},
    }

    def __init__(
        self,
        *,
        ask: bytearray,
        fair_play_pfx_password: str,
        fair_play_pfx: str,
        rental_and_lease_key_type: Union[str, "ContentKeyPolicyFairPlayRentalAndLeaseKeyType"],
        rental_duration: int,
        offline_rental_configuration: Optional["ContentKeyPolicyFairPlayOfflineRentalConfiguration"] = None,
        **kwargs
    ):
        super(ContentKeyPolicyFairPlayConfiguration, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration'  # type: str
        self.ask = ask
        self.fair_play_pfx_password = fair_play_pfx_password
        self.fair_play_pfx = fair_play_pfx
        self.rental_and_lease_key_type = rental_and_lease_key_type
        self.rental_duration = rental_duration
        self.offline_rental_configuration = offline_rental_configuration


class ContentKeyPolicyFairPlayOfflineRentalConfiguration(msrest.serialization.Model):
    """ContentKeyPolicyFairPlayOfflineRentalConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param playback_duration_seconds: Required. Playback duration.
    :type playback_duration_seconds: long
    :param storage_duration_seconds: Required. Storage duration.
    :type storage_duration_seconds: long
    """

    _validation = {
        'playback_duration_seconds': {'required': True},
        'storage_duration_seconds': {'required': True},
    }

    _attribute_map = {
        'playback_duration_seconds': {'key': 'playbackDurationSeconds', 'type': 'long'},
        'storage_duration_seconds': {'key': 'storageDurationSeconds', 'type': 'long'},
    }

    def __init__(
        self,
        *,
        playback_duration_seconds: int,
        storage_duration_seconds: int,
        **kwargs
    ):
        super(ContentKeyPolicyFairPlayOfflineRentalConfiguration, self).__init__(**kwargs)
        self.playback_duration_seconds = playback_duration_seconds
        self.storage_duration_seconds = storage_duration_seconds


class ContentKeyPolicyRestriction(msrest.serialization.Model):
    """Base class for Content Key Policy restrictions. A derived class must be used to create a restriction.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ContentKeyPolicyOpenRestriction, ContentKeyPolicyTokenRestriction, ContentKeyPolicyUnknownRestriction.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
    }

    _subtype_map = {
        'odata_type': {'#Microsoft.Media.ContentKeyPolicyOpenRestriction': 'ContentKeyPolicyOpenRestriction', '#Microsoft.Media.ContentKeyPolicyTokenRestriction': 'ContentKeyPolicyTokenRestriction', '#Microsoft.Media.ContentKeyPolicyUnknownRestriction': 'ContentKeyPolicyUnknownRestriction'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContentKeyPolicyRestriction, self).__init__(**kwargs)
        self.odata_type = None  # type: Optional[str]


class ContentKeyPolicyOpenRestriction(ContentKeyPolicyRestriction):
    """Represents an open restriction. License or key will be delivered on every request.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContentKeyPolicyOpenRestriction, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyOpenRestriction'  # type: str


class ContentKeyPolicyOption(msrest.serialization.Model):
    """Represents a policy option.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar policy_option_id: The legacy Policy Option ID.
    :vartype policy_option_id: str
    :param name: The Policy Option description.
    :type name: str
    :param configuration: Required. The key delivery configuration.
    :type configuration: ~azure.mgmt.media.models.ContentKeyPolicyConfiguration
    :param restriction: Required. The requirements that must be met to deliver keys with this
     configuration.
    :type restriction: ~azure.mgmt.media.models.ContentKeyPolicyRestriction
    """

    _validation = {
        'policy_option_id': {'readonly': True},
        'configuration': {'required': True},
        'restriction': {'required': True},
    }

    _attribute_map = {
        'policy_option_id': {'key': 'policyOptionId', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'configuration': {'key': 'configuration', 'type': 'ContentKeyPolicyConfiguration'},
        'restriction': {'key': 'restriction', 'type': 'ContentKeyPolicyRestriction'},
    }

    def __init__(
        self,
        *,
        configuration: "ContentKeyPolicyConfiguration",
        restriction: "ContentKeyPolicyRestriction",
        name: Optional[str] = None,
        **kwargs
    ):
        super(ContentKeyPolicyOption, self).__init__(**kwargs)
        self.policy_option_id = None
        self.name = name
        self.configuration = configuration
        self.restriction = restriction


class ContentKeyPolicyPlayReadyConfiguration(ContentKeyPolicyConfiguration):
    """Specifies a configuration for PlayReady licenses.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    :param licenses: Required. The PlayReady licenses.
    :type licenses: list[~azure.mgmt.media.models.ContentKeyPolicyPlayReadyLicense]
    :param response_custom_data: The custom response data.
    :type response_custom_data: str
    """

    _validation = {
        'odata_type': {'required': True},
        'licenses': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
        'licenses': {'key': 'licenses', 'type': '[ContentKeyPolicyPlayReadyLicense]'},
        'response_custom_data': {'key': 'responseCustomData', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        licenses: List["ContentKeyPolicyPlayReadyLicense"],
        response_custom_data: Optional[str] = None,
        **kwargs
    ):
        super(ContentKeyPolicyPlayReadyConfiguration, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration'  # type: str
        self.licenses = licenses
        self.response_custom_data = response_custom_data


class ContentKeyPolicyPlayReadyContentKeyLocation(msrest.serialization.Model):
    """Base class for content key ID location. A derived class must be used to represent the location.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader, ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
    }

    _subtype_map = {
        'odata_type': {'#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader': 'ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader', '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier': 'ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContentKeyPolicyPlayReadyContentKeyLocation, self).__init__(**kwargs)
        self.odata_type = None  # type: Optional[str]


class ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader(ContentKeyPolicyPlayReadyContentKeyLocation):
    """Specifies that the content key ID is in the PlayReady header.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader'  # type: str


class ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier(ContentKeyPolicyPlayReadyContentKeyLocation):
    """Specifies that the content key ID is specified in the PlayReady configuration.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    :param key_id: Required. The content key ID.
    :type key_id: str
    """

    _validation = {
        'odata_type': {'required': True},
        'key_id': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
        'key_id': {'key': 'keyId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        key_id: str,
        **kwargs
    ):
        super(ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'  # type: str
        self.key_id = key_id


class ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction(msrest.serialization.Model):
    """Configures the Explicit Analog Television Output Restriction control bits. For further details see the PlayReady Compliance Rules.

    All required parameters must be populated in order to send to Azure.

    :param best_effort: Required. Indicates whether this restriction is enforced on a Best Effort
     basis.
    :type best_effort: bool
    :param configuration_data: Required. Configures the restriction control bits. Must be between 0
     and 3 inclusive.
    :type configuration_data: int
    """

    _validation = {
        'best_effort': {'required': True},
        'configuration_data': {'required': True},
    }

    _attribute_map = {
        'best_effort': {'key': 'bestEffort', 'type': 'bool'},
        'configuration_data': {'key': 'configurationData', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        best_effort: bool,
        configuration_data: int,
        **kwargs
    ):
        super(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction, self).__init__(**kwargs)
        self.best_effort = best_effort
        self.configuration_data = configuration_data


class ContentKeyPolicyPlayReadyLicense(msrest.serialization.Model):
    """The PlayReady license.

    All required parameters must be populated in order to send to Azure.

    :param allow_test_devices: Required. A flag indicating whether test devices can use the
     license.
    :type allow_test_devices: bool
    :param begin_date: The begin date of license.
    :type begin_date: ~datetime.datetime
    :param expiration_date: The expiration date of license.
    :type expiration_date: ~datetime.datetime
    :param relative_begin_date: The relative begin date of license.
    :type relative_begin_date: ~datetime.timedelta
    :param relative_expiration_date: The relative expiration date of license.
    :type relative_expiration_date: ~datetime.timedelta
    :param grace_period: The grace period of license.
    :type grace_period: ~datetime.timedelta
    :param play_right: The license PlayRight.
    :type play_right: ~azure.mgmt.media.models.ContentKeyPolicyPlayReadyPlayRight
    :param license_type: Required. The license type. Possible values include: "Unknown",
     "NonPersistent", "Persistent".
    :type license_type: str or ~azure.mgmt.media.models.ContentKeyPolicyPlayReadyLicenseType
    :param content_key_location: Required. The content key location.
    :type content_key_location:
     ~azure.mgmt.media.models.ContentKeyPolicyPlayReadyContentKeyLocation
    :param content_type: Required. The PlayReady content type. Possible values include: "Unknown",
     "Unspecified", "UltraVioletDownload", "UltraVioletStreaming".
    :type content_type: str or ~azure.mgmt.media.models.ContentKeyPolicyPlayReadyContentType
    """

    _validation = {
        'allow_test_devices': {'required': True},
        'license_type': {'required': True},
        'content_key_location': {'required': True},
        'content_type': {'required': True},
    }

    _attribute_map = {
        'allow_test_devices': {'key': 'allowTestDevices', 'type': 'bool'},
        'begin_date': {'key': 'beginDate', 'type': 'iso-8601'},
        'expiration_date': {'key': 'expirationDate', 'type': 'iso-8601'},
        'relative_begin_date': {'key': 'relativeBeginDate', 'type': 'duration'},
        'relative_expiration_date': {'key': 'relativeExpirationDate', 'type': 'duration'},
        'grace_period': {'key': 'gracePeriod', 'type': 'duration'},
        'play_right': {'key': 'playRight', 'type': 'ContentKeyPolicyPlayReadyPlayRight'},
        'license_type': {'key': 'licenseType', 'type': 'str'},
        'content_key_location': {'key': 'contentKeyLocation', 'type': 'ContentKeyPolicyPlayReadyContentKeyLocation'},
        'content_type': {'key': 'contentType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        allow_test_devices: bool,
        license_type: Union[str, "ContentKeyPolicyPlayReadyLicenseType"],
        content_key_location: "ContentKeyPolicyPlayReadyContentKeyLocation",
        content_type: Union[str, "ContentKeyPolicyPlayReadyContentType"],
        begin_date: Optional[datetime.datetime] = None,
        expiration_date: Optional[datetime.datetime] = None,
        relative_begin_date: Optional[datetime.timedelta] = None,
        relative_expiration_date: Optional[datetime.timedelta] = None,
        grace_period: Optional[datetime.timedelta] = None,
        play_right: Optional["ContentKeyPolicyPlayReadyPlayRight"] = None,
        **kwargs
    ):
        super(ContentKeyPolicyPlayReadyLicense, self).__init__(**kwargs)
        self.allow_test_devices = allow_test_devices
        self.begin_date = begin_date
        self.expiration_date = expiration_date
        self.relative_begin_date = relative_begin_date
        self.relative_expiration_date = relative_expiration_date
        self.grace_period = grace_period
        self.play_right = play_right
        self.license_type = license_type
        self.content_key_location = content_key_location
        self.content_type = content_type


class ContentKeyPolicyPlayReadyPlayRight(msrest.serialization.Model):
    """Configures the Play Right in the PlayReady license.

    All required parameters must be populated in order to send to Azure.

    :param first_play_expiration: The amount of time that the license is valid after the license is
     first used to play content.
    :type first_play_expiration: ~datetime.timedelta
    :param scms_restriction: Configures the Serial Copy Management System (SCMS) in the license.
     Must be between 0 and 3 inclusive.
    :type scms_restriction: int
    :param agc_and_color_stripe_restriction: Configures Automatic Gain Control (AGC) and Color
     Stripe in the license. Must be between 0 and 3 inclusive.
    :type agc_and_color_stripe_restriction: int
    :param explicit_analog_television_output_restriction: Configures the Explicit Analog Television
     Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
    :type explicit_analog_television_output_restriction:
     ~azure.mgmt.media.models.ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction
    :param digital_video_only_content_restriction: Required. Enables the Image Constraint For
     Analog Component Video Restriction in the license.
    :type digital_video_only_content_restriction: bool
    :param image_constraint_for_analog_component_video_restriction: Required. Enables the Image
     Constraint For Analog Component Video Restriction in the license.
    :type image_constraint_for_analog_component_video_restriction: bool
    :param image_constraint_for_analog_computer_monitor_restriction: Required. Enables the Image
     Constraint For Analog Component Video Restriction in the license.
    :type image_constraint_for_analog_computer_monitor_restriction: bool
    :param allow_passing_video_content_to_unknown_output: Required. Configures Unknown output
     handling settings of the license. Possible values include: "Unknown", "NotAllowed", "Allowed",
     "AllowedWithVideoConstriction".
    :type allow_passing_video_content_to_unknown_output: str or
     ~azure.mgmt.media.models.ContentKeyPolicyPlayReadyUnknownOutputPassingOption
    :param uncompressed_digital_video_opl: Specifies the output protection level for uncompressed
     digital video.
    :type uncompressed_digital_video_opl: int
    :param compressed_digital_video_opl: Specifies the output protection level for compressed
     digital video.
    :type compressed_digital_video_opl: int
    :param analog_video_opl: Specifies the output protection level for compressed digital audio.
    :type analog_video_opl: int
    :param compressed_digital_audio_opl: Specifies the output protection level for compressed
     digital audio.
    :type compressed_digital_audio_opl: int
    :param uncompressed_digital_audio_opl: Specifies the output protection level for uncompressed
     digital audio.
    :type uncompressed_digital_audio_opl: int
    """

    _validation = {
        'digital_video_only_content_restriction': {'required': True},
        'image_constraint_for_analog_component_video_restriction': {'required': True},
        'image_constraint_for_analog_computer_monitor_restriction': {'required': True},
        'allow_passing_video_content_to_unknown_output': {'required': True},
    }

    _attribute_map = {
        'first_play_expiration': {'key': 'firstPlayExpiration', 'type': 'duration'},
        'scms_restriction': {'key': 'scmsRestriction', 'type': 'int'},
        'agc_and_color_stripe_restriction': {'key': 'agcAndColorStripeRestriction', 'type': 'int'},
        'explicit_analog_television_output_restriction': {'key': 'explicitAnalogTelevisionOutputRestriction', 'type': 'ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction'},
        'digital_video_only_content_restriction': {'key': 'digitalVideoOnlyContentRestriction', 'type': 'bool'},
        'image_constraint_for_analog_component_video_restriction': {'key': 'imageConstraintForAnalogComponentVideoRestriction', 'type': 'bool'},
        'image_constraint_for_analog_computer_monitor_restriction': {'key': 'imageConstraintForAnalogComputerMonitorRestriction', 'type': 'bool'},
        'allow_passing_video_content_to_unknown_output': {'key': 'allowPassingVideoContentToUnknownOutput', 'type': 'str'},
        'uncompressed_digital_video_opl': {'key': 'uncompressedDigitalVideoOpl', 'type': 'int'},
        'compressed_digital_video_opl': {'key': 'compressedDigitalVideoOpl', 'type': 'int'},
        'analog_video_opl': {'key': 'analogVideoOpl', 'type': 'int'},
        'compressed_digital_audio_opl': {'key': 'compressedDigitalAudioOpl', 'type': 'int'},
        'uncompressed_digital_audio_opl': {'key': 'uncompressedDigitalAudioOpl', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        digital_video_only_content_restriction: bool,
        image_constraint_for_analog_component_video_restriction: bool,
        image_constraint_for_analog_computer_monitor_restriction: bool,
        allow_passing_video_content_to_unknown_output: Union[str, "ContentKeyPolicyPlayReadyUnknownOutputPassingOption"],
        first_play_expiration: Optional[datetime.timedelta] = None,
        scms_restriction: Optional[int] = None,
        agc_and_color_stripe_restriction: Optional[int] = None,
        explicit_analog_television_output_restriction: Optional["ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction"] = None,
        uncompressed_digital_video_opl: Optional[int] = None,
        compressed_digital_video_opl: Optional[int] = None,
        analog_video_opl: Optional[int] = None,
        compressed_digital_audio_opl: Optional[int] = None,
        uncompressed_digital_audio_opl: Optional[int] = None,
        **kwargs
    ):
        super(ContentKeyPolicyPlayReadyPlayRight, self).__init__(**kwargs)
        self.first_play_expiration = first_play_expiration
        self.scms_restriction = scms_restriction
        self.agc_and_color_stripe_restriction = agc_and_color_stripe_restriction
        self.explicit_analog_television_output_restriction = explicit_analog_television_output_restriction
        self.digital_video_only_content_restriction = digital_video_only_content_restriction
        self.image_constraint_for_analog_component_video_restriction = image_constraint_for_analog_component_video_restriction
        self.image_constraint_for_analog_computer_monitor_restriction = image_constraint_for_analog_computer_monitor_restriction
        self.allow_passing_video_content_to_unknown_output = allow_passing_video_content_to_unknown_output
        self.uncompressed_digital_video_opl = uncompressed_digital_video_opl
        self.compressed_digital_video_opl = compressed_digital_video_opl
        self.analog_video_opl = analog_video_opl
        self.compressed_digital_audio_opl = compressed_digital_audio_opl
        self.uncompressed_digital_audio_opl = uncompressed_digital_audio_opl


class ContentKeyPolicyProperties(msrest.serialization.Model):
    """The properties of the Content Key Policy.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar policy_id: The legacy Policy ID.
    :vartype policy_id: str
    :ivar created: The creation date of the Policy.
    :vartype created: ~datetime.datetime
    :ivar last_modified: The last modified date of the Policy.
    :vartype last_modified: ~datetime.datetime
    :param description: A description for the Policy.
    :type description: str
    :param options: Required. The Key Policy options.
    :type options: list[~azure.mgmt.media.models.ContentKeyPolicyOption]
    """

    _validation = {
        'policy_id': {'readonly': True},
        'created': {'readonly': True},
        'last_modified': {'readonly': True},
        'options': {'required': True},
    }

    _attribute_map = {
        'policy_id': {'key': 'policyId', 'type': 'str'},
        'created': {'key': 'created', 'type': 'iso-8601'},
        'last_modified': {'key': 'lastModified', 'type': 'iso-8601'},
        'description': {'key': 'description', 'type': 'str'},
        'options': {'key': 'options', 'type': '[ContentKeyPolicyOption]'},
    }

    def __init__(
        self,
        *,
        options: List["ContentKeyPolicyOption"],
        description: Optional[str] = None,
        **kwargs
    ):
        super(ContentKeyPolicyProperties, self).__init__(**kwargs)
        self.policy_id = None
        self.created = None
        self.last_modified = None
        self.description = description
        self.options = options


class ContentKeyPolicyRestrictionTokenKey(msrest.serialization.Model):
    """Base class for Content Key Policy key for token validation. A derived class must be used to create a token key.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ContentKeyPolicyRsaTokenKey, ContentKeyPolicySymmetricTokenKey, ContentKeyPolicyX509CertificateTokenKey.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
    }

    _subtype_map = {
        'odata_type': {'#Microsoft.Media.ContentKeyPolicyRsaTokenKey': 'ContentKeyPolicyRsaTokenKey', '#Microsoft.Media.ContentKeyPolicySymmetricTokenKey': 'ContentKeyPolicySymmetricTokenKey', '#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey': 'ContentKeyPolicyX509CertificateTokenKey'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContentKeyPolicyRestrictionTokenKey, self).__init__(**kwargs)
        self.odata_type = None  # type: Optional[str]


class ContentKeyPolicyRsaTokenKey(ContentKeyPolicyRestrictionTokenKey):
    """Specifies a RSA key for token validation.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    :param exponent: Required. The RSA Parameter exponent.
    :type exponent: bytearray
    :param modulus: Required. The RSA Parameter modulus.
    :type modulus: bytearray
    """

    _validation = {
        'odata_type': {'required': True},
        'exponent': {'required': True},
        'modulus': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
        'exponent': {'key': 'exponent', 'type': 'bytearray'},
        'modulus': {'key': 'modulus', 'type': 'bytearray'},
    }

    def __init__(
        self,
        *,
        exponent: bytearray,
        modulus: bytearray,
        **kwargs
    ):
        super(ContentKeyPolicyRsaTokenKey, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyRsaTokenKey'  # type: str
        self.exponent = exponent
        self.modulus = modulus


class ContentKeyPolicySymmetricTokenKey(ContentKeyPolicyRestrictionTokenKey):
    """Specifies a symmetric key for token validation.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    :param key_value: Required. The key value of the key.
    :type key_value: bytearray
    """

    _validation = {
        'odata_type': {'required': True},
        'key_value': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
        'key_value': {'key': 'keyValue', 'type': 'bytearray'},
    }

    def __init__(
        self,
        *,
        key_value: bytearray,
        **kwargs
    ):
        super(ContentKeyPolicySymmetricTokenKey, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicySymmetricTokenKey'  # type: str
        self.key_value = key_value


class ContentKeyPolicyTokenClaim(msrest.serialization.Model):
    """Represents a token claim.

    :param claim_type: Token claim type.
    :type claim_type: str
    :param claim_value: Token claim value.
    :type claim_value: str
    """

    _attribute_map = {
        'claim_type': {'key': 'claimType', 'type': 'str'},
        'claim_value': {'key': 'claimValue', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        claim_type: Optional[str] = None,
        claim_value: Optional[str] = None,
        **kwargs
    ):
        super(ContentKeyPolicyTokenClaim, self).__init__(**kwargs)
        self.claim_type = claim_type
        self.claim_value = claim_value


class ContentKeyPolicyTokenRestriction(ContentKeyPolicyRestriction):
    """Represents a token restriction. Provided token must match these requirements for successful license or key delivery.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    :param issuer: Required. The token issuer.
    :type issuer: str
    :param audience: Required. The audience for the token.
    :type audience: str
    :param primary_verification_key: Required. The primary verification key.
    :type primary_verification_key: ~azure.mgmt.media.models.ContentKeyPolicyRestrictionTokenKey
    :param alternate_verification_keys: A list of alternative verification keys.
    :type alternate_verification_keys:
     list[~azure.mgmt.media.models.ContentKeyPolicyRestrictionTokenKey]
    :param required_claims: A list of required token claims.
    :type required_claims: list[~azure.mgmt.media.models.ContentKeyPolicyTokenClaim]
    :param restriction_token_type: Required. The type of token. Possible values include: "Unknown",
     "Swt", "Jwt".
    :type restriction_token_type: str or
     ~azure.mgmt.media.models.ContentKeyPolicyRestrictionTokenType
    :param open_id_connect_discovery_document: The OpenID connect discovery document.
    :type open_id_connect_discovery_document: str
    """

    _validation = {
        'odata_type': {'required': True},
        'issuer': {'required': True},
        'audience': {'required': True},
        'primary_verification_key': {'required': True},
        'restriction_token_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
        'issuer': {'key': 'issuer', 'type': 'str'},
        'audience': {'key': 'audience', 'type': 'str'},
        'primary_verification_key': {'key': 'primaryVerificationKey', 'type': 'ContentKeyPolicyRestrictionTokenKey'},
        'alternate_verification_keys': {'key': 'alternateVerificationKeys', 'type': '[ContentKeyPolicyRestrictionTokenKey]'},
        'required_claims': {'key': 'requiredClaims', 'type': '[ContentKeyPolicyTokenClaim]'},
        'restriction_token_type': {'key': 'restrictionTokenType', 'type': 'str'},
        'open_id_connect_discovery_document': {'key': 'openIdConnectDiscoveryDocument', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        issuer: str,
        audience: str,
        primary_verification_key: "ContentKeyPolicyRestrictionTokenKey",
        restriction_token_type: Union[str, "ContentKeyPolicyRestrictionTokenType"],
        alternate_verification_keys: Optional[List["ContentKeyPolicyRestrictionTokenKey"]] = None,
        required_claims: Optional[List["ContentKeyPolicyTokenClaim"]] = None,
        open_id_connect_discovery_document: Optional[str] = None,
        **kwargs
    ):
        super(ContentKeyPolicyTokenRestriction, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyTokenRestriction'  # type: str
        self.issuer = issuer
        self.audience = audience
        self.primary_verification_key = primary_verification_key
        self.alternate_verification_keys = alternate_verification_keys
        self.required_claims = required_claims
        self.restriction_token_type = restriction_token_type
        self.open_id_connect_discovery_document = open_id_connect_discovery_document


class ContentKeyPolicyUnknownConfiguration(ContentKeyPolicyConfiguration):
    """Represents a ContentKeyPolicyConfiguration that is unavailable in the current API version.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContentKeyPolicyUnknownConfiguration, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyUnknownConfiguration'  # type: str


class ContentKeyPolicyUnknownRestriction(ContentKeyPolicyRestriction):
    """Represents a ContentKeyPolicyRestriction that is unavailable in the current API version.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContentKeyPolicyUnknownRestriction, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyUnknownRestriction'  # type: str


class ContentKeyPolicyWidevineConfiguration(ContentKeyPolicyConfiguration):
    """Specifies a configuration for Widevine licenses.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    :param widevine_template: Required. The Widevine template.
    :type widevine_template: str
    """

    _validation = {
        'odata_type': {'required': True},
        'widevine_template': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
        'widevine_template': {'key': 'widevineTemplate', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        widevine_template: str,
        **kwargs
    ):
        super(ContentKeyPolicyWidevineConfiguration, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyWidevineConfiguration'  # type: str
        self.widevine_template = widevine_template


class ContentKeyPolicyX509CertificateTokenKey(ContentKeyPolicyRestrictionTokenKey):
    """Specifies a certificate for token validation.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. The discriminator for derived types.Constant filled by server.
    :type odata_type: str
    :param raw_body: Required. The raw data field of a certificate in PKCS 12 format
     (X509Certificate2 in .NET).
    :type raw_body: bytearray
    """

    _validation = {
        'odata_type': {'required': True},
        'raw_body': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': '@odata\\.type', 'type': 'str'},
        'raw_body': {'key': 'rawBody', 'type': 'bytearray'},
    }

    def __init__(
        self,
        *,
        raw_body: bytearray,
        **kwargs
    ):
        super(ContentKeyPolicyX509CertificateTokenKey, self).__init__(**kwargs)
        self.odata_type = '#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey'  # type: str
        self.raw_body = raw_body


class CrossSiteAccessPolicies(msrest.serialization.Model):
    """The client access policy.

    :param client_access_policy: The content of clientaccesspolicy.xml used by Silverlight.
    :type client_access_policy: str
    :param cross_domain_policy: The content of crossdomain.xml used by Silverlight.
    :type cross_domain_policy: str
    """

    _attribute_map = {
        'client_access_policy': {'key': 'clientAccessPolicy', 'type': 'str'},
        'cross_domain_policy': {'key': 'crossDomainPolicy', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        client_access_policy: Optional[str] = None,
        cross_domain_policy: Optional[str] = None,
        **kwargs
    ):
        super(CrossSiteAccessPolicies, self).__init__(**kwargs)
        self.client_access_policy = client_access_policy
        self.cross_domain_policy = cross_domain_policy


class DefaultKey(msrest.serialization.Model):
    """Class to specify properties of default content key for each encryption scheme.

    :param label: Label can be used to specify Content Key when creating a Streaming Locator.
    :type label: str
    :param policy_name: Policy used by Default Key.
    :type policy_name: str
    """

    _attribute_map = {
        'label': {'key': 'label', 'type': 'str'},
        'policy_name': {'key': 'policyName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        label: Optional[str] = None,
        policy_name: Optional[str] = None,
        **kwargs
    ):
        super(DefaultKey, self).__init__(**kwargs)
        self.label = label
        self.policy_name = policy_name


class EdgePolicies(msrest.serialization.Model):
    """EdgePolicies.

    :param usage_data_collection_policy:
    :type usage_data_collection_policy: ~azure.mgmt.media.models.EdgeUsageDataCollectionPolicy
    """

    _attribute_map = {
        'usage_data_collection_policy': {'key': 'usageDataCollectionPolicy', 'type': 'EdgeUsageDataCollectionPolicy'},
    }

    def __init__(
        self,
        *,
        usage_data_collection_policy: Optional["EdgeUsageDataCollectionPolicy"] = None,
        **kwargs
    ):
        super(EdgePolicies, self).__init__(**kwargs)
        self.usage_data_collection_policy = usage_data_collection_policy


class EdgeUsageDataCollectionPolicy(msrest.serialization.Model):
    """EdgeUsageDataCollectionPolicy.

    :param data_collection_frequency: Usage data collection frequency in ISO 8601 duration format
     e.g. PT10M , PT5H.
    :type data_collection_frequency: str
    :param data_reporting_frequency: Usage data reporting frequency in ISO 8601 duration format
     e.g. PT10M , PT5H.
    :type data_reporting_frequency: str
    :param max_allowed_unreported_usage_duration: Maximum time for which the functionality of the
     device will not be hampered for not reporting the usage data.
    :type max_allowed_unreported_usage_duration: str
    :param event_hub_details: Details of Event Hub where the usage will be reported.
    :type event_hub_details: ~azure.mgmt.media.models.EdgeUsageDataEventHub
    """

    _attribute_map = {
        'data_collection_frequency': {'key': 'dataCollectionFrequency', 'type': 'str'},
        'data_reporting_frequency': {'key': 'dataReportingFrequency', 'type': 'str'},
        'max_allowed_unreported_usage_duration': {'key': 'maxAllowedUnreportedUsageDuration', 'type': 'str'},
        'event_hub_details': {'key': 'eventHubDetails', 'type': 'EdgeUsageDataEventHub'},
    }

    def __init__(
        self,
        *,
        data_collection_frequency: Optional[str] = None,
        data_reporting_frequency: Optional[str] = None,
        max_allowed_unreported_usage_duration: Optional[str] = None,
        event_hub_details: Optional["EdgeUsageDataEventHub"] = None,
        **kwargs
    ):
        super(EdgeUsageDataCollectionPolicy, self).__init__(**kwargs)
        self.data_collection_frequency = data_collection_frequency
        self.data_reporting_frequency = data_reporting_frequency
        self.max_allowed_unreported_usage_duration = max_allowed_unreported_usage_duration
        self.event_hub_details = event_hub_details


class EdgeUsageDataEventHub(msrest.serialization.Model):
    """EdgeUsageDataEventHub.

    :param name: Name of the Event Hub where usage will be reported.
    :type name: str
    :param namespace: Namespace of the Event Hub where usage will be reported.
    :type namespace: str
    :param token: SAS token needed to interact with Event Hub.
    :type token: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'token': {'key': 'token', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        token: Optional[str] = None,
        **kwargs
    ):
        super(EdgeUsageDataEventHub, self).__init__(**kwargs)
        self.name = name
        self.namespace = namespace
        self.token = token


class EnabledProtocols(msrest.serialization.Model):
    """Class to specify which protocols are enabled.

    All required parameters must be populated in order to send to Azure.

    :param download: Required. Enable Download protocol or not.
    :type download: bool
    :param dash: Required. Enable DASH protocol or not.
    :type dash: bool
    :param hls: Required. Enable HLS protocol or not.
    :type hls: bool
    :param smooth_streaming: Required. Enable SmoothStreaming protocol or not.
    :type smooth_streaming: bool
    """

    _validation = {
        'download': {'required': True},
        'dash': {'required': True},
        'hls': {'required': True},
        'smooth_streaming': {'required': True},
    }

    _attribute_map = {
        'download': {'key': 'download', 'type': 'bool'},
        'dash': {'key': 'dash', 'type': 'bool'},
        'hls': {'key': 'hls', 'type': 'bool'},
        'smooth_streaming': {'key': 'smoothStreaming', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        download: bool,
        dash: bool,
        hls: bool,
        smooth_streaming: bool,
        **kwargs
    ):
        super(EnabledProtocols, self).__init__(**kwargs)
        self.download = download
        self.dash = dash
        self.hls = hls
        self.smooth_streaming = smooth_streaming


class EntityNameAvailabilityCheckOutput(msrest.serialization.Model):
    """The response from the check name availability request.

    All required parameters must be populated in order to send to Azure.

    :param name_available: Required. Specifies if the name is available.
    :type name_available: bool
    :param reason: Specifies the reason if the name is not available.
    :type reason: str
    :param message: Specifies the detailed reason if the name is not available.
    :type message: str
    """

    _validation = {
        'name_available': {'required': True},
    }

    _attribute_map = {
        'name_available': {'key': 'nameAvailable', 'type': 'bool'},
        'reason': {'key': 'reason', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name_available: bool,
        reason: Optional[str] = None,
        message: Optional[str] = None,
        **kwargs
    ):
        super(EntityNameAvailabilityCheckOutput, self).__init__(**kwargs)
        self.name_available = name_available
        self.reason = reason
        self.message = message


class EnvelopeEncryption(msrest.serialization.Model):
    """Class for EnvelopeEncryption encryption scheme.

    :param enabled_protocols: Representing supported protocols.
    :type enabled_protocols: ~azure.mgmt.media.models.EnabledProtocols
    :param clear_tracks: Representing which tracks should not be encrypted.
    :type clear_tracks: list[~azure.mgmt.media.models.TrackSelection]
    :param content_keys: Representing default content key for each encryption scheme and separate
     content keys for specific tracks.
    :type content_keys: ~azure.mgmt.media.models.StreamingPolicyContentKeys
    :param custom_key_acquisition_url_template: Template for the URL of the custom service
     delivering keys to end user players.  Not required when using Azure Media Services for issuing
     keys.  The template supports replaceable tokens that the service will update at runtime with
     the value specific to the request.  The currently supported token values are
     {AlternativeMediaId}, which is replaced with the value of
     StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of
     identifier of the key being requested.
    :type custom_key_acquisition_url_template: str
    """

    _attribute_map = {
        'enabled_protocols': {'key': 'enabledProtocols', 'type': 'EnabledProtocols'},
        'clear_tracks': {'key': 'clearTracks', 'type': '[TrackSelection]'},
        'content_keys': {'key': 'contentKeys', 'type': 'StreamingPolicyContentKeys'},
        'custom_key_acquisition_url_template': {'key': 'customKeyAcquisitionUrlTemplate', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        enabled_protocols: Optional["EnabledProtocols"] = None,
        clear_tracks: Optional[List["TrackSelection"]] = None,
        content_keys: Optional["StreamingPolicyContentKeys"] = None,
        custom_key_acquisition_url_template: Optional[str] = None,
        **kwargs
    ):
        super(EnvelopeEncryption, self).__init__(**kwargs)
        self.enabled_protocols = enabled_protocols
        self.clear_tracks = clear_tracks
        self.content_keys = content_keys
        self.custom_key_acquisition_url_template = custom_key_acquisition_url_template


class ErrorAdditionalInfo(msrest.serialization.Model):
    """The resource management error additional info.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: The additional info type.
    :vartype type: str
    :ivar info: The additional info.
    :vartype info: any
    """

    _validation = {
        'type': {'readonly': True},
        'info': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'info': {'key': 'info', 'type': 'object'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ErrorAdditionalInfo, self).__init__(**kwargs)
        self.type = None
        self.info = None


class ErrorDetail(msrest.serialization.Model):
    """The error detail.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar code: The error code.
    :vartype code: str
    :ivar message: The error message.
    :vartype message: str
    :ivar target: The error target.
    :vartype target: str
    :ivar details: The error details.
    :vartype details: list[~azure.mgmt.media.models.ErrorDetail]
    :ivar additional_info: The error additional info.
    :vartype additional_info: list[~azure.mgmt.media.models.ErrorAdditionalInfo]
    """

    _validation = {
        'code': {'readonly': True},
        'message': {'readonly': True},
        'target': {'readonly': True},
        'details': {'readonly': True},
        'additional_info': {'readonly': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[ErrorDetail]'},
        'additional_info': {'key': 'additionalInfo', 'type': '[ErrorAdditionalInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ErrorDetail, self).__init__(**kwargs)
        self.code = None
        self.message = None
        self.target = None
        self.details = None
        self.additional_info = None


class ErrorResponse(msrest.serialization.Model):
    """Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.).

    :param error: The error object.
    :type error: ~azure.mgmt.media.models.ErrorDetail
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'ErrorDetail'},
    }

    def __init__(
        self,
        *,
        error: Optional["ErrorDetail"] = None,
        **kwargs
    ):
        super(ErrorResponse, self).__init__(**kwargs)
        self.error = error


class FilterTrackPropertyCondition(msrest.serialization.Model):
    """The class to specify one track property condition.

    All required parameters must be populated in order to send to Azure.

    :param property: Required. The track property type. Possible values include: "Unknown", "Type",
     "Name", "Language", "FourCC", "Bitrate".
    :type property: str or ~azure.mgmt.media.models.FilterTrackPropertyType
    :param value: Required. The track property value.
    :type value: str
    :param operation: Required. The track property condition operation. Possible values include:
     "Equal", "NotEqual".
    :type operation: str or ~azure.mgmt.media.models.FilterTrackPropertyCompareOperation
    """

    _validation = {
        'property': {'required': True},
        'value': {'required': True},
        'operation': {'required': True},
    }

    _attribute_map = {
        'property': {'key': 'property', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
        'operation': {'key': 'operation', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        property: Union[str, "FilterTrackPropertyType"],
        value: str,
        operation: Union[str, "FilterTrackPropertyCompareOperation"],
        **kwargs
    ):
        super(FilterTrackPropertyCondition, self).__init__(**kwargs)
        self.property = property
        self.value = value
        self.operation = operation


class FilterTrackSelection(msrest.serialization.Model):
    """Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.

    All required parameters must be populated in order to send to Azure.

    :param track_selections: Required. The track selections.
    :type track_selections: list[~azure.mgmt.media.models.FilterTrackPropertyCondition]
    """

    _validation = {
        'track_selections': {'required': True},
    }

    _attribute_map = {
        'track_selections': {'key': 'trackSelections', 'type': '[FilterTrackPropertyCondition]'},
    }

    def __init__(
        self,
        *,
        track_selections: List["FilterTrackPropertyCondition"],
        **kwargs
    ):
        super(FilterTrackSelection, self).__init__(**kwargs)
        self.track_selections = track_selections


class FirstQuality(msrest.serialization.Model):
    """Filter First Quality.

    All required parameters must be populated in order to send to Azure.

    :param bitrate: Required. The first quality bitrate.
    :type bitrate: int
    """

    _validation = {
        'bitrate': {'required': True},
    }

    _attribute_map = {
        'bitrate': {'key': 'bitrate', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        bitrate: int,
        **kwargs
    ):
        super(FirstQuality, self).__init__(**kwargs)
        self.bitrate = bitrate


class Hls(msrest.serialization.Model):
    """HTTP Live Streaming (HLS) packing setting for the live output.

    :param fragments_per_ts_segment: The number of fragments in an HTTP Live Streaming (HLS) TS
     segment in the output of the live event. This value does not affect the packing ratio for HLS
     CMAF output.
    :type fragments_per_ts_segment: int
    """

    _attribute_map = {
        'fragments_per_ts_segment': {'key': 'fragmentsPerTsSegment', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        fragments_per_ts_segment: Optional[int] = None,
        **kwargs
    ):
        super(Hls, self).__init__(**kwargs)
        self.fragments_per_ts_segment = fragments_per_ts_segment


class IPAccessControl(msrest.serialization.Model):
    """The IP access control.

    :param allow: The IP allow list.
    :type allow: list[~azure.mgmt.media.models.IPRange]
    """

    _attribute_map = {
        'allow': {'key': 'allow', 'type': '[IPRange]'},
    }

    def __init__(
        self,
        *,
        allow: Optional[List["IPRange"]] = None,
        **kwargs
    ):
        super(IPAccessControl, self).__init__(**kwargs)
        self.allow = allow


class IPRange(msrest.serialization.Model):
    """The IP address range in the CIDR scheme.

    :param name: The friendly name for the IP address range.
    :type name: str
    :param address: The IP address.
    :type address: str
    :param subnet_prefix_length: The subnet mask prefix length (see CIDR notation).
    :type subnet_prefix_length: int
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'address': {'key': 'address', 'type': 'str'},
        'subnet_prefix_length': {'key': 'subnetPrefixLength', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        address: Optional[str] = None,
        subnet_prefix_length: Optional[int] = None,
        **kwargs
    ):
        super(IPRange, self).__init__(**kwargs)
        self.name = name
        self.address = address
        self.subnet_prefix_length = subnet_prefix_length


class KeyDelivery(msrest.serialization.Model):
    """KeyDelivery.

    :param access_control: The access control properties for Key Delivery.
    :type access_control: ~azure.mgmt.media.models.AccessControl
    """

    _attribute_map = {
        'access_control': {'key': 'accessControl', 'type': 'AccessControl'},
    }

    def __init__(
        self,
        *,
        access_control: Optional["AccessControl"] = None,
        **kwargs
    ):
        super(KeyDelivery, self).__init__(**kwargs)
        self.access_control = access_control


class KeyVaultProperties(msrest.serialization.Model):
    """KeyVaultProperties.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param key_identifier: The URL of the Key Vault key used to encrypt the account. The key may
     either be versioned (for example https://vault/keys/mykey/version1) or reference a key without
     a version (for example https://vault/keys/mykey).
    :type key_identifier: str
    :ivar current_key_identifier: The current key used to encrypt the Media Services account,
     including the key version.
    :vartype current_key_identifier: str
    """

    _validation = {
        'current_key_identifier': {'readonly': True},
    }

    _attribute_map = {
        'key_identifier': {'key': 'keyIdentifier', 'type': 'str'},
        'current_key_identifier': {'key': 'currentKeyIdentifier', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        key_identifier: Optional[str] = None,
        **kwargs
    ):
        super(KeyVaultProperties, self).__init__(**kwargs)
        self.key_identifier = key_identifier
        self.current_key_identifier = None


class ListContainerSasInput(msrest.serialization.Model):
    """The parameters to the list SAS request.

    :param permissions: The permissions to set on the SAS URL. Possible values include: "Read",
     "ReadWrite", "ReadWriteDelete".
    :type permissions: str or ~azure.mgmt.media.models.AssetContainerPermission
    :param expiry_time: The SAS URL expiration time.  This must be less than 24 hours from the
     current time.
    :type expiry_time: ~datetime.datetime
    """

    _attribute_map = {
        'permissions': {'key': 'permissions', 'type': 'str'},
        'expiry_time': {'key': 'expiryTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        permissions: Optional[Union[str, "AssetContainerPermission"]] = None,
        expiry_time: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(ListContainerSasInput, self).__init__(**kwargs)
        self.permissions = permissions
        self.expiry_time = expiry_time


class ListContentKeysResponse(msrest.serialization.Model):
    """Class of response for listContentKeys action.

    :param content_keys: ContentKeys used by current Streaming Locator.
    :type content_keys: list[~azure.mgmt.media.models.StreamingLocatorContentKey]
    """

    _attribute_map = {
        'content_keys': {'key': 'contentKeys', 'type': '[StreamingLocatorContentKey]'},
    }

    def __init__(
        self,
        *,
        content_keys: Optional[List["StreamingLocatorContentKey"]] = None,
        **kwargs
    ):
        super(ListContentKeysResponse, self).__init__(**kwargs)
        self.content_keys = content_keys


class ListEdgePoliciesInput(msrest.serialization.Model):
    """ListEdgePoliciesInput.

    :param device_id: Unique identifier of the edge device.
    :type device_id: str
    """

    _attribute_map = {
        'device_id': {'key': 'deviceId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        device_id: Optional[str] = None,
        **kwargs
    ):
        super(ListEdgePoliciesInput, self).__init__(**kwargs)
        self.device_id = device_id


class ListPathsResponse(msrest.serialization.Model):
    """Class of response for listPaths action.

    :param streaming_paths: Streaming Paths supported by current Streaming Locator.
    :type streaming_paths: list[~azure.mgmt.media.models.StreamingPath]
    :param download_paths: Download Paths supported by current Streaming Locator.
    :type download_paths: list[str]
    """

    _attribute_map = {
        'streaming_paths': {'key': 'streamingPaths', 'type': '[StreamingPath]'},
        'download_paths': {'key': 'downloadPaths', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        streaming_paths: Optional[List["StreamingPath"]] = None,
        download_paths: Optional[List[str]] = None,
        **kwargs
    ):
        super(ListPathsResponse, self).__init__(**kwargs)
        self.streaming_paths = streaming_paths
        self.download_paths = download_paths


class ListStreamingLocatorsResponse(msrest.serialization.Model):
    """The Streaming Locators associated with this Asset.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar streaming_locators: The list of Streaming Locators.
    :vartype streaming_locators: list[~azure.mgmt.media.models.AssetStreamingLocator]
    """

    _validation = {
        'streaming_locators': {'readonly': True},
    }

    _attribute_map = {
        'streaming_locators': {'key': 'streamingLocators', 'type': '[AssetStreamingLocator]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ListStreamingLocatorsResponse, self).__init__(**kwargs)
        self.streaming_locators = None


class TrackedResource(Resource):
    """The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags' and a 'location'.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param location: Required. The geo-location where the resource lives.
    :type location: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(TrackedResource, self).__init__(**kwargs)
        self.tags = tags
        self.location = location


class LiveEvent(TrackedResource):
    """The live event.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param location: Required. The geo-location where the resource lives.
    :type location: str
    :ivar system_data: The system metadata relating to this resource.
    :vartype system_data: ~azure.mgmt.media.models.SystemData
    :param description: A description for the live event.
    :type description: str
    :param input: Live event input settings. It defines how the live event receives input from a
     contribution encoder.
    :type input: ~azure.mgmt.media.models.LiveEventInput
    :param preview: Live event preview settings. Preview allows live event producers to preview the
     live streaming content without creating any live output.
    :type preview: ~azure.mgmt.media.models.LiveEventPreview
    :param encoding: Encoding settings for the live event. It configures whether a live encoder is
     used for the live event and settings for the live encoder if it is used.
    :type encoding: ~azure.mgmt.media.models.LiveEventEncoding
    :param transcriptions: Live transcription settings for the live event. See
     https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live
     transcription feature.
    :type transcriptions: list[~azure.mgmt.media.models.LiveEventTranscription]
    :ivar provisioning_state: The provisioning state of the live event.
    :vartype provisioning_state: str
    :ivar resource_state: The resource state of the live event. See
     https://go.microsoft.com/fwlink/?linkid=2139012 for more information. Possible values include:
     "Stopped", "Allocating", "StandBy", "Starting", "Running", "Stopping", "Deleting".
    :vartype resource_state: str or ~azure.mgmt.media.models.LiveEventResourceState
    :param cross_site_access_policies: Live event cross site access policies.
    :type cross_site_access_policies: ~azure.mgmt.media.models.CrossSiteAccessPolicies
    :param use_static_hostname: Specifies whether a static hostname would be assigned to the live
     event preview and ingest endpoints. This value can only be updated if the live event is in
     Standby state.
    :type use_static_hostname: bool
    :param hostname_prefix: When useStaticHostname is set to true, the hostnamePrefix specifies the
     first part of the hostname assigned to the live event preview and ingest endpoints. The final
     hostname would be a combination of this prefix, the media service account name and a short code
     for the Azure Media Services data center.
    :type hostname_prefix: str
    :param stream_options: The options to use for the LiveEvent. This value is specified at
     creation time and cannot be updated. The valid values for the array entry values are 'Default'
     and 'LowLatency'.
    :type stream_options: list[str or ~azure.mgmt.media.models.StreamOptionsFlag]
    :ivar created: The creation time for the live event.
    :vartype created: ~datetime.datetime
    :ivar last_modified: The last modified time of the live event.
    :vartype last_modified: ~datetime.datetime
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'system_data': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'resource_state': {'readonly': True},
        'created': {'readonly': True},
        'last_modified': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'input': {'key': 'properties.input', 'type': 'LiveEventInput'},
        'preview': {'key': 'properties.preview', 'type': 'LiveEventPreview'},
        'encoding': {'key': 'properties.encoding', 'type': 'LiveEventEncoding'},
        'transcriptions': {'key': 'properties.transcriptions', 'type': '[LiveEventTranscription]'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'resource_state': {'key': 'properties.resourceState', 'type': 'str'},
        'cross_site_access_policies': {'key': 'properties.crossSiteAccessPolicies', 'type': 'CrossSiteAccessPolicies'},
        'use_static_hostname': {'key': 'properties.useStaticHostname', 'type': 'bool'},
        'hostname_prefix': {'key': 'properties.hostnamePrefix', 'type': 'str'},
        'stream_options': {'key': 'properties.streamOptions', 'type': '[str]'},
        'created': {'key': 'properties.created', 'type': 'iso-8601'},
        'last_modified': {'key': 'properties.lastModified', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        description: Optional[str] = None,
        input: Optional["LiveEventInput"] = None,
        preview: Optional["LiveEventPreview"] = None,
        encoding: Optional["LiveEventEncoding"] = None,
        transcriptions: Optional[List["LiveEventTranscription"]] = None,
        cross_site_access_policies: Optional["CrossSiteAccessPolicies"] = None,
        use_static_hostname: Optional[bool] = None,
        hostname_prefix: Optional[str] = None,
        stream_options: Optional[List[Union[str, "StreamOptionsFlag"]]] = None,
        **kwargs
    ):
        super(LiveEvent, self).__init__(tags=tags, location=location, **kwargs)
        self.system_data = None
        self.description = description
        self.input = input
        self.preview = preview
        self.encoding = encoding
        self.transcriptions = transcriptions
        self.provisioning_state = None
        self.resource_state = None
        self.cross_site_access_policies = cross_site_access_policies
        self.use_static_hostname = use_static_hostname
        self.hostname_prefix = hostname_prefix
        self.stream_options = stream_options
        self.created = None
        self.last_modified = None


class LiveEventActionInput(msrest.serialization.Model):
    """The LiveEvent action input parameter definition.

    :param remove_outputs_on_stop: The flag indicates whether live outputs are automatically
     deleted when live event is being stopped. Deleting live outputs do not delete the underlying
     assets.
    :type remove_outputs_on_stop: bool
    """

    _attribute_map = {
        'remove_outputs_on_stop': {'key': 'removeOutputsOnStop', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        remove_outputs_on_stop: Optional[bool] = None,
        **kwargs
    ):
        super(LiveEventActionInput, self).__init__(**kwargs)
        self.remove_outputs_on_stop = remove_outputs_on_stop


class LiveEventEncoding(msrest.serialization.Model):
    """Specifies the live event type and optional encoding settings for encoding live events.

    :param encoding_type: Live event type. When encodingType is set to None, the service simply
     passes through the incoming video and audio layer(s) to the output. When encodingType is set to
     Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates
     or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This
     property cannot be modified after the live event is created. Possible values include: "None",
     "Standard", "Premium1080p", "PassthroughBasic", "PassthroughStandard".
    :type encoding_type: str or ~azure.mgmt.media.models.LiveEventEncodingType
    :param preset_name: The optional encoding preset name, used when encodingType is not None. This
     value is specified at creation time and cannot be updated. If the encodingType is set to
     Standard, then the default preset name is Default720p. Else if the encodingType is set to
     Premium1080p, the default preset is Default1080p.
    :type preset_name: str
    :param stretch_mode: Specifies how the input video will be resized to fit the desired output
     resolution(s). Default is None. Possible values include: "None", "AutoSize", "AutoFit".
    :type stretch_mode: str or ~azure.mgmt.media.models.StretchMode
    :param key_frame_interval: Use an ISO 8601 time value between 0.5 to 20 seconds to specify the
     output fragment length for the video and audio tracks of an encoding live event. For example,
     use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or
     the length of a GoP (group of pictures).   If this value is not set for an encoding live event,
     the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live
     events.
    :type key_frame_interval: ~datetime.timedelta
    """

    _attribute_map = {
        'encoding_type': {'key': 'encodingType', 'type': 'str'},
        'preset_name': {'key': 'presetName', 'type': 'str'},
        'stretch_mode': {'key': 'stretchMode', 'type': 'str'},
        'key_frame_interval': {'key': 'keyFrameInterval', 'type': 'duration'},
    }

    def __init__(
        self,
        *,
        encoding_type: Optional[Union[str, "LiveEventEncodingType"]] = None,
        preset_name: Optional[str] = None,
        stretch_mode: Optional[Union[str, "StretchMode"]] = None,
        key_frame_interval: Optional[datetime.timedelta] = None,
        **kwargs
    ):
        super(LiveEventEncoding, self).__init__(**kwargs)
        self.encoding_type = encoding_type
        self.preset_name = preset_name
        self.stretch_mode = stretch_mode
        self.key_frame_interval = key_frame_interval


class LiveEventEndpoint(msrest.serialization.Model):
    """The live event endpoint.

    :param protocol: The endpoint protocol.
    :type protocol: str
    :param url: The endpoint URL.
    :type url: str
    """

    _attribute_map = {
        'protocol': {'key': 'protocol', 'type': 'str'},
        'url': {'key': 'url', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        protocol: Optional[str] = None,
        url: Optional[str] = None,
        **kwargs
    ):
        super(LiveEventEndpoint, self).__init__(**kwargs)
        self.protocol = protocol
        self.url = url


class LiveEventInput(msrest.serialization.Model):
    """The live event input.

    All required parameters must be populated in order to send to Azure.

    :param streaming_protocol: Required. The input protocol for the live event. This is specified
     at creation time and cannot be updated. Possible values include: "FragmentedMP4", "RTMP".
    :type streaming_protocol: str or ~azure.mgmt.media.models.LiveEventInputProtocol
    :param access_control: Access control for live event input.
    :type access_control: ~azure.mgmt.media.models.LiveEventInputAccessControl
    :param key_frame_interval_duration: ISO 8601 time duration of the key frame interval duration
     of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example,
     use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
    :type key_frame_interval_duration: str
    :param access_token: A UUID in string form to uniquely identify the stream. This can be
     specified at creation time but cannot be updated. If omitted, the service will generate a
     unique value.
    :type access_token: str
    :param endpoints: The input endpoints for the live event.
    :type endpoints: list[~azure.mgmt.media.models.LiveEventEndpoint]
    """

    _validation = {
        'streaming_protocol': {'required': True},
    }

    _attribute_map = {
        'streaming_protocol': {'key': 'streamingProtocol', 'type': 'str'},
        'access_control': {'key': 'accessControl', 'type': 'LiveEventInputAccessControl'},
        'key_frame_interval_duration': {'key': 'keyFrameIntervalDuration', 'type': 'str'},
        'access_token': {'key': 'accessToken', 'type': 'str'},
        'endpoints': {'key': 'endpoints', 'type': '[LiveEventEndpoint]'},
    }

    def __init__(
        self,
        *,
        streaming_protocol: Union[str, "LiveEventInputProtocol"],
        access_control: Optional["LiveEventInputAccessControl"] = None,
        key_frame_interval_duration: Optional[str] = None,
        access_token: Optional[str] = None,
        endpoints: Optional[List["LiveEventEndpoint"]] = None,
        **kwargs
    ):
        super(LiveEventInput, self).__init__(**kwargs)
        self.streaming_protocol = streaming_protocol
        self.access_control = access_control
        self.key_frame_interval_duration = key_frame_interval_duration
        self.access_token = access_token
        self.endpoints = endpoints


class LiveEventInputAccessControl(msrest.serialization.Model):
    """The IP access control for live event input.

    :param ip: The IP access control properties.
    :type ip: ~azure.mgmt.media.models.IPAccessControl
    """

    _attribute_map = {
        'ip': {'key': 'ip', 'type': 'IPAccessControl'},
    }

    def __init__(
        self,
        *,
        ip: Optional["IPAccessControl"] = None,
        **kwargs
    ):
        super(LiveEventInputAccessControl, self).__init__(**kwargs)
        self.ip = ip


class LiveEventInputTrackSelection(msrest.serialization.Model):
    """A track selection condition. This property is reserved for future use, any value set on this property will be ignored.

    :param property: Property name to select. This property is reserved for future use, any value
     set on this property will be ignored.
    :type property: str
    :param operation: Comparing operation. This property is reserved for future use, any value set
     on this property will be ignored.
    :type operation: str
    :param value: Property value to select. This property is reserved for future use, any value set
     on this property will be ignored.
    :type value: str
    """

    _attribute_map = {
        'property': {'key': 'property', 'type': 'str'},
        'operation': {'key': 'operation', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        property: Optional[str] = None,
        operation: Optional[str] = None,
        value: Optional[str] = None,
        **kwargs
    ):
        super(LiveEventInputTrackSelection, self).__init__(**kwargs)
        self.property = property
        self.operation = operation
        self.value = value


class LiveEventListResult(msrest.serialization.Model):
    """The LiveEvent list result.

    :param value: The result of the List Live Event operation.
    :type value: list[~azure.mgmt.media.models.LiveEvent]
    :param odata_count: The number of result.
    :type odata_count: int
    :param odata_next_link: The link to the next set of results. Not empty if value contains
     incomplete list of live outputs.
    :type odata_next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[LiveEvent]'},
        'odata_count': {'key': '@odata\\.count', 'type': 'int'},
        'odata_next_link': {'key': '@odata\\.nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["LiveEvent"]] = None,
        odata_count: Optional[int] = None,
        odata_next_link: Optional[str] = None,
        **kwargs
    ):
        super(LiveEventListResult, self).__init__(**kwargs)
        self.value = value
        self.odata_count = odata_count
        self.odata_next_link = odata_next_link


class LiveEventOutputTranscriptionTrack(msrest.serialization.Model):
    """Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.

    All required parameters must be populated in order to send to Azure.

    :param track_name: Required. The output track name. This property is reserved for future use,
     any value set on this property will be ignored.
    :type track_name: str
    """

    _validation = {
        'track_name': {'required': True},
    }

    _attribute_map = {
        'track_name': {'key': 'trackName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        track_name: str,
        **kwargs
    ):
        super(LiveEventOutputTranscriptionTrack, self).__init__(**kwargs)
        self.track_name = track_name


class LiveEventPreview(msrest.serialization.Model):
    """Live event preview settings.

    :param endpoints: The endpoints for preview. Do not share the preview URL with the live event
     audience.
    :type endpoints: list[~azure.mgmt.media.models.LiveEventEndpoint]
    :param access_control: The access control for live event preview.
    :type access_control: ~azure.mgmt.media.models.LiveEventPreviewAccessControl
    :param preview_locator: The identifier of the preview locator in Guid format. Specifying this
     at creation time allows the caller to know the preview locator url before the event is created.
     If omitted, the service will generate a random identifier. This value cannot be updated once
     the live event is created.
    :type preview_locator: str
    :param streaming_policy_name: The name of streaming policy used for the live event preview.
     This value is specified at creation time and cannot be updated.
    :type streaming_policy_name: str
    :param alternative_media_id: An alternative media identifier associated with the streaming
     locator created for the preview. This value is specified at creation time and cannot be
     updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the
     CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName
     field.
    :type alternative_media_id: str
    """

    _attribute_map = {
        'endpoints': {'key': 'endpoints', 'type': '[LiveEventEndpoint]'},
        'access_control': {'key': 'accessControl', 'type': 'LiveEventPreviewAccessControl'},
        'preview_locator': {'key': 'previewLocator', 'type': 'str'},
        'streaming_policy_name': {'key': 'streamingPolicyName', 'type': 'str'},
        'alternative_media_id': {'key': 'alternativeMediaId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        endpoints: Optional[List["LiveEventEndpoint"]] = None,
        access_control: Optional["LiveEventPreviewAccessControl"] = None,
        preview_locator: Optional[str] = None,
        streaming_policy_name: Optional[str] = None,
        alternative_media_id: Optional[str] = None,
        **kwargs
    ):
        super(LiveEventPreview, self).__init__(**kwargs)
        self.endpoints = endpoints
        self.access_control = access_control
        self.preview_locator = preview_locator
        self.streaming_policy_name = streaming_policy_name
        self.alternative_media_id = alternative_media_id


class LiveEventPreviewAccessControl(msrest.serialization.Model):
    """The IP access control for the live event preview endpoint.

    :param ip: The IP access control properties.
    :type ip: ~azure.mgmt.media.models.IPAccessControl
    """

    _attribute_map = {
        'ip': {'key': 'ip', 'type': 'IPAccessControl'},
    }

    def __init__(
        self,
        *,
        ip: Optional["IPAccessControl"] = None,
        **kwargs
    ):
        super(LiveEventPreviewAccessControl, self).__init__(**kwargs)
        self.ip = ip


class LiveEventTranscription(msrest.serialization.Model):
    """Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.

    :param language: Specifies the language (locale) to be used for speech-to-text transcription 
     it should match the spoken language in the audio track. The value should be in BCP-47 format
     (e.g: 'en-US'). See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about
     the live transcription feature and the list of supported languages.
    :type language: str
    :param input_track_selection: Provides a mechanism to select the audio track in the input live
     feed, to which speech-to-text transcription is applied. This property is reserved for future
     use, any value set on this property will be ignored.
    :type input_track_selection: list[~azure.mgmt.media.models.LiveEventInputTrackSelection]
    :param output_transcription_track: Describes a transcription track in the output of a live
     event, generated using speech-to-text transcription. This property is reserved for future use,
     any value set on this property will be ignored.
    :type output_transcription_track: ~azure.mgmt.media.models.LiveEventOutputTranscriptionTrack
    """

    _attribute_map = {
        'language': {'key': 'language', 'type': 'str'},
        'input_track_selection': {'key': 'inputTrackSelection', 'type': '[LiveEventInputTrackSelection]'},
        'output_transcription_track': {'key': 'outputTranscriptionTrack', 'type': 'LiveEventOutputTranscriptionTrack'},
    }

    def __init__(
        self,
        *,
        language: Optional[str] = None,
        input_track_selection: Optional[List["LiveEventInputTrackSelection"]] = None,
        output_transcription_track: Optional["LiveEventOutputTranscriptionTrack"] = None,
        **kwargs
    ):
        super(LiveEventTranscription, self).__init__(**kwargs)
        self.language = language
        self.input_track_selection = input_track_selection
        self.output_transcription_track = output_transcription_track


class LiveOutput(ProxyResource):
    """The Live Output.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: The system metadata relating to this resource.
    :vartype system_data: ~azure.mgmt.media.models.SystemData
    :param description: The description of the live output.
    :type description: str
    :param asset_name: The asset that the live output will write to.
    :type asset_name: str
    :param archive_window_length: ISO 8601 time between 1 minute to 25 hours to indicate the
     maximum content length that can be archived in the asset for this live output. This also sets
     the maximum content length for the rewind window. For example, use PT1H30M to indicate 1 hour
     and 30 minutes of archive window.
    :type archive_window_length: ~datetime.timedelta
    :param manifest_name: The manifest file name. If not provided, the service will generate one
     automatically.
    :type manifest_name: str
    :param hls: HTTP Live Streaming (HLS) packing setting for the live output.
    :type hls: ~azure.mgmt.media.models.Hls
    :param output_snap_time: The initial timestamp that the live output will start at, any content
     before this value will not be archived.
    :type output_snap_time: long
    :ivar created: The creation time the live output.
    :vartype created: ~datetime.datetime
    :ivar last_modified: The time the live output was last modified.
    :vartype last_modified: ~datetime.datetime
    :ivar provisioning_state: The provisioning state of the live output.
    :vartype provisioning_state: str
    :ivar resource_state: The resource state of the live output. Possible values include:
     "Creating", "Running", "Deleting".
    :vartype resource_state: str or ~azure.mgmt.media.models.LiveOutputResourceState
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'created': {'readonly': True},
        'last_modified': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'resource_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'asset_name': {'key': 'properties.assetName', 'type': 'str'},
        'archive_window_length': {'key': 'properties.archiveWindowLength', 'type': 'duration'},
        'manifest_name': {'key': 'properties.manifestName', 'type': 'str'},
        'hls': {'key': 'properties.hls', 'type': 'Hls'},
        'output_snap_time': {'key': 'properties.outputSnapTime', 'type': 'long'},
        'created': {'key': 'properties.created', 'type': 'iso-8601'},
        'last_modified': {'key': 'properties.lastModified', 'type': 'iso-8601'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'resource_state': {'key': 'properties.resourceState', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        asset_name: Optional[str] = None,
        archive_window_length: Optional[datetime.timedelta] = None,
        manifest_name: Optional[str] = None,
        hls: Optional["Hls"] = None,
        output_snap_time: Optional[int] = None,
        **kwargs
    ):
        super(LiveOutput, self).__init__(**kwargs)
        self.system_data = None
        self.description = description
        self.asset_name = asset_name
        self.archive_window_length = archive_window_length
        self.manifest_name = manifest_name
        self.hls = hls
        self.output_snap_time = output_snap_time
        self.created = None
        self.last_modified = None
        self.provisioning_state = None
        self.resource_state = None


class LiveOutputListResult(msrest.serialization.Model):
    """The LiveOutput list result.

    :param value: The result of the List LiveOutput operation.
    :type value: list[~azure.mgmt.media.models.LiveOutput]
    :param odata_count: The number of result.
    :type odata_count: int
    :param odata_next_link: The link to the next set of results. Not empty if value contains
     incomplete list of live outputs.
    :type odata_next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[LiveOutput]'},
        'odata_count': {'key': '@odata\\.count', 'type': 'int'},
        'odata_next_link': {'key': '@odata\\.nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["LiveOutput"]] = None,
        odata_count: Optional[int] = None,
        odata_next_link: Optional[str] = None,
        **kwargs
    ):
        super(LiveOutputListResult, self).__init__(**kwargs)
        self.value = value
        self.odata_count = odata_count
        self.odata_next_link = odata_next_link


class LogSpecification(msrest.serialization.Model):
    """A diagnostic log emitted by service.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: The diagnostic log category name.
    :vartype name: str
    :ivar display_name: The diagnostic log category display name.
    :vartype display_name: str
    :ivar blob_duration: The time range for requests in each blob.
    :vartype blob_duration: str
    """

    _validation = {
        'name': {'readonly': True},
        'display_name': {'readonly': True},
        'blob_duration': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'display_name': {'key': 'displayName', 'type': 'str'},
        'blob_duration': {'key': 'blobDuration', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LogSpecification, self).__init__(**kwargs)
        self.name = None
        self.display_name = None
        self.blob_duration = None


class MediaService(TrackedResource):
    """A Media Services account.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param location: Required. The geo-location where the resource lives.
    :type location: str
    :param identity: The Managed Identity for the Media Services account.
    :type identity: ~azure.mgmt.media.models.MediaServiceIdentity
    :ivar system_data: The system metadata relating to this resource.
    :vartype system_data: ~azure.mgmt.media.models.SystemData
    :ivar media_service_id: The Media Services account ID.
    :vartype media_service_id: str
    :param storage_accounts: The storage accounts for this resource.
    :type storage_accounts: list[~azure.mgmt.media.models.StorageAccount]
    :param storage_authentication:  Possible values include: "System", "ManagedIdentity".
    :type storage_authentication: str or ~azure.mgmt.media.models.StorageAuthentication
    :param encryption: The account encryption properties.
    :type encryption: ~azure.mgmt.media.models.AccountEncryption
    :param key_delivery: The Key Delivery properties for Media Services account.
    :type key_delivery: ~azure.mgmt.media.models.KeyDelivery
    :param public_network_access: Whether or not public network access is allowed for resources
     under the Media Services account. Possible values include: "Enabled", "Disabled".
    :type public_network_access: str or ~azure.mgmt.media.models.PublicNetworkAccess
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'system_data': {'readonly': True},
        'media_service_id': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
        'identity': {'key': 'identity', 'type': 'MediaServiceIdentity'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'media_service_id': {'key': 'properties.mediaServiceId', 'type': 'str'},
        'storage_accounts': {'key': 'properties.storageAccounts', 'type': '[StorageAccount]'},
        'storage_authentication': {'key': 'properties.storageAuthentication', 'type': 'str'},
        'encryption': {'key': 'properties.encryption', 'type': 'AccountEncryption'},
        'key_delivery': {'key': 'properties.keyDelivery', 'type': 'KeyDelivery'},
        'public_network_access': {'key': 'properties.publicNetworkAccess', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        identity: Optional["MediaServiceIdentity"] = None,
        storage_accounts: Optional[List["StorageAccount"]] = None,
        storage_authentication: Optional[Union[str, "StorageAuthentication"]] = None,
        encryption: Optional["AccountEncryption"] = None,
        key_delivery: Optional["KeyDelivery"] = None,
        public_network_access: Optional[Union[str, "PublicNetworkAccess"]] = None,
        **kwargs
    ):
        super(MediaService, self).__init__(tags=tags, location=location, **kwargs)
        self.identity = identity
        self.system_data = None
        self.media_service_id = None
        self.storage_accounts = storage_accounts
        self.storage_authentication = storage_authentication
        self.encryption = encryption
        self.key_delivery = key_delivery
        self.public_network_access = public_network_access


class MediaServiceCollection(msrest.serialization.Model):
    """A collection of MediaService items.

    :param value: A collection of MediaService items.
    :type value: list[~azure.mgmt.media.models.MediaService]
    :param odata_next_link: A link to the next page of the collection (when the collection contains
     too many results to return in one response).
    :type odata_next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[MediaService]'},
        'odata_next_link': {'key': '@odata\\.nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["MediaService"]] = None,
        odata_next_link: Optional[str] = None,
        **kwargs
    ):
        super(MediaServiceCollection, self).__init__(**kwargs)
        self.value = value
        self.odata_next_link = odata_next_link


class MediaServiceIdentity(msrest.serialization.Model):
    """MediaServiceIdentity.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The identity type.
    :type type: str
    :ivar principal_id: The Principal ID of the identity.
    :vartype principal_id: str
    :ivar tenant_id: The Tenant ID of the identity.
    :vartype tenant_id: str
    :param user_assigned_identities: The user assigned managed identities.
    :type user_assigned_identities: dict[str, ~azure.mgmt.media.models.UserAssignedManagedIdentity]
    """

    _validation = {
        'type': {'required': True},
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
        'user_assigned_identities': {'key': 'userAssignedIdentities', 'type': '{UserAssignedManagedIdentity}'},
    }

    def __init__(
        self,
        *,
        type: str,
        user_assigned_identities: Optional[Dict[str, "UserAssignedManagedIdentity"]] = None,
        **kwargs
    ):
        super(MediaServiceIdentity, self).__init__(**kwargs)
        self.type = type
        self.principal_id = None
        self.tenant_id = None
        self.user_assigned_identities = user_assigned_identities


class MediaServiceUpdate(msrest.serialization.Model):
    """A Media Services account update.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param identity: The Managed Identity for the Media Services account.
    :type identity: ~azure.mgmt.media.models.MediaServiceIdentity
    :ivar media_service_id: The Media Services account ID.
    :vartype media_service_id: str
    :param storage_accounts: The storage accounts for this resource.
    :type storage_accounts: list[~azure.mgmt.media.models.StorageAccount]
    :param storage_authentication:  Possible values include: "System", "ManagedIdentity".
    :type storage_authentication: str or ~azure.mgmt.media.models.StorageAuthentication
    :param encryption: The account encryption properties.
    :type encryption: ~azure.mgmt.media.models.AccountEncryption
    :param key_delivery: The Key Delivery properties for Media Services account.
    :type key_delivery: ~azure.mgmt.media.models.KeyDelivery
    :param public_network_access: Whether or not public network access is allowed for resources
     under the Media Services account. Possible values include: "Enabled", "Disabled".
    :type public_network_access: str or ~azure.mgmt.media.models.PublicNetworkAccess
    """

    _validation = {
        'media_service_id': {'readonly': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'identity': {'key': 'identity', 'type': 'MediaServiceIdentity'},
        'media_service_id': {'key': 'properties.mediaServiceId', 'type': 'str'},
        'storage_accounts': {'key': 'properties.storageAccounts', 'type': '[StorageAccount]'},
        'storage_authentication': {'key': 'properties.storageAuthentication', 'type': 'str'},
        'encryption': {'key': 'properties.encryption', 'type': 'AccountEncryption'},
        'key_delivery': {'key': 'properties.keyDelivery', 'type': 'KeyDelivery'},
        'public_network_access': {'key': 'properties.publicNetworkAccess', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
        identity: Optional["MediaServiceIdentity"] = None,
        storage_accounts: Optional[List["StorageAccount"]] = None,
        storage_authentication: Optional[Union[str, "StorageAuthentication"]] = None,
        encryption: Optional["AccountEncryption"] = None,
        key_delivery: Optional["KeyDelivery"] = None,
        public_network_access: Optional[Union[str, "PublicNetworkAccess"]] = None,
        **kwargs
    ):
        super(MediaServiceUpdate, self).__init__(**kwargs)
        self.tags = tags
        self.identity = identity
        self.media_service_id = None
        self.storage_accounts = storage_accounts
        self.storage_authentication = storage_authentication
        self.encryption = encryption
        self.key_delivery = key_delivery
        self.public_network_access = public_network_access


class MetricDimension(msrest.serialization.Model):
    """A metric dimension.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: The metric dimension name.
    :vartype name: str
    :ivar display_name: The display name for the dimension.
    :vartype display_name: str
    :ivar to_be_exported_for_shoebox: Whether to export metric to shoebox.
    :vartype to_be_exported_for_shoebox: bool
    """

    _validation = {
        'name': {'readonly': True},
        'display_name': {'readonly': True},
        'to_be_exported_for_shoebox': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'display_name': {'key': 'displayName', 'type': 'str'},
        'to_be_exported_for_shoebox': {'key': 'toBeExportedForShoebox', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(MetricDimension, self).__init__(**kwargs)
        self.name = None
        self.display_name = None
        self.to_be_exported_for_shoebox = None


class MetricSpecification(msrest.serialization.Model):
    """A metric emitted by service.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: The metric name.
    :vartype name: str
    :ivar display_name: The metric display name.
    :vartype display_name: str
    :ivar display_description: The metric display description.
    :vartype display_description: str
    :ivar unit: The metric unit. Possible values include: "Bytes", "Count", "Milliseconds".
    :vartype unit: str or ~azure.mgmt.media.models.MetricUnit
    :ivar aggregation_type: The metric aggregation type. Possible values include: "Average",
     "Count", "Total".
    :vartype aggregation_type: str or ~azure.mgmt.media.models.MetricAggregationType
    :ivar lock_aggregation_type: The metric lock aggregation type. Possible values include:
     "Average", "Count", "Total".
    :vartype lock_aggregation_type: str or ~azure.mgmt.media.models.MetricAggregationType
    :param supported_aggregation_types: Supported aggregation types.
    :type supported_aggregation_types: list[str]
    :ivar dimensions: The metric dimensions.
    :vartype dimensions: list[~azure.mgmt.media.models.MetricDimension]
    :ivar enable_regional_mdm_account: Indicates whether regional MDM account is enabled.
    :vartype enable_regional_mdm_account: bool
    :ivar source_mdm_account: The source MDM account.
    :vartype source_mdm_account: str
    :ivar source_mdm_namespace: The source MDM namespace.
    :vartype source_mdm_namespace: str
    :ivar supported_time_grain_types: The supported time grain types.
    :vartype supported_time_grain_types: list[str]
    """

    _validation = {
        'name': {'readonly': True},
        'display_name': {'readonly': True},
        'display_description': {'readonly': True},
        'unit': {'readonly': True},
        'aggregation_type': {'readonly': True},
        'lock_aggregation_type': {'readonly': True},
        'dimensions': {'readonly': True},
        'enable_regional_mdm_account': {'readonly': True},
        'source_mdm_account': {'readonly': True},
        'source_mdm_namespace': {'readonly': True},
        'supported_time_grain_types': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'display_name': {'key': 'displayName', 'type': 'str'},
        'display_description': {'key': 'displayDescription', 'type': 'str'},
        'unit': {'key': 'unit', 'type': 'str'},
        'aggregation_type': {'key': 'aggregationType', 'type': 'str'},
        'lock_aggregation_type': {'key': 'lockAggregationType', 'type': 'str'},
        'supported_aggregation_types': {'key': 'supportedAggregationTypes', 'type': '[str]'},
        'dimensions': {'key': 'dimensions', 'type': '[MetricDimension]'},
        'enable_regional_mdm_account': {'key': 'enableRegionalMdmAccount', 'type': 'bool'},
        'source_mdm_account': {'key': 'sourceMdmAccount', 'type': 'str'},
        'source_mdm_namespace': {'key': 'sourceMdmNamespace', 'type': 'str'},
        'supported_time_grain_types': {'key': 'supportedTimeGrainTypes', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        supported_aggregation_types: Optional[List[str]] = None,
        **kwargs
    ):
        super(MetricSpecification, self).__init__(**kwargs)
        self.name = None
        self.display_name = None
        self.display_description = None
        self.unit = None
        self.aggregation_type = None
        self.lock_aggregation_type = None
        self.supported_aggregation_types = supported_aggregation_types
        self.dimensions = None
        self.enable_regional_mdm_account = None
        self.source_mdm_account = None
        self.source_mdm_namespace = None
        self.supported_time_grain_types = None


class NoEncryption(msrest.serialization.Model):
    """Class for NoEncryption scheme.

    :param enabled_protocols: Representing supported protocols.
    :type enabled_protocols: ~azure.mgmt.media.models.EnabledProtocols
    """

    _attribute_map = {
        'enabled_protocols': {'key': 'enabledProtocols', 'type': 'EnabledProtocols'},
    }

    def __init__(
        self,
        *,
        enabled_protocols: Optional["EnabledProtocols"] = None,
        **kwargs
    ):
        super(NoEncryption, self).__init__(**kwargs)
        self.enabled_protocols = enabled_protocols


class Operation(msrest.serialization.Model):
    """An operation.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The operation name.
    :type name: str
    :param display: The operation display name.
    :type display: ~azure.mgmt.media.models.OperationDisplay
    :param origin: Origin of the operation.
    :type origin: str
    :param properties: Operation properties format.
    :type properties: ~azure.mgmt.media.models.Properties
    :param is_data_action: Whether the operation applies to data-plane.
    :type is_data_action: bool
    :param action_type: Indicates the action type. Possible values include: "Internal".
    :type action_type: str or ~azure.mgmt.media.models.ActionType
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'display': {'key': 'display', 'type': 'OperationDisplay'},
        'origin': {'key': 'origin', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'Properties'},
        'is_data_action': {'key': 'isDataAction', 'type': 'bool'},
        'action_type': {'key': 'actionType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        display: Optional["OperationDisplay"] = None,
        origin: Optional[str] = None,
        properties: Optional["Properties"] = None,
        is_data_action: Optional[bool] = None,
        action_type: Optional[Union[str, "ActionType"]] = None,
        **kwargs
    ):
        super(Operation, self).__init__(**kwargs)
        self.name = name
        self.display = display
        self.origin = origin
        self.properties = properties
        self.is_data_action = is_data_action
        self.action_type = action_type


class OperationCollection(msrest.serialization.Model):
    """A collection of Operation items.

    :param value: A collection of Operation items.
    :type value: list[~azure.mgmt.media.models.Operation]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Operation]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["Operation"]] = None,
        **kwargs
    ):
        super(OperationCollection, self).__init__(**kwargs)
        self.value = value


class OperationDisplay(msrest.serialization.Model):
    """Operation details.

    :param provider: The service provider.
    :type provider: str
    :param resource: Resource on which the operation is performed.
    :type resource: str
    :param operation: The operation type.
    :type operation: str
    :param description: The operation description.
    :type description: str
    """

    _attribute_map = {
        'provider': {'key': 'provider', 'type': 'str'},
        'resource': {'key': 'resource', 'type': 'str'},
        'operation': {'key': 'operation', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        provider: Optional[str] = None,
        resource: Optional[str] = None,
        operation: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(OperationDisplay, self).__init__(**kwargs)
        self.provider = provider
        self.resource = resource
        self.operation = operation
        self.description = description


class PresentationTimeRange(msrest.serialization.Model):
    """The presentation time range, this is asset related and not recommended for Account Filter.

    :param start_timestamp: The absolute start time boundary.
    :type start_timestamp: long
    :param end_timestamp: The absolute end time boundary.
    :type end_timestamp: long
    :param presentation_window_duration: The relative to end sliding window.
    :type presentation_window_duration: long
    :param live_backoff_duration: The relative to end right edge.
    :type live_backoff_duration: long
    :param timescale: The time scale of time stamps.
    :type timescale: long
    :param force_end_timestamp: The indicator of forcing existing of end time stamp.
    :type force_end_timestamp: bool
    """

    _attribute_map = {
        'start_timestamp': {'key': 'startTimestamp', 'type': 'long'},
        'end_timestamp': {'key': 'endTimestamp', 'type': 'long'},
        'presentation_window_duration': {'key': 'presentationWindowDuration', 'type': 'long'},
        'live_backoff_duration': {'key': 'liveBackoffDuration', 'type': 'long'},
        'timescale': {'key': 'timescale', 'type': 'long'},
        'force_end_timestamp': {'key': 'forceEndTimestamp', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        start_timestamp: Optional[int] = None,
        end_timestamp: Optional[int] = None,
        presentation_window_duration: Optional[int] = None,
        live_backoff_duration: Optional[int] = None,
        timescale: Optional[int] = None,
        force_end_timestamp: Optional[bool] = None,
        **kwargs
    ):
        super(PresentationTimeRange, self).__init__(**kwargs)
        self.start_timestamp = start_timestamp
        self.end_timestamp = end_timestamp
        self.presentation_window_duration = presentation_window_duration
        self.live_backoff_duration = live_backoff_duration
        self.timescale = timescale
        self.force_end_timestamp = force_end_timestamp


class PrivateEndpoint(msrest.serialization.Model):
    """The Private Endpoint resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The ARM identifier for Private Endpoint.
    :vartype id: str
    """

    _validation = {
        'id': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PrivateEndpoint, self).__init__(**kwargs)
        self.id = None


class PrivateEndpointConnection(Resource):
    """The Private Endpoint Connection resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :param private_endpoint: The resource of private end point.
    :type private_endpoint: ~azure.mgmt.media.models.PrivateEndpoint
    :param private_link_service_connection_state: A collection of information about the state of
     the connection between service consumer and provider.
    :type private_link_service_connection_state:
     ~azure.mgmt.media.models.PrivateLinkServiceConnectionState
    :ivar provisioning_state: The provisioning state of the private endpoint connection resource.
     Possible values include: "Succeeded", "Creating", "Deleting", "Failed".
    :vartype provisioning_state: str or
     ~azure.mgmt.media.models.PrivateEndpointConnectionProvisioningState
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'private_endpoint': {'key': 'properties.privateEndpoint', 'type': 'PrivateEndpoint'},
        'private_link_service_connection_state': {'key': 'properties.privateLinkServiceConnectionState', 'type': 'PrivateLinkServiceConnectionState'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        private_endpoint: Optional["PrivateEndpoint"] = None,
        private_link_service_connection_state: Optional["PrivateLinkServiceConnectionState"] = None,
        **kwargs
    ):
        super(PrivateEndpointConnection, self).__init__(**kwargs)
        self.private_endpoint = private_endpoint
        self.private_link_service_connection_state = private_link_service_connection_state
        self.provisioning_state = None


class PrivateEndpointConnectionListResult(msrest.serialization.Model):
    """List of private endpoint connection associated with the specified storage account.

    :param value: Array of private endpoint connections.
    :type value: list[~azure.mgmt.media.models.PrivateEndpointConnection]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[PrivateEndpointConnection]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["PrivateEndpointConnection"]] = None,
        **kwargs
    ):
        super(PrivateEndpointConnectionListResult, self).__init__(**kwargs)
        self.value = value


class PrivateLinkResource(Resource):
    """A private link resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar group_id: The private link resource group id.
    :vartype group_id: str
    :ivar required_members: The private link resource required member names.
    :vartype required_members: list[str]
    :param required_zone_names: The private link resource Private link DNS zone name.
    :type required_zone_names: list[str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'group_id': {'readonly': True},
        'required_members': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'group_id': {'key': 'properties.groupId', 'type': 'str'},
        'required_members': {'key': 'properties.requiredMembers', 'type': '[str]'},
        'required_zone_names': {'key': 'properties.requiredZoneNames', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        required_zone_names: Optional[List[str]] = None,
        **kwargs
    ):
        super(PrivateLinkResource, self).__init__(**kwargs)
        self.group_id = None
        self.required_members = None
        self.required_zone_names = required_zone_names


class PrivateLinkResourceListResult(msrest.serialization.Model):
    """A list of private link resources.

    :param value: Array of private link resources.
    :type value: list[~azure.mgmt.media.models.PrivateLinkResource]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[PrivateLinkResource]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["PrivateLinkResource"]] = None,
        **kwargs
    ):
        super(PrivateLinkResourceListResult, self).__init__(**kwargs)
        self.value = value


class PrivateLinkServiceConnectionState(msrest.serialization.Model):
    """A collection of information about the state of the connection between service consumer and provider.

    :param status: Indicates whether the connection has been Approved/Rejected/Removed by the owner
     of the service. Possible values include: "Pending", "Approved", "Rejected".
    :type status: str or ~azure.mgmt.media.models.PrivateEndpointServiceConnectionStatus
    :param description: The reason for approval/rejection of the connection.
    :type description: str
    :param actions_required: A message indicating if changes on the service provider require any
     updates on the consumer.
    :type actions_required: str
    """

    _attribute_map = {
        'status': {'key': 'status', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'actions_required': {'key': 'actionsRequired', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        status: Optional[Union[str, "PrivateEndpointServiceConnectionStatus"]] = None,
        description: Optional[str] = None,
        actions_required: Optional[str] = None,
        **kwargs
    ):
        super(PrivateLinkServiceConnectionState, self).__init__(**kwargs)
        self.status = status
        self.description = description
        self.actions_required = actions_required


class Properties(msrest.serialization.Model):
    """The service specification property.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar service_specification: The service specifications.
    :vartype service_specification: ~azure.mgmt.media.models.ServiceSpecification
    """

    _validation = {
        'service_specification': {'readonly': True},
    }

    _attribute_map = {
        'service_specification': {'key': 'serviceSpecification', 'type': 'ServiceSpecification'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Properties, self).__init__(**kwargs)
        self.service_specification = None


class ResourceIdentity(msrest.serialization.Model):
    """ResourceIdentity.

    All required parameters must be populated in order to send to Azure.

    :param user_assigned_identity: The user assigned managed identity's ARM ID to use when
     accessing a resource.
    :type user_assigned_identity: str
    :param use_system_assigned_identity: Required. Indicates whether to use System Assigned Managed
     Identity. Mutual exclusive with User Assigned Managed Identity.
    :type use_system_assigned_identity: bool
    """

    _validation = {
        'use_system_assigned_identity': {'required': True},
    }

    _attribute_map = {
        'user_assigned_identity': {'key': 'userAssignedIdentity', 'type': 'str'},
        'use_system_assigned_identity': {'key': 'useSystemAssignedIdentity', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        use_system_assigned_identity: bool,
        user_assigned_identity: Optional[str] = None,
        **kwargs
    ):
        super(ResourceIdentity, self).__init__(**kwargs)
        self.user_assigned_identity = user_assigned_identity
        self.use_system_assigned_identity = use_system_assigned_identity


class ServiceSpecification(msrest.serialization.Model):
    """The service metric specifications.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar log_specifications: List of log specifications.
    :vartype log_specifications: list[~azure.mgmt.media.models.LogSpecification]
    :ivar metric_specifications: List of metric specifications.
    :vartype metric_specifications: list[~azure.mgmt.media.models.MetricSpecification]
    """

    _validation = {
        'log_specifications': {'readonly': True},
        'metric_specifications': {'readonly': True},
    }

    _attribute_map = {
        'log_specifications': {'key': 'logSpecifications', 'type': '[LogSpecification]'},
        'metric_specifications': {'key': 'metricSpecifications', 'type': '[MetricSpecification]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ServiceSpecification, self).__init__(**kwargs)
        self.log_specifications = None
        self.metric_specifications = None


class StorageAccount(msrest.serialization.Model):
    """The storage account details.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param id: The ID of the storage account resource. Media Services relies on tables and queues
     as well as blobs, so the primary storage account must be a Standard Storage account (either
     Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as
     secondary storage accounts.
    :type id: str
    :param type: Required. The type of the storage account. Possible values include: "Primary",
     "Secondary".
    :type type: str or ~azure.mgmt.media.models.StorageAccountType
    :param identity: The storage account identity.
    :type identity: ~azure.mgmt.media.models.ResourceIdentity
    :ivar status: The current status of the storage account mapping.
    :vartype status: str
    """

    _validation = {
        'type': {'required': True},
        'status': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'identity': {'key': 'identity', 'type': 'ResourceIdentity'},
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: Union[str, "StorageAccountType"],
        id: Optional[str] = None,
        identity: Optional["ResourceIdentity"] = None,
        **kwargs
    ):
        super(StorageAccount, self).__init__(**kwargs)
        self.id = id
        self.type = type
        self.identity = identity
        self.status = None


class StorageEncryptedAssetDecryptionData(msrest.serialization.Model):
    """Data needed to decrypt asset files encrypted with legacy storage encryption.

    :param key: The Asset File storage encryption key.
    :type key: bytearray
    :param asset_file_encryption_metadata: Asset File encryption metadata.
    :type asset_file_encryption_metadata:
     list[~azure.mgmt.media.models.AssetFileEncryptionMetadata]
    """

    _attribute_map = {
        'key': {'key': 'key', 'type': 'bytearray'},
        'asset_file_encryption_metadata': {'key': 'assetFileEncryptionMetadata', 'type': '[AssetFileEncryptionMetadata]'},
    }

    def __init__(
        self,
        *,
        key: Optional[bytearray] = None,
        asset_file_encryption_metadata: Optional[List["AssetFileEncryptionMetadata"]] = None,
        **kwargs
    ):
        super(StorageEncryptedAssetDecryptionData, self).__init__(**kwargs)
        self.key = key
        self.asset_file_encryption_metadata = asset_file_encryption_metadata


class StreamingEndpoint(TrackedResource):
    """The streaming endpoint.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param location: Required. The geo-location where the resource lives.
    :type location: str
    :ivar system_data: The system metadata relating to this resource.
    :vartype system_data: ~azure.mgmt.media.models.SystemData
    :param description: The streaming endpoint description.
    :type description: str
    :param scale_units: The number of scale units. Use the Scale operation to adjust this value.
    :type scale_units: int
    :param availability_set_name: This feature is deprecated, do not set a value for this property.
    :type availability_set_name: str
    :param access_control: The access control definition of the streaming endpoint.
    :type access_control: ~azure.mgmt.media.models.StreamingEndpointAccessControl
    :param max_cache_age: Max cache age.
    :type max_cache_age: long
    :param custom_host_names: The custom host names of the streaming endpoint.
    :type custom_host_names: list[str]
    :ivar host_name: The streaming endpoint host name.
    :vartype host_name: str
    :param cdn_enabled: The CDN enabled flag.
    :type cdn_enabled: bool
    :param cdn_provider: The CDN provider name.
    :type cdn_provider: str
    :param cdn_profile: The CDN profile name.
    :type cdn_profile: str
    :ivar provisioning_state: The provisioning state of the streaming endpoint.
    :vartype provisioning_state: str
    :ivar resource_state: The resource state of the streaming endpoint. Possible values include:
     "Stopped", "Starting", "Running", "Stopping", "Deleting", "Scaling".
    :vartype resource_state: str or ~azure.mgmt.media.models.StreamingEndpointResourceState
    :param cross_site_access_policies: The streaming endpoint access policies.
    :type cross_site_access_policies: ~azure.mgmt.media.models.CrossSiteAccessPolicies
    :ivar free_trial_end_time: The free trial expiration time.
    :vartype free_trial_end_time: ~datetime.datetime
    :ivar created: The exact time the streaming endpoint was created.
    :vartype created: ~datetime.datetime
    :ivar last_modified: The exact time the streaming endpoint was last modified.
    :vartype last_modified: ~datetime.datetime
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'system_data': {'readonly': True},
        'host_name': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'resource_state': {'readonly': True},
        'free_trial_end_time': {'readonly': True},
        'created': {'readonly': True},
        'last_modified': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'scale_units': {'key': 'properties.scaleUnits', 'type': 'int'},
        'availability_set_name': {'key': 'properties.availabilitySetName', 'type': 'str'},
        'access_control': {'key': 'properties.accessControl', 'type': 'StreamingEndpointAccessControl'},
        'max_cache_age': {'key': 'properties.maxCacheAge', 'type': 'long'},
        'custom_host_names': {'key': 'properties.customHostNames', 'type': '[str]'},
        'host_name': {'key': 'properties.hostName', 'type': 'str'},
        'cdn_enabled': {'key': 'properties.cdnEnabled', 'type': 'bool'},
        'cdn_provider': {'key': 'properties.cdnProvider', 'type': 'str'},
        'cdn_profile': {'key': 'properties.cdnProfile', 'type': 'str'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'resource_state': {'key': 'properties.resourceState', 'type': 'str'},
        'cross_site_access_policies': {'key': 'properties.crossSiteAccessPolicies', 'type': 'CrossSiteAccessPolicies'},
        'free_trial_end_time': {'key': 'properties.freeTrialEndTime', 'type': 'iso-8601'},
        'created': {'key': 'properties.created', 'type': 'iso-8601'},
        'last_modified': {'key': 'properties.lastModified', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        description: Optional[str] = None,
        scale_units: Optional[int] = None,
        availability_set_name: Optional[str] = None,
        access_control: Optional["StreamingEndpointAccessControl"] = None,
        max_cache_age: Optional[int] = None,
        custom_host_names: Optional[List[str]] = None,
        cdn_enabled: Optional[bool] = None,
        cdn_provider: Optional[str] = None,
        cdn_profile: Optional[str] = None,
        cross_site_access_policies: Optional["CrossSiteAccessPolicies"] = None,
        **kwargs
    ):
        super(StreamingEndpoint, self).__init__(tags=tags, location=location, **kwargs)
        self.system_data = None
        self.description = description
        self.scale_units = scale_units
        self.availability_set_name = availability_set_name
        self.access_control = access_control
        self.max_cache_age = max_cache_age
        self.custom_host_names = custom_host_names
        self.host_name = None
        self.cdn_enabled = cdn_enabled
        self.cdn_provider = cdn_provider
        self.cdn_profile = cdn_profile
        self.provisioning_state = None
        self.resource_state = None
        self.cross_site_access_policies = cross_site_access_policies
        self.free_trial_end_time = None
        self.created = None
        self.last_modified = None


class StreamingEndpointAccessControl(msrest.serialization.Model):
    """Streaming endpoint access control definition.

    :param akamai: The access control of Akamai.
    :type akamai: ~azure.mgmt.media.models.AkamaiAccessControl
    :param ip: The IP access control of the streaming endpoint.
    :type ip: ~azure.mgmt.media.models.IPAccessControl
    """

    _attribute_map = {
        'akamai': {'key': 'akamai', 'type': 'AkamaiAccessControl'},
        'ip': {'key': 'ip', 'type': 'IPAccessControl'},
    }

    def __init__(
        self,
        *,
        akamai: Optional["AkamaiAccessControl"] = None,
        ip: Optional["IPAccessControl"] = None,
        **kwargs
    ):
        super(StreamingEndpointAccessControl, self).__init__(**kwargs)
        self.akamai = akamai
        self.ip = ip


class StreamingEndpointListResult(msrest.serialization.Model):
    """The streaming endpoint list result.

    :param value: The result of the List StreamingEndpoint operation.
    :type value: list[~azure.mgmt.media.models.StreamingEndpoint]
    :param odata_count: The number of result.
    :type odata_count: int
    :param odata_next_link: The link to the next set of results. Not empty if value contains
     incomplete list of streaming endpoints.
    :type odata_next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[StreamingEndpoint]'},
        'odata_count': {'key': '@odata\\.count', 'type': 'int'},
        'odata_next_link': {'key': '@odata\\.nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["StreamingEndpoint"]] = None,
        odata_count: Optional[int] = None,
        odata_next_link: Optional[str] = None,
        **kwargs
    ):
        super(StreamingEndpointListResult, self).__init__(**kwargs)
        self.value = value
        self.odata_count = odata_count
        self.odata_next_link = odata_next_link


class StreamingEntityScaleUnit(msrest.serialization.Model):
    """scale units definition.

    :param scale_unit: The scale unit number of the streaming endpoint.
    :type scale_unit: int
    """

    _attribute_map = {
        'scale_unit': {'key': 'scaleUnit', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        scale_unit: Optional[int] = None,
        **kwargs
    ):
        super(StreamingEntityScaleUnit, self).__init__(**kwargs)
        self.scale_unit = scale_unit


class StreamingLocator(ProxyResource):
    """A Streaming Locator resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: The system metadata relating to this resource.
    :vartype system_data: ~azure.mgmt.media.models.SystemData
    :param asset_name: Asset Name.
    :type asset_name: str
    :ivar created: The creation time of the Streaming Locator.
    :vartype created: ~datetime.datetime
    :param start_time: The start time of the Streaming Locator.
    :type start_time: ~datetime.datetime
    :param end_time: The end time of the Streaming Locator.
    :type end_time: ~datetime.datetime
    :param streaming_locator_id: The StreamingLocatorId of the Streaming Locator.
    :type streaming_locator_id: str
    :param streaming_policy_name: Name of the Streaming Policy used by this Streaming Locator.
     Either specify the name of Streaming Policy you created or use one of the predefined Streaming
     Policies. The predefined Streaming Policies available are: 'Predefined_DownloadOnly',
     'Predefined_ClearStreamingOnly', 'Predefined_DownloadAndClearStreaming', 'Predefined_ClearKey',
     'Predefined_MultiDrmCencStreaming' and 'Predefined_MultiDrmStreaming'.
    :type streaming_policy_name: str
    :param default_content_key_policy_name: Name of the default ContentKeyPolicy used by this
     Streaming Locator.
    :type default_content_key_policy_name: str
    :param content_keys: The ContentKeys used by this Streaming Locator.
    :type content_keys: list[~azure.mgmt.media.models.StreamingLocatorContentKey]
    :param alternative_media_id: Alternative Media ID of this Streaming Locator.
    :type alternative_media_id: str
    :param filters: A list of asset or account filters which apply to this streaming locator.
    :type filters: list[str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'created': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'asset_name': {'key': 'properties.assetName', 'type': 'str'},
        'created': {'key': 'properties.created', 'type': 'iso-8601'},
        'start_time': {'key': 'properties.startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'properties.endTime', 'type': 'iso-8601'},
        'streaming_locator_id': {'key': 'properties.streamingLocatorId', 'type': 'str'},
        'streaming_policy_name': {'key': 'properties.streamingPolicyName', 'type': 'str'},
        'default_content_key_policy_name': {'key': 'properties.defaultContentKeyPolicyName', 'type': 'str'},
        'content_keys': {'key': 'properties.contentKeys', 'type': '[StreamingLocatorContentKey]'},
        'alternative_media_id': {'key': 'properties.alternativeMediaId', 'type': 'str'},
        'filters': {'key': 'properties.filters', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        asset_name: Optional[str] = None,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        streaming_locator_id: Optional[str] = None,
        streaming_policy_name: Optional[str] = None,
        default_content_key_policy_name: Optional[str] = None,
        content_keys: Optional[List["StreamingLocatorContentKey"]] = None,
        alternative_media_id: Optional[str] = None,
        filters: Optional[List[str]] = None,
        **kwargs
    ):
        super(StreamingLocator, self).__init__(**kwargs)
        self.system_data = None
        self.asset_name = asset_name
        self.created = None
        self.start_time = start_time
        self.end_time = end_time
        self.streaming_locator_id = streaming_locator_id
        self.streaming_policy_name = streaming_policy_name
        self.default_content_key_policy_name = default_content_key_policy_name
        self.content_keys = content_keys
        self.alternative_media_id = alternative_media_id
        self.filters = filters


class StreamingLocatorCollection(msrest.serialization.Model):
    """A collection of StreamingLocator items.

    :param value: A collection of StreamingLocator items.
    :type value: list[~azure.mgmt.media.models.StreamingLocator]
    :param odata_next_link: A link to the next page of the collection (when the collection contains
     too many results to return in one response).
    :type odata_next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[StreamingLocator]'},
        'odata_next_link': {'key': '@odata\\.nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["StreamingLocator"]] = None,
        odata_next_link: Optional[str] = None,
        **kwargs
    ):
        super(StreamingLocatorCollection, self).__init__(**kwargs)
        self.value = value
        self.odata_next_link = odata_next_link


class StreamingLocatorContentKey(msrest.serialization.Model):
    """Class for content key in Streaming Locator.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. ID of Content Key.
    :type id: str
    :ivar type: Encryption type of Content Key. Possible values include: "CommonEncryptionCenc",
     "CommonEncryptionCbcs", "EnvelopeEncryption".
    :vartype type: str or ~azure.mgmt.media.models.StreamingLocatorContentKeyType
    :param label_reference_in_streaming_policy: Label of Content Key as specified in the Streaming
     Policy.
    :type label_reference_in_streaming_policy: str
    :param value: Value of Content Key.
    :type value: str
    :ivar policy_name: ContentKeyPolicy used by Content Key.
    :vartype policy_name: str
    :ivar tracks: Tracks which use this Content Key.
    :vartype tracks: list[~azure.mgmt.media.models.TrackSelection]
    """

    _validation = {
        'id': {'required': True},
        'type': {'readonly': True},
        'policy_name': {'readonly': True},
        'tracks': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'label_reference_in_streaming_policy': {'key': 'labelReferenceInStreamingPolicy', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
        'policy_name': {'key': 'policyName', 'type': 'str'},
        'tracks': {'key': 'tracks', 'type': '[TrackSelection]'},
    }

    def __init__(
        self,
        *,
        id: str,
        label_reference_in_streaming_policy: Optional[str] = None,
        value: Optional[str] = None,
        **kwargs
    ):
        super(StreamingLocatorContentKey, self).__init__(**kwargs)
        self.id = id
        self.type = None
        self.label_reference_in_streaming_policy = label_reference_in_streaming_policy
        self.value = value
        self.policy_name = None
        self.tracks = None


class StreamingPath(msrest.serialization.Model):
    """Class of paths for streaming.

    All required parameters must be populated in order to send to Azure.

    :param streaming_protocol: Required. Streaming protocol. Possible values include: "Hls",
     "Dash", "SmoothStreaming", "Download".
    :type streaming_protocol: str or ~azure.mgmt.media.models.StreamingPolicyStreamingProtocol
    :param encryption_scheme: Required. Encryption scheme. Possible values include: "NoEncryption",
     "EnvelopeEncryption", "CommonEncryptionCenc", "CommonEncryptionCbcs".
    :type encryption_scheme: str or ~azure.mgmt.media.models.EncryptionScheme
    :param paths: Streaming paths for each protocol and encryptionScheme pair.
    :type paths: list[str]
    """

    _validation = {
        'streaming_protocol': {'required': True},
        'encryption_scheme': {'required': True},
    }

    _attribute_map = {
        'streaming_protocol': {'key': 'streamingProtocol', 'type': 'str'},
        'encryption_scheme': {'key': 'encryptionScheme', 'type': 'str'},
        'paths': {'key': 'paths', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        streaming_protocol: Union[str, "StreamingPolicyStreamingProtocol"],
        encryption_scheme: Union[str, "EncryptionScheme"],
        paths: Optional[List[str]] = None,
        **kwargs
    ):
        super(StreamingPath, self).__init__(**kwargs)
        self.streaming_protocol = streaming_protocol
        self.encryption_scheme = encryption_scheme
        self.paths = paths


class StreamingPolicy(ProxyResource):
    """A Streaming Policy resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: The system metadata relating to this resource.
    :vartype system_data: ~azure.mgmt.media.models.SystemData
    :ivar created: Creation time of Streaming Policy.
    :vartype created: ~datetime.datetime
    :param default_content_key_policy_name: Default ContentKey used by current Streaming Policy.
    :type default_content_key_policy_name: str
    :param envelope_encryption: Configuration of EnvelopeEncryption.
    :type envelope_encryption: ~azure.mgmt.media.models.EnvelopeEncryption
    :param common_encryption_cenc: Configuration of CommonEncryptionCenc.
    :type common_encryption_cenc: ~azure.mgmt.media.models.CommonEncryptionCenc
    :param common_encryption_cbcs: Configuration of CommonEncryptionCbcs.
    :type common_encryption_cbcs: ~azure.mgmt.media.models.CommonEncryptionCbcs
    :param no_encryption: Configurations of NoEncryption.
    :type no_encryption: ~azure.mgmt.media.models.NoEncryption
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'system_data': {'readonly': True},
        'created': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'created': {'key': 'properties.created', 'type': 'iso-8601'},
        'default_content_key_policy_name': {'key': 'properties.defaultContentKeyPolicyName', 'type': 'str'},
        'envelope_encryption': {'key': 'properties.envelopeEncryption', 'type': 'EnvelopeEncryption'},
        'common_encryption_cenc': {'key': 'properties.commonEncryptionCenc', 'type': 'CommonEncryptionCenc'},
        'common_encryption_cbcs': {'key': 'properties.commonEncryptionCbcs', 'type': 'CommonEncryptionCbcs'},
        'no_encryption': {'key': 'properties.noEncryption', 'type': 'NoEncryption'},
    }

    def __init__(
        self,
        *,
        default_content_key_policy_name: Optional[str] = None,
        envelope_encryption: Optional["EnvelopeEncryption"] = None,
        common_encryption_cenc: Optional["CommonEncryptionCenc"] = None,
        common_encryption_cbcs: Optional["CommonEncryptionCbcs"] = None,
        no_encryption: Optional["NoEncryption"] = None,
        **kwargs
    ):
        super(StreamingPolicy, self).__init__(**kwargs)
        self.system_data = None
        self.created = None
        self.default_content_key_policy_name = default_content_key_policy_name
        self.envelope_encryption = envelope_encryption
        self.common_encryption_cenc = common_encryption_cenc
        self.common_encryption_cbcs = common_encryption_cbcs
        self.no_encryption = no_encryption


class StreamingPolicyCollection(msrest.serialization.Model):
    """A collection of StreamingPolicy items.

    :param value: A collection of StreamingPolicy items.
    :type value: list[~azure.mgmt.media.models.StreamingPolicy]
    :param odata_next_link: A link to the next page of the collection (when the collection contains
     too many results to return in one response).
    :type odata_next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[StreamingPolicy]'},
        'odata_next_link': {'key': '@odata\\.nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["StreamingPolicy"]] = None,
        odata_next_link: Optional[str] = None,
        **kwargs
    ):
        super(StreamingPolicyCollection, self).__init__(**kwargs)
        self.value = value
        self.odata_next_link = odata_next_link


class StreamingPolicyContentKey(msrest.serialization.Model):
    """Class to specify properties of content key.

    :param label: Label can be used to specify Content Key when creating a Streaming Locator.
    :type label: str
    :param policy_name: Policy used by Content Key.
    :type policy_name: str
    :param tracks: Tracks which use this content key.
    :type tracks: list[~azure.mgmt.media.models.TrackSelection]
    """

    _attribute_map = {
        'label': {'key': 'label', 'type': 'str'},
        'policy_name': {'key': 'policyName', 'type': 'str'},
        'tracks': {'key': 'tracks', 'type': '[TrackSelection]'},
    }

    def __init__(
        self,
        *,
        label: Optional[str] = None,
        policy_name: Optional[str] = None,
        tracks: Optional[List["TrackSelection"]] = None,
        **kwargs
    ):
        super(StreamingPolicyContentKey, self).__init__(**kwargs)
        self.label = label
        self.policy_name = policy_name
        self.tracks = tracks


class StreamingPolicyContentKeys(msrest.serialization.Model):
    """Class to specify properties of all content keys in Streaming Policy.

    :param default_key: Default content key for an encryption scheme.
    :type default_key: ~azure.mgmt.media.models.DefaultKey
    :param key_to_track_mappings: Representing tracks needs separate content key.
    :type key_to_track_mappings: list[~azure.mgmt.media.models.StreamingPolicyContentKey]
    """

    _attribute_map = {
        'default_key': {'key': 'defaultKey', 'type': 'DefaultKey'},
        'key_to_track_mappings': {'key': 'keyToTrackMappings', 'type': '[StreamingPolicyContentKey]'},
    }

    def __init__(
        self,
        *,
        default_key: Optional["DefaultKey"] = None,
        key_to_track_mappings: Optional[List["StreamingPolicyContentKey"]] = None,
        **kwargs
    ):
        super(StreamingPolicyContentKeys, self).__init__(**kwargs)
        self.default_key = default_key
        self.key_to_track_mappings = key_to_track_mappings


class StreamingPolicyFairPlayConfiguration(msrest.serialization.Model):
    """Class to specify configurations of FairPlay in Streaming Policy.

    All required parameters must be populated in order to send to Azure.

    :param custom_license_acquisition_url_template: Template for the URL of the custom service
     delivering licenses to end user players.  Not required when using Azure Media Services for
     issuing licenses.  The template supports replaceable tokens that the service will update at
     runtime with the value specific to the request.  The currently supported token values are
     {AlternativeMediaId}, which is replaced with the value of
     StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of
     identifier of the key being requested.
    :type custom_license_acquisition_url_template: str
    :param allow_persistent_license: Required. All license to be persistent or not.
    :type allow_persistent_license: bool
    """

    _validation = {
        'allow_persistent_license': {'required': True},
    }

    _attribute_map = {
        'custom_license_acquisition_url_template': {'key': 'customLicenseAcquisitionUrlTemplate', 'type': 'str'},
        'allow_persistent_license': {'key': 'allowPersistentLicense', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        allow_persistent_license: bool,
        custom_license_acquisition_url_template: Optional[str] = None,
        **kwargs
    ):
        super(StreamingPolicyFairPlayConfiguration, self).__init__(**kwargs)
        self.custom_license_acquisition_url_template = custom_license_acquisition_url_template
        self.allow_persistent_license = allow_persistent_license


class StreamingPolicyPlayReadyConfiguration(msrest.serialization.Model):
    """Class to specify configurations of PlayReady in Streaming Policy.

    :param custom_license_acquisition_url_template: Template for the URL of the custom service
     delivering licenses to end user players.  Not required when using Azure Media Services for
     issuing licenses.  The template supports replaceable tokens that the service will update at
     runtime with the value specific to the request.  The currently supported token values are
     {AlternativeMediaId}, which is replaced with the value of
     StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of
     identifier of the key being requested.
    :type custom_license_acquisition_url_template: str
    :param play_ready_custom_attributes: Custom attributes for PlayReady.
    :type play_ready_custom_attributes: str
    """

    _attribute_map = {
        'custom_license_acquisition_url_template': {'key': 'customLicenseAcquisitionUrlTemplate', 'type': 'str'},
        'play_ready_custom_attributes': {'key': 'playReadyCustomAttributes', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        custom_license_acquisition_url_template: Optional[str] = None,
        play_ready_custom_attributes: Optional[str] = None,
        **kwargs
    ):
        super(StreamingPolicyPlayReadyConfiguration, self).__init__(**kwargs)
        self.custom_license_acquisition_url_template = custom_license_acquisition_url_template
        self.play_ready_custom_attributes = play_ready_custom_attributes


class StreamingPolicyWidevineConfiguration(msrest.serialization.Model):
    """Class to specify configurations of Widevine in Streaming Policy.

    :param custom_license_acquisition_url_template: Template for the URL of the custom service
     delivering licenses to end user players.  Not required when using Azure Media Services for
     issuing licenses.  The template supports replaceable tokens that the service will update at
     runtime with the value specific to the request.  The currently supported token values are
     {AlternativeMediaId}, which is replaced with the value of
     StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of
     identifier of the key being requested.
    :type custom_license_acquisition_url_template: str
    """

    _attribute_map = {
        'custom_license_acquisition_url_template': {'key': 'customLicenseAcquisitionUrlTemplate', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        custom_license_acquisition_url_template: Optional[str] = None,
        **kwargs
    ):
        super(StreamingPolicyWidevineConfiguration, self).__init__(**kwargs)
        self.custom_license_acquisition_url_template = custom_license_acquisition_url_template


class SyncStorageKeysInput(msrest.serialization.Model):
    """The input to the sync storage keys request.

    :param id: The ID of the storage account resource.
    :type id: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        **kwargs
    ):
        super(SyncStorageKeysInput, self).__init__(**kwargs)
        self.id = id


class SystemData(msrest.serialization.Model):
    """Metadata pertaining to creation and last modification of the resource.

    :param created_by: The identity that created the resource.
    :type created_by: str
    :param created_by_type: The type of identity that created the resource. Possible values
     include: "User", "Application", "ManagedIdentity", "Key".
    :type created_by_type: str or ~azure.mgmt.media.models.CreatedByType
    :param created_at: The timestamp of resource creation (UTC).
    :type created_at: ~datetime.datetime
    :param last_modified_by: The identity that last modified the resource.
    :type last_modified_by: str
    :param last_modified_by_type: The type of identity that last modified the resource. Possible
     values include: "User", "Application", "ManagedIdentity", "Key".
    :type last_modified_by_type: str or ~azure.mgmt.media.models.CreatedByType
    :param last_modified_at: The timestamp of resource last modification (UTC).
    :type last_modified_at: ~datetime.datetime
    """

    _attribute_map = {
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'created_by_type': {'key': 'createdByType', 'type': 'str'},
        'created_at': {'key': 'createdAt', 'type': 'iso-8601'},
        'last_modified_by': {'key': 'lastModifiedBy', 'type': 'str'},
        'last_modified_by_type': {'key': 'lastModifiedByType', 'type': 'str'},
        'last_modified_at': {'key': 'lastModifiedAt', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        created_by: Optional[str] = None,
        created_by_type: Optional[Union[str, "CreatedByType"]] = None,
        created_at: Optional[datetime.datetime] = None,
        last_modified_by: Optional[str] = None,
        last_modified_by_type: Optional[Union[str, "CreatedByType"]] = None,
        last_modified_at: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(SystemData, self).__init__(**kwargs)
        self.created_by = created_by
        self.created_by_type = created_by_type
        self.created_at = created_at
        self.last_modified_by = last_modified_by
        self.last_modified_by_type = last_modified_by_type
        self.last_modified_at = last_modified_at


class TrackPropertyCondition(msrest.serialization.Model):
    """Class to specify one track property condition.

    All required parameters must be populated in order to send to Azure.

    :param property: Required. Track property type. Possible values include: "Unknown", "FourCC".
    :type property: str or ~azure.mgmt.media.models.TrackPropertyType
    :param operation: Required. Track property condition operation. Possible values include:
     "Unknown", "Equal".
    :type operation: str or ~azure.mgmt.media.models.TrackPropertyCompareOperation
    :param value: Track property value.
    :type value: str
    """

    _validation = {
        'property': {'required': True},
        'operation': {'required': True},
    }

    _attribute_map = {
        'property': {'key': 'property', 'type': 'str'},
        'operation': {'key': 'operation', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        property: Union[str, "TrackPropertyType"],
        operation: Union[str, "TrackPropertyCompareOperation"],
        value: Optional[str] = None,
        **kwargs
    ):
        super(TrackPropertyCondition, self).__init__(**kwargs)
        self.property = property
        self.operation = operation
        self.value = value


class TrackSelection(msrest.serialization.Model):
    """Class to select a track.

    :param track_selections: TrackSelections is a track property condition list which can specify
     track(s).
    :type track_selections: list[~azure.mgmt.media.models.TrackPropertyCondition]
    """

    _attribute_map = {
        'track_selections': {'key': 'trackSelections', 'type': '[TrackPropertyCondition]'},
    }

    def __init__(
        self,
        *,
        track_selections: Optional[List["TrackPropertyCondition"]] = None,
        **kwargs
    ):
        super(TrackSelection, self).__init__(**kwargs)
        self.track_selections = track_selections


class UserAssignedManagedIdentity(msrest.serialization.Model):
    """UserAssignedManagedIdentity.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar client_id: The client ID.
    :vartype client_id: str
    :ivar principal_id: The principal ID.
    :vartype principal_id: str
    """

    _validation = {
        'client_id': {'readonly': True},
        'principal_id': {'readonly': True},
    }

    _attribute_map = {
        'client_id': {'key': 'clientId', 'type': 'str'},
        'principal_id': {'key': 'principalId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(UserAssignedManagedIdentity, self).__init__(**kwargs)
        self.client_id = None
        self.principal_id = None
