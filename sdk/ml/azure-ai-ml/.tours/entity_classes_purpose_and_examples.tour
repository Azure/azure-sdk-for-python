{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "entity_classes_purpose_and_examples",
  "steps": [
    {
      "directory": "sdk/ml/azure-ai-ml/azure/ai/ml/entities",
      "description": "This tour covers the various classes located within the entity directory. These entity classes are local representations of various AML resources, and serve multiple functions to simplify the user experience of handling resources. We will examine JobSchedule class and its related code in order to showcase the typical features and expectations of entity classes.",
      "title": "Introduction"
    },
    {
      "file": "sdk/ml/azure-ai-ml/azure/ai/ml/entities/__init__.py",
      "description": "Entity classes are one of the publicized features of the AML SDK. New classes usually ought to be included here, in the entity \\_\\_init\\_\\_.py file.",
      "line": 109,
      "title": "Entity Publicity"
    },
    {
      "file": "sdk/ml/azure-ai-ml/azure/ai/ml/entities/_schedule/schedule.py",
      "description": "This is the JobSchedule entity class. All top-level entity classes inherit the Resource base class, although they can also inherit other mixins depending on additional circumstances that outside the scope of this overview. The key takeaway is to know that for any resource that exists in Azure, there's probably a corresponding class here, assuming it's supported by the SDK.",
      "line": 31,
      "title": "Example Class: JobSchedule"
    },
    {
      "file": "sdk/ml/azure-ai-ml/azure/ai/ml/entities/_schedule/schedule.py",
      "description": "One of the most important features of entity classes is their ability to convert themselves to and from their corresponding autorest representations. Notice the `RestSchedule` typehint in the `_from_rest_object` function. That is the autorest equivalent of a JobSchedule, which this function consumes in order to produce a JobSchedule entity class.\n\nAt a glance, this might seem like a tedious level of redirection - after all, why can we not just use the Autorest classes directly? There are multiple reasons for that:\n\n - Implementing our own entity classes gives us much a more stable user-facing API, and which isn't subject to shifting if other teams modify the API's we're building off of.\n - Sometimes, we explicitly want to deviate from the API representation of a resource to achieve various user-friendly tradeoffs. Examples include hiding in-development faetures that we don't want users easily playing with, simplifying the representation of features to prevent users from easily mis-configuring resources, or simply hiding the awkward structure of the API object.",
      "line": 210,
      "title": "Critical feature: _from_rest_object"
    },
    {
      "file": "sdk/ml/azure-ai-ml/azure/ai/ml/entities/_schedule/schedule.py",
      "description": "This is the opposite of the `_from_rest_object` function. It produces a corresponding API-compatible object from the current entity.\n\nThese two functions both beg a question - where are they actually used?",
      "line": 248,
      "title": "Critical Feature: _to_rest_object"
    },
    {
      "directory": "sdk/ml/azure-ai-ml/azure/ai/ml/operations",
      "description": "The API conversion steps are generally used by the files in the operations directory. These \\<resource\\>_operations files contain the actual logic to make and process requests from the Azure API.",
      "title": "Related DIrectory: Operations"
    },
    {
      "file": "sdk/ml/azure-ai-ml/azure/ai/ml/operations/_schedule_operations.py",
      "description": "This is the ScheduleOperations class. It contains functions related to the JobSchedule entity class that we were just looking at. This tour isn't going to dive into the details of how these operation classes themselves are used - just know that this is where the user-implemented API interactions happen.",
      "line": 32,
      "title": "ScheduleOperations"
    },
    {
      "file": "sdk/ml/azure-ai-ml/azure/ai/ml/operations/_schedule_operations.py",
      "description": "Here is `begin_create_or_update` operation, which creates a JobSchedule resource in Azure. Notice how it calls `to_rest_object` on the inputted `schedule` field, then supplies the resulting `schedule_data` to the autorest operation (`self.service_client_begin_create_or_update`). The `cls` arg then processes the response, which uses `JobSchedule._from_rest_object(obj)` to convert the returned value back into a local JobSchedule object.",
      "line": 160,
      "selection": {
        "start": {
          "line": 178,
          "character": 9
        },
        "end": {
          "line": 178,
          "character": 22
        }
      },
      "title": "Example Operation"
    },
    {
      "file": "sdk/ml/azure-ai-ml/azure/ai/ml/entities/_schedule/schedule.py",
      "description": "Another important feature of Entity Classes is their ability to be loaded to and from YAML. This is largely achieved by a separete set of classes call Schema Classes, but those classes need some plugin-points in their corresponding entity classes. Namely, the `_load` and `dump` functions (dump is lower in this file). These functions are mostly boilerplate, but you should still be aware of them. They sometimes contain custom logic to help convert between an entity class and its corresponding schema class if they differ.",
      "line": 93,
      "title": "Critical Features: _load and dump"
    },
    {
      "file": "sdk/ml/azure-ai-ml/azure/ai/ml/_schema/schedule/schedule.py",
      "description": "For reference, here is the corresponding Schema Class for the JobSchedule entity class we've been examining. This is just for reference - this tour will not be doing a deep dive into how Schema Classes work.",
      "line": 17,
      "title": "Schema Class"
    },
    {
      "file": "sdk/ml/azure-ai-ml/tests/schedule/unittests/test_schedule_entity.py",
      "description": "Entity Classes ought to have a set of unit tests devoted to them, especially their to/from rest logic, and any resource-specific logic they may contain.",
      "line": 17,
      "title": "Testing"
    },
    {
      "directory": "sdk/ml/azure-ai-ml/azure/ai/ml/entities",
      "description": "That concludes the code tour of the AML entity classes. Remember the key takeaways.\n\n- Entity classes serve as local representations of objects. They can be created by users directly via the SDK, or are implicitly created by CLI users when calling relevant commands.\n- Entity classes serve as a bridge between users and the REST API implementation of the objects they're working with. This keeps things stable for us developers, and allows us to present users with an easier-to-use object than what the REST objects tend to be.\n- Entity classes are also linked to Schema Classes to help betwen converting entity objects to and from YAML.\n- Entity classes are common inputs/outputs of their corresponding operation functions. This is also where their rest/conversion functions are used.\n- Entity classes should have a unit test file dedicated to them.\n\nIf you'd like to learn more about entity classes or related systems, consider walking through the following code tours:\n- TODO: reference schema classes code tour when it exists.\n- TODO: reference autorest code tour when it exists\n- TODO: reference entity class edge cases code tour when it exists. ",
      "title": "Conclusion"
    }
  ]
}