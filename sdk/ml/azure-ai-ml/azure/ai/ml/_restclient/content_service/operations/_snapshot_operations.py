# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import TYPE_CHECKING

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.mgmt.core.exceptions import ARMErrorFormat
from msrest import Serializer

from .. import models as _models
from .._vendor import _convert_request, _format_url_section

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, List, Optional, TypeVar
    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False
# fmt: off

def build_get_sas_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    snapshot_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]
    account_name = kwargs.pop('account_name', None)  # type: Optional[str]
    path = kwargs.pop('path', None)  # type: Optional[str]
    duration = kwargs.pop('duration', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/sas")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
        "snapshotId": _SERIALIZER.url("snapshot_id", snapshot_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')
    if account_name is not None:
        _query_parameters['accountName'] = _SERIALIZER.query("account_name", account_name, 'str')
    if path is not None:
        _query_parameters['path'] = _SERIALIZER.query("path", path, 'str')
    if duration is not None:
        _query_parameters['duration'] = _SERIALIZER.query("duration", duration, 'str')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_get_storageurls_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    snapshot_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]
    account_name = kwargs.pop('account_name', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/storageurls")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
        "snapshotId": _SERIALIZER.url("snapshot_id", snapshot_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')
    if account_name is not None:
        _query_parameters['accountName'] = _SERIALIZER.query("account_name", account_name, 'str')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_get_latest_metadata_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]
    account_name = kwargs.pop('account_name', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/latest/metadata")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')
    if account_name is not None:
        _query_parameters['accountName'] = _SERIALIZER.query("account_name", account_name, 'str')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_get_diff_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]
    snapshot_id1 = kwargs.pop('snapshot_id1', None)  # type: Optional[str]
    snapshot_id2 = kwargs.pop('snapshot_id2', None)  # type: Optional[str]
    account_name = kwargs.pop('account_name', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/diff")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')
    if snapshot_id1 is not None:
        _query_parameters['snapshotId1'] = _SERIALIZER.query("snapshot_id1", snapshot_id1, 'str')
    if snapshot_id2 is not None:
        _query_parameters['snapshotId2'] = _SERIALIZER.query("snapshot_id2", snapshot_id2, 'str')
    if account_name is not None:
        _query_parameters['accountName'] = _SERIALIZER.query("account_name", account_name, 'str')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_create_diff_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]
    parent_snapshot_id = kwargs.pop('parent_snapshot_id', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/diff")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')
    if parent_snapshot_id is not None:
        _query_parameters['parentSnapshotId'] = _SERIALIZER.query("parent_snapshot_id", parent_snapshot_id, 'str')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        _header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_get_metadata_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    snapshot_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]
    account_name = kwargs.pop('account_name', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/metadata")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
        "snapshotId": _SERIALIZER.url("snapshot_id", snapshot_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')
    if account_name is not None:
        _query_parameters['accountName'] = _SERIALIZER.query("account_name", account_name, 'str')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_delete_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    snapshot_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]
    delete_latest_snapshot_pointer = kwargs.pop('delete_latest_snapshot_pointer', None)  # type: Optional[bool]
    account_name = kwargs.pop('account_name', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
        "snapshotId": _SERIALIZER.url("snapshot_id", snapshot_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')
    if delete_latest_snapshot_pointer is not None:
        _query_parameters['deleteLatestSnapshotPointer'] = _SERIALIZER.query("delete_latest_snapshot_pointer", delete_latest_snapshot_pointer, 'bool')
    if account_name is not None:
        _query_parameters['accountName'] = _SERIALIZER.query("account_name", account_name, 'str')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_bulk_delete_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/bulkdelete")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        _header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_create_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    snapshot_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
        "snapshotId": _SERIALIZER.url("snapshot_id", snapshot_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        _header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_create_or_update_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    snapshot_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "snapshotId": _SERIALIZER.url("snapshot_id", snapshot_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        _header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=_url,
        headers=_header_parameters,
        **kwargs
    )


def build_create_or_update_by_name_and_version_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    name,  # type: str
    version,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{name}/versions/{version}")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "name": _SERIALIZER.url("name", name, 'str'),
        "version": _SERIALIZER.url("version", version, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        _header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=_url,
        headers=_header_parameters,
        **kwargs
    )


def build_delete_by_name_and_version_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    name,  # type: str
    version,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{name}/versions/{version}")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "name": _SERIALIZER.url("name", name, 'str'),
        "version": _SERIALIZER.url("version", version, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_header_parameters,
        **kwargs
    )


def build_get_blob_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/getblob")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        _header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_header_parameters,
        **kwargs
    )


def build_get_metadata_with_credentials_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    snapshot_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/metadataWithCredentials")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
        "snapshotId": _SERIALIZER.url("snapshot_id", snapshot_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_create_metadata_with_credentials_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/metadataWithCredentials")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        _header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_create_uri_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    snapshot_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/uri/{snapshotId}")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "snapshotId": _SERIALIZER.url("snapshot_id", snapshot_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        _header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_header_parameters,
        **kwargs
    )


def build_create_or_update_uri_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/uri")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        _header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=_url,
        headers=_header_parameters,
        **kwargs
    )


def build_create_sas_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]
    account_name = kwargs.pop('account_name', None)  # type: Optional[str]
    duration = kwargs.pop('duration', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/sas")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')
    if account_name is not None:
        _query_parameters['accountName'] = _SERIALIZER.query("account_name", account_name, 'str')
    if duration is not None:
        _query_parameters['duration'] = _SERIALIZER.query("duration", duration, 'str')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        _header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )


def build_get_by_hash_request(
    subscription_id,  # type: str
    resource_group_name,  # type: str
    workspace_name,  # type: str
    workspace_name1,  # type: str
    subscription_id1,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    workspace_id = kwargs.pop('workspace_id', None)  # type: Optional[str]
    resource_group = kwargs.pop('resource_group', None)  # type: Optional[str]
    workspace_location = kwargs.pop('workspace_location', None)  # type: Optional[str]
    tenant_id = kwargs.pop('tenant_id', None)  # type: Optional[str]
    workspace_properties = kwargs.pop('workspace_properties', None)  # type: Optional[Dict[str, str]]
    tags = kwargs.pop('tags', None)  # type: Optional[Dict[str, str]]
    hash = kwargs.pop('hash', None)  # type: Optional[str]
    hash_version = kwargs.pop('hash_version', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    _url = kwargs.pop("template_url", "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/getByHash")  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, 'str'),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, 'str'),
        "workspaceName": _SERIALIZER.url("workspace_name", workspace_name, 'str'),
        "WorkspaceName": _SERIALIZER.url("workspace_name1", workspace_name1, 'str'),
        "SubscriptionId": _SERIALIZER.url("subscription_id1", subscription_id1, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if workspace_id is not None:
        _query_parameters['WorkspaceId'] = _SERIALIZER.query("workspace_id", workspace_id, 'str')
    if resource_group is not None:
        _query_parameters['ResourceGroup'] = _SERIALIZER.query("resource_group", resource_group, 'str')
    if workspace_location is not None:
        _query_parameters['WorkspaceLocation'] = _SERIALIZER.query("workspace_location", workspace_location, 'str')
    if tenant_id is not None:
        _query_parameters['TenantId'] = _SERIALIZER.query("tenant_id", tenant_id, 'str')
    if workspace_properties is not None:
        _query_parameters['WorkspaceProperties'] = _SERIALIZER.query("workspace_properties", workspace_properties, '{str}')
    if tags is not None:
        _query_parameters['Tags'] = _SERIALIZER.query("tags", tags, '{str}')
    if hash is not None:
        _query_parameters['hash'] = _SERIALIZER.query("hash", hash, 'str')
    if hash_version is not None:
        _query_parameters['hashVersion'] = _SERIALIZER.query("hash_version", hash_version, 'str')

    # Construct headers
    _header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    _header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_query_parameters,
        headers=_header_parameters,
        **kwargs
    )

# fmt: on
class SnapshotOperations(object):
    """SnapshotOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.mgmt.machinelearningservices.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace
    def get_sas(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        snapshot_id,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        account_name=None,  # type: Optional[str]
        path=None,  # type: Optional[str]
        duration=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.DirTreeNode"
        """get_sas.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id:
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param account_name:
        :type account_name: str
        :param path:
        :type path: str
        :param duration:
        :type duration: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DirTreeNode, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.DirTreeNode
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DirTreeNode"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_sas_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            account_name=account_name,
            path=path,
            duration=duration,
            template_url=self.get_sas.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('DirTreeNode', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_sas.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/sas"}  # type: ignore


    @distributed_trace
    def get_storageurls(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        snapshot_id,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        account_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.DirTreeNode"
        """get_storageurls.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id:
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param account_name:
        :type account_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DirTreeNode, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.DirTreeNode
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DirTreeNode"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_storageurls_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            account_name=account_name,
            template_url=self.get_storageurls.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('DirTreeNode', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_storageurls.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/storageurls"}  # type: ignore


    @distributed_trace
    def get_latest_metadata(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        account_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.Snapshot"
        """get_latest_metadata.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param account_name:
        :type account_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Snapshot, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.Snapshot
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Snapshot"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_latest_metadata_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            account_name=account_name,
            template_url=self.get_latest_metadata.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('Snapshot', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_latest_metadata.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/latest/metadata"}  # type: ignore


    @distributed_trace
    def get_diff(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        snapshot_id1=None,  # type: Optional[str]
        snapshot_id2=None,  # type: Optional[str]
        account_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> List["_models.MerkleDiffEntry"]
        """get_diff.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param snapshot_id1:
        :type snapshot_id1: str
        :param snapshot_id2:
        :type snapshot_id2: str
        :param account_name:
        :type account_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MerkleDiffEntry, or the result of cls(response)
        :rtype: list[~azure.mgmt.machinelearningservices.models.MerkleDiffEntry]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["_models.MerkleDiffEntry"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_diff_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            snapshot_id1=snapshot_id1,
            snapshot_id2=snapshot_id2,
            account_name=account_name,
            template_url=self.get_diff.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MerkleDiffEntry]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_diff.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/diff"}  # type: ignore


    @distributed_trace
    def create_diff(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        parent_snapshot_id=None,  # type: Optional[str]
        body=None,  # type: Optional["_models.FlatDirTreeNodeList"]
        **kwargs  # type: Any
    ):
        # type: (...) -> List["_models.MerkleDiffEntry"]
        """Caller has not computed the file changes locally and is expecting the service to do this.

        Caller has not computed the file changes locally and is expecting the service to do this.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param parent_snapshot_id: Compare to this snapshot.
        :type parent_snapshot_id: str
        :param body: Caller specified list of files (with hashes) and directories.
        :type body: ~azure.mgmt.machinelearningservices.models.FlatDirTreeNodeList
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MerkleDiffEntry, or the result of cls(response)
        :rtype: list[~azure.mgmt.machinelearningservices.models.MerkleDiffEntry]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["_models.MerkleDiffEntry"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'FlatDirTreeNodeList')
        else:
            _json = None

        request = build_create_diff_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            content_type=content_type,
            json=_json,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            parent_snapshot_id=parent_snapshot_id,
            template_url=self.create_diff.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MerkleDiffEntry]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_diff.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/diff"}  # type: ignore


    @distributed_trace
    def get_metadata(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        snapshot_id,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        account_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.Snapshot"
        """get_metadata.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id:
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param account_name:
        :type account_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Snapshot, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.Snapshot
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Snapshot"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_metadata_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            account_name=account_name,
            template_url=self.get_metadata.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('Snapshot', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_metadata.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/metadata"}  # type: ignore


    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        snapshot_id,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        delete_latest_snapshot_pointer=None,  # type: Optional[bool]
        account_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Used to clean up state in test flow. Otherwise
        it will leave snapshots behind.

        Used to clean up state in test flow. Otherwise
        it will leave snapshots behind.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id: snapshotId.
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param delete_latest_snapshot_pointer: deleteLatestSnapshotPointer.
        :type delete_latest_snapshot_pointer: bool
        :param account_name: accountName.
        :type account_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            delete_latest_snapshot_pointer=delete_latest_snapshot_pointer,
            account_name=account_name,
            template_url=self.delete.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}"}  # type: ignore


    @distributed_trace
    def bulk_delete(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        body=None,  # type: Optional["_models.SnapshotList"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete a set of snapshot IDs in bulk.

        Delete a set of snapshot IDs in bulk.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param body: collection of snapshot IDs to delete.
        :type body: ~azure.mgmt.machinelearningservices.models.SnapshotList
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'SnapshotList')
        else:
            _json = None

        request = build_bulk_delete_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            content_type=content_type,
            json=_json,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            template_url=self.bulk_delete.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    bulk_delete.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/bulkdelete"}  # type: ignore


    @distributed_trace
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        snapshot_id,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        body=None,  # type: Optional["_models.CreateSnapshot"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Point in time representation of the user's directory structure, that the files already uploaded
        to blobs.

        Base + diffs are stored on the service to allow for restoration.
        The snapshotId is then used by services to download the files and reproduce the directory
        structure.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id: Caller supplied ID for this snapshot. Expected to be globally unique.
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param body: Caller supplied the snapshot data including the directory tree.
        :type body: ~azure.mgmt.machinelearningservices.models.CreateSnapshot
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'CreateSnapshot')
        else:
            _json = None

        request = build_create_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            content_type=content_type,
            json=_json,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            template_url=self.create.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    create.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}"}  # type: ignore


    @distributed_trace
    def create_or_update(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        snapshot_id,  # type: str
        body=None,  # type: Optional["_models.SnapshotMetadata"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.Snapshot"
        """Update a Snapshot's metadata.

        Update a Snapshot's metadata.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param snapshot_id:
        :type snapshot_id: str
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.SnapshotMetadata
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Snapshot, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.Snapshot
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Snapshot"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'SnapshotMetadata')
        else:
            _json = None

        request = build_create_or_update_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            snapshot_id=snapshot_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_or_update.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('Snapshot', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_or_update.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}"}  # type: ignore


    @distributed_trace
    def create_or_update_by_name_and_version(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        name,  # type: str
        version,  # type: str
        body=None,  # type: Optional["_models.CreateSnapshot"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.ValueTuple2"
        """create_or_update_by_name_and_version.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param name:
        :type name: str
        :param version:
        :type version: str
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.CreateSnapshot
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ValueTuple2, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.ValueTuple2
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ValueTuple2"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'CreateSnapshot')
        else:
            _json = None

        request = build_create_or_update_by_name_and_version_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            name=name,
            version=version,
            content_type=content_type,
            json=_json,
            template_url=self.create_or_update_by_name_and_version.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('ValueTuple2', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_or_update_by_name_and_version.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{name}/versions/{version}"}  # type: ignore


    @distributed_trace
    def delete_by_name_and_version(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        name,  # type: str
        version,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """delete_by_name_and_version.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param name:
        :type name: str
        :param version:
        :type version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_by_name_and_version_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            name=name,
            version=version,
            template_url=self.delete_by_name_and_version.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_by_name_and_version.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{name}/versions/{version}"}  # type: ignore


    @distributed_trace
    def get_blob(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        body=None,  # type: Optional["_models.FileNameList"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.FileNodeList"
        """List of snapshot files to get their blobs Uri.

        List of snapshot files to get their blobs Uri.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param body: Caller supplied file names of the snapshot directory tree.
        :type body: ~azure.mgmt.machinelearningservices.models.FileNameList
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FileNodeList, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.FileNodeList
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FileNodeList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'FileNameList')
        else:
            _json = None

        request = build_get_blob_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            content_type=content_type,
            json=_json,
            template_url=self.get_blob.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if response.status_code == 200:
            deserialized = self._deserialize('FileNodeList', pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize('FileNodeList', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_blob.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/getblob"}  # type: ignore


    @distributed_trace
    def get_metadata_with_credentials(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        snapshot_id,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.SnapshotCredentials"
        """get_metadata_with_credentials.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id:
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SnapshotCredentials, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.SnapshotCredentials
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SnapshotCredentials"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_metadata_with_credentials_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            template_url=self.get_metadata_with_credentials.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('SnapshotCredentials', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_metadata_with_credentials.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/metadataWithCredentials"}  # type: ignore


    @distributed_trace
    def create_metadata_with_credentials(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        body=None,  # type: Optional["_models.SnapshotConsumptionRequest"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.SnapshotCredentials"
        """The API supports the new Asset Store, can be called with snapshot or Asset Id to get metadata.

        The API supports the new Asset Store, can be called with snapshot or Asset Id to get metadata.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.SnapshotConsumptionRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SnapshotCredentials, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.SnapshotCredentials
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SnapshotCredentials"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'SnapshotConsumptionRequest')
        else:
            _json = None

        request = build_create_metadata_with_credentials_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            content_type=content_type,
            json=_json,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            template_url=self.create_metadata_with_credentials.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('SnapshotCredentials', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_metadata_with_credentials.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/metadataWithCredentials"}  # type: ignore


    @distributed_trace
    def create_uri(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        snapshot_id,  # type: str
        body=None,  # type: Optional["_models.CreateSnapshotFromUri"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.Snapshot"
        """Creates a Snapshot from a Uri that points to a folder in blob storage.

        Creates a Snapshot from a Uri that points to a folder in blob storage.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param snapshot_id:
        :type snapshot_id: str
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.CreateSnapshotFromUri
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Snapshot, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.Snapshot
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Snapshot"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'CreateSnapshotFromUri')
        else:
            _json = None

        request = build_create_uri_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            snapshot_id=snapshot_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_uri.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('Snapshot', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_uri.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/uri/{snapshotId}"}  # type: ignore


    @distributed_trace
    def create_or_update_uri(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        body=None,  # type: Optional["_models.CreateSnapshotFromUri"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.ValueTuple2"
        """Create or update a Snapshot from a URI.

        Create or update a Snapshot from a URI.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.CreateSnapshotFromUri
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ValueTuple2, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.ValueTuple2
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ValueTuple2"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'CreateSnapshotFromUri')
        else:
            _json = None

        request = build_create_or_update_uri_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            content_type=content_type,
            json=_json,
            template_url=self.create_or_update_uri.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('ValueTuple2', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_or_update_uri.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/uri"}  # type: ignore


    @distributed_trace
    def create_sas(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        account_name=None,  # type: Optional[str]
        duration=None,  # type: Optional[str]
        body=None,  # type: Optional["_models.SnapshotConsumptionRequest"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.DirTreeNode"
        """The API supports the new Asset Store, can be called with snapshot or Asset Id to get SAS Urls.

        The API supports the new Asset Store, can be called with snapshot or Asset Id to get SAS Urls.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param account_name:
        :type account_name: str
        :param duration:
        :type duration: str
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.SnapshotConsumptionRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DirTreeNode, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.DirTreeNode
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DirTreeNode"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'SnapshotConsumptionRequest')
        else:
            _json = None

        request = build_create_sas_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            content_type=content_type,
            json=_json,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            account_name=account_name,
            duration=duration,
            template_url=self.create_sas.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('DirTreeNode', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_sas.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/sas"}  # type: ignore


    @distributed_trace
    def get_by_hash(
        self,
        subscription_id,  # type: str
        resource_group_name,  # type: str
        workspace_name,  # type: str
        workspace_name1,  # type: str
        subscription_id1,  # type: str
        workspace_id=None,  # type: Optional[str]
        resource_group=None,  # type: Optional[str]
        workspace_location=None,  # type: Optional[str]
        tenant_id=None,  # type: Optional[str]
        workspace_properties=None,  # type: Optional[Dict[str, str]]
        tags=None,  # type: Optional[Dict[str, str]]
        hash=None,  # type: Optional[str]
        hash_version=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.Snapshot"
        """Fetch a snapshot by content hash, if it exists. This would be used to by a client to avoid
        creating
        duplicate snapshots / code assets.

        Fetch a snapshot by content hash, if it exists. This would be used to by a client to avoid
        creating
        duplicate snapshots / code assets.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param hash:
        :type hash: str
        :param hash_version:
        :type hash_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Snapshot, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.Snapshot
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Snapshot"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_by_hash_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            hash=hash,
            hash_version=hash_version,
            template_url=self.get_by_hash.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('Snapshot', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_by_hash.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/getByHash"}  # type: ignore

