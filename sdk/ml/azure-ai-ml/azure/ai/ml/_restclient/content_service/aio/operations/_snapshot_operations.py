# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, List, Optional, TypeVar

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models as _models
from ..._vendor import _convert_request
from ...operations._snapshot_operations import (
    build_bulk_delete_request,
    build_create_diff_request,
    build_create_metadata_with_credentials_request,
    build_create_or_update_by_name_and_version_request,
    build_create_or_update_request,
    build_create_or_update_uri_request,
    build_create_request,
    build_create_sas_request,
    build_create_uri_request,
    build_delete_by_name_and_version_request,
    build_delete_request,
    build_get_blob_request,
    build_get_by_hash_request,
    build_get_diff_request,
    build_get_latest_metadata_request,
    build_get_metadata_request,
    build_get_metadata_with_credentials_request,
    build_get_sas_request,
    build_get_storageurls_request,
)

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class SnapshotOperations:
    """SnapshotOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.mgmt.machinelearningservices.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace_async
    async def get_sas(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        snapshot_id: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        account_name: Optional[str] = None,
        path: Optional[str] = None,
        duration: Optional[str] = None,
        **kwargs: Any
    ) -> "_models.DirTreeNode":
        """get_sas.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id:
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param account_name:
        :type account_name: str
        :param path:
        :type path: str
        :param duration:
        :type duration: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DirTreeNode, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.DirTreeNode
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DirTreeNode"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_sas_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            account_name=account_name,
            path=path,
            duration=duration,
            template_url=self.get_sas.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('DirTreeNode', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_sas.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/sas"}  # type: ignore


    @distributed_trace_async
    async def get_storageurls(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        snapshot_id: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        account_name: Optional[str] = None,
        **kwargs: Any
    ) -> "_models.DirTreeNode":
        """get_storageurls.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id:
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param account_name:
        :type account_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DirTreeNode, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.DirTreeNode
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DirTreeNode"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_storageurls_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            account_name=account_name,
            template_url=self.get_storageurls.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('DirTreeNode', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_storageurls.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/storageurls"}  # type: ignore


    @distributed_trace_async
    async def get_latest_metadata(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        account_name: Optional[str] = None,
        **kwargs: Any
    ) -> "_models.Snapshot":
        """get_latest_metadata.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param account_name:
        :type account_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Snapshot, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.Snapshot
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Snapshot"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_latest_metadata_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            account_name=account_name,
            template_url=self.get_latest_metadata.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('Snapshot', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_latest_metadata.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/latest/metadata"}  # type: ignore


    @distributed_trace_async
    async def get_diff(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        snapshot_id1: Optional[str] = None,
        snapshot_id2: Optional[str] = None,
        account_name: Optional[str] = None,
        **kwargs: Any
    ) -> List["_models.MerkleDiffEntry"]:
        """get_diff.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param snapshot_id1:
        :type snapshot_id1: str
        :param snapshot_id2:
        :type snapshot_id2: str
        :param account_name:
        :type account_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MerkleDiffEntry, or the result of cls(response)
        :rtype: list[~azure.mgmt.machinelearningservices.models.MerkleDiffEntry]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["_models.MerkleDiffEntry"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_diff_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            snapshot_id1=snapshot_id1,
            snapshot_id2=snapshot_id2,
            account_name=account_name,
            template_url=self.get_diff.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MerkleDiffEntry]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_diff.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/diff"}  # type: ignore


    @distributed_trace_async
    async def create_diff(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        parent_snapshot_id: Optional[str] = None,
        body: Optional["_models.FlatDirTreeNodeList"] = None,
        **kwargs: Any
    ) -> List["_models.MerkleDiffEntry"]:
        """Caller has not computed the file changes locally and is expecting the service to do this.

        Caller has not computed the file changes locally and is expecting the service to do this.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param parent_snapshot_id: Compare to this snapshot.
        :type parent_snapshot_id: str
        :param body: Caller specified list of files (with hashes) and directories.
        :type body: ~azure.mgmt.machinelearningservices.models.FlatDirTreeNodeList
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MerkleDiffEntry, or the result of cls(response)
        :rtype: list[~azure.mgmt.machinelearningservices.models.MerkleDiffEntry]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["_models.MerkleDiffEntry"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'FlatDirTreeNodeList')
        else:
            _json = None

        request = build_create_diff_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            content_type=content_type,
            json=_json,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            parent_snapshot_id=parent_snapshot_id,
            template_url=self.create_diff.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MerkleDiffEntry]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_diff.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/diff"}  # type: ignore


    @distributed_trace_async
    async def get_metadata(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        snapshot_id: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        account_name: Optional[str] = None,
        **kwargs: Any
    ) -> "_models.Snapshot":
        """get_metadata.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id:
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param account_name:
        :type account_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Snapshot, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.Snapshot
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Snapshot"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_metadata_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            account_name=account_name,
            template_url=self.get_metadata.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('Snapshot', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_metadata.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/metadata"}  # type: ignore


    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        snapshot_id: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        delete_latest_snapshot_pointer: Optional[bool] = None,
        account_name: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Used to clean up state in test flow. Otherwise
        it will leave snapshots behind.

        Used to clean up state in test flow. Otherwise
        it will leave snapshots behind.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id: snapshotId.
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param delete_latest_snapshot_pointer: deleteLatestSnapshotPointer.
        :type delete_latest_snapshot_pointer: bool
        :param account_name: accountName.
        :type account_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            delete_latest_snapshot_pointer=delete_latest_snapshot_pointer,
            account_name=account_name,
            template_url=self.delete.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}"}  # type: ignore


    @distributed_trace_async
    async def bulk_delete(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        body: Optional["_models.SnapshotList"] = None,
        **kwargs: Any
    ) -> None:
        """Delete a set of snapshot IDs in bulk.

        Delete a set of snapshot IDs in bulk.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param body: collection of snapshot IDs to delete.
        :type body: ~azure.mgmt.machinelearningservices.models.SnapshotList
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'SnapshotList')
        else:
            _json = None

        request = build_bulk_delete_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            content_type=content_type,
            json=_json,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            template_url=self.bulk_delete.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    bulk_delete.metadata = {'url': "/content/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/bulkdelete"}  # type: ignore


    @distributed_trace_async
    async def create(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        snapshot_id: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        body: Optional["_models.CreateSnapshot"] = None,
        **kwargs: Any
    ) -> None:
        """Point in time representation of the user's directory structure, that the files already uploaded
        to blobs.

        Base + diffs are stored on the service to allow for restoration.
        The snapshotId is then used by services to download the files and reproduce the directory
        structure.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id: Caller supplied ID for this snapshot. Expected to be globally unique.
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param body: Caller supplied the snapshot data including the directory tree.
        :type body: ~azure.mgmt.machinelearningservices.models.CreateSnapshot
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'CreateSnapshot')
        else:
            _json = None

        request = build_create_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            content_type=content_type,
            json=_json,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            template_url=self.create.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    create.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}"}  # type: ignore


    @distributed_trace_async
    async def create_or_update(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        snapshot_id: str,
        body: Optional["_models.SnapshotMetadata"] = None,
        **kwargs: Any
    ) -> "_models.Snapshot":
        """Update a Snapshot's metadata.

        Update a Snapshot's metadata.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param snapshot_id:
        :type snapshot_id: str
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.SnapshotMetadata
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Snapshot, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.Snapshot
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Snapshot"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'SnapshotMetadata')
        else:
            _json = None

        request = build_create_or_update_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            snapshot_id=snapshot_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_or_update.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('Snapshot', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_or_update.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}"}  # type: ignore


    @distributed_trace_async
    async def create_or_update_by_name_and_version(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        name: str,
        version: str,
        body: Optional["_models.CreateSnapshot"] = None,
        **kwargs: Any
    ) -> "_models.ValueTuple2":
        """create_or_update_by_name_and_version.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param name:
        :type name: str
        :param version:
        :type version: str
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.CreateSnapshot
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ValueTuple2, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.ValueTuple2
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ValueTuple2"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'CreateSnapshot')
        else:
            _json = None

        request = build_create_or_update_by_name_and_version_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            name=name,
            version=version,
            content_type=content_type,
            json=_json,
            template_url=self.create_or_update_by_name_and_version.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('ValueTuple2', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_or_update_by_name_and_version.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{name}/versions/{version}"}  # type: ignore


    @distributed_trace_async
    async def delete_by_name_and_version(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        name: str,
        version: str,
        **kwargs: Any
    ) -> None:
        """delete_by_name_and_version.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param name:
        :type name: str
        :param version:
        :type version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_by_name_and_version_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            name=name,
            version=version,
            template_url=self.delete_by_name_and_version.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_by_name_and_version.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{name}/versions/{version}"}  # type: ignore


    @distributed_trace_async
    async def get_blob(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        body: Optional["_models.FileNameList"] = None,
        **kwargs: Any
    ) -> "_models.FileNodeList":
        """List of snapshot files to get their blobs Uri.

        List of snapshot files to get their blobs Uri.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param body: Caller supplied file names of the snapshot directory tree.
        :type body: ~azure.mgmt.machinelearningservices.models.FileNameList
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FileNodeList, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.FileNodeList
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FileNodeList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'FileNameList')
        else:
            _json = None

        request = build_get_blob_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            content_type=content_type,
            json=_json,
            template_url=self.get_blob.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if response.status_code == 200:
            deserialized = self._deserialize('FileNodeList', pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize('FileNodeList', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_blob.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/getblob"}  # type: ignore


    @distributed_trace_async
    async def get_metadata_with_credentials(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        snapshot_id: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        **kwargs: Any
    ) -> "_models.SnapshotCredentials":
        """get_metadata_with_credentials.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param snapshot_id:
        :type snapshot_id: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SnapshotCredentials, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.SnapshotCredentials
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SnapshotCredentials"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_metadata_with_credentials_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            snapshot_id=snapshot_id,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            template_url=self.get_metadata_with_credentials.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('SnapshotCredentials', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_metadata_with_credentials.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/{snapshotId}/metadataWithCredentials"}  # type: ignore


    @distributed_trace_async
    async def create_metadata_with_credentials(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        body: Optional["_models.SnapshotConsumptionRequest"] = None,
        **kwargs: Any
    ) -> "_models.SnapshotCredentials":
        """The API supports the new Asset Store, can be called with snapshot or Asset Id to get metadata.

        The API supports the new Asset Store, can be called with snapshot or Asset Id to get metadata.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.SnapshotConsumptionRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SnapshotCredentials, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.SnapshotCredentials
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SnapshotCredentials"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'SnapshotConsumptionRequest')
        else:
            _json = None

        request = build_create_metadata_with_credentials_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            content_type=content_type,
            json=_json,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            template_url=self.create_metadata_with_credentials.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('SnapshotCredentials', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_metadata_with_credentials.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/metadataWithCredentials"}  # type: ignore


    @distributed_trace_async
    async def create_uri(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        snapshot_id: str,
        body: Optional["_models.CreateSnapshotFromUri"] = None,
        **kwargs: Any
    ) -> "_models.Snapshot":
        """Creates a Snapshot from a Uri that points to a folder in blob storage.

        Creates a Snapshot from a Uri that points to a folder in blob storage.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param snapshot_id:
        :type snapshot_id: str
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.CreateSnapshotFromUri
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Snapshot, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.Snapshot
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Snapshot"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'CreateSnapshotFromUri')
        else:
            _json = None

        request = build_create_uri_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            snapshot_id=snapshot_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_uri.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('Snapshot', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_uri.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/uri/{snapshotId}"}  # type: ignore


    @distributed_trace_async
    async def create_or_update_uri(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        body: Optional["_models.CreateSnapshotFromUri"] = None,
        **kwargs: Any
    ) -> "_models.ValueTuple2":
        """Create or update a Snapshot from a URI.

        Create or update a Snapshot from a URI.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.CreateSnapshotFromUri
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ValueTuple2, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.ValueTuple2
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ValueTuple2"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'CreateSnapshotFromUri')
        else:
            _json = None

        request = build_create_or_update_uri_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            content_type=content_type,
            json=_json,
            template_url=self.create_or_update_uri.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('ValueTuple2', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_or_update_uri.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/uri"}  # type: ignore


    @distributed_trace_async
    async def create_sas(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        account_name: Optional[str] = None,
        duration: Optional[str] = None,
        body: Optional["_models.SnapshotConsumptionRequest"] = None,
        **kwargs: Any
    ) -> "_models.DirTreeNode":
        """The API supports the new Asset Store, can be called with snapshot or Asset Id to get SAS Urls.

        The API supports the new Asset Store, can be called with snapshot or Asset Id to get SAS Urls.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param account_name:
        :type account_name: str
        :param duration:
        :type duration: str
        :param body:
        :type body: ~azure.mgmt.machinelearningservices.models.SnapshotConsumptionRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DirTreeNode, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.DirTreeNode
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DirTreeNode"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'SnapshotConsumptionRequest')
        else:
            _json = None

        request = build_create_sas_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            content_type=content_type,
            json=_json,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            account_name=account_name,
            duration=duration,
            template_url=self.create_sas.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('DirTreeNode', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_sas.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/sas"}  # type: ignore


    @distributed_trace_async
    async def get_by_hash(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        workspace_name1: str,
        subscription_id1: str,
        workspace_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_location: Optional[str] = None,
        tenant_id: Optional[str] = None,
        workspace_properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        hash: Optional[str] = None,
        hash_version: Optional[str] = None,
        **kwargs: Any
    ) -> "_models.Snapshot":
        """Fetch a snapshot by content hash, if it exists. This would be used to by a client to avoid
        creating
        duplicate snapshots / code assets.

        Fetch a snapshot by content hash, if it exists. This would be used to by a client to avoid
        creating
        duplicate snapshots / code assets.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group_name: The Name of the resource group in which the workspace is located.
        :type resource_group_name: str
        :param workspace_name: The name of the workspace.
        :type workspace_name: str
        :param workspace_name1:
        :type workspace_name1: str
        :param subscription_id1:
        :type subscription_id1: str
        :param workspace_id:
        :type workspace_id: str
        :param resource_group:
        :type resource_group: str
        :param workspace_location:
        :type workspace_location: str
        :param tenant_id:
        :type tenant_id: str
        :param workspace_properties:
        :type workspace_properties: dict[str, str]
        :param tags:
        :type tags: dict[str, str]
        :param hash:
        :type hash: str
        :param hash_version:
        :type hash_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Snapshot, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.Snapshot
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Snapshot"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_by_hash_request(
            subscription_id=subscription_id,
            resource_group_name=resource_group_name,
            workspace_name=workspace_name,
            workspace_name1=workspace_name1,
            subscription_id1=subscription_id1,
            workspace_id=workspace_id,
            resource_group=resource_group,
            workspace_location=workspace_location,
            tenant_id=tenant_id,
            workspace_properties=workspace_properties,
            tags=tags,
            hash=hash,
            hash_version=hash_version,
            template_url=self.get_by_hash.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('Snapshot', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_by_hash.metadata = {'url': "/content/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/snapshots/getByHash"}  # type: ignore

