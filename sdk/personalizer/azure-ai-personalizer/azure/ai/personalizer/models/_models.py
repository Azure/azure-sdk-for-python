# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.1.3, generator: {generator})
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from azure.core.exceptions import HttpResponseError
import msrest.serialization


class ApprenticeLearningMetrics(msrest.serialization.Model):
    """ApprenticeLearningMetrics.

    All required parameters must be populated in order to send to Azure.

    :param number_of_events: Required. Number of Events.
    :type number_of_events: long
    :param sum_of_rewards: Required. Sum of Rewards.
    :type sum_of_rewards: float
    :param number_of_imitated_events: Required. Number of Events where Personalizer predicted
     'Baseline Action'.
    :type number_of_imitated_events: long
    :param sum_of_imitated_rewards: Required. Sum of Rewards for Events where Personalizer
     predicted 'Baseline Action'.
    :type sum_of_imitated_rewards: float
    """

    _validation = {
        'number_of_events': {'required': True},
        'sum_of_rewards': {'required': True},
        'number_of_imitated_events': {'required': True},
        'sum_of_imitated_rewards': {'required': True},
    }

    _attribute_map = {
        'number_of_events': {'key': 'numberOfEvents', 'type': 'long'},
        'sum_of_rewards': {'key': 'sumOfRewards', 'type': 'float'},
        'number_of_imitated_events': {'key': 'numberOfImitatedEvents', 'type': 'long'},
        'sum_of_imitated_rewards': {'key': 'sumOfImitatedRewards', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ApprenticeLearningMetrics, self).__init__(**kwargs)
        self.number_of_events = kwargs['number_of_events']
        self.sum_of_rewards = kwargs['sum_of_rewards']
        self.number_of_imitated_events = kwargs['number_of_imitated_events']
        self.sum_of_imitated_rewards = kwargs['sum_of_imitated_rewards']


class ApprenticeModeMetrics(msrest.serialization.Model):
    """ApprenticeModeMetrics.

    All required parameters must be populated in order to send to Azure.

    :param start_time: Required. Start time.
    :type start_time: ~datetime.datetime
    :param last_processed_event_time: Required. Last processed event time.
    :type last_processed_event_time: ~datetime.datetime
    :param last_batch_metrics: Previous batch of Apprentice Mode metrics.
    :type last_batch_metrics: ~personalizerv11_preview1.models.ApprenticeLearningMetrics
    :param number_of_events: Required. Number of Events.
    :type number_of_events: long
    :param sum_of_rewards: Required. Sum of Rewards.
    :type sum_of_rewards: float
    :param number_of_imitated_events: Required. Number of Events where Personalizer predicted
     'Baseline Action'.
    :type number_of_imitated_events: long
    :param sum_of_imitated_rewards: Required. Sum of Rewards where Personalizer predicted 'Baseline
     Action'.
    :type sum_of_imitated_rewards: float
    """

    _validation = {
        'start_time': {'required': True},
        'last_processed_event_time': {'required': True},
        'number_of_events': {'required': True},
        'sum_of_rewards': {'required': True},
        'number_of_imitated_events': {'required': True},
        'sum_of_imitated_rewards': {'required': True},
    }

    _attribute_map = {
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'last_processed_event_time': {'key': 'lastProcessedEventTime', 'type': 'iso-8601'},
        'last_batch_metrics': {'key': 'lastBatchMetrics', 'type': 'ApprenticeLearningMetrics'},
        'number_of_events': {'key': 'numberOfEvents', 'type': 'long'},
        'sum_of_rewards': {'key': 'sumOfRewards', 'type': 'float'},
        'number_of_imitated_events': {'key': 'numberOfImitatedEvents', 'type': 'long'},
        'sum_of_imitated_rewards': {'key': 'sumOfImitatedRewards', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ApprenticeModeMetrics, self).__init__(**kwargs)
        self.start_time = kwargs['start_time']
        self.last_processed_event_time = kwargs['last_processed_event_time']
        self.last_batch_metrics = kwargs.get('last_batch_metrics', None)
        self.number_of_events = kwargs['number_of_events']
        self.sum_of_rewards = kwargs['sum_of_rewards']
        self.number_of_imitated_events = kwargs['number_of_imitated_events']
        self.sum_of_imitated_rewards = kwargs['sum_of_imitated_rewards']


class DateRange(msrest.serialization.Model):
    """A date range starting at From and ending at To.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar from_property: Start date for the range.
    :vartype from_property: ~datetime.datetime
    :ivar to: End date for the range.
    :vartype to: ~datetime.datetime
    """

    _validation = {
        'from_property': {'readonly': True},
        'to': {'readonly': True},
    }

    _attribute_map = {
        'from_property': {'key': 'from', 'type': 'iso-8601'},
        'to': {'key': 'to', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DateRange, self).__init__(**kwargs)
        self.from_property = None
        self.to = None


class ErrorResponse(msrest.serialization.Model):
    """Used to return an error to the client.

    All required parameters must be populated in order to send to Azure.

    :param error: Required. The error object.
    :type error: ~personalizerv11_preview1.models.PersonalizerError
    """

    _validation = {
        'error': {'required': True},
    }

    _attribute_map = {
        'error': {'key': 'error', 'type': 'PersonalizerError'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ErrorResponse, self).__init__(**kwargs)
        self.error = kwargs['error']


class Evaluation(msrest.serialization.Model):
    """A Counterfactual Evaluation.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The ID of the evaluation.
    :vartype id: str
    :ivar name: The name of the evaluation.
    :vartype name: str
    :ivar start_time: The start time of the evaluation.
    :vartype start_time: ~datetime.datetime
    :ivar end_time: The end time of the evaluation.
    :vartype end_time: ~datetime.datetime
    :ivar job_id: The ID of the job processing the evaluation.
    :vartype job_id: str
    :ivar status: The status of the job processing the evaluation. Possible values include:
     "completed", "pending", "failed", "notSubmitted", "timeout", "optimalPolicyApplied",
     "onlinePolicyRetained".
    :vartype status: str or ~personalizerv11_preview1.models.EvaluationJobStatus
    :param policy_results: The results of the evaluation.
    :type policy_results: list[~personalizerv11_preview1.models.PolicyResult]
    :param feature_importance: Feature Importance.
    :type feature_importance: list[list[str]]
    :param evaluation_type: Evaluation type (manual or through Automatic Optimization). Possible
     values include: "Manual", "Auto".
    :type evaluation_type: str or ~personalizerv11_preview1.models.EvaluationType
    :param optimal_policy: Thr optimal policy.
    :type optimal_policy: str
    :param creation_time: Craetion time.
    :type creation_time: ~datetime.datetime
    """

    _validation = {
        'id': {'readonly': True, 'max_length': 256, 'min_length': 0},
        'name': {'readonly': True, 'max_length': 256, 'min_length': 0},
        'start_time': {'readonly': True},
        'end_time': {'readonly': True},
        'job_id': {'readonly': True},
        'status': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
        'job_id': {'key': 'jobId', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'policy_results': {'key': 'policyResults', 'type': '[PolicyResult]'},
        'feature_importance': {'key': 'featureImportance', 'type': '[[str]]'},
        'evaluation_type': {'key': 'evaluationType', 'type': 'str'},
        'optimal_policy': {'key': 'optimalPolicy', 'type': 'str'},
        'creation_time': {'key': 'creationTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Evaluation, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.start_time = None
        self.end_time = None
        self.job_id = None
        self.status = None
        self.policy_results = kwargs.get('policy_results', None)
        self.feature_importance = kwargs.get('feature_importance', None)
        self.evaluation_type = kwargs.get('evaluation_type', None)
        self.optimal_policy = kwargs.get('optimal_policy', None)
        self.creation_time = kwargs.get('creation_time', None)


class EvaluationContract(msrest.serialization.Model):
    """A counterfactual evaluation.

    All required parameters must be populated in order to send to Azure.

    :param enable_offline_experimentation: True if the evaluation should explore for a more optimal
     learning settings.
    :type enable_offline_experimentation: bool
    :param name: Required. The name of the evaluation.
    :type name: str
    :param start_time: Required. The start time of the evaluation.
    :type start_time: ~datetime.datetime
    :param end_time: Required. The end time of the evaluation.
    :type end_time: ~datetime.datetime
    :param policies: Required. Additional learning settings to evaluate.
    :type policies: list[~personalizerv11_preview1.models.PolicyContract]
    """

    _validation = {
        'name': {'required': True, 'max_length': 256, 'min_length': 0},
        'start_time': {'required': True},
        'end_time': {'required': True},
        'policies': {'required': True},
    }

    _attribute_map = {
        'enable_offline_experimentation': {'key': 'enableOfflineExperimentation', 'type': 'bool'},
        'name': {'key': 'name', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
        'policies': {'key': 'policies', 'type': '[PolicyContract]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(EvaluationContract, self).__init__(**kwargs)
        self.enable_offline_experimentation = kwargs.get('enable_offline_experimentation', None)
        self.name = kwargs['name']
        self.start_time = kwargs['start_time']
        self.end_time = kwargs['end_time']
        self.policies = kwargs['policies']


class InternalError(msrest.serialization.Model):
    """An object containing more specific information than the parent object about the error.

    :param code: Detailed error code.
    :type code: str
    :param innererror: An object containing more specific information than the parent object about
     the error.
    :type innererror: ~personalizerv11_preview1.models.InternalError
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'innererror': {'key': 'innererror', 'type': 'InternalError'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(InternalError, self).__init__(**kwargs)
        self.code = kwargs.get('code', None)
        self.innererror = kwargs.get('innererror', None)


class LogsProperties(msrest.serialization.Model):
    """Properties related to data used to train the model.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar date_range: Date range.
    :vartype date_range: ~personalizerv11_preview1.models.LogsPropertiesDateRange
    """

    _validation = {
        'date_range': {'readonly': True},
    }

    _attribute_map = {
        'date_range': {'key': 'dateRange', 'type': 'LogsPropertiesDateRange'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LogsProperties, self).__init__(**kwargs)
        self.date_range = None


class LogsPropertiesDateRange(DateRange):
    """Date range.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar from_property: Start date for the range.
    :vartype from_property: ~datetime.datetime
    :ivar to: End date for the range.
    :vartype to: ~datetime.datetime
    """

    _validation = {
        'from_property': {'readonly': True},
        'to': {'readonly': True},
    }

    _attribute_map = {
        'from_property': {'key': 'from', 'type': 'iso-8601'},
        'to': {'key': 'to', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LogsPropertiesDateRange, self).__init__(**kwargs)


class ModelProperties(msrest.serialization.Model):
    """Properties related to the trained model.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar creation_time: Creation time of the model.
    :vartype creation_time: ~datetime.datetime
    :ivar last_modified_time: Last time the model was modified.
    :vartype last_modified_time: ~datetime.datetime
    """

    _validation = {
        'creation_time': {'readonly': True},
        'last_modified_time': {'readonly': True},
    }

    _attribute_map = {
        'creation_time': {'key': 'creationTime', 'type': 'iso-8601'},
        'last_modified_time': {'key': 'lastModifiedTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ModelProperties, self).__init__(**kwargs)
        self.creation_time = None
        self.last_modified_time = None


class MultiSlotRankRequest(msrest.serialization.Model):
    """MultiSlotRankRequest.

    All required parameters must be populated in order to send to Azure.

    :param context_features: Features of the context used for Personalizer as a
     dictionary of dictionaries. This is determined by your application, and
     typically includes features about the current user, their
     device, profile information, aggregated data about time and date, etc.
     Features should not include personally identifiable information (PII),
     unique UserIDs, or precise timestamps.
    :type context_features: list[any]
    :param actions: Required. The set of actions the Personalizer service can pick from.
     The set should not contain more than 50 actions.
     The order of the actions does not affect the rank result but the order
     should match the sequence your application would have used to display them.
     The first item in the array will be used as Baseline item in Offline Evaluations.
    :type actions: list[~personalizerv11_preview1.models.RankableAction]
    :param slots: Required. The set of slots the Personalizer service should select actions for.
     The set should not contain more than 50 slots.
    :type slots: list[~personalizerv11_preview1.models.SlotRequest]
    :param event_id: Optionally pass an eventId that uniquely identifies this Rank event.
     If null, the service generates a unique eventId. The eventId will be used for
     associating this request with its reward, as well as seeding the pseudo-random
     generator when making a Personalizer call.
    :type event_id: str
    :param defer_activation: Send false if it is certain the rewardActionId in rank results will be
     shown to the user, therefore
     Personalizer will expect a Reward call, otherwise it will assign the default
     Reward to the event. Send true if it is possible the user will not see the action specified in
     the rank results,
     (e.g. because the page is rendering later, or the Rank results may be overridden by code
     further downstream).
     You must call the Activate Event API if the event output is shown to users, otherwise Rewards
     will be ignored.
    :type defer_activation: bool
    """

    _validation = {
        'actions': {'required': True},
        'slots': {'required': True},
        'event_id': {'max_length': 256, 'min_length': 0},
    }

    _attribute_map = {
        'context_features': {'key': 'contextFeatures', 'type': '[object]'},
        'actions': {'key': 'actions', 'type': '[RankableAction]'},
        'slots': {'key': 'slots', 'type': '[SlotRequest]'},
        'event_id': {'key': 'eventId', 'type': 'str'},
        'defer_activation': {'key': 'deferActivation', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(MultiSlotRankRequest, self).__init__(**kwargs)
        self.context_features = kwargs.get('context_features', None)
        self.actions = kwargs['actions']
        self.slots = kwargs['slots']
        self.event_id = kwargs.get('event_id', None)
        self.defer_activation = kwargs.get('defer_activation', False)


class MultiSlotRankResponse(msrest.serialization.Model):
    """MultiSlotRankResponse.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar slots: Each slot has a corresponding rewardActionID which is the action ID recommended by
     Personalizer.
    :vartype slots: list[~personalizerv11_preview1.models.SlotResponse]
    :ivar event_id: The eventId for the round trip from request to response.
    :vartype event_id: str
    """

    _validation = {
        'slots': {'readonly': True},
        'event_id': {'readonly': True, 'max_length': 256, 'min_length': 0},
    }

    _attribute_map = {
        'slots': {'key': 'slots', 'type': '[SlotResponse]'},
        'event_id': {'key': 'eventId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(MultiSlotRankResponse, self).__init__(**kwargs)
        self.slots = None
        self.event_id = None


class MultiSlotRewardRequest(msrest.serialization.Model):
    """Reward given to a list of slots.

    All required parameters must be populated in order to send to Azure.

    :param reward: Required. List of SlotRewards.
    :type reward: list[~personalizerv11_preview1.models.SlotReward]
    """

    _validation = {
        'reward': {'required': True},
    }

    _attribute_map = {
        'reward': {'key': 'reward', 'type': '[SlotReward]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(MultiSlotRewardRequest, self).__init__(**kwargs)
        self.reward = kwargs['reward']


class PersonalizerError(msrest.serialization.Model):
    """The error object.

    All required parameters must be populated in order to send to Azure.

    :param code: Required. Error Codes returned by Personalizer. Possible values include:
     "BadRequest", "InvalidServiceConfiguration", "InvalidLearningModeServiceConfiguration",
     "InvalidPolicyConfiguration", "InvalidPolicyContract", "InvalidEvaluationContract",
     "DuplicateCustomPolicyNames", "NoLogsExistInDateRange", "LogsSizeExceedAllowedLimit",
     "InvalidRewardRequest", "InvalidEventIdToActivate", "InvalidRankRequest",
     "InvalidExportLogsRequest", "InvalidContainer", "InvalidModelMetadata",
     "ApprenticeModeNeverTurnedOn", "MissingAppId", "InvalidRewardWaitTime",
     "InvalidMultiSlotApiAccess", "ModelFileAccessDenied",
     "ProblemTypeIncompatibleWithAutoOptimization", "ResourceNotFound", "FrontEndNotFound",
     "EvaluationNotFound", "LearningSettingsNotFound", "EvaluationModelNotFound",
     "LogsPropertiesNotFound", "ModelRankingError", "InternalServerError", "RankNullResponse",
     "UpdateConfigurationFailed", "ModelResetFailed", "ModelPublishFailed",
     "ModelMetadataUpdateFailed", "OperationNotAllowed".
    :type code: str or ~personalizerv11_preview1.models.PersonalizerErrorCode
    :param message: Required. A message explaining the error reported by the service.
    :type message: str
    :param target: Error source element.
    :type target: str
    :param details: An array of details about specific errors that led to this reported error.
    :type details: list[~personalizerv11_preview1.models.PersonalizerError]
    :param inner_error: An object containing more specific information than the parent object about
     the error.
    :type inner_error: ~personalizerv11_preview1.models.InternalError
    """

    _validation = {
        'code': {'required': True},
        'message': {'required': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[PersonalizerError]'},
        'inner_error': {'key': 'innerError', 'type': 'InternalError'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PersonalizerError, self).__init__(**kwargs)
        self.code = kwargs['code']
        self.message = kwargs['message']
        self.target = kwargs.get('target', None)
        self.details = kwargs.get('details', None)
        self.inner_error = kwargs.get('inner_error', None)


class PolicyContract(msrest.serialization.Model):
    """Learning settings specifying how to train the model.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. Name of the learning settings.
    :type name: str
    :param arguments: Required. Arguments of the learning settings.
    :type arguments: str
    """

    _validation = {
        'name': {'required': True, 'max_length': 256, 'min_length': 0},
        'arguments': {'required': True, 'max_length': 1024, 'min_length': 0},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'arguments': {'key': 'arguments', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PolicyContract, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.arguments = kwargs['arguments']


class PolicyReferenceContract(msrest.serialization.Model):
    """Reference to the policy within the evaluation.

    All required parameters must be populated in order to send to Azure.

    :param evaluation_id: Required. Evaluation Id of the evaluation.
    :type evaluation_id: str
    :param policy_name: Required. Name of the learning settings.
    :type policy_name: str
    """

    _validation = {
        'evaluation_id': {'required': True, 'max_length': 256, 'min_length': 0},
        'policy_name': {'required': True, 'max_length': 256, 'min_length': 0},
    }

    _attribute_map = {
        'evaluation_id': {'key': 'evaluationId', 'type': 'str'},
        'policy_name': {'key': 'policyName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PolicyReferenceContract, self).__init__(**kwargs)
        self.evaluation_id = kwargs['evaluation_id']
        self.policy_name = kwargs['policy_name']


class PolicyResult(msrest.serialization.Model):
    """This class contains the Learning Settings information and the results of the Offline Evaluation using that policy.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: The name of the Learning Settings.
    :vartype name: str
    :ivar arguments: The arguments of the Learning Settings.
    :vartype arguments: str
    :ivar policy_source: The source of the Learning Settings. Possible values include: "Online",
     "Baseline", "Random", "Custom", "OfflineExperimentation".
    :vartype policy_source: str or ~personalizerv11_preview1.models.PolicySource
    :ivar summary: The aggregate results of the Offline Evaluation.
    :vartype summary: list[~personalizerv11_preview1.models.PolicyResultSummary]
    :ivar total_summary: The aggregate total of the Offline Evaluation.
    :vartype total_summary: ~personalizerv11_preview1.models.PolicyResultTotalSummary
    """

    _validation = {
        'name': {'readonly': True},
        'arguments': {'readonly': True},
        'policy_source': {'readonly': True},
        'summary': {'readonly': True},
        'total_summary': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'arguments': {'key': 'arguments', 'type': 'str'},
        'policy_source': {'key': 'policySource', 'type': 'str'},
        'summary': {'key': 'summary', 'type': '[PolicyResultSummary]'},
        'total_summary': {'key': 'totalSummary', 'type': 'PolicyResultTotalSummary'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PolicyResult, self).__init__(**kwargs)
        self.name = None
        self.arguments = None
        self.policy_source = None
        self.summary = None
        self.total_summary = None


class PolicyResultSummary(msrest.serialization.Model):
    """This class contains the summary of evaluating a policy on a counterfactual evaluation.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar time_stamp: Timestamp of the aggregation.
    :vartype time_stamp: ~datetime.datetime
    :ivar ips_estimator_numerator: Numerator for IPS estimator.
    :vartype ips_estimator_numerator: float
    :ivar ips_estimator_denominator: Denominator for IPS estimator.
    :vartype ips_estimator_denominator: float
    :ivar snips_estimator_denominator: Denominator for SNIPS estimator.
    :vartype snips_estimator_denominator: float
    :ivar aggregate_time_window: Time window for aggregation.
     For example, PT5M (5 mins). For information about the time format,
     see http://en.wikipedia.org/wiki/ISO_8601#Durations.
    :vartype aggregate_time_window: ~datetime.timedelta
    :param non_zero_probability: Probability of non-zero values for the Policy evaluation.
    :type non_zero_probability: float
    :ivar sum_of_squares: Sum of Squares for the Policy evaluation results.
    :vartype sum_of_squares: float
    :ivar confidence_interval: Gaussian confidence interval for the Policy evaluation.
    :vartype confidence_interval: float
    :ivar average_reward: Average reward.
    :vartype average_reward: float
    """

    _validation = {
        'time_stamp': {'readonly': True},
        'ips_estimator_numerator': {'readonly': True},
        'ips_estimator_denominator': {'readonly': True},
        'snips_estimator_denominator': {'readonly': True},
        'aggregate_time_window': {'readonly': True},
        'sum_of_squares': {'readonly': True},
        'confidence_interval': {'readonly': True},
        'average_reward': {'readonly': True},
    }

    _attribute_map = {
        'time_stamp': {'key': 'timeStamp', 'type': 'iso-8601'},
        'ips_estimator_numerator': {'key': 'ipsEstimatorNumerator', 'type': 'float'},
        'ips_estimator_denominator': {'key': 'ipsEstimatorDenominator', 'type': 'float'},
        'snips_estimator_denominator': {'key': 'snipsEstimatorDenominator', 'type': 'float'},
        'aggregate_time_window': {'key': 'aggregateTimeWindow', 'type': 'duration'},
        'non_zero_probability': {'key': 'nonZeroProbability', 'type': 'float'},
        'sum_of_squares': {'key': 'sumOfSquares', 'type': 'float'},
        'confidence_interval': {'key': 'confidenceInterval', 'type': 'float'},
        'average_reward': {'key': 'averageReward', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PolicyResultSummary, self).__init__(**kwargs)
        self.time_stamp = None
        self.ips_estimator_numerator = None
        self.ips_estimator_denominator = None
        self.snips_estimator_denominator = None
        self.aggregate_time_window = None
        self.non_zero_probability = kwargs.get('non_zero_probability', None)
        self.sum_of_squares = None
        self.confidence_interval = None
        self.average_reward = None


class PolicyResultTotalSummary(PolicyResultSummary):
    """The aggregate total of the Offline Evaluation.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar time_stamp: Timestamp of the aggregation.
    :vartype time_stamp: ~datetime.datetime
    :ivar ips_estimator_numerator: Numerator for IPS estimator.
    :vartype ips_estimator_numerator: float
    :ivar ips_estimator_denominator: Denominator for IPS estimator.
    :vartype ips_estimator_denominator: float
    :ivar snips_estimator_denominator: Denominator for SNIPS estimator.
    :vartype snips_estimator_denominator: float
    :ivar aggregate_time_window: Time window for aggregation.
     For example, PT5M (5 mins). For information about the time format,
     see http://en.wikipedia.org/wiki/ISO_8601#Durations.
    :vartype aggregate_time_window: ~datetime.timedelta
    :param non_zero_probability: Probability of non-zero values for the Policy evaluation.
    :type non_zero_probability: float
    :ivar sum_of_squares: Sum of Squares for the Policy evaluation results.
    :vartype sum_of_squares: float
    :ivar confidence_interval: Gaussian confidence interval for the Policy evaluation.
    :vartype confidence_interval: float
    :ivar average_reward: Average reward.
    :vartype average_reward: float
    """

    _validation = {
        'time_stamp': {'readonly': True},
        'ips_estimator_numerator': {'readonly': True},
        'ips_estimator_denominator': {'readonly': True},
        'snips_estimator_denominator': {'readonly': True},
        'aggregate_time_window': {'readonly': True},
        'sum_of_squares': {'readonly': True},
        'confidence_interval': {'readonly': True},
        'average_reward': {'readonly': True},
    }

    _attribute_map = {
        'time_stamp': {'key': 'timeStamp', 'type': 'iso-8601'},
        'ips_estimator_numerator': {'key': 'ipsEstimatorNumerator', 'type': 'float'},
        'ips_estimator_denominator': {'key': 'ipsEstimatorDenominator', 'type': 'float'},
        'snips_estimator_denominator': {'key': 'snipsEstimatorDenominator', 'type': 'float'},
        'aggregate_time_window': {'key': 'aggregateTimeWindow', 'type': 'duration'},
        'non_zero_probability': {'key': 'nonZeroProbability', 'type': 'float'},
        'sum_of_squares': {'key': 'sumOfSquares', 'type': 'float'},
        'confidence_interval': {'key': 'confidenceInterval', 'type': 'float'},
        'average_reward': {'key': 'averageReward', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PolicyResultTotalSummary, self).__init__(**kwargs)


class RankableAction(msrest.serialization.Model):
    """An action with its associated features used for ranking.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. Id of the action.
    :type id: str
    :param features: Required. List of dictionaries containing features.
    :type features: list[any]
    """

    _validation = {
        'id': {'required': True, 'max_length': 256, 'min_length': 0},
        'features': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'features': {'key': 'features', 'type': '[object]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RankableAction, self).__init__(**kwargs)
        self.id = kwargs['id']
        self.features = kwargs['features']


class RankedAction(msrest.serialization.Model):
    """A ranked action with its resulting probability.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Id of the action.
    :vartype id: str
    :ivar probability: Probability of the action.
    :vartype probability: float
    """

    _validation = {
        'id': {'readonly': True, 'max_length': 256, 'min_length': 0},
        'probability': {'readonly': True, 'maximum': 1, 'minimum': 0},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'probability': {'key': 'probability', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RankedAction, self).__init__(**kwargs)
        self.id = None
        self.probability = None


class RankRequest(msrest.serialization.Model):
    """Request a set of actions to be ranked by the Personalizer service.

    All required parameters must be populated in order to send to Azure.

    :param context_features: Features of the context used for Personalizer as a
     dictionary of dictionaries. This is determined by your application, and
     typically includes features about the current user, their
     device, profile information, aggregated data about time and date, etc.
     Features should not include personally identifiable information (PII),
     unique UserIDs, or precise timestamps.
    :type context_features: list[any]
    :param actions: Required. The set of actions the Personalizer service can pick from.
     The set should not contain more than 50 actions.
     The order of the actions does not affect the rank result but the order
     should match the sequence your application would have used to display them.
     The first item in the array will be used as Baseline item in Offline Evaluations.
    :type actions: list[~personalizerv11_preview1.models.RankableAction]
    :param excluded_actions: The set of action ids to exclude from ranking.
     Personalizer will consider the first non-excluded item in the array as the Baseline action
     when performing Offline Evaluations.
    :type excluded_actions: list[str]
    :param event_id: Optionally pass an eventId that uniquely identifies this Rank event.
     If null, the service generates a unique eventId. The eventId will be used for
     associating this request with its reward, as well as seeding the pseudo-random
     generator when making a Personalizer call.
    :type event_id: str
    :param defer_activation: Send false if it is certain the rewardActionId in rank results will be
     shown to the user, therefore
     Personalizer will expect a Reward call, otherwise it will assign the default
     Reward to the event. Send true if it is possible the user will not see the action specified in
     the rank results,
     (e.g. because the page is rendering later, or the Rank results may be overridden by code
     further downstream).
     You must call the Activate Event API if the event output is shown to users, otherwise Rewards
     will be ignored.
    :type defer_activation: bool
    """

    _validation = {
        'actions': {'required': True},
        'event_id': {'max_length': 256, 'min_length': 0},
    }

    _attribute_map = {
        'context_features': {'key': 'contextFeatures', 'type': '[object]'},
        'actions': {'key': 'actions', 'type': '[RankableAction]'},
        'excluded_actions': {'key': 'excludedActions', 'type': '[str]'},
        'event_id': {'key': 'eventId', 'type': 'str'},
        'defer_activation': {'key': 'deferActivation', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RankRequest, self).__init__(**kwargs)
        self.context_features = kwargs.get('context_features', None)
        self.actions = kwargs['actions']
        self.excluded_actions = kwargs.get('excluded_actions', None)
        self.event_id = kwargs.get('event_id', None)
        self.defer_activation = kwargs.get('defer_activation', False)


class RankResponse(msrest.serialization.Model):
    """Returns which action to use as rewardActionId, and additional information about each action as a result of a Rank request.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar ranking: The calculated ranking for the current request.
    :vartype ranking: list[~personalizerv11_preview1.models.RankedAction]
    :ivar event_id: The eventId for the round trip from request to response.
    :vartype event_id: str
    :ivar reward_action_id: The action chosen by the Personalizer service.
     This is the action your application should display, and for which to report the reward.
     This might not be the first found in 'ranking'.
    :vartype reward_action_id: str
    """

    _validation = {
        'ranking': {'readonly': True},
        'event_id': {'readonly': True, 'max_length': 256, 'min_length': 0},
        'reward_action_id': {'readonly': True, 'max_length': 256, 'min_length': 0},
    }

    _attribute_map = {
        'ranking': {'key': 'ranking', 'type': '[RankedAction]'},
        'event_id': {'key': 'eventId', 'type': 'str'},
        'reward_action_id': {'key': 'rewardActionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RankResponse, self).__init__(**kwargs)
        self.ranking = None
        self.event_id = None
        self.reward_action_id = None


class RewardRequest(msrest.serialization.Model):
    """Reward given to a rank response.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Reward to be assigned to an action. Value is a float calculated by your
     application, typically between 0 and 1, and must be between -1 and 1.
    :type value: float
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RewardRequest, self).__init__(**kwargs)
        self.value = kwargs['value']


class ServiceConfiguration(msrest.serialization.Model):
    """The configuration of the service.

    All required parameters must be populated in order to send to Azure.

    :param reward_wait_time: Required. The time span waited until a request is marked with the
     default reward
     and should be between 5 seconds and 2 days.
     For example, PT5M (5 mins). For information about the time format,
     see http://en.wikipedia.org/wiki/ISO_8601#Durations.
    :type reward_wait_time: ~datetime.timedelta
    :param default_reward: Required. The reward given if a reward is not received within the
     specified wait time.
    :type default_reward: float
    :param reward_aggregation: Required. The function used to process rewards, if multiple reward
     scores are received before rewardWaitTime is over.
    :type reward_aggregation: str
    :param exploration_percentage: Required. The percentage of rank responses that will use
     exploration.
    :type exploration_percentage: float
    :param model_export_frequency: Required. Personalizer will start using the most updated trained
     model for online ranks automatically every specified time period.
     For example, PT5M (5 mins). For information about the time format,
     see http://en.wikipedia.org/wiki/ISO_8601#Durations.
    :type model_export_frequency: ~datetime.timedelta
    :param log_mirror_enabled: Flag indicates whether log mirroring is enabled.
    :type log_mirror_enabled: bool
    :param log_mirror_sas_uri: Azure storage account container SAS URI for log mirroring.
    :type log_mirror_sas_uri: str
    :param log_retention_days: Required. Number of days historical logs are to be maintained. -1
     implies the logs will never be deleted.
    :type log_retention_days: int
    :param last_configuration_edit_date: Last time model training configuration was updated.
    :type last_configuration_edit_date: ~datetime.datetime
    :param learning_mode: Learning Modes for Personalizer. Possible values include: "Online",
     "Apprentice", "LoggingOnly".
    :type learning_mode: str or ~personalizerv11_preview1.models.LearningMode
    :param latest_apprentice_mode_metrics: Most recent Apprentice Mode metrics.
    :type latest_apprentice_mode_metrics: ~personalizerv11_preview1.models.ApprenticeModeMetrics
    :param is_auto_optimization_enabled: Flag indicating whether Personalizer will automatically
     optimize Learning Settings by running Offline Evaluations periodically.
    :type is_auto_optimization_enabled: bool
    :param auto_optimization_frequency: Frequency of automatic optimization. Only relevant if
     IsAutoOptimizationEnabled is true.
     For example, PT5M (5 mins). For information about the time format,
     \r\nsee http://en.wikipedia.org/wiki/ISO_8601#Durations.
    :type auto_optimization_frequency: ~datetime.timedelta
    :param auto_optimization_start_date: Date when the first automatic optimization evaluation must
     be performed. Only relevant if IsAutoOptimizationEnabled is true.
    :type auto_optimization_start_date: ~datetime.datetime
    """

    _validation = {
        'reward_wait_time': {'required': True},
        'default_reward': {'required': True, 'maximum': 1, 'minimum': -1},
        'reward_aggregation': {'required': True, 'max_length': 256, 'min_length': 0},
        'exploration_percentage': {'required': True, 'maximum': 1, 'minimum': 0},
        'model_export_frequency': {'required': True},
        'log_retention_days': {'required': True, 'maximum': 2147483647, 'minimum': -1},
    }

    _attribute_map = {
        'reward_wait_time': {'key': 'rewardWaitTime', 'type': 'duration'},
        'default_reward': {'key': 'defaultReward', 'type': 'float'},
        'reward_aggregation': {'key': 'rewardAggregation', 'type': 'str'},
        'exploration_percentage': {'key': 'explorationPercentage', 'type': 'float'},
        'model_export_frequency': {'key': 'modelExportFrequency', 'type': 'duration'},
        'log_mirror_enabled': {'key': 'logMirrorEnabled', 'type': 'bool'},
        'log_mirror_sas_uri': {'key': 'logMirrorSasUri', 'type': 'str'},
        'log_retention_days': {'key': 'logRetentionDays', 'type': 'int'},
        'last_configuration_edit_date': {'key': 'lastConfigurationEditDate', 'type': 'iso-8601'},
        'learning_mode': {'key': 'learningMode', 'type': 'str'},
        'latest_apprentice_mode_metrics': {'key': 'latestApprenticeModeMetrics', 'type': 'ApprenticeModeMetrics'},
        'is_auto_optimization_enabled': {'key': 'isAutoOptimizationEnabled', 'type': 'bool'},
        'auto_optimization_frequency': {'key': 'autoOptimizationFrequency', 'type': 'duration'},
        'auto_optimization_start_date': {'key': 'autoOptimizationStartDate', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ServiceConfiguration, self).__init__(**kwargs)
        self.reward_wait_time = kwargs['reward_wait_time']
        self.default_reward = kwargs['default_reward']
        self.reward_aggregation = kwargs['reward_aggregation']
        self.exploration_percentage = kwargs['exploration_percentage']
        self.model_export_frequency = kwargs['model_export_frequency']
        self.log_mirror_enabled = kwargs.get('log_mirror_enabled', None)
        self.log_mirror_sas_uri = kwargs.get('log_mirror_sas_uri', None)
        self.log_retention_days = kwargs['log_retention_days']
        self.last_configuration_edit_date = kwargs.get('last_configuration_edit_date', None)
        self.learning_mode = kwargs.get('learning_mode', None)
        self.latest_apprentice_mode_metrics = kwargs.get('latest_apprentice_mode_metrics', None)
        self.is_auto_optimization_enabled = kwargs.get('is_auto_optimization_enabled', None)
        self.auto_optimization_frequency = kwargs.get('auto_optimization_frequency', None)
        self.auto_optimization_start_date = kwargs.get('auto_optimization_start_date', None)


class ServiceStatus(msrest.serialization.Model):
    """ServiceStatus.

    :param service:
    :type service: str
    :param api_status:
    :type api_status: str
    :param api_status_message:
    :type api_status_message: str
    """

    _attribute_map = {
        'service': {'key': 'service', 'type': 'str'},
        'api_status': {'key': 'apiStatus', 'type': 'str'},
        'api_status_message': {'key': 'apiStatusMessage', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ServiceStatus, self).__init__(**kwargs)
        self.service = kwargs.get('service', None)
        self.api_status = kwargs.get('api_status', None)
        self.api_status_message = kwargs.get('api_status_message', None)


class SlotRequest(msrest.serialization.Model):
    """A slot with it's associated features and list of excluded actions.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. Slot ID.
    :type id: str
    :param features: List of dictionaries containing slot features.
    :type features: list[any]
    :param excluded_actions: List of excluded action Ids.
    :type excluded_actions: list[str]
    :param baseline_action: Required. The 'baseline action' ID for the slot.
     The BaselineAction is the Id of the Action your application would use in that slot if
     Personalizer didn't exist.
     BaselineAction must be defined for every slot.
     BaselineAction should never be part of ExcludedActions.
     Each slot must have a unique BaselineAction which corresponds to an an action from the event's
     Actions list.
    :type baseline_action: str
    """

    _validation = {
        'id': {'required': True},
        'baseline_action': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'features': {'key': 'features', 'type': '[object]'},
        'excluded_actions': {'key': 'excludedActions', 'type': '[str]'},
        'baseline_action': {'key': 'baselineAction', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SlotRequest, self).__init__(**kwargs)
        self.id = kwargs['id']
        self.features = kwargs.get('features', None)
        self.excluded_actions = kwargs.get('excluded_actions', None)
        self.baseline_action = kwargs['baseline_action']


class SlotResponse(msrest.serialization.Model):
    """SlotResponse.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. Id is the slot ID.
    :type id: str
    :ivar reward_action_id: RewardActionID is the action ID recommended by Personalizer.
    :vartype reward_action_id: str
    """

    _validation = {
        'id': {'required': True, 'max_length': 256, 'min_length': 0},
        'reward_action_id': {'readonly': True, 'max_length': 256, 'min_length': 0},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'reward_action_id': {'key': 'rewardActionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SlotResponse, self).__init__(**kwargs)
        self.id = kwargs['id']
        self.reward_action_id = None


class SlotReward(msrest.serialization.Model):
    """SlotReward.

    All required parameters must be populated in order to send to Azure.

    :param slot_id: Required. Slot id for which we are sending the reward.
    :type slot_id: str
    :param value: Required. Reward to be assigned to slotId. Value should be between -1 and 1
     inclusive.
    :type value: float
    """

    _validation = {
        'slot_id': {'required': True, 'max_length': 256, 'min_length': 1},
        'value': {'required': True},
    }

    _attribute_map = {
        'slot_id': {'key': 'slotId', 'type': 'str'},
        'value': {'key': 'value', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SlotReward, self).__init__(**kwargs)
        self.slot_id = kwargs['slot_id']
        self.value = kwargs['value']
