# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, List, Literal, Optional, Type, TypeVar, Union, cast, overload
from .. import _model_base

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._model_base import SdkJSONEncoder, _deserialize
from .._serialization import Serializer
from .._vendor import prepare_multipart_form_data

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
_Unset: Any = object()

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_ingestions_list_request(collection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/ingestions"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_read_request(ingestion_id: str, collection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/ingestions/{ingestionId}"
    path_format_arguments = {
        "ingestionId": _SERIALIZER.url("ingestion_id", ingestion_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_create_request(collection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/ingestions"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_get_features_request(
    collection_id: str,
    *,
    limit: Optional[int] = None,
    bbox: Optional[List[float]] = None,
    datetime: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if limit is not None:
        _params["limit"] = _SERIALIZER.query("limit", limit, "int")
    if bbox is not None:
        _params["bbox"] = [_SERIALIZER.query("bbox", q, "float") if q is not None else "" for q in bbox]
    if datetime is not None:
        _params["datetime"] = _SERIALIZER.query("datetime", datetime, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_get_item_request(collection_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_create_request(collection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_update_request(collection_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_patch_request(collection_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_delete_request(collection_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_sources_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/ingestion-sources"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_sources_read_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/ingestion-sources/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_sources_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/ingestion-sources"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_sources_update_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/ingestion-sources/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_sources_delete_request(id: str, **kwargs: Any) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    # Construct URL
    _url = "/api/ingestion-sources/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)


def build_ingestion_geo_templates_list_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/ingestion-geo-templates"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_geo_templates_read_request(id: str, **kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/ingestion-geo-templates/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_geo_templates_create_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/ingestion-geo-templates"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_geo_templates_update_request(  # pylint: disable=name-too-long
    id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/ingestion-geo-templates/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_geo_templates_delete_request(  # pylint: disable=name-too-long
    id: str, **kwargs: Any
) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    # Construct URL
    _url = "/api/ingestion-geo-templates/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)


def build_operations_list_request(
    collection_id: str, *, _top: int, _skip: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/operations"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["$top"] = _SERIALIZER.query("top", _top, "int")
    if _skip is not None:
        _params["$skip"] = _SERIALIZER.query("skip", _skip, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_operations_read_request(collection_id: str, operation_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/operations/{operationId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_operations_cancel_request(collection_id: str, operation_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/operations/{operationId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_operations_cancel_all_request(collection_id: str, **kwargs: Any) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    # Construct URL
    _url = "/api/collections/{collectionId}/operations"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)


def build_operations_download_logs_request(collection_id: str, operation_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/operations/{operationId}/logs"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_operations_token_api_token_collection_id_get_request(  # pylint: disable=name-too-long
    collection_id: str, *, duration: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/token/{collectionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_revoke_operations_token_api_token_revoke_post_request(  # pylint: disable=name-too-long
    *, duration: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/token/revoke"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_signed_operations_href_api_sign_get_request(  # pylint: disable=name-too-long
    *, href: str, duration: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/sign"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["href"] = _SERIALIZER.query("href", href, "str")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_landing_operations_page_api_get_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_conformance_operations_classes_api_conformance_get_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/conformance"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_operations_api_search_get_request(  # pylint: disable=name-too-long
    *,
    collections: Optional[str] = None,
    ids: Optional[str] = None,
    bbox: Optional[str] = None,
    intersects: Optional[str] = None,
    datetime: Optional[str] = None,
    limit: Optional[int] = None,
    sign: Optional[bool] = None,
    duration: Optional[int] = None,
    query: Optional[str] = None,
    sortby: Optional[str] = None,
    fields: Optional[str] = None,
    filter: Optional[str] = None,
    token: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept: Literal["application/geo+json"] = kwargs.pop("accept", _headers.pop("accept", "application/geo+json"))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    # Construct URL
    _url = "/api/search"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if collections is not None:
        _params["collections"] = _SERIALIZER.query("collections", collections, "str")
    if ids is not None:
        _params["ids"] = _SERIALIZER.query("ids", ids, "str")
    if bbox is not None:
        _params["bbox"] = _SERIALIZER.query("bbox", bbox, "str")
    if intersects is not None:
        _params["intersects"] = _SERIALIZER.query("intersects", intersects, "str")
    if datetime is not None:
        _params["datetime"] = _SERIALIZER.query("datetime", datetime, "str")
    if limit is not None:
        _params["limit"] = _SERIALIZER.query("limit", limit, "int")
    if sign is not None:
        _params["sign"] = _SERIALIZER.query("sign", sign, "bool")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if sortby is not None:
        _params["sortby"] = _SERIALIZER.query("sortby", sortby, "str")
    if fields is not None:
        _params["fields"] = _SERIALIZER.query("fields", fields, "str")
    if filter is not None:
        _params["filter"] = _SERIALIZER.query("filter", filter, "str")
    if token is not None:
        _params["token"] = _SERIALIZER.query("token", token, "str")

    # Construct headers
    _headers["accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_operations_api_search_post_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept: Literal["application/geo+json"] = kwargs.pop("accept", _headers.pop("accept", "application/geo+json"))
    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    # Construct URL
    _url = "/api/search"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_collections_api_collections_get_request(  # pylint: disable=name-too-long
    *, sign: Optional[bool] = None, duration: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if sign is not None:
        _params["sign"] = _SERIALIZER.query("sign", sign, "bool")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_collection_api_collections_collection_id_get_request(  # pylint: disable=name-too-long
    collection_id: str, *, sign: Optional[bool] = None, duration: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if sign is not None:
        _params["sign"] = _SERIALIZER.query("sign", sign, "bool")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_collection_thumbnail_api_collections_collection_id_thumbnail_get_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/thumbnail"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_azmaps_token_api_config_map_token_get_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/config/map/token"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_azmaps_client_id_api_config_map_id_get_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/config/map/id"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_auth_config_api_config_auth_get_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/config/auth"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_config_api_collections_collection_id_config_get_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_collection_mosaics_api_collections_collection_id_config_mosaics_get_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/mosaics"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_get_request(  # pylint: disable=name-too-long
    collection_id: str, mosaic_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/mosaics/{mosaicId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "mosaicId": _SERIALIZER.url("mosaic_id", mosaic_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_collection_render_options_api_collections_collection_id_config_render_options_get_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/render-options"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_collection_render_option_api_collections_collection_id_config_render_options_render_option_id_get_request(  # pylint: disable=name-too-long
    collection_id: str, render_option_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/render-options/{renderOptionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "renderOptionId": _SERIALIZER.url("render_option_id", render_option_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_collection_tile_settings_api_collections_collection_id_config_tile_settings_get_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/tile-settings"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_collections_partitiontype_api_collections_collection_id_config_partition_type_get_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/partition-type"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_create_operations_collections_collection_api_collections_post_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_create_operations_collections_collection_asset_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/assets"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_create_operations_collections_partitiontype_api_collections_collection_id_config_partition_type_put_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/partition-type"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_update_operations_collection_api_collections_collection_id_put_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_update_operations_collection_asset_request(  # pylint: disable=name-too-long
    collection_id: str, asset_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/assets/{assetId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "assetId": _SERIALIZER.url("asset_id", asset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_update_operations_collection_queryables_api_collections_collection_id_queryables_queryable_name_put_request(  # pylint: disable=name-too-long
    collection_id: str, queryable_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/queryables/{queryableName}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "queryableName": _SERIALIZER.url("queryable_name", queryable_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_update_operations_collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_put_request(  # pylint: disable=name-too-long
    collection_id: str, mosaic_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/mosaics/{mosaicId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "mosaicId": _SERIALIZER.url("mosaic_id", mosaic_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_update_operations_collection_render_option_api_collections_collection_id_config_render_options_render_option_id_put_request(  # pylint: disable=name-too-long
    collection_id: str, render_option_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/render-options/{renderOptionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "renderOptionId": _SERIALIZER.url("render_option_id", render_option_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_update_operations_collection_tile_settings_api_collections_collection_id_config_tile_settings_put_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/tile-settings"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_delete_operations_collection_api_collections_collection_id_delete_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_delete_operations_collection_asset_api_collections_collection_id_assets_asset_id_delete_request(  # pylint: disable=name-too-long
    collection_id: str, asset_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/assets/{assetId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "assetId": _SERIALIZER.url("asset_id", asset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_delete_operations_queryables_api_collections_collection_id_queryables_queryable_name_delete_request(  # pylint: disable=name-too-long
    collection_id: str, queryable_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/queryables/{queryableName}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "queryableName": _SERIALIZER.url("queryable_name", queryable_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_delete_operations_collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_delete_request(  # pylint: disable=name-too-long
    collection_id: str, mosaic_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/mosaics/{mosaicId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "mosaicId": _SERIALIZER.url("mosaic_id", mosaic_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_delete_operations_collection_render_option_api_collections_collection_id_config_render_options_render_option_id_delete_request(  # pylint: disable=name-too-long
    collection_id: str, render_option_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/render-options/{renderOptionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "renderOptionId": _SERIALIZER.url("render_option_id", render_option_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_queryables_operations_api_queryables_get_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/queryables"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_collection_operations_queryables_api_collections_collection_id_queryables_get_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/queryables"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_set_operations_collection_queryables_api_collections_collection_id_queryables_post_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/queryables"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_add_operations_collection_mosaic_api_collections_collection_id_config_mosaics_post_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/mosaics"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_add_operations_collection_render_option_api_collections_collection_id_config_render_options_post_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/config/render-options"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_bounds_operations_api_collections_collection_id_items_item_id_bounds_get_request(  # pylint: disable=name-too-long
    collection_id: str, item_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/bounds"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_info_operations_api_collections_collection_id_items_item_id_info_get_request(  # pylint: disable=name-too-long
    collection_id: str, item_id: str, *, assets: Optional[List[str]] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/info"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_info_operations_geojson_api_collections_collection_id_items_item_id_info_geojson_get_request(  # pylint: disable=name-too-long
    collection_id: str, item_id: str, *, assets: Optional[List[str]] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept: Literal["application/geo+json"] = kwargs.pop("accept", _headers.pop("accept", "application/geo+json"))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/info.geojson"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]

    # Construct headers
    _headers["accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_info_operations_search_api_mosaic_searchid_info_get_request(  # pylint: disable=name-too-long
    searchid: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/info"
    path_format_arguments = {
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_available_operations_assets_api_collections_collection_id_items_item_id_assets_get_request(  # pylint: disable=name-too-long
    collection_id: str, item_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/assets"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_operations_statistics_api_collections_collection_id_items_item_id_asset_statistics_get_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    *,
    assets: Optional[List[str]] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_expression: Optional[List[str]] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    categorical: Optional[bool] = None,
    c: Optional[List[Any]] = None,
    p: Optional[List[int]] = None,
    histogram_bins: Optional[str] = None,
    histogram_range: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/asset_statistics"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_expression is not None:
        _params["asset_expression"] = [
            _SERIALIZER.query("asset_expression", q, "str") if q is not None else "" for q in asset_expression
        ]
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if categorical is not None:
        _params["categorical"] = _SERIALIZER.query("categorical", categorical, "bool")
    if c is not None:
        _params["c"] = [_SERIALIZER.query("c", q, "object") if q is not None else "" for q in c]
    if p is not None:
        _params["p"] = [_SERIALIZER.query("p", q, "int") if q is not None else "" for q in p]
    if histogram_bins is not None:
        _params["histogram_bins"] = _SERIALIZER.query("histogram_bins", histogram_bins, "str")
    if histogram_range is not None:
        _params["histogram_range"] = _SERIALIZER.query("histogram_range", histogram_range, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_statistics_operations_api_collections_collection_id_items_item_id_statistics_get_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    categorical: Optional[bool] = None,
    c: Optional[List[Any]] = None,
    p: Optional[List[int]] = None,
    histogram_bins: Optional[str] = None,
    histogram_range: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/statistics"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if categorical is not None:
        _params["categorical"] = _SERIALIZER.query("categorical", categorical, "bool")
    if c is not None:
        _params["c"] = [_SERIALIZER.query("c", q, "object") if q is not None else "" for q in c]
    if p is not None:
        _params["p"] = [_SERIALIZER.query("p", q, "int") if q is not None else "" for q in p]
    if histogram_bins is not None:
        _params["histogram_bins"] = _SERIALIZER.query("histogram_bins", histogram_bins, "str")
    if histogram_range is not None:
        _params["histogram_range"] = _SERIALIZER.query("histogram_range", histogram_range, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_geojson_operations_statistics_api_collections_collection_id_items_item_id_statistics_post_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    *,
    coord_crs: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    categorical: Optional[bool] = None,
    c: Optional[List[Any]] = None,
    p: Optional[List[int]] = None,
    histogram_bins: Optional[str] = None,
    histogram_range: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept: Literal["application/geo+json, application/json"] = kwargs.pop(
        "accept", _headers.pop("accept", "application/geo+json, application/json")
    )
    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/statistics"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if categorical is not None:
        _params["categorical"] = _SERIALIZER.query("categorical", categorical, "bool")
    if c is not None:
        _params["c"] = [_SERIALIZER.query("c", q, "object") if q is not None else "" for q in c]
    if p is not None:
        _params["p"] = [_SERIALIZER.query("p", q, "int") if q is not None else "" for q in p]
    if histogram_bins is not None:
        _params["histogram_bins"] = _SERIALIZER.query("histogram_bins", histogram_bins, "str")
    if histogram_range is not None:
        _params["histogram_range"] = _SERIALIZER.query("histogram_range", histogram_range, "str")

    # Construct headers
    _headers["accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_geojson_operations_crop_api_collections_collection_id_items_item_id_crop_width_x_height_format_post_request(  # pylint: disable=name-too-long
    format: Union[str, _models.ImageType],
    collection_id: str,
    item_id: str,
    height: int,
    width: int,
    *,
    color_formula: Optional[str] = None,
    coord_crs: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/crop/{width}x{height}.{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "height": _SERIALIZER.url("height", height, "int"),
        "width": _SERIALIZER.url("width", width, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_geojson_operations_crop_api_collections_collection_id_items_item_id_crop_format_post_request(  # pylint: disable=name-too-long
    format: Union[str, _models.ImageType],
    collection_id: str,
    item_id: str,
    *,
    color_formula: Optional[str] = None,
    coord_crs: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/crop.{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_geojson_operations_crop_api_collections_collection_id_items_item_id_crop_post_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    *,
    format: Optional[Union[str, _models.ImageType]] = None,
    color_formula: Optional[str] = None,
    coord_crs: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/crop"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_scale_x_format_get_request(  # pylint: disable=name-too-long
    z: int,
    x: int,
    y: int,
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    scale: int,
    format: Union[str, _models.ImageType],
    collection_id: str,
    item_id: str,
    *,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/tiles/{tileMatrixSetId}/{z}/{x}/{y}@{scale}x.{format}"
    path_format_arguments = {
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "scale": _SERIALIZER.url("scale", scale, "int"),
        "format": _SERIALIZER.url("format", format, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_scale_x_get_request(  # pylint: disable=name-too-long
    z: int,
    x: int,
    y: int,
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    scale: int,
    collection_id: str,
    item_id: str,
    *,
    format: Optional[Union[str, _models.ImageType]] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/tiles/{tileMatrixSetId}/{z}/{x}/{y}@{scale}x"
    path_format_arguments = {
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "scale": _SERIALIZER.url("scale", scale, "int"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_format_get_request(  # pylint: disable=name-too-long
    z: int,
    x: int,
    y: int,
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    format: Union[str, _models.ImageType],
    collection_id: str,
    item_id: str,
    *,
    scale: Optional[int] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/tiles/{tileMatrixSetId}/{z}/{x}/{y}.{format}"
    path_format_arguments = {
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "format": _SERIALIZER.url("format", format, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if scale is not None:
        _params["scale"] = _SERIALIZER.query("scale", scale, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_get_request(  # pylint: disable=name-too-long
    z: int,
    x: int,
    y: int,
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    collection_id: str,
    item_id: str,
    *,
    scale: Optional[int] = None,
    format: Optional[Union[str, _models.ImageType]] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/tiles/{tileMatrixSetId}/{z}/{x}/{y}"
    path_format_arguments = {
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if scale is not None:
        _params["scale"] = _SERIALIZER.query("scale", scale, "int")
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_collections_collection_id_items_item_id_tiles_z_x_y_scale_x_format_get_request(  # pylint: disable=name-too-long
    z: int,
    x: int,
    y: int,
    scale: int,
    format: Union[str, _models.ImageType],
    collection_id: str,
    item_id: str,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/tiles/{z}/{x}/{y}@{scale}x.{format}"
    path_format_arguments = {
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
        "scale": _SERIALIZER.url("scale", scale, "int"),
        "format": _SERIALIZER.url("format", format, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_collections_collection_id_items_item_id_tiles_z_x_y_scale_x_get_request(  # pylint: disable=name-too-long
    z: int,
    x: int,
    y: int,
    scale: int,
    collection_id: str,
    item_id: str,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    format: Optional[Union[str, _models.ImageType]] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/tiles/{z}/{x}/{y}@{scale}x"
    path_format_arguments = {
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
        "scale": _SERIALIZER.url("scale", scale, "int"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_collections_collection_id_items_item_id_tiles_z_x_y_format_get_request(  # pylint: disable=name-too-long
    z: int,
    x: int,
    y: int,
    format: Union[str, _models.ImageType],
    collection_id: str,
    item_id: str,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    scale: Optional[int] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/tiles/{z}/{x}/{y}.{format}"
    path_format_arguments = {
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
        "format": _SERIALIZER.url("format", format, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if scale is not None:
        _params["scale"] = _SERIALIZER.query("scale", scale, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_collections_collection_id_items_item_id_tiles_z_x_y_get_request(  # pylint: disable=name-too-long
    z: int,
    x: int,
    y: int,
    collection_id: str,
    item_id: str,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    scale: Optional[int] = None,
    format: Optional[Union[str, _models.ImageType]] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/tiles/{z}/{x}/{y}"
    path_format_arguments = {
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if scale is not None:
        _params["scale"] = _SERIALIZER.query("scale", scale, "int")
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_scale_x_format_get_request(  # pylint: disable=name-too-long
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    scale: int,
    format: Union[str, _models.ImageType],
    searchid: str,
    z: int,
    x: int,
    y: int,
    *,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    collection: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/tiles/{tileMatrixSetId}/{z}/{x}/{y}@{scale}x.{format}"
    path_format_arguments = {
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "scale": _SERIALIZER.url("scale", scale, "int"),
        "format": _SERIALIZER.url("format", format, "str"),
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_scale_x_get_request(  # pylint: disable=name-too-long
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    scale: int,
    searchid: str,
    z: int,
    x: int,
    y: int,
    *,
    format: Optional[Union[str, _models.ImageType]] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    collection: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/tiles/{tileMatrixSetId}/{z}/{x}/{y}@{scale}x"
    path_format_arguments = {
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "scale": _SERIALIZER.url("scale", scale, "int"),
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_format_get_request(  # pylint: disable=name-too-long
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    format: Union[str, _models.ImageType],
    searchid: str,
    z: int,
    x: int,
    y: int,
    *,
    scale: Optional[int] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    collection: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/tiles/{tileMatrixSetId}/{z}/{x}/{y}.{format}"
    path_format_arguments = {
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "format": _SERIALIZER.url("format", format, "str"),
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if scale is not None:
        _params["scale"] = _SERIALIZER.query("scale", scale, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_get_request(  # pylint: disable=name-too-long
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    searchid: str,
    z: int,
    x: int,
    y: int,
    *,
    scale: Optional[int] = None,
    format: Optional[Union[str, _models.ImageType]] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    collection: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/tiles/{tileMatrixSetId}/{z}/{x}/{y}"
    path_format_arguments = {
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if scale is not None:
        _params["scale"] = _SERIALIZER.query("scale", scale, "int")
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_mosaic_searchid_tiles_z_x_y_scale_x_format_get_request(  # pylint: disable=name-too-long
    scale: int,
    format: Union[str, _models.ImageType],
    searchid: str,
    z: int,
    x: int,
    y: int,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    collection: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/tiles/{z}/{x}/{y}@{scale}x.{format}"
    path_format_arguments = {
        "scale": _SERIALIZER.url("scale", scale, "int"),
        "format": _SERIALIZER.url("format", format, "str"),
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_mosaic_searchid_tiles_z_x_y_scale_x_get_request(  # pylint: disable=name-too-long
    scale: int,
    searchid: str,
    z: int,
    x: int,
    y: int,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    format: Optional[Union[str, _models.ImageType]] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    collection: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/tiles/{z}/{x}/{y}@{scale}x"
    path_format_arguments = {
        "scale": _SERIALIZER.url("scale", scale, "int"),
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_mosaic_searchid_tiles_z_x_y_format_get_request(  # pylint: disable=name-too-long
    format: Union[str, _models.ImageType],
    searchid: str,
    z: int,
    x: int,
    y: int,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    scale: Optional[int] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    collection: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/tiles/{z}/{x}/{y}.{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if scale is not None:
        _params["scale"] = _SERIALIZER.query("scale", scale, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_operations_api_mosaic_searchid_tiles_z_x_y_get_request(  # pylint: disable=name-too-long
    searchid: str,
    z: int,
    x: int,
    y: int,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    scale: Optional[int] = None,
    format: Optional[Union[str, _models.ImageType]] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    collection: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/tiles/{z}/{x}/{y}"
    path_format_arguments = {
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if scale is not None:
        _params["scale"] = _SERIALIZER.query("scale", scale, "int")
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tilejson_operations_api_collections_collection_id_items_item_id_tile_matrix_set_id_tilejson_json_get_request(  # pylint: disable=name-too-long
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    collection_id: str,
    item_id: str,
    *,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/{tileMatrixSetId}/tilejson.json"
    path_format_arguments = {
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tilejson_operations_api_collections_collection_id_items_item_id_tilejson_json_get_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/tilejson.json"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tilejson_operations_api_mosaic_searchid_tile_matrix_set_id_tilejson_json_get_request(  # pylint: disable=name-too-long
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    searchid: str,
    *,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    collection: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/{tileMatrixSetId}/tilejson.json"
    path_format_arguments = {
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tilejson_operations_api_mosaic_searchid_tilejson_json_get_request(  # pylint: disable=name-too-long
    searchid: str,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    collection: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/tilejson.json"
    path_format_arguments = {
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_wmts_operations_api_collections_collection_id_items_item_id_tile_matrix_set_id_w_m_t_s_capabilities_xml_get_request(  # pylint: disable=name-too-long
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    collection_id: str,
    item_id: str,
    *,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/{tileMatrixSetId}/WMTSCapabilities.xml"
    path_format_arguments = {
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_wmts_operations_api_collections_collection_id_items_item_id_w_m_t_s_capabilities_xml_get_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/WMTSCapabilities.xml"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_wmts_operations_api_mosaic_searchid_tile_matrix_set_id_w_m_t_s_capabilities_xml_get_request(  # pylint: disable=name-too-long
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    searchid: str,
    *,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    # Construct URL
    _url = "/api/mosaic/{searchid}/{tileMatrixSetId}/WMTSCapabilities.xml"
    path_format_arguments = {
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")

    # Construct headers
    _headers["accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_wmts_operations_api_mosaic_searchid_w_m_t_s_capabilities_xml_get_request(  # pylint: disable=name-too-long
    searchid: str,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    # Construct URL
    _url = "/api/mosaic/{searchid}/WMTSCapabilities.xml"
    path_format_arguments = {
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")

    # Construct headers
    _headers["accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_point_operations_api_collections_collection_id_items_item_id_point_lon_lat_get_request(  # pylint: disable=name-too-long
    lon: float,
    lat: float,
    collection_id: str,
    item_id: str,
    *,
    coord_crs: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/point/{lon},{lat}"
    path_format_arguments = {
        "lon": _SERIALIZER.url("lon", lon, "float"),
        "lat": _SERIALIZER.url("lat", lat, "float"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_preview_operations_api_collections_collection_id_items_item_id_preview_format_get_request(  # pylint: disable=name-too-long
    format: Union[str, _models.ImageType],
    collection_id: str,
    item_id: str,
    *,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    dst_crs: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/preview.{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if dst_crs is not None:
        _params["dst-crs"] = _SERIALIZER.query("dst_crs", dst_crs, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_preview_operations_api_collections_collection_id_items_item_id_preview_get_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    *,
    format: Optional[Union[str, _models.ImageType]] = None,
    color_formula: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    dst_crs: Optional[str] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/preview"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if dst_crs is not None:
        _params["dst-crs"] = _SERIALIZER.query("dst_crs", dst_crs, "str")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_part_operations_api_collections_collection_id_items_item_id_crop_minx_miny_maxx_maxy_width_x_height_format_get_request(  # pylint: disable=name-too-long
    minx: float,
    miny: float,
    maxx: float,
    maxy: float,
    format: Union[str, _models.ImageType],
    collection_id: str,
    item_id: str,
    height: int,
    width: int,
    *,
    color_formula: Optional[str] = None,
    dst_crs: Optional[str] = None,
    coord_crs: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/crop/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}"
    path_format_arguments = {
        "minx": _SERIALIZER.url("minx", minx, "float"),
        "miny": _SERIALIZER.url("miny", miny, "float"),
        "maxx": _SERIALIZER.url("maxx", maxx, "float"),
        "maxy": _SERIALIZER.url("maxy", maxy, "float"),
        "format": _SERIALIZER.url("format", format, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "height": _SERIALIZER.url("height", height, "int"),
        "width": _SERIALIZER.url("width", width, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if dst_crs is not None:
        _params["dst-crs"] = _SERIALIZER.query("dst_crs", dst_crs, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_part_operations_api_collections_collection_id_items_item_id_crop_minx_miny_maxx_maxy_format_get_request(  # pylint: disable=name-too-long
    minx: float,
    miny: float,
    maxx: float,
    maxy: float,
    format: Union[str, _models.ImageType],
    collection_id: str,
    item_id: str,
    *,
    color_formula: Optional[str] = None,
    dst_crs: Optional[str] = None,
    coord_crs: Optional[str] = None,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[str] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/items/{itemId}/crop/{minx},{miny},{maxx},{maxy}.{format}"
    path_format_arguments = {
        "minx": _SERIALIZER.url("minx", minx, "float"),
        "miny": _SERIALIZER.url("miny", miny, "float"),
        "maxx": _SERIALIZER.url("maxx", maxx, "float"),
        "maxy": _SERIALIZER.url("maxy", maxy, "float"),
        "format": _SERIALIZER.url("format", format, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if dst_crs is not None:
        _params["dst-crs"] = _SERIALIZER.query("dst_crs", dst_crs, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = [_SERIALIZER.query("asset_bidx", q, "str") if q is not None else "" for q in asset_bidx]
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "str")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_register_operations_search_api_mosaic_register_post_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/register"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_operations_for_tile_api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_assets_get_request(  # pylint: disable=name-too-long
    tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
    searchid: str,
    z: int,
    x: int,
    y: int,
    *,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/tiles/{tileMatrixSetId}/{z}/{x}/{y}/assets"
    path_format_arguments = {
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_operations_for_tile_api_mosaic_searchid_tiles_z_x_y_assets_get_request(  # pylint: disable=name-too-long
    searchid: str,
    z: int,
    x: int,
    y: int,
    *,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/tiles/{z}/{x}/{y}/assets"
    path_format_arguments = {
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
        "z": _SERIALIZER.url("z", z, "int"),
        "x": _SERIALIZER.url("x", x, "int"),
        "y": _SERIALIZER.url("y", y, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_operations_for_point_api_mosaic_searchid_lon_lat_assets_get_request(  # pylint: disable=name-too-long
    lon: float,
    lat: float,
    searchid: str,
    *,
    coord_crs: Optional[str] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/mosaic/{searchid}/{lon},{lat}/assets"
    path_format_arguments = {
        "lon": _SERIALIZER.url("lon", lon, "float"),
        "lat": _SERIALIZER.url("lat", lat, "float"),
        "searchid": _SERIALIZER.url("searchid", searchid, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_interval_legend_api_legend_interval_classmap_name_get_request(  # pylint: disable=name-too-long
    classmap_name: str, *, trim_start: Optional[int] = None, trim_end: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/legend/interval/{classmapName}"
    path_format_arguments = {
        "classmapName": _SERIALIZER.url("classmap_name", classmap_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if trim_start is not None:
        _params["trim_start"] = _SERIALIZER.query("trim_start", trim_start, "int")
    if trim_end is not None:
        _params["trim_end"] = _SERIALIZER.query("trim_end", trim_end, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_classmap_legend_api_legend_classmap_classmap_name_get_request(  # pylint: disable=name-too-long
    classmap_name: str, *, trim_start: Optional[int] = None, trim_end: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/legend/classmap/{classmapName}"
    path_format_arguments = {
        "classmapName": _SERIALIZER.url("classmap_name", classmap_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if trim_start is not None:
        _params["trim_start"] = _SERIALIZER.query("trim_start", trim_start, "int")
    if trim_end is not None:
        _params["trim_end"] = _SERIALIZER.query("trim_end", trim_end, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_legend_api_legend_colormap_cmap_name_get_request(  # pylint: disable=name-too-long
    cmap_name: str,
    *,
    height: Optional[float] = None,
    width: Optional[float] = None,
    trim_start: Optional[int] = None,
    trim_end: Optional[int] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/legend/colormap/{cmapName}"
    path_format_arguments = {
        "cmapName": _SERIALIZER.url("cmap_name", cmap_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "float")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "float")
    if trim_start is not None:
        _params["trim_start"] = _SERIALIZER.query("trim_start", trim_start, "int")
    if trim_end is not None:
        _params["trim_end"] = _SERIALIZER.query("trim_end", trim_end, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operations_static_image_api_collections_collection_id_image_static_id_get_request(  # pylint: disable=name-too-long
    id: str, collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/image/static/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_create_operations_static_image_api_collections_collection_id_image_static_post_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/image/static"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_matrix_operations_list_api_tile_matrix_sets_get_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/tile-matrix-sets"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_matrix_operations_definition_api_tile_matrix_sets_tile_matrix_set_id_get_request(  # pylint: disable=name-too-long
    tile_matrix_set_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-01-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/tile-matrix-sets/{tileMatrixSetId}"
    path_format_arguments = {
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_runs_list_request(
    ingestion_id: str, collection_id: str, *, api_version: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/ingestions/{ingestionId}/runs"
    path_format_arguments = {
        "ingestionId": _SERIALIZER.url("ingestion_id", ingestion_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_runs_read_request(
    run_id: str, ingestion_id: str, collection_id: str, *, api_version: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/ingestions/{ingestionId}/runs/{runId}"
    path_format_arguments = {
        "runId": _SERIALIZER.url("run_id", run_id, "str"),
        "ingestionId": _SERIALIZER.url("ingestion_id", ingestion_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_runs_create_request(
    ingestion_id: str, collection_id: str, *, api_version: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/ingestions/{ingestionId}/runs"
    path_format_arguments = {
        "ingestionId": _SERIALIZER.url("ingestion_id", ingestion_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_runs_retry_request(
    run_id: str, ingestion_id: str, collection_id: str, *, api_version: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/collections/{collectionId}/ingestions/{ingestionId}/runs/{runId}/retry"
    path_format_arguments = {
        "runId": _SERIALIZER.url("run_id", run_id, "str"),
        "ingestionId": _SERIALIZER.url("ingestion_id", ingestion_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


class IngestionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`ingestions` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

        self.runs = IngestionsRunsOperations(self._client, self._config, self._serialize, self._deserialize)

    @distributed_trace
    def list(self, collection_id: str, **kwargs: Any) -> List[_models.IngestionDefinition]:
        """Get ingestions of a catalog.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: list of IngestionDefinition
        :rtype: list[~spatiopackage.models.IngestionDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "creationTime": "2020-02-20 00:00:00",
                        "id": "str",
                        "importType": "str",
                        "keepOriginalAssets": bool,
                        "skipExistingItems": bool,
                        "geoTemplateId": "str",
                        "sourceCatalogUrl": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.IngestionDefinition]] = kwargs.pop("cls", None)

        _request = build_ingestions_list_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.IngestionDefinition], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def read(self, ingestion_id: str, collection_id: str, **kwargs: Any) -> _models.IngestionDefinition:
        """Get the definition of an ingestion.

        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~spatiopackage.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "geoTemplateId": "str",
                    "sourceCatalogUrl": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionDefinition] = kwargs.pop("cls", None)

        _request = build_ingestions_read_request(
            ingestion_id=ingestion_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionDefinition, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self,
        collection_id: str,
        definition: _models.IngestionDefinitionCreation,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Required.
        :type definition: ~spatiopackage.models.IngestionDefinitionCreation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~spatiopackage.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                definition = {
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "geoTemplateId": "str",
                    "sourceCatalogUrl": "str"
                }

                # response body for status code(s): 201
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "geoTemplateId": "str",
                    "sourceCatalogUrl": "str"
                }
        """

    @overload
    def create(
        self, collection_id: str, definition: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Required.
        :type definition: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~spatiopackage.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "geoTemplateId": "str",
                    "sourceCatalogUrl": "str"
                }
        """

    @overload
    def create(
        self, collection_id: str, definition: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Required.
        :type definition: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~spatiopackage.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "geoTemplateId": "str",
                    "sourceCatalogUrl": "str"
                }
        """

    @distributed_trace
    def create(
        self, collection_id: str, definition: Union[_models.IngestionDefinitionCreation, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Is one of the following types:
         IngestionDefinitionCreation, JSON, IO[bytes] Required.
        :type definition: ~spatiopackage.models.IngestionDefinitionCreation or JSON or IO[bytes]
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~spatiopackage.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                definition = {
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "geoTemplateId": "str",
                    "sourceCatalogUrl": "str"
                }

                # response body for status code(s): 201
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "geoTemplateId": "str",
                    "sourceCatalogUrl": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IngestionDefinition] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(definition, (IOBase, bytes)):
            _content = definition
        else:
            _content = json.dumps(definition, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ingestions_create_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class ItemsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`items` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_features(
        self,
        collection_id: str,
        *,
        limit: Optional[int] = None,
        bbox: Optional[List[float]] = None,
        datetime: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.STACItemCollection:
        """Fetch features of the feature collection with id ``collectionId``.

        Every feature in a dataset belongs to a collection. A dataset may
        consist of multiple feature collections. A feature collection is often a
        collection of features of a similar type, based on a common schema.").

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :keyword limit: The optional limit parameter recommends the number of items that should be
         present in the response document.

         If the limit parameter value is greater than advertised limit maximum, the server must return
         the
         maximum possible number of items, rather than responding with an error.

         Only items are counted that are on the first level of the collection in the response document.
         Nested objects contained within the explicitly requested items must not be counted.

         Minimum = 1. Maximum = 10000. Default = 10. Default value is None.
        :paramtype limit: int
        :keyword bbox: Only features that have a geometry that intersects the bounding box are
         selected.
         The bounding box is provided as four or six numbers, depending on whether the
         coordinate reference system includes a vertical axis (height or depth):


         * Lower left corner, coordinate axis 1
         * Lower left corner, coordinate axis 2
         * Minimum value, coordinate axis 3 (optional)
         * Upper right corner, coordinate axis 1
         * Upper right corner, coordinate axis 2
         * Maximum value, coordinate axis 3 (optional)

         The coordinate reference system of the values is WGS 84 longitude/latitude
         (http://www.opengis.net/def/crs/OGC/1.3/CRS84).

         For WGS 84 longitude/latitude the values are in most cases the sequence of
         minimum longitude, minimum latitude, maximum longitude and maximum latitude.
         However, in cases where the box spans the antimeridian the first value
         (west-most box edge) is larger than the third value (east-most box edge).

         If the vertical axis is included, the third and the sixth number are
         the bottom and the top of the 3-dimensional bounding box.

         If a feature has multiple spatial geometry properties, it is the decision of the
         server whether only a single spatial geometry property is used to determine
         the extent or all relevant geometries. Default value is None.
        :paramtype bbox: list[float]
        :keyword datetime: Either a date-time or an interval, open or closed. Date and time expressions
         adhere to RFC 3339. Open intervals are expressed using double-dots.

         Examples:


         * A date-time: "2018-02-12T23:20:50Z"
         * A closed interval: "2018-02-12T00:00:00Z/2018-03-18T12:31:12Z"
         * Open intervals: "2018-02-12T00:00:00Z/.." or "../2018-03-18T12:31:12Z"

         Only features that have a temporal property that intersects the value of
         ``datetime`` are selected.

         If a feature has multiple temporal properties, it is the decision of the
         server whether only a single temporal property is used to determine
         the extent or all relevant temporal properties. Default value is None.
        :paramtype datetime: str
        :return: STACItemCollection. The STACItemCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.STACItemCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "features": [
                        {
                            "assets": {},
                            "bbox": [
                                0
                            ],
                            "collection": "str",
                            "geometry": {},
                            "id": "str",
                            "links": [
                                {
                                    "href": "str",
                                    "hreflang": "str",
                                    "length": 0,
                                    "rel": "str",
                                    "title": "str",
                                    "type": "str"
                                }
                            ],
                            "properties": {
                                "datetime": "str"
                            },
                            "stac_extensions": [
                                "str"
                            ],
                            "stac_version": "str",
                            "type": "str"
                        }
                    ],
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "type": "str",
                    "numberMatched": 0,
                    "numberReturned": 0,
                    "stac_version": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.STACItemCollection] = kwargs.pop("cls", None)

        _request = build_items_get_features_request(
            collection_id=collection_id,
            limit=limit,
            bbox=bbox,
            datetime=datetime,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.STACItemCollection, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.STACItemCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_item(self, collection_id: str, item_id: str, **kwargs: Any) -> _models.STACItem:
        """Fetch a single STAC Item.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :return: STACItem. The STACItem is compatible with MutableMapping
        :rtype: ~spatiopackage.models.STACItem
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.STACItem] = kwargs.pop("cls", None)

        _request = build_items_get_item_request(
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.STACItem, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.STACItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self,
        collection_id: str,
        item: _models.STACPostOrPutItem,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Operation:
        """Create a new STAC item or a set of items in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item: STAC Item or ItemCollection. Required.
        :type item: ~spatiopackage.models.STACPostOrPutItem
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @overload
    def create(
        self,
        collection_id: str,
        item: _models.STACPostOrPutItemCollection,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Operation:
        """Create a new STAC item or a set of items in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item: STAC Item or ItemCollection. Required.
        :type item: ~spatiopackage.models.STACPostOrPutItemCollection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "features": [
                        {
                            "assets": {},
                            "bbox": [
                                0
                            ],
                            "collection": "str",
                            "geometry": {},
                            "id": "str",
                            "links": [
                                {
                                    "href": "str",
                                    "hreflang": "str",
                                    "length": 0,
                                    "rel": "str",
                                    "title": "str",
                                    "type": "str"
                                }
                            ],
                            "properties": {
                                "datetime": "str"
                            },
                            "stac_extensions": [
                                "str"
                            ],
                            "stac_version": "str",
                            "type": "str"
                        }
                    ],
                    "type": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "numberMatched": 0,
                    "numberReturned": 0,
                    "stac_version": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @distributed_trace
    def create(
        self,
        collection_id: str,
        item: Union[_models.STACPostOrPutItem, _models.STACPostOrPutItemCollection],
        **kwargs: Any,
    ) -> _models.Operation:
        """Create a new STAC item or a set of items in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item: STAC Item or ItemCollection. Is either a STACPostOrPutItem type or a
         STACPostOrPutItemCollection type. Required.
        :type item: ~spatiopackage.models.STACPostOrPutItem or
         ~spatiopackage.models.STACPostOrPutItemCollection
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(item, _model_base.Model):
            _content = json.dumps(item, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(item, _model_base.Model):
            _content = json.dumps(item, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_items_create_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 202:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self,
        collection_id: str,
        item_id: str,
        item: _models.STACPostOrPutItem,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: ~spatiopackage.models.STACPostOrPutItem
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @overload
    def update(
        self, collection_id: str, item_id: str, item: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @overload
    def update(
        self,
        collection_id: str,
        item_id: str,
        item: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @distributed_trace
    def update(
        self, collection_id: str, item_id: str, item: Union[_models.STACPostOrPutItem, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Is one of the following types: STACPostOrPutItem, JSON, IO[bytes]
         Required.
        :type item: ~spatiopackage.models.STACPostOrPutItem or JSON or IO[bytes]
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(item, (IOBase, bytes)):
            _content = item
        else:
            _content = json.dumps(item, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_items_update_request(
            collection_id=collection_id,
            item_id=item_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 202:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def patch(
        self,
        collection_id: str,
        item_id: str,
        item: _models.STACPostOrPutItem,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: ~spatiopackage.models.STACPostOrPutItem
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @overload
    def patch(
        self, collection_id: str, item_id: str, item: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @overload
    def patch(
        self,
        collection_id: str,
        item_id: str,
        item: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @distributed_trace
    def patch(
        self, collection_id: str, item_id: str, item: Union[_models.STACPostOrPutItem, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Is one of the following types: STACPostOrPutItem, JSON, IO[bytes]
         Required.
        :type item: ~spatiopackage.models.STACPostOrPutItem or JSON or IO[bytes]
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(item, (IOBase, bytes)):
            _content = item
        else:
            _content = json.dumps(item, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_items_patch_request(
            collection_id=collection_id,
            item_id=item_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 202:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(self, collection_id: str, item_id: str, **kwargs: Any) -> _models.Operation:
        """Delete a STAC item from a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        _request = build_items_delete_request(
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 202:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class IngestionSourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`ingestion_sources` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> List[_models.IngestionSourceSummary]:
        """Get ingestion sources in a geo-catalog.

        :return: list of IngestionSourceSummary
        :rtype: list[~spatiopackage.models.IngestionSourceSummary]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "created": "2020-02-20 00:00:00",
                        "id": "str",
                        "sourceType": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.IngestionSourceSummary]] = kwargs.pop("cls", None)

        _request = build_ingestion_sources_list_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.IngestionSourceSummary], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def read(self, id: str, **kwargs: Any) -> _models.SasTokenIngestionSourceSummary:
        """Get an ingestion source in a geo-catalog.

        :param id: Ingestion source id. Required.
        :type id: str
        :return: SasTokenIngestionSourceSummary. The SasTokenIngestionSourceSummary is compatible with
         MutableMapping
        :rtype: ~spatiopackage.models.SasTokenIngestionSourceSummary
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "expiration": "2020-02-20 00:00:00"
                    },
                    "created": "2020-02-20 00:00:00",
                    "id": "str",
                    "sourceType": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SasTokenIngestionSourceSummary] = kwargs.pop("cls", None)

        _request = build_ingestion_sources_read_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SasTokenIngestionSourceSummary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self,
        ingestion_source: _models.SasTokenIngestionSourceCreation,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.SasTokenIngestionSourceSummary:
        """Create a new ingestion source in a geo-catalog.

        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: ~spatiopackage.models.SasTokenIngestionSourceCreation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SasTokenIngestionSourceSummary. The SasTokenIngestionSourceSummary is compatible with
         MutableMapping
        :rtype: ~spatiopackage.models.SasTokenIngestionSourceSummary
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                ingestion_source = {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "sasToken": "str"
                    },
                    "sourceType": "str"
                }

                # response body for status code(s): 201
                response == {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "expiration": "2020-02-20 00:00:00"
                    },
                    "created": "2020-02-20 00:00:00",
                    "id": "str",
                    "sourceType": "str"
                }
        """

    @overload
    def create(
        self, ingestion_source: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SasTokenIngestionSourceSummary:
        """Create a new ingestion source in a geo-catalog.

        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SasTokenIngestionSourceSummary. The SasTokenIngestionSourceSummary is compatible with
         MutableMapping
        :rtype: ~spatiopackage.models.SasTokenIngestionSourceSummary
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "expiration": "2020-02-20 00:00:00"
                    },
                    "created": "2020-02-20 00:00:00",
                    "id": "str",
                    "sourceType": "str"
                }
        """

    @overload
    def create(
        self, ingestion_source: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SasTokenIngestionSourceSummary:
        """Create a new ingestion source in a geo-catalog.

        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SasTokenIngestionSourceSummary. The SasTokenIngestionSourceSummary is compatible with
         MutableMapping
        :rtype: ~spatiopackage.models.SasTokenIngestionSourceSummary
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "expiration": "2020-02-20 00:00:00"
                    },
                    "created": "2020-02-20 00:00:00",
                    "id": "str",
                    "sourceType": "str"
                }
        """

    @distributed_trace
    def create(
        self, ingestion_source: Union[_models.SasTokenIngestionSourceCreation, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SasTokenIngestionSourceSummary:
        """Create a new ingestion source in a geo-catalog.

        :param ingestion_source: Definition of the ingestion source. Is one of the following types:
         SasTokenIngestionSourceCreation, JSON, IO[bytes] Required.
        :type ingestion_source: ~spatiopackage.models.SasTokenIngestionSourceCreation or JSON or
         IO[bytes]
        :return: SasTokenIngestionSourceSummary. The SasTokenIngestionSourceSummary is compatible with
         MutableMapping
        :rtype: ~spatiopackage.models.SasTokenIngestionSourceSummary
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                ingestion_source = {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "sasToken": "str"
                    },
                    "sourceType": "str"
                }

                # response body for status code(s): 201
                response == {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "expiration": "2020-02-20 00:00:00"
                    },
                    "created": "2020-02-20 00:00:00",
                    "id": "str",
                    "sourceType": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SasTokenIngestionSourceSummary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(ingestion_source, (IOBase, bytes)):
            _content = ingestion_source
        else:
            _content = json.dumps(ingestion_source, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ingestion_sources_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SasTokenIngestionSourceSummary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self,
        id: str,
        ingestion_source: _models.SasTokenIngestionSourceCreation,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.SasTokenIngestionSourceSummary:
        """Update an existing ingestion source in a geo-catalog.

        :param id: Ingestion source id. Required.
        :type id: str
        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: ~spatiopackage.models.SasTokenIngestionSourceCreation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SasTokenIngestionSourceSummary. The SasTokenIngestionSourceSummary is compatible with
         MutableMapping
        :rtype: ~spatiopackage.models.SasTokenIngestionSourceSummary
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                ingestion_source = {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "sasToken": "str"
                    },
                    "sourceType": "str"
                }

                # response body for status code(s): 201, 404
                response == {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "expiration": "2020-02-20 00:00:00"
                    },
                    "created": "2020-02-20 00:00:00",
                    "id": "str",
                    "sourceType": "str"
                }
        """

    @overload
    def update(
        self, id: str, ingestion_source: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SasTokenIngestionSourceSummary:
        """Update an existing ingestion source in a geo-catalog.

        :param id: Ingestion source id. Required.
        :type id: str
        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SasTokenIngestionSourceSummary. The SasTokenIngestionSourceSummary is compatible with
         MutableMapping
        :rtype: ~spatiopackage.models.SasTokenIngestionSourceSummary
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 404
                response == {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "expiration": "2020-02-20 00:00:00"
                    },
                    "created": "2020-02-20 00:00:00",
                    "id": "str",
                    "sourceType": "str"
                }
        """

    @overload
    def update(
        self, id: str, ingestion_source: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SasTokenIngestionSourceSummary:
        """Update an existing ingestion source in a geo-catalog.

        :param id: Ingestion source id. Required.
        :type id: str
        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SasTokenIngestionSourceSummary. The SasTokenIngestionSourceSummary is compatible with
         MutableMapping
        :rtype: ~spatiopackage.models.SasTokenIngestionSourceSummary
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 404
                response == {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "expiration": "2020-02-20 00:00:00"
                    },
                    "created": "2020-02-20 00:00:00",
                    "id": "str",
                    "sourceType": "str"
                }
        """

    @distributed_trace
    def update(
        self, id: str, ingestion_source: Union[_models.SasTokenIngestionSourceCreation, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SasTokenIngestionSourceSummary:
        """Update an existing ingestion source in a geo-catalog.

        :param id: Ingestion source id. Required.
        :type id: str
        :param ingestion_source: Definition of the ingestion source. Is one of the following types:
         SasTokenIngestionSourceCreation, JSON, IO[bytes] Required.
        :type ingestion_source: ~spatiopackage.models.SasTokenIngestionSourceCreation or JSON or
         IO[bytes]
        :return: SasTokenIngestionSourceSummary. The SasTokenIngestionSourceSummary is compatible with
         MutableMapping
        :rtype: ~spatiopackage.models.SasTokenIngestionSourceSummary
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                ingestion_source = {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "sasToken": "str"
                    },
                    "sourceType": "str"
                }

                # response body for status code(s): 201, 404
                response == {
                    "connectionInfo": {
                        "containerUrl": "str",
                        "expiration": "2020-02-20 00:00:00"
                    },
                    "created": "2020-02-20 00:00:00",
                    "id": "str",
                    "sourceType": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SasTokenIngestionSourceSummary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(ingestion_source, (IOBase, bytes)):
            _content = ingestion_source
        else:
            _content = json.dumps(ingestion_source, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ingestion_sources_update_request(
            id=id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.SasTokenIngestionSourceSummary, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.SasTokenIngestionSourceSummary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(self, id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete an ingestion source from a geo-catalog.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_ingestion_sources_delete_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class IngestionGeoTemplatesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`ingestion_geo_templates` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> List[_models.GeoTemplateSummary]:
        """Get ingestion templates in a geo-catalog.

        :return: list of GeoTemplateSummary
        :rtype: list[~spatiopackage.models.GeoTemplateSummary]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "created": "2020-02-20 00:00:00",
                        "displayName": "str",
                        "id": "str",
                        "kind": "str",
                        "version": 0
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.GeoTemplateSummary]] = kwargs.pop("cls", None)

        _request = build_ingestion_geo_templates_list_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.GeoTemplateSummary], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def read(self, id: str, **kwargs: Any) -> _models.GeoTemplate:
        """Get an ingestion template in a geo-catalog.

        :param id: Ingestion template id. Required.
        :type id: str
        :return: GeoTemplate. The GeoTemplate is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoTemplate
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "created": "2020-02-20 00:00:00",
                    "description": "str",
                    "displayName": "str",
                    "id": "str",
                    "kind": "str",
                    "version": 0,
                    "versionComment": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GeoTemplate] = kwargs.pop("cls", None)

        _request = build_ingestion_geo_templates_read_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GeoTemplate, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GeoTemplate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, geo_template: _models.GeoTemplateCreation, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GeoTemplate:
        """Create a new ingestion template in a geo-catalog.

        :param geo_template: Definition of the ingestion template. Required.
        :type geo_template: ~spatiopackage.models.GeoTemplateCreation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoTemplate. The GeoTemplate is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoTemplate
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                geo_template = {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "description": "str",
                    "displayName": "str",
                    "versionComment": "str"
                }

                # response body for status code(s): 201
                response == {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "created": "2020-02-20 00:00:00",
                    "description": "str",
                    "displayName": "str",
                    "id": "str",
                    "kind": "str",
                    "version": 0,
                    "versionComment": "str"
                }
        """

    @overload
    def create(
        self, geo_template: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GeoTemplate:
        """Create a new ingestion template in a geo-catalog.

        :param geo_template: Definition of the ingestion template. Required.
        :type geo_template: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoTemplate. The GeoTemplate is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoTemplate
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "created": "2020-02-20 00:00:00",
                    "description": "str",
                    "displayName": "str",
                    "id": "str",
                    "kind": "str",
                    "version": 0,
                    "versionComment": "str"
                }
        """

    @overload
    def create(
        self, geo_template: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GeoTemplate:
        """Create a new ingestion template in a geo-catalog.

        :param geo_template: Definition of the ingestion template. Required.
        :type geo_template: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoTemplate. The GeoTemplate is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoTemplate
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "created": "2020-02-20 00:00:00",
                    "description": "str",
                    "displayName": "str",
                    "id": "str",
                    "kind": "str",
                    "version": 0,
                    "versionComment": "str"
                }
        """

    @distributed_trace
    def create(
        self, geo_template: Union[_models.GeoTemplateCreation, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.GeoTemplate:
        """Create a new ingestion template in a geo-catalog.

        :param geo_template: Definition of the ingestion template. Is one of the following types:
         GeoTemplateCreation, JSON, IO[bytes] Required.
        :type geo_template: ~spatiopackage.models.GeoTemplateCreation or JSON or IO[bytes]
        :return: GeoTemplate. The GeoTemplate is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoTemplate
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                geo_template = {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "description": "str",
                    "displayName": "str",
                    "versionComment": "str"
                }

                # response body for status code(s): 201
                response == {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "created": "2020-02-20 00:00:00",
                    "description": "str",
                    "displayName": "str",
                    "id": "str",
                    "kind": "str",
                    "version": 0,
                    "versionComment": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GeoTemplate] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(geo_template, (IOBase, bytes)):
            _content = geo_template
        else:
            _content = json.dumps(geo_template, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ingestion_geo_templates_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GeoTemplate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self,
        id: str,
        geo_template: _models.GeoTemplateCreation,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GeoTemplate:
        """Update an existing ingestion template in a geo-catalog.

        :param id: Ingestion template id. Required.
        :type id: str
        :param geo_template: Definition of the ingestion template. Required.
        :type geo_template: ~spatiopackage.models.GeoTemplateCreation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoTemplate. The GeoTemplate is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoTemplate
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                geo_template = {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "description": "str",
                    "displayName": "str",
                    "versionComment": "str"
                }

                # response body for status code(s): 201, 404
                response == {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "created": "2020-02-20 00:00:00",
                    "description": "str",
                    "displayName": "str",
                    "id": "str",
                    "kind": "str",
                    "version": 0,
                    "versionComment": "str"
                }
        """

    @overload
    def update(
        self, id: str, geo_template: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GeoTemplate:
        """Update an existing ingestion template in a geo-catalog.

        :param id: Ingestion template id. Required.
        :type id: str
        :param geo_template: Definition of the ingestion template. Required.
        :type geo_template: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoTemplate. The GeoTemplate is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoTemplate
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 404
                response == {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "created": "2020-02-20 00:00:00",
                    "description": "str",
                    "displayName": "str",
                    "id": "str",
                    "kind": "str",
                    "version": 0,
                    "versionComment": "str"
                }
        """

    @overload
    def update(
        self, id: str, geo_template: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GeoTemplate:
        """Update an existing ingestion template in a geo-catalog.

        :param id: Ingestion template id. Required.
        :type id: str
        :param geo_template: Definition of the ingestion template. Required.
        :type geo_template: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoTemplate. The GeoTemplate is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoTemplate
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 404
                response == {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "created": "2020-02-20 00:00:00",
                    "description": "str",
                    "displayName": "str",
                    "id": "str",
                    "kind": "str",
                    "version": 0,
                    "versionComment": "str"
                }
        """

    @distributed_trace
    def update(
        self, id: str, geo_template: Union[_models.GeoTemplateCreation, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.GeoTemplate:
        """Update an existing ingestion template in a geo-catalog.

        :param id: Ingestion template id. Required.
        :type id: str
        :param geo_template: Definition of the ingestion template. Is one of the following types:
         GeoTemplateCreation, JSON, IO[bytes] Required.
        :type geo_template: ~spatiopackage.models.GeoTemplateCreation or JSON or IO[bytes]
        :return: GeoTemplate. The GeoTemplate is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoTemplate
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                geo_template = {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "description": "str",
                    "displayName": "str",
                    "versionComment": "str"
                }

                # response body for status code(s): 201, 404
                response == {
                    "content": "str",
                    "crawlingStrategy": "str",
                    "created": "2020-02-20 00:00:00",
                    "description": "str",
                    "displayName": "str",
                    "id": "str",
                    "kind": "str",
                    "version": 0,
                    "versionComment": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GeoTemplate] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(geo_template, (IOBase, bytes)):
            _content = geo_template
        else:
            _content = json.dumps(geo_template, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ingestion_geo_templates_update_request(
            id=id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GeoTemplate, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GeoTemplate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(self, id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete an ingestion template from a geo-catalog.

        :param id: Ingestion template id. Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_ingestion_geo_templates_delete_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, collection_id: str, *, _top: int, _skip: Optional[int] = None, **kwargs: Any
    ) -> List[_models.OperationSummary]:
        """Get operations of a geo-catalog collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :keyword _top: Number of items to return. Required.
        :paramtype _top: int
        :keyword _skip: Number of items to skip. Default value is None.
        :paramtype _skip: int
        :return: list of OperationSummary
        :rtype: list[~spatiopackage.models.OperationSummary]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "id": "str",
                        "status": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.OperationSummary]] = kwargs.pop("cls", None)

        _request = build_operations_list_request(
            collection_id=collection_id,
            _top=_top,
            _skip=_skip,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.OperationSummary], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def read(self, collection_id: str, operation_id: str, **kwargs: Any) -> _models.Operation:
        """Get an operation of a geo-catalog collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param operation_id: Operation id. Required.
        :type operation_id: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        _request = build_operations_read_request(
            collection_id=collection_id,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def cancel(  # pylint: disable=inconsistent-return-statements
        self, collection_id: str, operation_id: str, **kwargs: Any
    ) -> None:
        """Cancel a running operation of a geo-catalog collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param operation_id: Operation id. Required.
        :type operation_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_operations_cancel_request(
            collection_id=collection_id,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def cancel_all(self, collection_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Cancel all running operations of a geo-catalog collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_operations_cancel_all_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def download_logs(self, collection_id: str, operation_id: str, **kwargs: Any) -> bytes:
        """Get operation logs.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param operation_id: Operation id. Required.
        :type operation_id: str
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[bytes] = kwargs.pop("cls", None)

        _request = build_operations_download_logs_request(
            collection_id=collection_id,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(bytes, response.json(), format="base64")

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(bytes, response.json(), format="base64")

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class containerOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`container_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def token_api_token_collection_id_get(
        self, collection_id: str, *, duration: Optional[int] = None, **kwargs: Any
    ) -> _models.SASToken:
        """generate a SAS Token for the given Azure Blob storage account and container.

        Generate a `SAS
        Token
        <https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview#how-a-shared-access-signature-works>`_
        for the given storage account and container. The storage account and container
        must be associated with a Planetary Computer dataset indexed by the STAC API.

        :param collection_id: The name of the Collection that the SAS token will be issued for.
         Required.
        :type collection_id: str
        :keyword duration: The duration, in minutes, that the SAS token will be valid. Only valid for
         approved users. Default value is None.
        :paramtype duration: int
        :return: SASToken. The SASToken is compatible with MutableMapping
        :rtype: ~spatiopackage.models.SASToken
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "msft:expiry": "2020-02-20 00:00:00",
                    "token": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SASToken] = kwargs.pop("cls", None)

        _request = build_container_operations_token_api_token_collection_id_get_request(
            collection_id=collection_id,
            duration=duration,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SASToken, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class revokeOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`revoke_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def token_api_token_revoke_post(  # pylint: disable=inconsistent-return-statements
        self, *, duration: Optional[int] = None, **kwargs: Any
    ) -> None:
        """revoke a SAS Token for the given Azure Blob storage account.

        Revoke a `SAS
        Token
        <https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview#how-a-shared-access-signature-works>`_
        for managed storage account of this GeoCatalog.

        :keyword duration: The duration, in minutes, that the SAS token will be valid. Only valid for
         approved users. Default value is None.
        :paramtype duration: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_revoke_operations_token_api_token_revoke_post_request(
            duration=duration,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class signedOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`signed_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def href_api_sign_get(  # pylint: disable=inconsistent-return-statements
        self, *, href: str, duration: Optional[int] = None, **kwargs: Any
    ) -> None:
        """sign an HREF in the format of a URL and returns a SingedLink.

        Signs a HREF (a link URL) by appending a `SAS
        Token
        <https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview#how-a-shared-access-signature-works>`_.
        If the HREF is not a Azure Blob Storage HREF, then pass back the HREF unsigned.

        :keyword href: HREF (URL) to sign. Required.
        :paramtype href: str
        :keyword duration: The duration, in minutes, that the SAS token will be valid. Only valid for
         approved users. Default value is None.
        :paramtype duration: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_signed_operations_href_api_sign_get_request(
            href=href,
            duration=duration,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class LandingOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`landing_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def page_api_get(self, **kwargs: Any) -> _models.LandingPage:
        """Landing Page.

        Endpoint.

        :return: LandingPage. The LandingPage is compatible with MutableMapping
        :rtype: ~spatiopackage.models.LandingPage
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "conformsTo": [
                        "str"
                    ],
                    "description": "str",
                    "id": "str",
                    "links": [
                        {}
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "title": "str",
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LandingPage] = kwargs.pop("cls", None)

        _request = build_landing_operations_page_api_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LandingPage, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ConformanceOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`conformance_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def classes_api_conformance_get(self, **kwargs: Any) -> _models.ConformanceClasses:
        """Conformance Classes.

        Endpoint.

        :return: ConformanceClasses. The ConformanceClasses is compatible with MutableMapping
        :rtype: ~spatiopackage.models.ConformanceClasses
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "conformsTo": [
                        "str"
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ConformanceClasses] = kwargs.pop("cls", None)

        _request = build_conformance_operations_classes_api_conformance_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConformanceClasses, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SearchOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`search_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def api_search_get(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        collections: Optional[str] = None,
        ids: Optional[str] = None,
        bbox: Optional[str] = None,
        intersects: Optional[str] = None,
        datetime: Optional[str] = None,
        limit: Optional[int] = None,
        sign: Optional[bool] = None,
        duration: Optional[int] = None,
        query: Optional[str] = None,
        sortby: Optional[str] = None,
        fields: Optional[str] = None,
        filter: Optional[str] = None,
        token: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Search.

        Endpoint.

        :keyword collections: Default value is None.
        :paramtype collections: str
        :keyword ids: Default value is None.
        :paramtype ids: str
        :keyword bbox: Default value is None.
        :paramtype bbox: str
        :keyword intersects: Default value is None.
        :paramtype intersects: str
        :keyword datetime: Default value is None.
        :paramtype datetime: str
        :keyword limit: Default value is None.
        :paramtype limit: int
        :keyword sign: Default value is None.
        :paramtype sign: bool
        :keyword duration: Default value is None.
        :paramtype duration: int
        :keyword query: Default value is None.
        :paramtype query: str
        :keyword sortby: Default value is None.
        :paramtype sortby: str
        :keyword fields: Default value is None.
        :paramtype fields: str
        :keyword filter: Default value is None.
        :paramtype filter: str
        :keyword token: Default value is None.
        :paramtype token: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/geo+json"] = kwargs.pop("accept", _headers.pop("accept", "application/geo+json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_search_operations_api_search_get_request(
            collections=collections,
            ids=ids,
            bbox=bbox,
            intersects=intersects,
            datetime=datetime,
            limit=limit,
            sign=sign,
            duration=duration,
            query=query,
            sortby=sortby,
            fields=fields,
            filter=filter,
            token=token,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def api_search_post(  # pylint: disable=inconsistent-return-statements
        self, body: _models.SearchPostRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Search.

        Endpoint.

        :param body: Required.
        :type body: ~spatiopackage.models.SearchPostRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "collections": [
                        "str"
                    ],
                    "conf": {
                        "str": {}
                    },
                    "datetime": "str",
                    "duration": 0,
                    "fields": [
                        {
                            "exclude": [
                                "str"
                            ],
                            "include": [
                                "str"
                            ]
                        }
                    ],
                    "filter": {
                        "str": {}
                    },
                    "filter-crs": "str",
                    "filter-lang": "str",
                    "ids": [
                        "str"
                    ],
                    "intersects": {},
                    "limit": 0,
                    "query": {
                        "str": {
                            "str": {}
                        }
                    },
                    "sign": bool,
                    "sortby": [
                        {
                            "direction": "str",
                            "field": "str"
                        }
                    ],
                    "token": "str"
                }
        """

    @overload
    def api_search_post(  # pylint: disable=inconsistent-return-statements
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Search.

        Endpoint.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def api_search_post(  # pylint: disable=inconsistent-return-statements
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Search.

        Endpoint.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def api_search_post(  # pylint: disable=inconsistent-return-statements
        self, body: Union[_models.SearchPostRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        """Search.

        Endpoint.

        :param body: Is one of the following types: SearchPostRequest, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.SearchPostRequest or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "collections": [
                        "str"
                    ],
                    "conf": {
                        "str": {}
                    },
                    "datetime": "str",
                    "duration": 0,
                    "fields": [
                        {
                            "exclude": [
                                "str"
                            ],
                            "include": [
                                "str"
                            ]
                        }
                    ],
                    "filter": {
                        "str": {}
                    },
                    "filter-crs": "str",
                    "filter-lang": "str",
                    "ids": [
                        "str"
                    ],
                    "intersects": {},
                    "limit": 0,
                    "query": {
                        "str": {
                            "str": {}
                        }
                    },
                    "sign": bool,
                    "sortby": [
                        {
                            "direction": "str",
                            "field": "str"
                        }
                    ],
                    "token": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/geo+json"] = kwargs.pop("accept", _headers.pop("accept", "application/geo+json"))
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_search_operations_api_search_post_request(
            accept=accept,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class GetOperationsCollectionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`get_operations_collections` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def collections_api_collections_get(
        self, *, sign: Optional[bool] = None, duration: Optional[int] = None, **kwargs: Any
    ) -> _models.Collections:
        """Get Collections.

        Endpoint.

        :keyword sign: Default value is None.
        :paramtype sign: bool
        :keyword duration: Default value is None.
        :paramtype duration: int
        :return: Collections. The Collections is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Collections
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "collections": [
                        {
                            "description": "str",
                            "extent": {
                                "spatial": {
                                    "bbox": [
                                        [
                                            {}
                                        ]
                                    ]
                                },
                                "temporal": {
                                    "interval": [
                                        [
                                            "str"
                                        ]
                                    ]
                                }
                            },
                            "id": "str",
                            "license": "str",
                            "links": [
                                {}
                            ],
                            "assets": {
                                "str": {
                                    "href": "str",
                                    "constellation": "str",
                                    "created": "2020-02-20 00:00:00",
                                    "description": "str",
                                    "end_datetime": "2020-02-20 00:00:00",
                                    "gsd": 0.0,
                                    "instruments": [
                                        "str"
                                    ],
                                    "mission": "str",
                                    "platform": "str",
                                    "providers": [
                                        {
                                            "name": "str",
                                            "description": "str",
                                            "roles": [
                                                "str"
                                            ],
                                            "url": "str"
                                        }
                                    ],
                                    "roles": [
                                        "str"
                                    ],
                                    "start_datetime": "2020-02-20 00:00:00",
                                    "title": "str",
                                    "type": "str",
                                    "updated": "2020-02-20 00:00:00"
                                }
                            },
                            "keywords": [
                                "str"
                            ],
                            "providers": [
                                {
                                    "name": "str",
                                    "description": "str",
                                    "roles": [
                                        "str"
                                    ],
                                    "url": "str"
                                }
                            ],
                            "stac_extensions": [
                                "str"
                            ],
                            "stac_version": "str",
                            "summaries": {
                                "str": {}
                            },
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Collections] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_collections_api_collections_get_request(
            sign=sign,
            duration=duration,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Collections, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def collection_api_collections_collection_id_get(  # pylint: disable=name-too-long
        self, collection_id: str, *, sign: Optional[bool] = None, duration: Optional[int] = None, **kwargs: Any
    ) -> _models.Collection:
        """Get Collection.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :keyword sign: Default value is None.
        :paramtype sign: bool
        :keyword duration: Default value is None.
        :paramtype duration: int
        :return: Collection. The Collection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "spatial": {
                            "bbox": [
                                [
                                    {}
                                ]
                            ]
                        },
                        "temporal": {
                            "interval": [
                                [
                                    "str"
                                ]
                            ]
                        }
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {}
                    ],
                    "assets": {
                        "str": {
                            "href": "str",
                            "constellation": "str",
                            "created": "2020-02-20 00:00:00",
                            "description": "str",
                            "end_datetime": "2020-02-20 00:00:00",
                            "gsd": 0.0,
                            "instruments": [
                                "str"
                            ],
                            "mission": "str",
                            "platform": "str",
                            "providers": [
                                {
                                    "name": "str",
                                    "description": "str",
                                    "roles": [
                                        "str"
                                    ],
                                    "url": "str"
                                }
                            ],
                            "roles": [
                                "str"
                            ],
                            "start_datetime": "2020-02-20 00:00:00",
                            "title": "str",
                            "type": "str",
                            "updated": "2020-02-20 00:00:00"
                        }
                    },
                    "keywords": [
                        "str"
                    ],
                    "providers": [
                        {
                            "name": "str",
                            "description": "str",
                            "roles": [
                                "str"
                            ],
                            "url": "str"
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "summaries": {
                        "str": {}
                    },
                    "title": "str",
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Collection] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_collection_api_collections_collection_id_get_request(
            collection_id=collection_id,
            sign=sign,
            duration=duration,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Collection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def collection_thumbnail_api_collections_collection_id_thumbnail_get(  # pylint: disable=name-too-long
        self, collection_id: str, **kwargs: Any
    ) -> _models.ImageResponse:
        """Get Collection Thumbnail.

        Get thumbnail for given collection.

        Args:
        request: The incoming request.
        collection_id: The ID of the collection to retrieve assets for.

        Returns:
        thumbnail image.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :return: ImageResponse. The ImageResponse is compatible with MutableMapping
        :rtype: ~spatiopackage.models.ImageResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "url": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ImageResponse] = kwargs.pop("cls", None)

        _request = (
            build_get_operations_collections_collection_thumbnail_api_collections_collection_id_thumbnail_get_request(
                collection_id=collection_id,
                api_version=self._config.api_version,
                headers=_headers,
                params=_params,
            )
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ImageResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def azmaps_token_api_config_map_token_get(self, **kwargs: Any) -> _models.AzMapsToken:
        """Get Azmaps Token.

        Fetch a token for the Azure Maps API service based on the current
        service identity. This token is used for the Explorer to authenticate
        with the Azure Maps API service.

        :return: AzMapsToken. The AzMapsToken is compatible with MutableMapping
        :rtype: ~spatiopackage.models.AzMapsToken
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "expires_on": 0,
                    "token": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AzMapsToken] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_azmaps_token_api_config_map_token_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AzMapsToken, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def azmaps_client_id_api_config_map_id_get(self, **kwargs: Any) -> _models.AzMapsClientId:
        """Get Azmaps Client Id.

        Fetch the client id for the Azure Maps API service based on the current
        on the current identity. This client id is used for the Explorer to
        authenticate with the Azure Maps API service.

        :return: AzMapsClientId. The AzMapsClientId is compatible with MutableMapping
        :rtype: ~spatiopackage.models.AzMapsClientId
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "client_id": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AzMapsClientId] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_azmaps_client_id_api_config_map_id_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AzMapsClientId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def auth_config_api_config_auth_get(self, **kwargs: Any) -> _models.AuthConfig:
        """Get Auth Config.

        Get the app id and tenant id information to make a MSAL request for this
        GeoCatalog instance.

        :return: AuthConfig. The AuthConfig is compatible with MutableMapping
        :rtype: ~spatiopackage.models.AuthConfig
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "authn_app_id": "str",
                    "instance": "str",
                    "tenant_id": "str",
                    "redirect_uri": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AuthConfig] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_auth_config_api_config_auth_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AuthConfig, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def config_api_collections_collection_id_config_get(  # pylint: disable=name-too-long
        self, collection_id: str, **kwargs: Any
    ) -> _models.UserCollectionSettings:
        """Get Config.

        Get the complete user configuration for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :return: UserCollectionSettings. The UserCollectionSettings is compatible with MutableMapping
        :rtype: ~spatiopackage.models.UserCollectionSettings
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "mosaicInfo": {
                        "mosaics": [
                            {
                                "cql": [
                                    {
                                        "str": {}
                                    }
                                ],
                                "id": "str",
                                "name": "str",
                                "description": "str"
                            }
                        ],
                        "renderOptions": [
                            {
                                "id": "str",
                                "name": "str",
                                "conditions": [
                                    {
                                        "property": "str",
                                        "value": {}
                                    }
                                ],
                                "description": "str",
                                "legend": {
                                    "labels": [
                                        "str"
                                    ],
                                    "scaleFactor": 0.0,
                                    "trimEnd": 0,
                                    "trimStart": 0,
                                    "type": "str"
                                },
                                "minZoom": 0,
                                "options": "str",
                                "type": "str",
                                "vectorOptions": {
                                    "sourceLayer": "str",
                                    "tilejsonKey": "str",
                                    "fillColor": "str",
                                    "filter": [
                                        {}
                                    ],
                                    "strokeColor": "str",
                                    "strokeWidth": 0
                                }
                            }
                        ],
                        "defaultCustomQuery": {
                            "str": {}
                        },
                        "defaultLocation": {
                            "coordinates": [
                                0.0
                            ],
                            "zoom": 0
                        }
                    },
                    "tileSettings": {
                        "maxItemsPerTile": 0,
                        "minZoom": 0,
                        "defaultLocation": {
                            "coordinates": [
                                0.0
                            ],
                            "zoom": 0
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UserCollectionSettings] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_config_api_collections_collection_id_config_get_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.UserCollectionSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def collection_mosaics_api_collections_collection_id_config_mosaics_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, **kwargs: Any
    ) -> None:
        """Get Collection Mosaics.

        Get the mosaic definitions for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_collection_mosaics_api_collections_collection_id_config_mosaics_get_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_get(  # pylint: disable=name-too-long
        self, collection_id: str, mosaic_id: str, **kwargs: Any
    ) -> _models.Mosaic:
        """Get Collection Mosaic.

        Get a mosaic definition from a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param mosaic_id: Required.
        :type mosaic_id: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Mosaic] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_get_request(
            collection_id=collection_id,
            mosaic_id=mosaic_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Mosaic, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def collection_render_options_api_collections_collection_id_config_render_options_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, **kwargs: Any
    ) -> None:
        """Get Collection Render Options.

        Get all render options for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_collection_render_options_api_collections_collection_id_config_render_options_get_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def collection_render_option_api_collections_collection_id_config_render_options_render_option_id_get(  # pylint: disable=name-too-long
        self, collection_id: str, render_option_id: str, **kwargs: Any
    ) -> _models.RenderOption:
        """Get Collection Render Option.

        Get a render option for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param render_option_id: Required.
        :type render_option_id: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RenderOption] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_collection_render_option_api_collections_collection_id_config_render_options_render_option_id_get_request(
            collection_id=collection_id,
            render_option_id=render_option_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RenderOption, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def collection_tile_settings_api_collections_collection_id_config_tile_settings_get(  # pylint: disable=name-too-long
        self, collection_id: str, **kwargs: Any
    ) -> _models.TileSettings:
        """Get Collection Tile Settings.

        Get the tile settings for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :return: TileSettings. The TileSettings is compatible with MutableMapping
        :rtype: ~spatiopackage.models.TileSettings
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "maxItemsPerTile": 0,
                    "minZoom": 0,
                    "defaultLocation": {
                        "coordinates": [
                            0.0
                        ],
                        "zoom": 0
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileSettings] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_collection_tile_settings_api_collections_collection_id_config_tile_settings_get_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def partitiontype_api_collections_collection_id_config_partition_type_get(  # pylint: disable=name-too-long
        self, collection_id: str, **kwargs: Any
    ) -> _models.PartitionType:
        """Get Partitiontype.

        Get the partitiontype for a GeoCatalog Collection.

        Args:
        collection_id: the collection id to get the partitiontype for.

        Returns:
        The partitiontype for the collection.

        :param collection_id: Required.
        :type collection_id: str
        :return: PartitionType. The PartitionType is compatible with MutableMapping
        :rtype: ~spatiopackage.models.PartitionType
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "scheme": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PartitionType] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_partitiontype_api_collections_collection_id_config_partition_type_get_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PartitionType, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class CreateOperationsCollectionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`create_operations_collections` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def collection_api_collections_post(
        self, body: _models.GeoCatalogCollection, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Create Collection.

        Add a new collection to the GeoCatalog instance

        Args:
        collection: the collection to create.

        Returns:
        The collection that was created.

        :param body: Required.
        :type body: ~spatiopackage.models.GeoCatalogCollection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """

    @overload
    def collection_api_collections_post(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Create Collection.

        Add a new collection to the GeoCatalog instance

        Args:
        collection: the collection to create.

        Returns:
        The collection that was created.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """

    @overload
    def collection_api_collections_post(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Create Collection.

        Add a new collection to the GeoCatalog instance

        Args:
        collection: the collection to create.

        Returns:
        The collection that was created.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """

    @distributed_trace
    def collection_api_collections_post(
        self, body: Union[_models.GeoCatalogCollection, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Create Collection.

        Add a new collection to the GeoCatalog instance

        Args:
        collection: the collection to create.

        Returns:
        The collection that was created.

        :param body: Is one of the following types: GeoCatalogCollection, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.GeoCatalogCollection or JSON or IO[bytes]
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GeoCatalogCollection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_create_operations_collections_collection_api_collections_post_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200,201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GeoCatalogCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def collection_asset(self, collection_id: str, body: JSON, **kwargs: Any) -> _models.GeoCatalogCollection:
        """Create Collection Asset.

        Create a new asset in the Collection metadata and write the associated
        file to managed storage.

        Args:
        request: The incoming request.
        asset: The Asset object to write, without a valid href to the asset.
        file: The file to write.
        collection_id: The ID of the collection to write the asset to.
        content_type: The content type of the request.

        Returns:
        A Response object containing the newly created asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Required.
        :type body: JSON
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "data": "str",
                    "file": filetype
                }

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """

    @overload
    def collection_asset(
        self, collection_id: str, *, file: bytes, data: str, **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Create Collection Asset.

        Create a new asset in the Collection metadata and write the associated
        file to managed storage.

        Args:
        request: The incoming request.
        asset: The Asset object to write, without a valid href to the asset.
        file: The file to write.
        collection_id: The ID of the collection to write the asset to.
        content_type: The content type of the request.

        Returns:
        A Response object containing the newly created asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :keyword file: Required.
        :paramtype file: bytes
        :keyword data: Required.
        :paramtype data: str
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """

    @distributed_trace
    def collection_asset(
        self, collection_id: str, body: JSON = _Unset, *, file: bytes = _Unset, data: str = _Unset, **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Create Collection Asset.

        Create a new asset in the Collection metadata and write the associated
        file to managed storage.

        Args:
        request: The incoming request.
        asset: The Asset object to write, without a valid href to the asset.
        file: The file to write.
        collection_id: The ID of the collection to write the asset to.
        content_type: The content type of the request.

        Returns:
        A Response object containing the newly created asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Is one of the following types: JSON Required.
        :type body: JSON
        :keyword file: Required.
        :paramtype file: bytes
        :keyword data: Required.
        :paramtype data: str
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "data": "str",
                    "file": filetype
                }

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GeoCatalogCollection] = kwargs.pop("cls", None)

        if body is _Unset:
            if file is _Unset:
                raise TypeError("missing required argument: file")
            if data is _Unset:
                raise TypeError("missing required argument: data")
            body = {"data": data, "file": file}
            body = {k: v for k, v in body.items() if v is not None}
        _body = body.as_dict() if isinstance(body, _model_base.Model) else body
        _file_fields: List[str] = ["file"]
        _data_fields: List[str] = ["data"]
        _files, _data = prepare_multipart_form_data(_body, _file_fields, _data_fields)

        _request = build_create_operations_collections_collection_asset_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            files=_files,
            data=_data,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200,201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GeoCatalogCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def partitiontype_api_collections_collection_id_config_partition_type_put(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, body: _models.PartitionType, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create Partitiontype.

        Updates partition type for a GeoCatalog Collection. This will
        determine the partitioning scheme for items within the database,
        and can only be set before any items are loaded.

        Ideal partitioning schemes result in partitions of roughly 100k items each.

        The default partitioning scheme is "none" which does not partition items.

        Args:
        collection_id: the collection id to add the partitiontype to.
        partitiontype: the partitiontype to add.

        Returns:
        None.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: ~spatiopackage.models.PartitionType
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "scheme": "str"
                }
        """

    @overload
    def partitiontype_api_collections_collection_id_config_partition_type_put(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create Partitiontype.

        Updates partition type for a GeoCatalog Collection. This will
        determine the partitioning scheme for items within the database,
        and can only be set before any items are loaded.

        Ideal partitioning schemes result in partitions of roughly 100k items each.

        The default partitioning scheme is "none" which does not partition items.

        Args:
        collection_id: the collection id to add the partitiontype to.
        partitiontype: the partitiontype to add.

        Returns:
        None.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def partitiontype_api_collections_collection_id_config_partition_type_put(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create Partitiontype.

        Updates partition type for a GeoCatalog Collection. This will
        determine the partitioning scheme for items within the database,
        and can only be set before any items are loaded.

        Ideal partitioning schemes result in partitions of roughly 100k items each.

        The default partitioning scheme is "none" which does not partition items.

        Args:
        collection_id: the collection id to add the partitiontype to.
        partitiontype: the partitiontype to add.

        Returns:
        None.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def partitiontype_api_collections_collection_id_config_partition_type_put(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, body: Union[_models.PartitionType, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        """Create Partitiontype.

        Updates partition type for a GeoCatalog Collection. This will
        determine the partitioning scheme for items within the database,
        and can only be set before any items are loaded.

        Ideal partitioning schemes result in partitions of roughly 100k items each.

        The default partitioning scheme is "none" which does not partition items.

        Args:
        collection_id: the collection id to add the partitiontype to.
        partitiontype: the partitiontype to add.

        Returns:
        None.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Is one of the following types: PartitionType, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.PartitionType or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "scheme": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_create_operations_collections_partitiontype_api_collections_collection_id_config_partition_type_put_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class updateOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`update_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def collection_api_collections_collection_id_put(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        body: _models.GeoCatalogCollection,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GeoCatalogCollection:
        """Update Collection.

        Update a collection in the GeoCatalog instance

        Args:
        collection: the collection to upate.

        Returns:
        The collection that was updated.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: ~spatiopackage.models.GeoCatalogCollection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """

    @overload
    def collection_api_collections_collection_id_put(  # pylint: disable=name-too-long
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Update Collection.

        Update a collection in the GeoCatalog instance

        Args:
        collection: the collection to upate.

        Returns:
        The collection that was updated.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """

    @overload
    def collection_api_collections_collection_id_put(  # pylint: disable=name-too-long
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Update Collection.

        Update a collection in the GeoCatalog instance

        Args:
        collection: the collection to upate.

        Returns:
        The collection that was updated.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """

    @distributed_trace
    def collection_api_collections_collection_id_put(  # pylint: disable=name-too-long
        self, collection_id: str, body: Union[_models.GeoCatalogCollection, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Update Collection.

        Update a collection in the GeoCatalog instance

        Args:
        collection: the collection to upate.

        Returns:
        The collection that was updated.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Is one of the following types: GeoCatalogCollection, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.GeoCatalogCollection or JSON or IO[bytes]
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GeoCatalogCollection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_update_operations_collection_api_collections_collection_id_put_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GeoCatalogCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def collection_asset(
        self, collection_id: str, asset_id: str, body: JSON, **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Update Collection Asset.

        Update an existing asset in a given collection.

        Args:
        request: The incoming request.
        asset: The Asset object to update.
        file: The file to update (optional).
        collection_id: The ID of the collection to update the asset in.
        asset_id: The ID of the asset to update.
        content_type: The content type of the request.

        Returns:
        A Response object containing the updated asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param asset_id: STAC Asset ID. Required.
        :type asset_id: str
        :param body: Required.
        :type body: JSON
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "data": "str",
                    "file": filetype
                }

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """

    @overload
    def collection_asset(
        self, collection_id: str, asset_id: str, *, data: str, file: Optional[bytes] = None, **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Update Collection Asset.

        Update an existing asset in a given collection.

        Args:
        request: The incoming request.
        asset: The Asset object to update.
        file: The file to update (optional).
        collection_id: The ID of the collection to update the asset in.
        asset_id: The ID of the asset to update.
        content_type: The content type of the request.

        Returns:
        A Response object containing the updated asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param asset_id: STAC Asset ID. Required.
        :type asset_id: str
        :keyword data: Required.
        :paramtype data: str
        :keyword file: Default value is None.
        :paramtype file: bytes
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """

    @distributed_trace
    def collection_asset(
        self,
        collection_id: str,
        asset_id: str,
        body: JSON = _Unset,
        *,
        data: str = _Unset,
        file: Optional[bytes] = None,
        **kwargs: Any,
    ) -> _models.GeoCatalogCollection:
        """Update Collection Asset.

        Update an existing asset in a given collection.

        Args:
        request: The incoming request.
        asset: The Asset object to update.
        file: The file to update (optional).
        collection_id: The ID of the collection to update the asset in.
        asset_id: The ID of the asset to update.
        content_type: The content type of the request.

        Returns:
        A Response object containing the updated asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param asset_id: STAC Asset ID. Required.
        :type asset_id: str
        :param body: Is one of the following types: JSON Required.
        :type body: JSON
        :keyword data: Required.
        :paramtype data: str
        :keyword file: Default value is None.
        :paramtype file: bytes
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "data": "str",
                    "file": filetype
                }

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GeoCatalogCollection] = kwargs.pop("cls", None)

        if body is _Unset:
            if data is _Unset:
                raise TypeError("missing required argument: data")
            body = {"data": data, "file": file}
            body = {k: v for k, v in body.items() if v is not None}
        _body = body.as_dict() if isinstance(body, _model_base.Model) else body
        _file_fields: List[str] = ["file"]
        _data_fields: List[str] = ["data"]
        _files, _data = prepare_multipart_form_data(_body, _file_fields, _data_fields)

        _request = build_update_operations_collection_asset_request(
            collection_id=collection_id,
            asset_id=asset_id,
            api_version=self._config.api_version,
            files=_files,
            data=_data,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GeoCatalogCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def collection_queryables_api_collections_collection_id_queryables_queryable_name_put(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        queryable_name: str,
        body: _models.QueryableDefinition,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.QueryableDefinition:
        """Update Collection Queryables.

        Updates a queryable given a queryable definition and
        corresponding collection id.

        :param collection_id: Required.
        :type collection_id: str
        :param queryable_name: Required.
        :type queryable_name: str
        :param body: Required.
        :type body: ~spatiopackage.models.QueryableDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryableDefinition. The QueryableDefinition is compatible with MutableMapping
        :rtype: ~spatiopackage.models.QueryableDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "str": {}
                    },
                    "name": "str",
                    "create_index": bool,
                    "data_type": "str"
                }

                # response body for status code(s): 200
                response == {
                    "definition": {
                        "str": {}
                    },
                    "name": "str",
                    "create_index": bool,
                    "data_type": "str"
                }
        """

    @overload
    def collection_queryables_api_collections_collection_id_queryables_queryable_name_put(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        queryable_name: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.QueryableDefinition:
        """Update Collection Queryables.

        Updates a queryable given a queryable definition and
        corresponding collection id.

        :param collection_id: Required.
        :type collection_id: str
        :param queryable_name: Required.
        :type queryable_name: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryableDefinition. The QueryableDefinition is compatible with MutableMapping
        :rtype: ~spatiopackage.models.QueryableDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "definition": {
                        "str": {}
                    },
                    "name": "str",
                    "create_index": bool,
                    "data_type": "str"
                }
        """

    @overload
    def collection_queryables_api_collections_collection_id_queryables_queryable_name_put(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        queryable_name: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.QueryableDefinition:
        """Update Collection Queryables.

        Updates a queryable given a queryable definition and
        corresponding collection id.

        :param collection_id: Required.
        :type collection_id: str
        :param queryable_name: Required.
        :type queryable_name: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryableDefinition. The QueryableDefinition is compatible with MutableMapping
        :rtype: ~spatiopackage.models.QueryableDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "definition": {
                        "str": {}
                    },
                    "name": "str",
                    "create_index": bool,
                    "data_type": "str"
                }
        """

    @distributed_trace
    def collection_queryables_api_collections_collection_id_queryables_queryable_name_put(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        queryable_name: str,
        body: Union[_models.QueryableDefinition, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> _models.QueryableDefinition:
        """Update Collection Queryables.

        Updates a queryable given a queryable definition and
        corresponding collection id.

        :param collection_id: Required.
        :type collection_id: str
        :param queryable_name: Required.
        :type queryable_name: str
        :param body: Is one of the following types: QueryableDefinition, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.QueryableDefinition or JSON or IO[bytes]
        :return: QueryableDefinition. The QueryableDefinition is compatible with MutableMapping
        :rtype: ~spatiopackage.models.QueryableDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "str": {}
                    },
                    "name": "str",
                    "create_index": bool,
                    "data_type": "str"
                }

                # response body for status code(s): 200
                response == {
                    "definition": {
                        "str": {}
                    },
                    "name": "str",
                    "create_index": bool,
                    "data_type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.QueryableDefinition] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_update_operations_collection_queryables_api_collections_collection_id_queryables_queryable_name_put_request(
            collection_id=collection_id,
            queryable_name=queryable_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.QueryableDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_put(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        mosaic_id: str,
        body: _models.Mosaic,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Mosaic:
        """Update Collection Mosaic.

        Update a mosaic definition from a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param mosaic_id: Required.
        :type mosaic_id: str
        :param body: Required.
        :type body: ~spatiopackage.models.Mosaic
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }

                # response body for status code(s): 200
                response == {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }
        """

    @overload
    def collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_put(  # pylint: disable=name-too-long
        self, collection_id: str, mosaic_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Mosaic:
        """Update Collection Mosaic.

        Update a mosaic definition from a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param mosaic_id: Required.
        :type mosaic_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }
        """

    @overload
    def collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_put(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        mosaic_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Mosaic:
        """Update Collection Mosaic.

        Update a mosaic definition from a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param mosaic_id: Required.
        :type mosaic_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }
        """

    @distributed_trace
    def collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_put(  # pylint: disable=name-too-long
        self, collection_id: str, mosaic_id: str, body: Union[_models.Mosaic, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.Mosaic:
        """Update Collection Mosaic.

        Update a mosaic definition from a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param mosaic_id: Required.
        :type mosaic_id: str
        :param body: Is one of the following types: Mosaic, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.Mosaic or JSON or IO[bytes]
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }

                # response body for status code(s): 200
                response == {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Mosaic] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_update_operations_collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_put_request(
            collection_id=collection_id,
            mosaic_id=mosaic_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Mosaic, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def collection_render_option_api_collections_collection_id_config_render_options_render_option_id_put(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        render_option_id: str,
        body: _models.RenderOption,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RenderOption:
        """Update Collection Render Option.

        Update a render option for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param render_option_id: Required.
        :type render_option_id: str
        :param body: Required.
        :type body: ~spatiopackage.models.RenderOption
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }
        """

    @overload
    def collection_render_option_api_collections_collection_id_config_render_options_render_option_id_put(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        render_option_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RenderOption:
        """Update Collection Render Option.

        Update a render option for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param render_option_id: Required.
        :type render_option_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }
        """

    @overload
    def collection_render_option_api_collections_collection_id_config_render_options_render_option_id_put(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        render_option_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RenderOption:
        """Update Collection Render Option.

        Update a render option for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param render_option_id: Required.
        :type render_option_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }
        """

    @distributed_trace
    def collection_render_option_api_collections_collection_id_config_render_options_render_option_id_put(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        render_option_id: str,
        body: Union[_models.RenderOption, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> _models.RenderOption:
        """Update Collection Render Option.

        Update a render option for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param render_option_id: Required.
        :type render_option_id: str
        :param body: Is one of the following types: RenderOption, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.RenderOption or JSON or IO[bytes]
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RenderOption] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_update_operations_collection_render_option_api_collections_collection_id_config_render_options_render_option_id_put_request(
            collection_id=collection_id,
            render_option_id=render_option_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RenderOption, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def collection_tile_settings_api_collections_collection_id_config_tile_settings_put(  # pylint: disable=name-too-long
        self, collection_id: str, body: _models.TileSettings, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TileSettings:
        """Update Collection Tile Settings.

        Update the tile settings for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: ~spatiopackage.models.TileSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TileSettings. The TileSettings is compatible with MutableMapping
        :rtype: ~spatiopackage.models.TileSettings
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "maxItemsPerTile": 0,
                    "minZoom": 0,
                    "defaultLocation": {
                        "coordinates": [
                            0.0
                        ],
                        "zoom": 0
                    }
                }

                # response body for status code(s): 200
                response == {
                    "maxItemsPerTile": 0,
                    "minZoom": 0,
                    "defaultLocation": {
                        "coordinates": [
                            0.0
                        ],
                        "zoom": 0
                    }
                }
        """

    @overload
    def collection_tile_settings_api_collections_collection_id_config_tile_settings_put(  # pylint: disable=name-too-long
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TileSettings:
        """Update Collection Tile Settings.

        Update the tile settings for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TileSettings. The TileSettings is compatible with MutableMapping
        :rtype: ~spatiopackage.models.TileSettings
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "maxItemsPerTile": 0,
                    "minZoom": 0,
                    "defaultLocation": {
                        "coordinates": [
                            0.0
                        ],
                        "zoom": 0
                    }
                }
        """

    @overload
    def collection_tile_settings_api_collections_collection_id_config_tile_settings_put(  # pylint: disable=name-too-long
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TileSettings:
        """Update Collection Tile Settings.

        Update the tile settings for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TileSettings. The TileSettings is compatible with MutableMapping
        :rtype: ~spatiopackage.models.TileSettings
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "maxItemsPerTile": 0,
                    "minZoom": 0,
                    "defaultLocation": {
                        "coordinates": [
                            0.0
                        ],
                        "zoom": 0
                    }
                }
        """

    @distributed_trace
    def collection_tile_settings_api_collections_collection_id_config_tile_settings_put(  # pylint: disable=name-too-long
        self, collection_id: str, body: Union[_models.TileSettings, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.TileSettings:
        """Update Collection Tile Settings.

        Update the tile settings for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Is one of the following types: TileSettings, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.TileSettings or JSON or IO[bytes]
        :return: TileSettings. The TileSettings is compatible with MutableMapping
        :rtype: ~spatiopackage.models.TileSettings
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "maxItemsPerTile": 0,
                    "minZoom": 0,
                    "defaultLocation": {
                        "coordinates": [
                            0.0
                        ],
                        "zoom": 0
                    }
                }

                # response body for status code(s): 200
                response == {
                    "maxItemsPerTile": 0,
                    "minZoom": 0,
                    "defaultLocation": {
                        "coordinates": [
                            0.0
                        ],
                        "zoom": 0
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.TileSettings] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_update_operations_collection_tile_settings_api_collections_collection_id_config_tile_settings_put_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class deleteOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`delete_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def collection_api_collections_collection_id_delete(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, **kwargs: Any
    ) -> None:
        """Delete Collection.

        Delete a collection from the GeoCatalog instance

        Args:
        collection_id: the collection id to delete.

        :param collection_id: Required.
        :type collection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_operations_collection_api_collections_collection_id_delete_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def collection_asset_api_collections_collection_id_assets_asset_id_delete(  # pylint: disable=name-too-long
        self, collection_id: str, asset_id: str, **kwargs: Any
    ) -> _models.GeoCatalogCollection:
        """Delete Collection Asset.

        Delete an asset from a given collection.

        Args:
        request: The incoming request.
        collection_id: The ID of the collection to delete the asset from.
        asset_id: The ID of the asset to delete.

        Returns:
        A Response object indicating the success of the deletion.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param asset_id: STAC Asset ID. Required.
        :type asset_id: str
        :return: GeoCatalogCollection. The GeoCatalogCollection is compatible with MutableMapping
        :rtype: ~spatiopackage.models.GeoCatalogCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "description": "str",
                    "extent": {
                        "str": {}
                    },
                    "id": "str",
                    "license": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_version": "str",
                    "type": "str",
                    "assets": {
                        "str": {}
                    },
                    "keywords": [
                        "str"
                    ],
                    "msft:short_description": "str",
                    "providers": [
                        {
                            "str": {}
                        }
                    ],
                    "stac_extensions": [
                        "str"
                    ],
                    "summaries": {
                        "str": {}
                    },
                    "title": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GeoCatalogCollection] = kwargs.pop("cls", None)

        _request = (
            build_delete_operations_collection_asset_api_collections_collection_id_assets_asset_id_delete_request(
                collection_id=collection_id,
                asset_id=asset_id,
                api_version=self._config.api_version,
                headers=_headers,
                params=_params,
            )
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GeoCatalogCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def queryables_api_collections_collection_id_queryables_queryable_name_delete(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, queryable_name: str, **kwargs: Any
    ) -> None:
        """Delete Queryables.

        Delete queryables by name for specified collection.

        :param collection_id: Required.
        :type collection_id: str
        :param queryable_name: Required.
        :type queryable_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = (
            build_delete_operations_queryables_api_collections_collection_id_queryables_queryable_name_delete_request(
                collection_id=collection_id,
                queryable_name=queryable_name,
                api_version=self._config.api_version,
                headers=_headers,
                params=_params,
            )
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_delete(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, mosaic_id: str, **kwargs: Any
    ) -> None:
        """Delete Collection Mosaic.

        Delete a mosaic definition from a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param mosaic_id: Required.
        :type mosaic_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_operations_collection_mosaic_api_collections_collection_id_config_mosaics_mosaic_id_delete_request(
            collection_id=collection_id,
            mosaic_id=mosaic_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def collection_render_option_api_collections_collection_id_config_render_options_render_option_id_delete(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, render_option_id: str, **kwargs: Any
    ) -> None:
        """Delete Collection Render Option.

        Delete a render option for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param render_option_id: Required.
        :type render_option_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_operations_collection_render_option_api_collections_collection_id_config_render_options_render_option_id_delete_request(
            collection_id=collection_id,
            render_option_id=render_option_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class QueryablesOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`queryables_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def api_queryables_get(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Queryables.

        Endpoint.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_queryables_operations_api_queryables_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class CollectionOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`collection_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def queryables_api_collections_collection_id_queryables_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, **kwargs: Any
    ) -> None:
        """Collection Queryables.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_collection_operations_queryables_api_collections_collection_id_queryables_get_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class setOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`set_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def collection_queryables_api_collections_collection_id_queryables_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        body: List[_models.QueryableDefinition],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Set Collection Queryables.

        Set queryables for a collection given a list of queryable definitions.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: list[~spatiopackage.models.QueryableDefinition]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = [
                    {
                        "definition": {
                            "str": {}
                        },
                        "name": "str",
                        "create_index": bool,
                        "data_type": "str"
                    }
                ]
        """

    @overload
    def collection_queryables_api_collections_collection_id_queryables_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Set Collection Queryables.

        Set queryables for a collection given a list of queryable definitions.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def collection_queryables_api_collections_collection_id_queryables_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, body: Union[List[_models.QueryableDefinition], IO[bytes]], **kwargs: Any
    ) -> None:
        """Set Collection Queryables.

        Set queryables for a collection given a list of queryable definitions.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Is either a [QueryableDefinition] type or a IO[bytes] type. Required.
        :type body: list[~spatiopackage.models.QueryableDefinition] or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_set_operations_collection_queryables_api_collections_collection_id_queryables_post_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class addOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`add_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def collection_mosaic_api_collections_collection_id_config_mosaics_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: _models.Mosaic, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Mosaic:
        """Add Collection Mosaic.

        Add a mosaic definition to a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: ~spatiopackage.models.Mosaic
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }

                # response body for status code(s): 200
                response == {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }
        """

    @overload
    def collection_mosaic_api_collections_collection_id_config_mosaics_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Mosaic:
        """Add Collection Mosaic.

        Add a mosaic definition to a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }
        """

    @overload
    def collection_mosaic_api_collections_collection_id_config_mosaics_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Mosaic:
        """Add Collection Mosaic.

        Add a mosaic definition to a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }
        """

    @distributed_trace
    def collection_mosaic_api_collections_collection_id_config_mosaics_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: Union[_models.Mosaic, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.Mosaic:
        """Add Collection Mosaic.

        Add a mosaic definition to a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Is one of the following types: Mosaic, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.Mosaic or JSON or IO[bytes]
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }

                # response body for status code(s): 200
                response == {
                    "cql": [
                        {
                            "str": {}
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "description": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Mosaic] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_add_operations_collection_mosaic_api_collections_collection_id_config_mosaics_post_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Mosaic, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def collection_render_option_api_collections_collection_id_config_render_options_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: _models.RenderOption, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RenderOption:
        """Add Collection Render Option.

        Add a render option for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: ~spatiopackage.models.RenderOption
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }
        """

    @overload
    def collection_render_option_api_collections_collection_id_config_render_options_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RenderOption:
        """Add Collection Render Option.

        Add a render option for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }
        """

    @overload
    def collection_render_option_api_collections_collection_id_config_render_options_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RenderOption:
        """Add Collection Render Option.

        Add a render option for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }
        """

    @distributed_trace
    def collection_render_option_api_collections_collection_id_config_render_options_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: Union[_models.RenderOption, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.RenderOption:
        """Add Collection Render Option.

        Add a render option for a given collection.

        :param collection_id: Required.
        :type collection_id: str
        :param body: Is one of the following types: RenderOption, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.RenderOption or JSON or IO[bytes]
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "conditions": [
                        {
                            "property": "str",
                            "value": {}
                        }
                    ],
                    "description": "str",
                    "legend": {
                        "labels": [
                            "str"
                        ],
                        "scaleFactor": 0.0,
                        "trimEnd": 0,
                        "trimStart": 0,
                        "type": "str"
                    },
                    "minZoom": 0,
                    "options": "str",
                    "type": "str",
                    "vectorOptions": {
                        "sourceLayer": "str",
                        "tilejsonKey": "str",
                        "fillColor": "str",
                        "filter": [
                            {}
                        ],
                        "strokeColor": "str",
                        "strokeWidth": 0
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RenderOption] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_add_operations_collection_render_option_api_collections_collection_id_config_render_options_post_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RenderOption, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class boundsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`bounds_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def api_collections_collection_id_items_item_id_bounds_get(  # pylint: disable=name-too-long
        self, collection_id: str, item_id: str, **kwargs: Any
    ) -> _models.Bounds:
        """Bounds.

        Bounds.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :return: Bounds. The Bounds is compatible with MutableMapping
        :rtype: ~spatiopackage.models.Bounds
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bounds": [
                        {}
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Bounds] = kwargs.pop("cls", None)

        _request = build_bounds_operations_api_collections_collection_id_items_item_id_bounds_get_request(
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Bounds, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class infoOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`info_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def api_collections_collection_id_items_item_id_info_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, item_id: str, *, assets: Optional[List[str]] = None, **kwargs: Any
    ) -> None:
        """Info.

        Return dataset's basic info.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_info_operations_api_collections_collection_id_items_item_id_info_get_request(
            collection_id=collection_id,
            item_id=item_id,
            assets=assets,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def geojson_api_collections_collection_id_items_item_id_info_geojson_get(  # pylint: disable=name-too-long
        self, collection_id: str, item_id: str, *, assets: Optional[List[str]] = None, **kwargs: Any
    ) -> _models.FeaturePolygonDictStrRioTilerModelsInfo:
        """Info Geojson.

        Info Geojson.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :return: FeaturePolygonDictStrRioTilerModelsInfo. The FeaturePolygonDictStrRioTilerModelsInfo
         is compatible with MutableMapping
        :rtype: ~spatiopackage.models.FeaturePolygonDictStrRioTilerModelsInfo
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "geometry": {
                        "coordinates": [
                            [
                                {}
                            ]
                        ],
                        "type": "str",
                        "bbox": {}
                    },
                    "properties": {
                        "str": {
                            "band_descriptions": [
                                [
                                    "str"
                                ]
                            ],
                            "band_metadata": [
                                [
                                    "str"
                                ]
                            ],
                            "bounds": [
                                {}
                            ],
                            "dtype": "str",
                            "maxzoom": 0,
                            "minzoom": 0,
                            "nodata_type": "str",
                            "colorinterp": [
                                "str"
                            ],
                            "colormap": {
                                "str": [
                                    0
                                ]
                            },
                            "offset": 0.0,
                            "scale": 0.0
                        }
                    },
                    "type": "str",
                    "bbox": {},
                    "id": {}
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/geo+json"] = kwargs.pop("accept", _headers.pop("accept", "application/geo+json"))
        cls: ClsType[_models.FeaturePolygonDictStrRioTilerModelsInfo] = kwargs.pop("cls", None)

        _request = build_info_operations_geojson_api_collections_collection_id_items_item_id_info_geojson_get_request(
            collection_id=collection_id,
            item_id=item_id,
            assets=assets,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FeaturePolygonDictStrRioTilerModelsInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def search_api_mosaic_searchid_info_get(self, searchid: str, **kwargs: Any) -> _models.TitilerPgstacModelInfo:
        """Info Search.

        Get Search query metadata.

        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :return: TitilerPgstacModelInfo. The TitilerPgstacModelInfo is compatible with MutableMapping
        :rtype: ~spatiopackage.models.TitilerPgstacModelInfo
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "search": {
                        "_where": "str",
                        "hash": "str",
                        "lastused": "2020-02-20 00:00:00",
                        "metadata": {
                            "assets": [
                                "str"
                            ],
                            "bounds": {},
                            "defaults": {
                                "str": {}
                            },
                            "maxzoom": 0,
                            "minzoom": 0,
                            "name": "str",
                            "type": "str"
                        },
                        "orderby": "str",
                        "search": {
                            "str": {}
                        },
                        "usecount": 0
                    },
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TitilerPgstacModelInfo] = kwargs.pop("cls", None)

        _request = build_info_operations_search_api_mosaic_searchid_info_get_request(
            searchid=searchid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TitilerPgstacModelInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class availableOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`available_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def assets_api_collections_collection_id_items_item_id_assets_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, item_id: str, **kwargs: Any
    ) -> None:
        """Available Assets.

        Return a list of supported assets.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_available_operations_assets_api_collections_collection_id_items_item_id_assets_get_request(
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class assetOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`asset_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def statistics_api_collections_collection_id_items_item_id_asset_statistics_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        *,
        assets: Optional[List[str]] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_expression: Optional[List[str]] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Asset Statistics.

        Per Asset statistics.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_expression: Per asset band expression. Default value is None.
        :paramtype asset_expression: list[str]
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = (
            build_asset_operations_statistics_api_collections_collection_id_items_item_id_asset_statistics_get_request(
                collection_id=collection_id,
                item_id=item_id,
                assets=assets,
                asset_bidx=asset_bidx,
                asset_expression=asset_expression,
                nodata=nodata,
                unscale=unscale,
                resampling=resampling,
                max_size=max_size,
                height=height,
                width=width,
                categorical=categorical,
                c=c,
                p=p,
                histogram_bins=histogram_bins,
                histogram_range=histogram_range,
                api_version=self._config.api_version,
                headers=_headers,
                params=_params,
            )
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class statisticsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`statistics_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def api_collections_collection_id_items_item_id_statistics_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Statistics.

        Merged assets statistics.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_statistics_operations_api_collections_collection_id_items_item_id_statistics_get_request(
            collection_id=collection_id,
            item_id=item_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            categorical=categorical,
            c=c,
            p=p,
            histogram_bins=histogram_bins,
            histogram_range=histogram_range,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class geojsonOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`geojson_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def statistics_api_collections_collection_id_items_item_id_statistics_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: _models.Geojson,
        *,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Required.
        :type body: ~spatiopackage.models.Geojson
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """

    @overload
    def statistics_api_collections_collection_id_items_item_id_statistics_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: JSON,
        *,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Required.
        :type body: JSON
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def statistics_api_collections_collection_id_items_item_id_statistics_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: IO[bytes],
        *,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def statistics_api_collections_collection_id_items_item_id_statistics_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: Union[_models.Geojson, JSON, IO[bytes]],
        *,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Is one of the following types: Geojson, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.Geojson or JSON or IO[bytes]
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/geo+json, application/json"] = kwargs.pop(
            "accept", _headers.pop("accept", "application/geo+json, application/json")
        )
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = (
            build_geojson_operations_statistics_api_collections_collection_id_items_item_id_statistics_post_request(
                collection_id=collection_id,
                item_id=item_id,
                coord_crs=coord_crs,
                assets=assets,
                expression=expression,
                asset_bidx=asset_bidx,
                asset_as_band=asset_as_band,
                nodata=nodata,
                unscale=unscale,
                resampling=resampling,
                max_size=max_size,
                height=height,
                width=width,
                categorical=categorical,
                c=c,
                p=p,
                histogram_bins=histogram_bins,
                histogram_range=histogram_range,
                accept=accept,
                content_type=content_type,
                api_version=self._config.api_version,
                content=_content,
                headers=_headers,
                params=_params,
            )
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def crop_api_collections_collection_id_items_item_id_crop_width_x_height_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        height: int,
        width: int,
        body: _models.Geojson,
        *,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param height: Required.
        :type height: int
        :param width: Required.
        :type width: int
        :param body: Required.
        :type body: ~spatiopackage.models.Geojson
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """

    @overload
    def crop_api_collections_collection_id_items_item_id_crop_width_x_height_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        height: int,
        width: int,
        body: JSON,
        *,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param height: Required.
        :type height: int
        :param width: Required.
        :type width: int
        :param body: Required.
        :type body: JSON
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def crop_api_collections_collection_id_items_item_id_crop_width_x_height_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        height: int,
        width: int,
        body: IO[bytes],
        *,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param height: Required.
        :type height: int
        :param width: Required.
        :type width: int
        :param body: Required.
        :type body: IO[bytes]
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def crop_api_collections_collection_id_items_item_id_crop_width_x_height_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        height: int,
        width: int,
        body: Union[_models.Geojson, JSON, IO[bytes]],
        *,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param height: Required.
        :type height: int
        :param width: Required.
        :type width: int
        :param body: Is one of the following types: Geojson, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.Geojson or JSON or IO[bytes]
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_geojson_operations_crop_api_collections_collection_id_items_item_id_crop_width_x_height_format_post_request(
            format=format,
            collection_id=collection_id,
            item_id=item_id,
            height=height,
            width=width,
            color_formula=color_formula,
            coord_crs=coord_crs,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def crop_api_collections_collection_id_items_item_id_crop_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        body: _models.Geojson,
        *,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Required.
        :type body: ~spatiopackage.models.Geojson
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """

    @overload
    def crop_api_collections_collection_id_items_item_id_crop_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        body: JSON,
        *,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Required.
        :type body: JSON
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def crop_api_collections_collection_id_items_item_id_crop_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        body: IO[bytes],
        *,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def crop_api_collections_collection_id_items_item_id_crop_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        body: Union[_models.Geojson, JSON, IO[bytes]],
        *,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Is one of the following types: Geojson, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.Geojson or JSON or IO[bytes]
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_geojson_operations_crop_api_collections_collection_id_items_item_id_crop_format_post_request(
            format=format,
            collection_id=collection_id,
            item_id=item_id,
            color_formula=color_formula,
            coord_crs=coord_crs,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def crop_api_collections_collection_id_items_item_id_crop_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: _models.Geojson,
        *,
        format: Optional[Union[str, _models.ImageType]] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Required.
        :type body: ~spatiopackage.models.Geojson
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """

    @overload
    def crop_api_collections_collection_id_items_item_id_crop_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: JSON,
        *,
        format: Optional[Union[str, _models.ImageType]] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Required.
        :type body: JSON
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def crop_api_collections_collection_id_items_item_id_crop_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: IO[bytes],
        *,
        format: Optional[Union[str, _models.ImageType]] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def crop_api_collections_collection_id_items_item_id_crop_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: Union[_models.Geojson, JSON, IO[bytes]],
        *,
        format: Optional[Union[str, _models.ImageType]] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Is one of the following types: Geojson, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.Geojson or JSON or IO[bytes]
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_geojson_operations_crop_api_collections_collection_id_items_item_id_crop_post_request(
            collection_id=collection_id,
            item_id=item_id,
            format=format,
            color_formula=color_formula,
            coord_crs=coord_crs,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class tileOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`tile_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_scale_x_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        scale: int,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        *,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param scale: Required.
        :type scale: int
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_scale_x_format_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            format=format,
            collection_id=collection_id,
            item_id=item_id,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_scale_x_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        scale: int,
        collection_id: str,
        item_id: str,
        *,
        format: Optional[Union[str, _models.ImageType]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param scale: Required.
        :type scale: int
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_scale_x_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            collection_id=collection_id,
            item_id=item_id,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        *,
        scale: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword scale: Default value is None.
        :paramtype scale: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_format_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            format=format,
            collection_id=collection_id,
            item_id=item_id,
            scale=scale,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        collection_id: str,
        item_id: str,
        *,
        scale: Optional[int] = None,
        format: Optional[Union[str, _models.ImageType]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword scale: Default value is None.
        :paramtype scale: int
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_collections_collection_id_items_item_id_tiles_tile_matrix_set_id_z_x_y_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            collection_id=collection_id,
            item_id=item_id,
            scale=scale,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_collections_collection_id_items_item_id_tiles_z_x_y_scale_x_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        scale: int,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :param scale: Required.
        :type scale: int
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = (
            build_tile_operations_api_collections_collection_id_items_item_id_tiles_z_x_y_scale_x_format_get_request(
                z=z,
                x=x,
                y=y,
                scale=scale,
                format=format,
                collection_id=collection_id,
                item_id=item_id,
                tile_matrix_set_id=tile_matrix_set_id,
                buffer=buffer,
                color_formula=color_formula,
                assets=assets,
                expression=expression,
                asset_bidx=asset_bidx,
                asset_as_band=asset_as_band,
                nodata=nodata,
                unscale=unscale,
                resampling=resampling,
                algorithm=algorithm,
                algorithm_params=algorithm_params,
                rescale=rescale,
                colormap_name=colormap_name,
                colormap=colormap,
                return_mask=return_mask,
                api_version=self._config.api_version,
                headers=_headers,
                params=_params,
            )
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_collections_collection_id_items_item_id_tiles_z_x_y_scale_x_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        scale: int,
        collection_id: str,
        item_id: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        format: Optional[Union[str, _models.ImageType]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :param scale: Required.
        :type scale: int
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_collections_collection_id_items_item_id_tiles_z_x_y_scale_x_get_request(
            z=z,
            x=x,
            y=y,
            scale=scale,
            collection_id=collection_id,
            item_id=item_id,
            tile_matrix_set_id=tile_matrix_set_id,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_collections_collection_id_items_item_id_tiles_z_x_y_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        scale: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword scale: Default value is None.
        :paramtype scale: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_collections_collection_id_items_item_id_tiles_z_x_y_format_get_request(
            z=z,
            x=x,
            y=y,
            format=format,
            collection_id=collection_id,
            item_id=item_id,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_collections_collection_id_items_item_id_tiles_z_x_y_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        collection_id: str,
        item_id: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        scale: Optional[int] = None,
        format: Optional[Union[str, _models.ImageType]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword scale: Default value is None.
        :paramtype scale: int
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_collections_collection_id_items_item_id_tiles_z_x_y_get_request(
            z=z,
            x=x,
            y=y,
            collection_id=collection_id,
            item_id=item_id,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_scale_x_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        scale: int,
        format: Union[str, _models.ImageType],
        searchid: str,
        z: int,
        x: int,
        y: int,
        *,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param scale: Required.
        :type scale: int
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~spatiopackage.models.PixelSelection
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_scale_x_format_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            format=format,
            searchid=searchid,
            z=z,
            x=x,
            y=y,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            pixel_selection=pixel_selection,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_scale_x_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        scale: int,
        searchid: str,
        z: int,
        x: int,
        y: int,
        *,
        format: Optional[Union[str, _models.ImageType]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param scale: Required.
        :type scale: int
        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~spatiopackage.models.PixelSelection
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_scale_x_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            searchid=searchid,
            z=z,
            x=x,
            y=y,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            pixel_selection=pixel_selection,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        format: Union[str, _models.ImageType],
        searchid: str,
        z: int,
        x: int,
        y: int,
        *,
        scale: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :keyword scale: Default value is None.
        :paramtype scale: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~spatiopackage.models.PixelSelection
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_format_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            format=format,
            searchid=searchid,
            z=z,
            x=x,
            y=y,
            scale=scale,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            pixel_selection=pixel_selection,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        searchid: str,
        z: int,
        x: int,
        y: int,
        *,
        scale: Optional[int] = None,
        format: Optional[Union[str, _models.ImageType]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :keyword scale: Default value is None.
        :paramtype scale: int
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~spatiopackage.models.PixelSelection
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            searchid=searchid,
            z=z,
            x=x,
            y=y,
            scale=scale,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            pixel_selection=pixel_selection,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_tiles_z_x_y_scale_x_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        scale: int,
        format: Union[str, _models.ImageType],
        searchid: str,
        z: int,
        x: int,
        y: int,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile.

        :param scale: Required.
        :type scale: int
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~spatiopackage.models.PixelSelection
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_mosaic_searchid_tiles_z_x_y_scale_x_format_get_request(
            scale=scale,
            format=format,
            searchid=searchid,
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            pixel_selection=pixel_selection,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_tiles_z_x_y_scale_x_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        scale: int,
        searchid: str,
        z: int,
        x: int,
        y: int,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        format: Optional[Union[str, _models.ImageType]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile.

        :param scale: Required.
        :type scale: int
        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~spatiopackage.models.PixelSelection
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_mosaic_searchid_tiles_z_x_y_scale_x_get_request(
            scale=scale,
            searchid=searchid,
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            pixel_selection=pixel_selection,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_tiles_z_x_y_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType],
        searchid: str,
        z: int,
        x: int,
        y: int,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        scale: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword scale: Default value is None.
        :paramtype scale: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~spatiopackage.models.PixelSelection
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_mosaic_searchid_tiles_z_x_y_format_get_request(
            format=format,
            searchid=searchid,
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            pixel_selection=pixel_selection,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_tiles_z_x_y_get(  # pylint: disable=inconsistent-return-statements
        self,
        searchid: str,
        z: int,
        x: int,
        y: int,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        scale: Optional[int] = None,
        format: Optional[Union[str, _models.ImageType]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Tile.

        Create map tile.

        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword scale: Default value is None.
        :paramtype scale: int
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~spatiopackage.models.PixelSelection
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_api_mosaic_searchid_tiles_z_x_y_get_request(
            searchid=searchid,
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            pixel_selection=pixel_selection,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class tilejsonOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`tilejson_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def api_collections_collection_id_items_item_id_tile_matrix_set_id_tilejson_json_get(  # pylint: disable=name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        collection_id: str,
        item_id: str,
        *,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.TileJson:
        """Tilejson.

        Tilejson.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword tile_format: Default will be automatically defined if the output image needs a mask
         (png) or
         not (jpeg). Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw".
         Default value is None.
        :paramtype tile_format: str or ~spatiopackage.models.ImageType
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: TileJson. The TileJson is compatible with MutableMapping
        :rtype: ~spatiopackage.models.TileJson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tiles": [
                        "str"
                    ],
                    "attribution": "str",
                    "bounds": [
                        0.0
                    ],
                    "center": [
                        0.0
                    ],
                    "data": [
                        "str"
                    ],
                    "description": "str",
                    "grids": [
                        "str"
                    ],
                    "legend": "str",
                    "maxzoom": 0,
                    "minzoom": 0,
                    "name": "str",
                    "scheme": "str",
                    "template": "str",
                    "tilejson": "str",
                    "version": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJson] = kwargs.pop("cls", None)

        _request = build_tilejson_operations_api_collections_collection_id_items_item_id_tile_matrix_set_id_tilejson_json_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            collection_id=collection_id,
            item_id=item_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def api_collections_collection_id_items_item_id_tilejson_json_get(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        item_id: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.TileJson:
        """Tilejson.

        Tilejson.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword tile_format: Default will be automatically defined if the output image needs a mask
         (png) or
         not (jpeg). Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw".
         Default value is None.
        :paramtype tile_format: str or ~spatiopackage.models.ImageType
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: TileJson. The TileJson is compatible with MutableMapping
        :rtype: ~spatiopackage.models.TileJson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tiles": [
                        "str"
                    ],
                    "attribution": "str",
                    "bounds": [
                        0.0
                    ],
                    "center": [
                        0.0
                    ],
                    "data": [
                        "str"
                    ],
                    "description": "str",
                    "grids": [
                        "str"
                    ],
                    "legend": "str",
                    "maxzoom": 0,
                    "minzoom": 0,
                    "name": "str",
                    "scheme": "str",
                    "template": "str",
                    "tilejson": "str",
                    "version": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJson] = kwargs.pop("cls", None)

        _request = build_tilejson_operations_api_collections_collection_id_items_item_id_tilejson_json_get_request(
            collection_id=collection_id,
            item_id=item_id,
            tile_matrix_set_id=tile_matrix_set_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_tile_matrix_set_id_tilejson_json_get(  # pylint: disable=name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        searchid: str,
        *,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.TileJson:
        """Tilejson.

        Return TileJSON document for a SearchId.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :keyword tile_format: Default will be automatically defined if the output image needs a mask
         (png) or
         not (jpeg). Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw".
         Default value is None.
        :paramtype tile_format: str or ~spatiopackage.models.ImageType
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~spatiopackage.models.PixelSelection
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: TileJson. The TileJson is compatible with MutableMapping
        :rtype: ~spatiopackage.models.TileJson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tiles": [
                        "str"
                    ],
                    "attribution": "str",
                    "bounds": [
                        0.0
                    ],
                    "center": [
                        0.0
                    ],
                    "data": [
                        "str"
                    ],
                    "description": "str",
                    "grids": [
                        "str"
                    ],
                    "legend": "str",
                    "maxzoom": 0,
                    "minzoom": 0,
                    "name": "str",
                    "scheme": "str",
                    "template": "str",
                    "tilejson": "str",
                    "version": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJson] = kwargs.pop("cls", None)

        _request = build_tilejson_operations_api_mosaic_searchid_tile_matrix_set_id_tilejson_json_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            searchid=searchid,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            pixel_selection=pixel_selection,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_tilejson_json_get(
        self,
        searchid: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.TileJson:
        """Tilejson.

        Return TileJSON document for a SearchId.

        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword tile_format: Default will be automatically defined if the output image needs a mask
         (png) or
         not (jpeg). Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw".
         Default value is None.
        :paramtype tile_format: str or ~spatiopackage.models.ImageType
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~spatiopackage.models.PixelSelection
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: TileJson. The TileJson is compatible with MutableMapping
        :rtype: ~spatiopackage.models.TileJson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tiles": [
                        "str"
                    ],
                    "attribution": "str",
                    "bounds": [
                        0.0
                    ],
                    "center": [
                        0.0
                    ],
                    "data": [
                        "str"
                    ],
                    "description": "str",
                    "grids": [
                        "str"
                    ],
                    "legend": "str",
                    "maxzoom": 0,
                    "minzoom": 0,
                    "name": "str",
                    "scheme": "str",
                    "template": "str",
                    "tilejson": "str",
                    "version": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJson] = kwargs.pop("cls", None)

        _request = build_tilejson_operations_api_mosaic_searchid_tilejson_json_get_request(
            searchid=searchid,
            tile_matrix_set_id=tile_matrix_set_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            pixel_selection=pixel_selection,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class wmtsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`wmts_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def api_collections_collection_id_items_item_id_tile_matrix_set_id_w_m_t_s_capabilities_xml_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        collection_id: str,
        item_id: str,
        *,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Wmts.

        OGC WMTS endpoint.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~spatiopackage.models.ImageType
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_wmts_operations_api_collections_collection_id_items_item_id_tile_matrix_set_id_w_m_t_s_capabilities_xml_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            collection_id=collection_id,
            item_id=item_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_collections_collection_id_items_item_id_w_m_t_s_capabilities_xml_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Wmts.

        OGC WMTS endpoint.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~spatiopackage.models.ImageType
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = (
            build_wmts_operations_api_collections_collection_id_items_item_id_w_m_t_s_capabilities_xml_get_request(
                collection_id=collection_id,
                item_id=item_id,
                tile_matrix_set_id=tile_matrix_set_id,
                tile_format=tile_format,
                tile_scale=tile_scale,
                minzoom=minzoom,
                maxzoom=maxzoom,
                buffer=buffer,
                color_formula=color_formula,
                assets=assets,
                expression=expression,
                asset_bidx=asset_bidx,
                asset_as_band=asset_as_band,
                nodata=nodata,
                unscale=unscale,
                resampling=resampling,
                algorithm=algorithm,
                algorithm_params=algorithm_params,
                rescale=rescale,
                colormap_name=colormap_name,
                colormap=colormap,
                return_mask=return_mask,
                accept=accept,
                api_version=self._config.api_version,
                headers=_headers,
                params=_params,
            )
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_tile_matrix_set_id_w_m_t_s_capabilities_xml_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        searchid: str,
        *,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        **kwargs: Any,
    ) -> None:
        """Wmts.

        OGC WMTS endpoint.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~spatiopackage.models.ImageType
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_wmts_operations_api_mosaic_searchid_tile_matrix_set_id_w_m_t_s_capabilities_xml_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            searchid=searchid,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_mosaic_searchid_w_m_t_s_capabilities_xml_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        searchid: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        **kwargs: Any,
    ) -> None:
        """Wmts.

        OGC WMTS endpoint.

        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~spatiopackage.models.ImageType
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_wmts_operations_api_mosaic_searchid_w_m_t_s_capabilities_xml_get_request(
            searchid=searchid,
            tile_matrix_set_id=tile_matrix_set_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class pointOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`point_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def api_collections_collection_id_items_item_id_point_lon_lat_get(  # pylint: disable=name-too-long
        self,
        lon: float,
        lat: float,
        collection_id: str,
        item_id: str,
        *,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        **kwargs: Any,
    ) -> _models.TitilerCoreModelsResponsesPoint:
        """Point.

        Get Point value for a dataset.

        :param lon: Longitude. Required.
        :type lon: float
        :param lat: Latitude. Required.
        :type lat: float
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :return: TitilerCoreModelsResponsesPoint. The TitilerCoreModelsResponsesPoint is compatible
         with MutableMapping
        :rtype: ~spatiopackage.models.TitilerCoreModelsResponsesPoint
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "band_names": [
                        "str"
                    ],
                    "coordinates": [
                        0.0
                    ],
                    "values": [
                        0.0
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TitilerCoreModelsResponsesPoint] = kwargs.pop("cls", None)

        _request = build_point_operations_api_collections_collection_id_items_item_id_point_lon_lat_get_request(
            lon=lon,
            lat=lat,
            collection_id=collection_id,
            item_id=item_id,
            coord_crs=coord_crs,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TitilerCoreModelsResponsesPoint, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class previewOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`preview_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def api_collections_collection_id_items_item_id_preview_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        *,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        dst_crs: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Preview.

        Create preview of a dataset.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword dst_crs: Output Coordinate Reference System. Default value is None.
        :paramtype dst_crs: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_preview_operations_api_collections_collection_id_items_item_id_preview_format_get_request(
            format=format,
            collection_id=collection_id,
            item_id=item_id,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            dst_crs=dst_crs,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_collections_collection_id_items_item_id_preview_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        *,
        format: Optional[Union[str, _models.ImageType]] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        dst_crs: Optional[str] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Preview.

        Create preview of a dataset.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Default value is None.
        :paramtype format: str or ~spatiopackage.models.ImageType
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword dst_crs: Output Coordinate Reference System. Default value is None.
        :paramtype dst_crs: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_preview_operations_api_collections_collection_id_items_item_id_preview_get_request(
            collection_id=collection_id,
            item_id=item_id,
            format=format,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            dst_crs=dst_crs,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class partOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`part_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def api_collections_collection_id_items_item_id_crop_minx_miny_maxx_maxy_width_x_height_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        minx: float,
        miny: float,
        maxx: float,
        maxy: float,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        height: int,
        width: int,
        *,
        color_formula: Optional[str] = None,
        dst_crs: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Part.

        Create image from part of a dataset.

        :param minx: Bounding box min X. Required.
        :type minx: float
        :param miny: Bounding box min Y. Required.
        :type miny: float
        :param maxx: Bounding box max X. Required.
        :type maxx: float
        :param maxy: Bounding box max Y. Required.
        :type maxy: float
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param height: Required.
        :type height: int
        :param width: Required.
        :type width: int
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword dst_crs: Output Coordinate Reference System. Default value is None.
        :paramtype dst_crs: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_part_operations_api_collections_collection_id_items_item_id_crop_minx_miny_maxx_maxy_width_x_height_format_get_request(
            minx=minx,
            miny=miny,
            maxx=maxx,
            maxy=maxy,
            format=format,
            collection_id=collection_id,
            item_id=item_id,
            height=height,
            width=width,
            color_formula=color_formula,
            dst_crs=dst_crs,
            coord_crs=coord_crs,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def api_collections_collection_id_items_item_id_crop_minx_miny_maxx_maxy_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        minx: float,
        miny: float,
        maxx: float,
        maxy: float,
        format: Union[str, _models.ImageType],
        collection_id: str,
        item_id: str,
        *,
        color_formula: Optional[str] = None,
        dst_crs: Optional[str] = None,
        coord_crs: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[str] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Part.

        Create image from part of a dataset.

        :param minx: Bounding box min X. Required.
        :type minx: float
        :param miny: Bounding box min Y. Required.
        :type miny: float
        :param maxx: Bounding box max X. Required.
        :type maxx: float
        :param maxy: Bounding box max Y. Required.
        :type maxy: float
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~spatiopackage.models.ImageType
        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword dst_crs: Output Coordinate Reference System. Default value is None.
        :paramtype dst_crs: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: str
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~spatiopackage.models.Resampling
        :keyword max_size: Default value is None.
        :paramtype max_size: int
        :keyword height: Default value is None.
        :paramtype height: int
        :keyword width: Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~spatiopackage.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~spatiopackage.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_part_operations_api_collections_collection_id_items_item_id_crop_minx_miny_maxx_maxy_format_get_request(
            minx=minx,
            miny=miny,
            maxx=maxx,
            maxy=maxy,
            format=format,
            collection_id=collection_id,
            item_id=item_id,
            color_formula=color_formula,
            dst_crs=dst_crs,
            coord_crs=coord_crs,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class registerOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`register_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def search_api_mosaic_register_post(
        self, body: _models.RegisterMosaic, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :param body: Required.
        :type body: ~spatiopackage.models.RegisterMosaic
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "collections": [
                        "str"
                    ],
                    "datetime": "str",
                    "filter": {
                        "str": {}
                    },
                    "filter-lang": "str",
                    "ids": [
                        "str"
                    ],
                    "intersects": {},
                    "metadata": {
                        "assets": [
                            "str"
                        ],
                        "bounds": {},
                        "defaults": {
                            "str": {}
                        },
                        "maxzoom": 0,
                        "minzoom": 0,
                        "name": "str",
                        "type": "str"
                    },
                    "query": {
                        "str": {
                            "str": {}
                        }
                    },
                    "sortby": {}
                }

                # response body for status code(s): 200
                response == {
                    "searchid": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ]
                }
        """

    @overload
    def search_api_mosaic_register_post(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "searchid": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ]
                }
        """

    @overload
    def search_api_mosaic_register_post(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "searchid": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ]
                }
        """

    @distributed_trace
    def search_api_mosaic_register_post(
        self, body: Union[_models.RegisterMosaic, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :param body: Is one of the following types: RegisterMosaic, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.RegisterMosaic or JSON or IO[bytes]
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~spatiopackage.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "collections": [
                        "str"
                    ],
                    "datetime": "str",
                    "filter": {
                        "str": {}
                    },
                    "filter-lang": "str",
                    "ids": [
                        "str"
                    ],
                    "intersects": {},
                    "metadata": {
                        "assets": [
                            "str"
                        ],
                        "bounds": {},
                        "defaults": {
                            "str": {}
                        },
                        "maxzoom": 0,
                        "minzoom": 0,
                        "name": "str",
                        "type": "str"
                    },
                    "query": {
                        "str": {
                            "str": {}
                        }
                    },
                    "sortby": {}
                }

                # response body for status code(s): 200
                response == {
                    "searchid": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RegisterResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_register_operations_search_api_mosaic_register_post_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RegisterResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class assetsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`assets_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def for_tile_api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_assets_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        searchid: str,
        z: int,
        x: int,
        y: int,
        *,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Assets For Tile.

        Return a list of assets which overlap a given tile.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = (
            build_assets_operations_for_tile_api_mosaic_searchid_tiles_tile_matrix_set_id_z_x_y_assets_get_request(
                tile_matrix_set_id=tile_matrix_set_id,
                searchid=searchid,
                z=z,
                x=x,
                y=y,
                scan_limit=scan_limit,
                items_limit=items_limit,
                time_limit=time_limit,
                exitwhenfull=exitwhenfull,
                skipcovered=skipcovered,
                api_version=self._config.api_version,
                headers=_headers,
                params=_params,
            )
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def for_tile_api_mosaic_searchid_tiles_z_x_y_assets_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        searchid: str,
        z: int,
        x: int,
        y: int,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Assets For Tile.

        Return a list of assets which overlap a given tile.

        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: int
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: int
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: int
        :keyword tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~spatiopackage.models.Tilematrixsetid
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_assets_operations_for_tile_api_mosaic_searchid_tiles_z_x_y_assets_get_request(
            searchid=searchid,
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def for_point_api_mosaic_searchid_lon_lat_assets_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        lon: float,
        lat: float,
        searchid: str,
        *,
        coord_crs: Optional[str] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        """Assets For Point.

        Return a list of assets for a given point.

        :param lon: Longitude. Required.
        :type lon: float
        :param lat: Latitude. Required.
        :type lat: float
        :param searchid: Search Id (pgSTAC Search Hash). Required.
        :type searchid: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_assets_operations_for_point_api_mosaic_searchid_lon_lat_assets_get_request(
            lon=lon,
            lat=lat,
            searchid=searchid,
            coord_crs=coord_crs,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class getOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`get_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def interval_legend_api_legend_interval_classmap_name_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, classmap_name: str, *, trim_start: Optional[int] = None, trim_end: Optional[int] = None, **kwargs: Any
    ) -> None:
        """Get Interval Legend.

        Generate values and color swatches mapping for a given interval classmap.

        Args:
        trim_start (int, optional): Number of items to trim from
        the start of the cmap
        trim_end (int, optional): Number of items to trim from the end of the cmap.

        :param classmap_name: Required.
        :type classmap_name: str
        :keyword trim_start: Default value is None.
        :paramtype trim_start: int
        :keyword trim_end: Default value is None.
        :paramtype trim_end: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_interval_legend_api_legend_interval_classmap_name_get_request(
            classmap_name=classmap_name,
            trim_start=trim_start,
            trim_end=trim_end,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def classmap_legend_api_legend_classmap_classmap_name_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, classmap_name: str, *, trim_start: Optional[int] = None, trim_end: Optional[int] = None, **kwargs: Any
    ) -> None:
        """Get Classmap Legend.

        Generate values and color swatches mapping for a given classmap.

        Args:
        trim_start (int, optional): Number of items to trim
        from the start of the cmap
        trim_end (int, optional): Number of items to trim from the end of the cmap.

        :param classmap_name: Required.
        :type classmap_name: str
        :keyword trim_start: Default value is None.
        :paramtype trim_start: int
        :keyword trim_end: Default value is None.
        :paramtype trim_end: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_classmap_legend_api_legend_classmap_classmap_name_get_request(
            classmap_name=classmap_name,
            trim_start=trim_start,
            trim_end=trim_end,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def legend_api_legend_colormap_cmap_name_get(  # pylint: disable=inconsistent-return-statements
        self,
        cmap_name: str,
        *,
        height: Optional[float] = None,
        width: Optional[float] = None,
        trim_start: Optional[int] = None,
        trim_end: Optional[int] = None,
        **kwargs: Any,
    ) -> None:
        """Get Legend.

        Generate a legend image for a given colormap.

        If the colormap has non-contiguous values at the beginning or end,
        which aren't desired in the output image, they can be trimmed by specifying
        the number of values to trim.

        Args:
        cmap_name (string): The name of the registered colormap to generate
        a legend for
        height (float, optional): The output height of the legend image
        width (float, optional): The output width of the legend image
        trim_start (int, optional): Number of items to trim from
        the start of the cmap
        trim_end (int, optional): Number of items to trim from the end of the cmap

        Returns:
        HTTP response with jpeg encoded image data.

        :param cmap_name: Required.
        :type cmap_name: str
        :keyword height: Default value is None.
        :paramtype height: float
        :keyword width: Default value is None.
        :paramtype width: float
        :keyword trim_start: Default value is None.
        :paramtype trim_start: int
        :keyword trim_end: Default value is None.
        :paramtype trim_end: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_legend_api_legend_colormap_cmap_name_get_request(
            cmap_name=cmap_name,
            height=height,
            width=width,
            trim_start=trim_start,
            trim_end=trim_end,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def static_image_api_collections_collection_id_image_static_id_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, id: str, collection_id: str, **kwargs: Any
    ) -> None:
        """Get Static Image.

        Fetch an existing image export by ID.

        :param id: Image export ID. Required.
        :type id: str
        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_static_image_api_collections_collection_id_image_static_id_get_request(
            id=id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class CreateOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`create_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def static_image_api_collections_collection_id_image_static_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: _models.ImageRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ImageResponse:
        """Create Static Image.

        Create a new image export.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Required.
        :type body: ~spatiopackage.models.ImageRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ImageResponse. The ImageResponse is compatible with MutableMapping
        :rtype: ~spatiopackage.models.ImageResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "cols": 0,
                    "cql": {
                        "str": {}
                    },
                    "render_params": "str",
                    "rows": 0,
                    "format": "str",
                    "geometry": {
                        "str": {}
                    },
                    "mask": bool,
                    "showBranding": bool
                }

                # response body for status code(s): 200
                response == {
                    "url": "str"
                }
        """

    @overload
    def static_image_api_collections_collection_id_image_static_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ImageResponse:
        """Create Static Image.

        Create a new image export.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ImageResponse. The ImageResponse is compatible with MutableMapping
        :rtype: ~spatiopackage.models.ImageResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "url": "str"
                }
        """

    @overload
    def static_image_api_collections_collection_id_image_static_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ImageResponse:
        """Create Static Image.

        Create a new image export.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ImageResponse. The ImageResponse is compatible with MutableMapping
        :rtype: ~spatiopackage.models.ImageResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "url": "str"
                }
        """

    @distributed_trace
    def static_image_api_collections_collection_id_image_static_post(  # pylint: disable=name-too-long
        self, collection_id: str, body: Union[_models.ImageRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.ImageResponse:
        """Create Static Image.

        Create a new image export.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Is one of the following types: ImageRequest, JSON, IO[bytes] Required.
        :type body: ~spatiopackage.models.ImageRequest or JSON or IO[bytes]
        :return: ImageResponse. The ImageResponse is compatible with MutableMapping
        :rtype: ~spatiopackage.models.ImageResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "cols": 0,
                    "cql": {
                        "str": {}
                    },
                    "render_params": "str",
                    "rows": 0,
                    "format": "str",
                    "geometry": {
                        "str": {}
                    },
                    "mask": bool,
                    "showBranding": bool
                }

                # response body for status code(s): 200
                response == {
                    "url": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ImageResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_create_operations_static_image_api_collections_collection_id_image_static_post_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ImageResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class matrixOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`matrix_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_api_tile_matrix_sets_get(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Matrix List.

        Matrix List.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_matrix_operations_list_api_tile_matrix_sets_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def definition_api_tile_matrix_sets_tile_matrix_set_id_get(  # pylint: disable=name-too-long
        self, tile_matrix_set_id: str, **kwargs: Any
    ) -> _models.TileMatrixSet:
        """Matrix Definition.

        Matrix Definition.

        :param tile_matrix_set_id: Required.
        :type tile_matrix_set_id: str
        :return: TileMatrixSet. The TileMatrixSet is compatible with MutableMapping
        :rtype: ~spatiopackage.models.TileMatrixSet
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "crs": {},
                    "tileMatrices": [
                        {
                            "cellSize": 0.0,
                            "id": "str",
                            "matrixHeight": 0,
                            "matrixWidth": 0,
                            "pointOfOrigin": [
                                {}
                            ],
                            "scaleDenominator": 0.0,
                            "tileHeight": 0,
                            "tileWidth": 0,
                            "cornerOfOrigin": "str",
                            "description": "str",
                            "keywords": [
                                "str"
                            ],
                            "title": "str"
                        }
                    ],
                    "boundingBox": {
                        "lowerLeft": [
                            {}
                        ],
                        "upperRight": [
                            {}
                        ],
                        "crs": {},
                        "orderedAxes": [
                            "str"
                        ]
                    },
                    "description": "str",
                    "id": "str",
                    "keywords": [
                        "str"
                    ],
                    "orderedAxes": [
                        "str"
                    ],
                    "title": "str",
                    "uri": "str",
                    "wellKnownScaleSet": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileMatrixSet] = kwargs.pop("cls", None)

        _request = build_matrix_operations_definition_api_tile_matrix_sets_tile_matrix_set_id_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileMatrixSet, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class IngestionsRunsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~spatiopackage.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`runs` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, ingestion_id: str, collection_id: str, **kwargs: Any) -> List[_models.IngestionRunSummary]:
        """Get the runs of an ingestion.

        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: list of IngestionRunSummary
        :rtype: list[~spatiopackage.models.IngestionRunSummary]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "id": "str",
                        "operation": {
                            "id": "str",
                            "status": "str"
                        }
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.IngestionRunSummary]] = kwargs.pop("cls", None)

        _request = build_ingestions_runs_list_request(
            ingestion_id=ingestion_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.IngestionRunSummary], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def read(self, run_id: str, ingestion_id: str, collection_id: str, **kwargs: Any) -> _models.IngestionRun:
        """Get a run of an ingestion.

        :param run_id: Run id. Required.
        :type run_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: IngestionRun. The IngestionRun is compatible with MutableMapping
        :rtype: ~spatiopackage.models.IngestionRun
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "id": "str",
                    "operation": {
                        "creationTime": "2020-02-20 00:00:00",
                        "id": "str",
                        "status": "str",
                        "statusHistory": [
                            {
                                "status": "str",
                                "time": "2020-02-20 00:00:00",
                                "errorMessage": "str"
                            }
                        ],
                        "totalFailedItems": 0,
                        "totalItems": 0,
                        "totalPendingItems": 0,
                        "totalSuccessfullItems": 0,
                        "finishTime": "2020-02-20 00:00:00",
                        "startTime": "2020-02-20 00:00:00"
                    },
                    "parentRunId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionRun] = kwargs.pop("cls", None)

        _request = build_ingestions_runs_read_request(
            run_id=run_id,
            ingestion_id=ingestion_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def create(self, ingestion_id: str, collection_id: str, **kwargs: Any) -> _models.IngestionRun:
        """Create a new run of an ingestion.

        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: IngestionRun. The IngestionRun is compatible with MutableMapping
        :rtype: ~spatiopackage.models.IngestionRun
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 404
                response == {
                    "id": "str",
                    "operation": {
                        "creationTime": "2020-02-20 00:00:00",
                        "id": "str",
                        "status": "str",
                        "statusHistory": [
                            {
                                "status": "str",
                                "time": "2020-02-20 00:00:00",
                                "errorMessage": "str"
                            }
                        ],
                        "totalFailedItems": 0,
                        "totalItems": 0,
                        "totalPendingItems": 0,
                        "totalSuccessfullItems": 0,
                        "finishTime": "2020-02-20 00:00:00",
                        "startTime": "2020-02-20 00:00:00"
                    },
                    "parentRunId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionRun] = kwargs.pop("cls", None)

        _request = build_ingestions_runs_create_request(
            ingestion_id=ingestion_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def retry(self, run_id: str, ingestion_id: str, collection_id: str, **kwargs: Any) -> _models.IngestionRun:
        """Retries a run of an ingestion processing failed items.

        :param run_id: Run id. Required.
        :type run_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: IngestionRun. The IngestionRun is compatible with MutableMapping
        :rtype: ~spatiopackage.models.IngestionRun
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 404
                response == {
                    "id": "str",
                    "operation": {
                        "creationTime": "2020-02-20 00:00:00",
                        "id": "str",
                        "status": "str",
                        "statusHistory": [
                            {
                                "status": "str",
                                "time": "2020-02-20 00:00:00",
                                "errorMessage": "str"
                            }
                        ],
                        "totalFailedItems": 0,
                        "totalItems": 0,
                        "totalPendingItems": 0,
                        "totalSuccessfullItems": 0,
                        "finishTime": "2020-02-20 00:00:00",
                        "startTime": "2020-02-20 00:00:00"
                    },
                    "parentRunId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionRun] = kwargs.pop("cls", None)

        _request = build_ingestions_runs_retry_request(
            run_id=run_id,
            ingestion_id=ingestion_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 404]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore
