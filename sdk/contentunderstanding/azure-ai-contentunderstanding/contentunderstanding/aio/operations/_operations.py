# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
from io import IOBase
import json
from typing import Any, AsyncIterator, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core import AsyncPipelineClient
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.polling.async_base_polling import AsyncLROBasePolling
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._utils.model_base import SdkJSONEncoder, _deserialize
from ..._utils.serialization import Deserializer, Serializer
from ...operations._operations import (
    build_content_analyzers_analyze_binary_request,
    build_content_analyzers_analyze_request,
    build_content_analyzers_create_or_replace_request,
    build_content_analyzers_delete_request,
    build_content_analyzers_get_operation_status_request,
    build_content_analyzers_get_request,
    build_content_analyzers_get_result_file_request,
    build_content_analyzers_get_result_request,
    build_content_analyzers_list_request,
    build_content_analyzers_update_request,
    build_content_classifiers_classify_binary_request,
    build_content_classifiers_classify_request,
    build_content_classifiers_create_or_replace_request,
    build_content_classifiers_delete_request,
    build_content_classifiers_get_operation_status_request,
    build_content_classifiers_get_request,
    build_content_classifiers_get_result_request,
    build_content_classifiers_list_request,
    build_content_classifiers_update_request,
    build_faces_compare_request,
    build_faces_detect_request,
    build_person_directories_add_face_request,
    build_person_directories_add_person_request,
    build_person_directories_create_request,
    build_person_directories_delete_face_request,
    build_person_directories_delete_person_request,
    build_person_directories_delete_request,
    build_person_directories_find_similar_faces_request,
    build_person_directories_get_face_request,
    build_person_directories_get_person_request,
    build_person_directories_get_request,
    build_person_directories_identify_person_request,
    build_person_directories_list_faces_request,
    build_person_directories_list_persons_request,
    build_person_directories_list_request,
    build_person_directories_update_face_request,
    build_person_directories_update_person_request,
    build_person_directories_update_request,
    build_person_directories_verify_person_request,
)
from .._configuration import ContentUnderstandingClientConfiguration

JSON = MutableMapping[str, Any]
_Unset: Any = object()
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class ContentAnalyzersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~contentunderstanding.aio.ContentUnderstandingClient`'s
        :attr:`content_analyzers` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: ContentUnderstandingClientConfiguration = (
            input_args.pop(0) if input_args else kwargs.pop("config")
        )
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_operation_status(
        self, analyzer_id: str, operation_id: str, **kwargs: Any
    ) -> _models.ResourceOperationStatusContentAnalyzerContentAnalyzerError:
        """Get the status of an analyzer creation operation.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param operation_id: The unique ID of the operation. Required.
        :type operation_id: str
        :return: ResourceOperationStatusContentAnalyzerContentAnalyzerError. The
         ResourceOperationStatusContentAnalyzerContentAnalyzerError is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.ResourceOperationStatusContentAnalyzerContentAnalyzerError
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ResourceOperationStatusContentAnalyzerContentAnalyzerError] = kwargs.pop("cls", None)

        _request = build_content_analyzers_get_operation_status_request(
            analyzer_id=analyzer_id,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(
                _models.ResourceOperationStatusContentAnalyzerContentAnalyzerError, response.json()
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_replace_initial(
        self, analyzer_id: str, resource: Union[_models.ContentAnalyzer, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_analyzers_create_or_replace_request(
            analyzer_id=analyzer_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_replace(
        self,
        analyzer_id: str,
        resource: _models.ContentAnalyzer,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ContentAnalyzer]:
        """Create a new analyzer asynchronously.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: ~contentunderstanding.models.ContentAnalyzer
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ContentAnalyzer. The ContentAnalyzer is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ContentAnalyzer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_replace(
        self, analyzer_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.ContentAnalyzer]:
        """Create a new analyzer asynchronously.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ContentAnalyzer. The ContentAnalyzer is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ContentAnalyzer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_replace(
        self, analyzer_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.ContentAnalyzer]:
        """Create a new analyzer asynchronously.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ContentAnalyzer. The ContentAnalyzer is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ContentAnalyzer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_replace(
        self, analyzer_id: str, resource: Union[_models.ContentAnalyzer, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncLROPoller[_models.ContentAnalyzer]:
        """Create a new analyzer asynchronously.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Is one of the following types: ContentAnalyzer, JSON,
         IO[bytes] Required.
        :type resource: ~contentunderstanding.models.ContentAnalyzer or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns ContentAnalyzer. The ContentAnalyzer is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ContentAnalyzer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ContentAnalyzer] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_replace_initial(
                analyzer_id=analyzer_id,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )

            deserialized = _deserialize(_models.ContentAnalyzer, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod,
                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.ContentAnalyzer].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.ContentAnalyzer](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update(
        self,
        analyzer_id: str,
        resource: _models.ContentAnalyzer,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.ContentAnalyzer:
        """Update analyzer properties.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: ~contentunderstanding.models.ContentAnalyzer
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentAnalyzer. The ContentAnalyzer is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.ContentAnalyzer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self, analyzer_id: str, resource: JSON, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.ContentAnalyzer:
        """Update analyzer properties.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentAnalyzer. The ContentAnalyzer is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.ContentAnalyzer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        analyzer_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.ContentAnalyzer:
        """Update analyzer properties.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentAnalyzer. The ContentAnalyzer is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.ContentAnalyzer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self, analyzer_id: str, resource: Union[_models.ContentAnalyzer, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.ContentAnalyzer:
        """Update analyzer properties.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Is one of the following types: ContentAnalyzer, JSON,
         IO[bytes] Required.
        :type resource: ~contentunderstanding.models.ContentAnalyzer or JSON or IO[bytes]
        :return: ContentAnalyzer. The ContentAnalyzer is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.ContentAnalyzer
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ContentAnalyzer] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_analyzers_update_request(
            analyzer_id=analyzer_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ContentAnalyzer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get(self, analyzer_id: str, **kwargs: Any) -> _models.ContentAnalyzer:
        """Get analyzer properties.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :return: ContentAnalyzer. The ContentAnalyzer is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.ContentAnalyzer
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ContentAnalyzer] = kwargs.pop("cls", None)

        _request = build_content_analyzers_get_request(
            analyzer_id=analyzer_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ContentAnalyzer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, analyzer_id: str, **kwargs: Any) -> None:
        """Delete analyzer.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_content_analyzers_delete_request(
            analyzer_id=analyzer_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncItemPaged["_models.ContentAnalyzer"]:
        """List analyzers.

        :return: An iterator like instance of ContentAnalyzer
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~contentunderstanding.models.ContentAnalyzer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ContentAnalyzer]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_content_analyzers_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ContentAnalyzer], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _analyze_initial(
        self,
        analyzer_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        url: Optional[str] = None,
        data: Optional[bytes] = None,
        inputs: Optional[List[_models.AnalyzeInput]] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"data": data, "inputs": inputs, "url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_analyzers_analyze_request(
            analyzer_id=analyzer_id,
            string_encoding=string_encoding,
            processing_location=processing_location,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_analyze(
        self,
        analyzer_id: str,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        url: Optional[str] = None,
        data: Optional[bytes] = None,
        inputs: Optional[List[_models.AnalyzeInput]] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AnalyzeResult]:
        """Extract content and fields from input.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword url: The URL of the primary input to analyze.  Only one of url or data should be
         specified. Default value is None.
        :paramtype url: str
        :keyword data: Base64-encoded binary content of the primary input to analyze.  Only one of url
         or data should be specified. Default value is None.
        :paramtype data: bytes
        :keyword inputs: Additional inputs to analyze.  Only supported in analyzers with mode=pro.
         Default value is None.
        :paramtype inputs: list[~contentunderstanding.models.AnalyzeInput]
        :return: An instance of AsyncLROPoller that returns AnalyzeResult. The AnalyzeResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.AnalyzeResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_analyze(
        self,
        analyzer_id: str,
        body: JSON,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AnalyzeResult]:
        """Extract content and fields from input.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param body: Required.
        :type body: JSON
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns AnalyzeResult. The AnalyzeResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.AnalyzeResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_analyze(
        self,
        analyzer_id: str,
        body: IO[bytes],
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AnalyzeResult]:
        """Extract content and fields from input.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns AnalyzeResult. The AnalyzeResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.AnalyzeResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_analyze(
        self,
        analyzer_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        url: Optional[str] = None,
        data: Optional[bytes] = None,
        inputs: Optional[List[_models.AnalyzeInput]] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AnalyzeResult]:
        """Extract content and fields from input.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~contentunderstanding.models.ProcessingLocation
        :keyword url: The URL of the primary input to analyze.  Only one of url or data should be
         specified. Default value is None.
        :paramtype url: str
        :keyword data: Base64-encoded binary content of the primary input to analyze.  Only one of url
         or data should be specified. Default value is None.
        :paramtype data: bytes
        :keyword inputs: Additional inputs to analyze.  Only supported in analyzers with mode=pro.
         Default value is None.
        :paramtype inputs: list[~contentunderstanding.models.AnalyzeInput]
        :return: An instance of AsyncLROPoller that returns AnalyzeResult. The AnalyzeResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.AnalyzeResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AnalyzeResult] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._analyze_initial(
                analyzer_id=analyzer_id,
                body=body,
                string_encoding=string_encoding,
                processing_location=processing_location,
                url=url,
                data=data,
                inputs=inputs,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )

            deserialized = _deserialize(_models.AnalyzeResult, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod,
                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.AnalyzeResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.AnalyzeResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _analyze_binary_initial(
        self,
        analyzer_id: str,
        input: bytes,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type")
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _content = input

        _request = build_content_analyzers_analyze_binary_request(
            analyzer_id=analyzer_id,
            string_encoding=string_encoding,
            processing_location=processing_location,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_analyze_binary(
        self,
        analyzer_id: str,
        input: bytes,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[_models.AnalyzeResult]:
        """Extract content and fields from input.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param input: The binary content of the document to analyze. Required.
        :type input: bytes
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~contentunderstanding.models.ProcessingLocation
        :return: An instance of AsyncLROPoller that returns AnalyzeResult. The AnalyzeResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.AnalyzeResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type")
        cls: ClsType[_models.AnalyzeResult] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._analyze_binary_initial(
                analyzer_id=analyzer_id,
                input=input,
                string_encoding=string_encoding,
                processing_location=processing_location,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )

            deserialized = _deserialize(_models.AnalyzeResult, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod,
                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.AnalyzeResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.AnalyzeResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def get_result(self, operation_id: str, **kwargs: Any) -> _models.OperationStatusAnalyzeResultError:
        """Get the result of an analysis operation.

        :param operation_id: The unique ID of the operation. Required.
        :type operation_id: str
        :return: OperationStatusAnalyzeResultError. The OperationStatusAnalyzeResultError is compatible
         with MutableMapping
        :rtype: ~contentunderstanding.models.OperationStatusAnalyzeResultError
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.OperationStatusAnalyzeResultError] = kwargs.pop("cls", None)

        _request = build_content_analyzers_get_result_request(
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OperationStatusAnalyzeResultError, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_result_file(self, operation_id: str, path: str, **kwargs: Any) -> AsyncIterator[bytes]:
        """Get a file associated with the result of an analysis operation.

        :param operation_id: Operation identifier. Required.
        :type operation_id: str
        :param path: File path. Required.
        :type path: str
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_content_analyzers_get_result_file_request(
            operation_id=operation_id,
            path=path,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class PersonDirectoriesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~contentunderstanding.aio.ContentUnderstandingClient`'s
        :attr:`person_directories` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: ContentUnderstandingClientConfiguration = (
            input_args.pop(0) if input_args else kwargs.pop("config")
        )
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self,
        person_directory_id: str,
        resource: _models.PersonDirectory,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PersonDirectory:
        """Create a new person directory.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: ~contentunderstanding.models.PersonDirectory
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, person_directory_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectory:
        """Create a new person directory.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, person_directory_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectory:
        """Create a new person directory.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, person_directory_id: str, resource: Union[_models.PersonDirectory, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.PersonDirectory:
        """Create a new person directory.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Is one of the following types: PersonDirectory, JSON,
         IO[bytes] Required.
        :type resource: ~contentunderstanding.models.PersonDirectory or JSON or IO[bytes]
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectory] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_create_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update(
        self,
        person_directory_id: str,
        resource: _models.PersonDirectory,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectory:
        """Update person directory properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: ~contentunderstanding.models.PersonDirectory
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        person_directory_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectory:
        """Update person directory properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        person_directory_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectory:
        """Update person directory properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self, person_directory_id: str, resource: Union[_models.PersonDirectory, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.PersonDirectory:
        """Update person directory properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Is one of the following types: PersonDirectory, JSON,
         IO[bytes] Required.
        :type resource: ~contentunderstanding.models.PersonDirectory or JSON or IO[bytes]
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectory] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_update_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get(self, person_directory_id: str, **kwargs: Any) -> _models.PersonDirectory:
        """Get person directory properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonDirectory] = kwargs.pop("cls", None)

        _request = build_person_directories_get_request(
            person_directory_id=person_directory_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, person_directory_id: str, **kwargs: Any) -> None:
        """Delete person directory and all associated persons and faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_directories_delete_request(
            person_directory_id=person_directory_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncItemPaged["_models.PersonDirectory"]:
        """List person directories.

        :return: An iterator like instance of PersonDirectory
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~contentunderstanding.models.PersonDirectory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PersonDirectory]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_person_directories_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PersonDirectory], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def add_person(
        self,
        person_directory_id: str,
        *,
        content_type: str = "application/json",
        tags: Optional[Dict[str, str]] = None,
        face_ids: Optional[List[str]] = None,
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Add a new person and optionally associate with existing faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword tags: Tags associated with the person. Default value is None.
        :paramtype tags: dict[str, str]
        :keyword face_ids: List of faces associated with the person. Default value is None.
        :paramtype face_ids: list[str]
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_person(
        self, person_directory_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Add a new person and optionally associate with existing faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_person(
        self, person_directory_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Add a new person and optionally associate with existing faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_person(
        self,
        person_directory_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        tags: Optional[Dict[str, str]] = None,
        face_ids: Optional[List[str]] = None,
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Add a new person and optionally associate with existing faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword tags: Tags associated with the person. Default value is None.
        :paramtype tags: dict[str, str]
        :keyword face_ids: List of faces associated with the person. Default value is None.
        :paramtype face_ids: list[str]
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectoryPerson] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"faceIds": face_ids, "tags": tags}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_add_person_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_person(
        self,
        person_directory_id: str,
        person_id: str,
        resource: _models.PersonDirectoryPerson,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Update person properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: ~contentunderstanding.models.PersonDirectoryPerson
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_person(
        self,
        person_directory_id: str,
        person_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Update person properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_person(
        self,
        person_directory_id: str,
        person_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Update person properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_person(
        self,
        person_directory_id: str,
        person_id: str,
        resource: Union[_models.PersonDirectoryPerson, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Update person properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Is one of the following types: PersonDirectoryPerson,
         JSON, IO[bytes] Required.
        :type resource: ~contentunderstanding.models.PersonDirectoryPerson or JSON or IO[bytes]
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectoryPerson] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_update_person_request(
            person_directory_id=person_directory_id,
            person_id=person_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_person(
        self, person_directory_id: str, person_id: str, **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Get person properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonDirectoryPerson] = kwargs.pop("cls", None)

        _request = build_person_directories_get_person_request(
            person_directory_id=person_directory_id,
            person_id=person_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_person(self, person_directory_id: str, person_id: str, **kwargs: Any) -> None:
        """Delete person.  Any linked faces will be disassociated, but not deleted.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_directories_delete_person_request(
            person_directory_id=person_directory_id,
            person_id=person_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list_persons(self, person_directory_id: str, **kwargs: Any) -> AsyncItemPaged["_models.PersonDirectoryPerson"]:
        """List persons.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :return: An iterator like instance of PersonDirectoryPerson
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~contentunderstanding.models.PersonDirectoryPerson]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PersonDirectoryPerson]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_person_directories_list_persons_request(
                    person_directory_id=person_directory_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PersonDirectoryPerson], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def add_face(
        self,
        person_directory_id: str,
        *,
        face_source: _models.FaceSource,
        content_type: str = "application/json",
        person_id: Optional[str] = None,
        quality_threshold: Optional[Union[str, _models.QualityForRecognition]] = None,
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Add a new face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~contentunderstanding.models.FaceSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword person_id: Person identifier with which to associate the face. Default value is None.
        :paramtype person_id: str
        :keyword quality_threshold: Face quality threshold below which the face will not be added.
         Default is medium. Known values are: "low", "medium", and "high". Default value is None.
        :paramtype quality_threshold: str or ~contentunderstanding.models.QualityForRecognition
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_face(
        self, person_directory_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Add a new face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_face(
        self, person_directory_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Add a new face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_face(
        self,
        person_directory_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_source: _models.FaceSource = _Unset,
        person_id: Optional[str] = None,
        quality_threshold: Optional[Union[str, _models.QualityForRecognition]] = None,
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Add a new face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~contentunderstanding.models.FaceSource
        :keyword person_id: Person identifier with which to associate the face. Default value is None.
        :paramtype person_id: str
        :keyword quality_threshold: Face quality threshold below which the face will not be added.
         Default is medium. Known values are: "low", "medium", and "high". Default value is None.
        :paramtype quality_threshold: str or ~contentunderstanding.models.QualityForRecognition
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectoryFace] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_source is _Unset:
                raise TypeError("missing required argument: face_source")
            body = {"faceSource": face_source, "personId": person_id, "qualityThreshold": quality_threshold}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_add_face_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_face(
        self,
        person_directory_id: str,
        face_id: str,
        resource: _models.PersonDirectoryFace,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Update face properties, such as modifying the association with a person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :param resource: The resource instance. Required.
        :type resource: ~contentunderstanding.models.PersonDirectoryFace
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_face(
        self,
        person_directory_id: str,
        face_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Update face properties, such as modifying the association with a person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_face(
        self,
        person_directory_id: str,
        face_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Update face properties, such as modifying the association with a person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_face(
        self,
        person_directory_id: str,
        face_id: str,
        resource: Union[_models.PersonDirectoryFace, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Update face properties, such as modifying the association with a person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :param resource: The resource instance. Is one of the following types: PersonDirectoryFace,
         JSON, IO[bytes] Required.
        :type resource: ~contentunderstanding.models.PersonDirectoryFace or JSON or IO[bytes]
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectoryFace] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_update_face_request(
            person_directory_id=person_directory_id,
            face_id=face_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_face(self, person_directory_id: str, face_id: str, **kwargs: Any) -> _models.PersonDirectoryFace:
        """Get face properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonDirectoryFace] = kwargs.pop("cls", None)

        _request = build_person_directories_get_face_request(
            person_directory_id=person_directory_id,
            face_id=face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_face(self, person_directory_id: str, face_id: str, **kwargs: Any) -> None:
        """Delete face.  Any linked person will be disassociated, but not deleted.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_directories_delete_face_request(
            person_directory_id=person_directory_id,
            face_id=face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list_faces(self, person_directory_id: str, **kwargs: Any) -> AsyncItemPaged["_models.PersonDirectoryFace"]:
        """List faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :return: An iterator like instance of PersonDirectoryFace
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~contentunderstanding.models.PersonDirectoryFace]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PersonDirectoryFace]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_person_directories_list_faces_request(
                    person_directory_id=person_directory_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PersonDirectoryFace], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def identify_person(
        self,
        person_directory_id: str,
        *,
        face_source: _models.FaceSource,
        content_type: str = "application/json",
        max_person_candidates: Optional[int] = None,
        **kwargs: Any
    ) -> _models.IdentifyPersonResult:
        """Identify the person from a face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~contentunderstanding.models.FaceSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword max_person_candidates: Maximum number of person candidates to return (up to 10).
         Default value is None.
        :paramtype max_person_candidates: int
        :return: IdentifyPersonResult. The IdentifyPersonResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.IdentifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def identify_person(
        self, person_directory_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IdentifyPersonResult:
        """Identify the person from a face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IdentifyPersonResult. The IdentifyPersonResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.IdentifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def identify_person(
        self, person_directory_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IdentifyPersonResult:
        """Identify the person from a face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IdentifyPersonResult. The IdentifyPersonResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.IdentifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def identify_person(
        self,
        person_directory_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_source: _models.FaceSource = _Unset,
        max_person_candidates: Optional[int] = None,
        **kwargs: Any
    ) -> _models.IdentifyPersonResult:
        """Identify the person from a face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~contentunderstanding.models.FaceSource
        :keyword max_person_candidates: Maximum number of person candidates to return (up to 10).
         Default value is None.
        :paramtype max_person_candidates: int
        :return: IdentifyPersonResult. The IdentifyPersonResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.IdentifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IdentifyPersonResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_source is _Unset:
                raise TypeError("missing required argument: face_source")
            body = {"faceSource": face_source, "maxPersonCandidates": max_person_candidates}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_identify_person_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IdentifyPersonResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def find_similar_faces(
        self,
        person_directory_id: str,
        *,
        content_type: str = "application/json",
        face_source: Optional[_models.FaceSource] = None,
        max_similar_faces: Optional[int] = None,
        **kwargs: Any
    ) -> _models.FindSimilarFacesResult:
        """Find similar faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword face_source: Source of the face. Default value is None.
        :paramtype face_source: ~contentunderstanding.models.FaceSource
        :keyword max_similar_faces: Maximum number of similar faces to return (up to 1000). Default
         value is None.
        :paramtype max_similar_faces: int
        :return: FindSimilarFacesResult. The FindSimilarFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.FindSimilarFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def find_similar_faces(
        self, person_directory_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FindSimilarFacesResult:
        """Find similar faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FindSimilarFacesResult. The FindSimilarFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.FindSimilarFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def find_similar_faces(
        self, person_directory_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FindSimilarFacesResult:
        """Find similar faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FindSimilarFacesResult. The FindSimilarFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.FindSimilarFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def find_similar_faces(
        self,
        person_directory_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_source: Optional[_models.FaceSource] = None,
        max_similar_faces: Optional[int] = None,
        **kwargs: Any
    ) -> _models.FindSimilarFacesResult:
        """Find similar faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_source: Source of the face. Default value is None.
        :paramtype face_source: ~contentunderstanding.models.FaceSource
        :keyword max_similar_faces: Maximum number of similar faces to return (up to 1000). Default
         value is None.
        :paramtype max_similar_faces: int
        :return: FindSimilarFacesResult. The FindSimilarFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.FindSimilarFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FindSimilarFacesResult] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"faceSource": face_source, "maxSimilarFaces": max_similar_faces}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_find_similar_faces_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FindSimilarFacesResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def verify_person(
        self,
        person_directory_id: str,
        person_id: str,
        *,
        face_source: _models.FaceSource,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VerifyPersonResult:
        """Verify if a face matches the person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~contentunderstanding.models.FaceSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyPersonResult. The VerifyPersonResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.VerifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def verify_person(
        self,
        person_directory_id: str,
        person_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VerifyPersonResult:
        """Verify if a face matches the person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyPersonResult. The VerifyPersonResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.VerifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def verify_person(
        self,
        person_directory_id: str,
        person_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VerifyPersonResult:
        """Verify if a face matches the person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyPersonResult. The VerifyPersonResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.VerifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def verify_person(
        self,
        person_directory_id: str,
        person_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_source: _models.FaceSource = _Unset,
        **kwargs: Any
    ) -> _models.VerifyPersonResult:
        """Verify if a face matches the person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~contentunderstanding.models.FaceSource
        :return: VerifyPersonResult. The VerifyPersonResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.VerifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VerifyPersonResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_source is _Unset:
                raise TypeError("missing required argument: face_source")
            body = {"faceSource": face_source}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_verify_person_request(
            person_directory_id=person_directory_id,
            person_id=person_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VerifyPersonResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class FacesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~contentunderstanding.aio.ContentUnderstandingClient`'s
        :attr:`faces` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: ContentUnderstandingClientConfiguration = (
            input_args.pop(0) if input_args else kwargs.pop("config")
        )
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def detect(
        self,
        *,
        content_type: str = "application/json",
        url: Optional[str] = None,
        data: Optional[bytes] = None,
        max_detected_faces: Optional[int] = None,
        **kwargs: Any
    ) -> _models.DetectFacesResult:
        """Detect faces in an image.

        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword url: Image URL.  Only one of url or data should be specified. Default value is None.
        :paramtype url: str
        :keyword data: Base64-encoded image data.  Only one of url or data should be specified. Default
         value is None.
        :paramtype data: bytes
        :keyword max_detected_faces: Maximum number of faces to return (up to 100). Default value is
         None.
        :paramtype max_detected_faces: int
        :return: DetectFacesResult. The DetectFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.DetectFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def detect(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DetectFacesResult:
        """Detect faces in an image.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DetectFacesResult. The DetectFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.DetectFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def detect(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DetectFacesResult:
        """Detect faces in an image.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DetectFacesResult. The DetectFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.DetectFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def detect(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        url: Optional[str] = None,
        data: Optional[bytes] = None,
        max_detected_faces: Optional[int] = None,
        **kwargs: Any
    ) -> _models.DetectFacesResult:
        """Detect faces in an image.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword url: Image URL.  Only one of url or data should be specified. Default value is None.
        :paramtype url: str
        :keyword data: Base64-encoded image data.  Only one of url or data should be specified. Default
         value is None.
        :paramtype data: bytes
        :keyword max_detected_faces: Maximum number of faces to return (up to 100). Default value is
         None.
        :paramtype max_detected_faces: int
        :return: DetectFacesResult. The DetectFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.DetectFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DetectFacesResult] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"data": data, "maxDetectedFaces": max_detected_faces, "url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_faces_detect_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DetectFacesResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def compare(
        self,
        *,
        face_source1: _models.FaceSource,
        face_source2: _models.FaceSource,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CompareFacesResult:
        """Compare the similarity between two faces.

        :keyword face_source1: First face to compare. Required.
        :paramtype face_source1: ~contentunderstanding.models.FaceSource
        :keyword face_source2: Second face to compare. Required.
        :paramtype face_source2: ~contentunderstanding.models.FaceSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CompareFacesResult. The CompareFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.CompareFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def compare(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CompareFacesResult:
        """Compare the similarity between two faces.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CompareFacesResult. The CompareFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.CompareFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def compare(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CompareFacesResult:
        """Compare the similarity between two faces.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CompareFacesResult. The CompareFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.CompareFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def compare(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_source1: _models.FaceSource = _Unset,
        face_source2: _models.FaceSource = _Unset,
        **kwargs: Any
    ) -> _models.CompareFacesResult:
        """Compare the similarity between two faces.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_source1: First face to compare. Required.
        :paramtype face_source1: ~contentunderstanding.models.FaceSource
        :keyword face_source2: Second face to compare. Required.
        :paramtype face_source2: ~contentunderstanding.models.FaceSource
        :return: CompareFacesResult. The CompareFacesResult is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.CompareFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CompareFacesResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_source1 is _Unset:
                raise TypeError("missing required argument: face_source1")
            if face_source2 is _Unset:
                raise TypeError("missing required argument: face_source2")
            body = {"faceSource1": face_source1, "faceSource2": face_source2}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_faces_compare_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CompareFacesResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ContentClassifiersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~contentunderstanding.aio.ContentUnderstandingClient`'s
        :attr:`content_classifiers` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: ContentUnderstandingClientConfiguration = (
            input_args.pop(0) if input_args else kwargs.pop("config")
        )
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_operation_status(
        self, classifier_id: str, operation_id: str, **kwargs: Any
    ) -> _models.ResourceOperationStatusContentClassifierContentClassifierError:
        """Get the status of a classifier creation operation.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param operation_id: The unique ID of the operation. Required.
        :type operation_id: str
        :return: ResourceOperationStatusContentClassifierContentClassifierError. The
         ResourceOperationStatusContentClassifierContentClassifierError is compatible with
         MutableMapping
        :rtype:
         ~contentunderstanding.models.ResourceOperationStatusContentClassifierContentClassifierError
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ResourceOperationStatusContentClassifierContentClassifierError] = kwargs.pop("cls", None)

        _request = build_content_classifiers_get_operation_status_request(
            classifier_id=classifier_id,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(
                _models.ResourceOperationStatusContentClassifierContentClassifierError, response.json()
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_replace_initial(
        self, classifier_id: str, resource: Union[_models.ContentClassifier, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_classifiers_create_or_replace_request(
            classifier_id=classifier_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_replace(
        self,
        classifier_id: str,
        resource: _models.ContentClassifier,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ContentClassifier]:
        """Create a new classifier asynchronously.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: ~contentunderstanding.models.ContentClassifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ContentClassifier. The ContentClassifier is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ContentClassifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_replace(
        self, classifier_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.ContentClassifier]:
        """Create a new classifier asynchronously.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ContentClassifier. The ContentClassifier is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ContentClassifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_replace(
        self, classifier_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.ContentClassifier]:
        """Create a new classifier asynchronously.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ContentClassifier. The ContentClassifier is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ContentClassifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_replace(
        self, classifier_id: str, resource: Union[_models.ContentClassifier, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncLROPoller[_models.ContentClassifier]:
        """Create a new classifier asynchronously.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Is one of the following types: ContentClassifier, JSON,
         IO[bytes] Required.
        :type resource: ~contentunderstanding.models.ContentClassifier or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns ContentClassifier. The ContentClassifier is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ContentClassifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ContentClassifier] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_replace_initial(
                classifier_id=classifier_id,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )

            deserialized = _deserialize(_models.ContentClassifier, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod,
                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.ContentClassifier].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.ContentClassifier](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update(
        self,
        classifier_id: str,
        resource: _models.ContentClassifier,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.ContentClassifier:
        """Update classifier properties.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: ~contentunderstanding.models.ContentClassifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentClassifier. The ContentClassifier is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.ContentClassifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self, classifier_id: str, resource: JSON, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.ContentClassifier:
        """Update classifier properties.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentClassifier. The ContentClassifier is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.ContentClassifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        classifier_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.ContentClassifier:
        """Update classifier properties.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentClassifier. The ContentClassifier is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.ContentClassifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self, classifier_id: str, resource: Union[_models.ContentClassifier, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.ContentClassifier:
        """Update classifier properties.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Is one of the following types: ContentClassifier, JSON,
         IO[bytes] Required.
        :type resource: ~contentunderstanding.models.ContentClassifier or JSON or IO[bytes]
        :return: ContentClassifier. The ContentClassifier is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.ContentClassifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ContentClassifier] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_classifiers_update_request(
            classifier_id=classifier_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ContentClassifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get(self, classifier_id: str, **kwargs: Any) -> _models.ContentClassifier:
        """Get classifier properties.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :return: ContentClassifier. The ContentClassifier is compatible with MutableMapping
        :rtype: ~contentunderstanding.models.ContentClassifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ContentClassifier] = kwargs.pop("cls", None)

        _request = build_content_classifiers_get_request(
            classifier_id=classifier_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ContentClassifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, classifier_id: str, **kwargs: Any) -> None:
        """Delete classifier.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_content_classifiers_delete_request(
            classifier_id=classifier_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncItemPaged["_models.ContentClassifier"]:
        """List classifiers.

        :return: An iterator like instance of ContentClassifier
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~contentunderstanding.models.ContentClassifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ContentClassifier]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_content_classifiers_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ContentClassifier], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _classify_initial(
        self,
        classifier_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        url: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_classifiers_classify_request(
            classifier_id=classifier_id,
            string_encoding=string_encoding,
            processing_location=processing_location,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_classify(
        self,
        classifier_id: str,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        url: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ClassifyResult]:
        """Classify content with optional splitting.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword url: The URL of the document to classify. Default value is None.
        :paramtype url: str
        :return: An instance of AsyncLROPoller that returns ClassifyResult. The ClassifyResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ClassifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_classify(
        self,
        classifier_id: str,
        body: JSON,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ClassifyResult]:
        """Classify content with optional splitting.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param body: Required.
        :type body: JSON
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ClassifyResult. The ClassifyResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ClassifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_classify(
        self,
        classifier_id: str,
        body: IO[bytes],
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ClassifyResult]:
        """Classify content with optional splitting.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ClassifyResult. The ClassifyResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ClassifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_classify(
        self,
        classifier_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        url: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ClassifyResult]:
        """Classify content with optional splitting.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~contentunderstanding.models.ProcessingLocation
        :keyword url: The URL of the document to classify. Default value is None.
        :paramtype url: str
        :return: An instance of AsyncLROPoller that returns ClassifyResult. The ClassifyResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ClassifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ClassifyResult] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._classify_initial(
                classifier_id=classifier_id,
                body=body,
                string_encoding=string_encoding,
                processing_location=processing_location,
                url=url,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )

            deserialized = _deserialize(_models.ClassifyResult, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod,
                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.ClassifyResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.ClassifyResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _classify_binary_initial(
        self,
        classifier_id: str,
        input: bytes,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type")
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _content = input

        _request = build_content_classifiers_classify_binary_request(
            classifier_id=classifier_id,
            string_encoding=string_encoding,
            processing_location=processing_location,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_classify_binary(
        self,
        classifier_id: str,
        input: bytes,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ClassifyResult]:
        """Classify content with optional splitting.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param input: The binary content of the document to classify. Required.
        :type input: bytes
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~contentunderstanding.models.ProcessingLocation
        :return: An instance of AsyncLROPoller that returns ClassifyResult. The ClassifyResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~contentunderstanding.models.ClassifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type")
        cls: ClsType[_models.ClassifyResult] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._classify_binary_initial(
                classifier_id=classifier_id,
                input=input,
                string_encoding=string_encoding,
                processing_location=processing_location,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )

            deserialized = _deserialize(_models.ClassifyResult, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod,
                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.ClassifyResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.ClassifyResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def get_result(self, operation_id: str, **kwargs: Any) -> _models.OperationStatusClassifyResultError:
        """Get the result of a classifier operation.

        :param operation_id: The unique ID of the operation. Required.
        :type operation_id: str
        :return: OperationStatusClassifyResultError. The OperationStatusClassifyResultError is
         compatible with MutableMapping
        :rtype: ~contentunderstanding.models.OperationStatusClassifyResultError
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.OperationStatusClassifyResultError] = kwargs.pop("cls", None)

        _request = build_content_classifiers_get_result_request(
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OperationStatusClassifyResultError, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
