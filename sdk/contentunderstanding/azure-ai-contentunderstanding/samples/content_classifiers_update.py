# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import asyncio
import os
from datetime import datetime
import uuid

from azure.ai.contentunderstanding.aio import ContentUnderstandingClient
from azure.ai.contentunderstanding.models import ContentClassifier

from sample_helper import get_credential, new_simple_classifier_schema

from dotenv import load_dotenv

load_dotenv()

"""
Prerequisites:
    pip install azure-ai-contentunderstanding python-dotenv
    az login  # Used for DefaultAzureCredential(). Alternatively, set the AZURE_CONTENT_UNDERSTANDING_KEY environment variable

Environment variables:
    AZURE_CONTENT_UNDERSTANDING_ENDPOINT   (required)
    AZURE_CONTENT_UNDERSTANDING_KEY        (optional - DefaultAzureCredential() will be used if not set)
    These variables can be set in a .env file in the samples directory for repeated use. Please see env.sample for an example.

Run:
    python content_classifiers_update.py
"""


async def main():
    """
    Update classifier using update API.

    High-level steps:
    1. Create an initial classifier
    2. Get the classifier to verify initial state
    3. Update the classifier with new description and tags
    4. Get the classifier again to verify changes persisted
    5. Clean up the created classifier
    """
    endpoint = os.getenv("AZURE_CONTENT_UNDERSTANDING_ENDPOINT") or ""
    credential = get_credential()

    async with ContentUnderstandingClient(
        endpoint=endpoint, credential=credential
    ) as client, credential:
        classifier_id = f"sdk-sample-clf-{datetime.now().strftime('%Y%m%d')}-{datetime.now().strftime('%H%M%S')}-{uuid.uuid4().hex[:8]}"

        # Create initial classifier using object model
        print(f"üîß Creating initial classifier '{classifier_id}'...")

        initial_classifier = new_simple_classifier_schema(
            classifier_id=classifier_id,
            description=f"Initial classifier for update demo: {classifier_id}",
            tags={"initial_tag": "initial_value", "demo_type": "update"},
        )

        # Start the classifier creation operation
        poller = await client.content_classifiers.begin_create_or_replace(
            classifier_id=classifier_id,
            resource=initial_classifier,
        )

        # Wait for the classifier to be created
        print(f"‚è≥ Waiting for classifier creation to complete...")
        await poller.result()
        print(f"‚úÖ Classifier '{classifier_id}' created successfully!")

        # Get the classifier before update to verify initial state
        print(f"üìã Getting classifier '{classifier_id}' before update...")
        classifier_before_update = await client.content_classifiers.get(
            classifier_id=classifier_id
        )

        print(f"‚úÖ Initial classifier state verified:")
        print(
            f"   Description: {getattr(classifier_before_update, 'description', 'N/A')}"
        )
        print(f"   Tags: {getattr(classifier_before_update, 'tags', 'N/A')}")

        # Create updated classifier with only allowed properties (description and tags)
        print(f"üîÑ Creating updated classifier configuration...")
        # Use a partial resource dict for update to avoid requiring categories
        updated_classifier = {
            "description": f"Updated classifier for update demo: {classifier_id}",
            "tags": {
                "initial_tag": "initial_value",
                "updated_tag": "updated_value",
                "demo_type": "update",
            },
        }

        # Update the classifier
        print(
            f"üìù Updating classifier '{classifier_id}' with new description and tags..."
        )
        response = await client.content_classifiers.update(
            classifier_id=classifier_id,
            resource=updated_classifier,
        )

        print(f"‚úÖ Classifier updated successfully!")
        print(f"   Updated description: {getattr(response, 'description', 'N/A')}")
        print(f"   Updated tags: {getattr(response, 'tags', 'N/A')}")

        # Get the classifier after update to verify the changes persisted
        print(f"üìã Getting classifier '{classifier_id}' after update...")
        classifier_after_update = await client.content_classifiers.get(
            classifier_id=classifier_id
        )

        print(f"‚úÖ Updated classifier state verified:")
        print(
            f"   Description: {getattr(classifier_after_update, 'description', 'N/A')}"
        )
        print(f"   Tags: {getattr(classifier_after_update, 'tags', 'N/A')}")

        # Verify the changes were applied correctly
        expected_description = f"Updated classifier for update demo: {classifier_id}"
        actual_description = getattr(classifier_after_update, "description", "")
        actual_tags = getattr(classifier_after_update, "tags", {})

        if actual_description == expected_description and "updated_tag" in actual_tags:
            print(f"‚úÖ All changes verified successfully!")
        else:
            print(f"‚ö†Ô∏è  Some changes may not have been applied as expected")

        # Clean up the created classifier (demo cleanup)
        print(f"üóëÔ∏è  Deleting classifier '{classifier_id}' (demo cleanup)...")
        await client.content_classifiers.delete(classifier_id=classifier_id)
        print(f"‚úÖ Classifier '{classifier_id}' deleted successfully!")


# x-ms-original-file: 2025-05-01-preview/ContentClassifiers_Update.json
if __name__ == "__main__":
    asyncio.run(main())
