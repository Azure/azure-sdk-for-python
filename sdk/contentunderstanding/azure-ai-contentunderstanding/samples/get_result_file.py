# pylint: disable=line-too-long,useless-suppression

# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import asyncio
import os
from datetime import datetime
import uuid
from collections.abc import AsyncIterator

from typing import Any, Optional

from azure.ai.contentunderstanding.aio import ContentUnderstandingClient
from azure.ai.contentunderstanding.models import (
    AnalyzeInput,
    AnalyzeResult,
    ContentAnalyzer,
    ContentAnalyzerConfig,
    ContentFieldSchema,
    ContentFieldDefinition,
    ContentFieldType,
    GenerationMethod,
    ProcessingLocation,
    AudioVisualContent,
)

from sample_helper import (
    save_json_to_file,
)
from azure.core.credentials import AzureKeyCredential
from azure.identity.aio import DefaultAzureCredential

from dotenv import load_dotenv

load_dotenv()

"""
Prerequisites:
    pip install azure-ai-contentunderstanding python-dotenv
    az login  # Used for DefaultAzureCredential(). Alternatively, set the AZURE_CONTENT_UNDERSTANDING_KEY environment variable

Environment variables:
    AZURE_CONTENT_UNDERSTANDING_ENDPOINT   (required)
    AZURE_CONTENT_UNDERSTANDING_KEY        (optional - DefaultAzureCredential() will be used if not set)
    These variables can be set in a .env file in the samples directory for repeated use. Please see env.sample for an example.

Run:
    python get_result_file.py
"""


def save_keyframe_image_to_file(
    image_content: bytes,
    keyframe_id: str,
    test_name: str,
    test_py_file_dir: str,
    identifier: Optional[str] = None,
    output_dir: str = "sample_output",
) -> str:
    """Save keyframe image to output file using pytest naming convention.

    Args:
        image_content: The binary image content to save
        keyframe_id: The keyframe ID (e.g., "keyframes/733")
        test_name: Name of the test case (e.g., function name)
        test_py_file_dir: Directory where pytest files are located
        identifier: Optional unique identifier to avoid conflicts (e.g., analyzer_id)
        output_dir: Directory name to save the output file (default: "sample_output")

    Returns:
        str: Path to the saved image file

    Raises:
        OSError: If there are issues creating directory or writing file
    """
    # Generate timestamp and frame ID
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    # Extract the frame time from the keyframe path (e.g., "keyframes/733" -> "733")
    if "/" in keyframe_id:
        frame_id = keyframe_id.split("/")[-1]
    else:
        # Fallback: use as-is if no slash found
        frame_id = keyframe_id

    # Create output directory if it doesn't exist
    output_dir_path = os.path.join(test_py_file_dir, output_dir)
    os.makedirs(output_dir_path, exist_ok=True)

    # Generate output filename with optional identifier to avoid conflicts
    if identifier:
        output_filename = f"{test_name}_{identifier}_{timestamp}_{frame_id}.jpg"
    else:
        output_filename = f"{test_name}_{timestamp}_{frame_id}.jpg"

    saved_file_path = os.path.join(output_dir_path, output_filename)

    # Write the image content to file
    with open(saved_file_path, "wb") as image_file:
        image_file.write(image_content)

    print(f"Image file saved to: {saved_file_path}")
    return saved_file_path


async def main():
    """
    Get result files using get_result_file API.

    High-level steps:
    1. Create a marketing video analyzer
    2. Analyze a video file to generate keyframes
    3. Extract operation ID from the analysis
    4. Get result files (keyframe images) using the operation ID
    5. Save the keyframe images to local files
    6. Clean up the created analyzer
    """
    endpoint = os.getenv("AZURE_CONTENT_UNDERSTANDING_ENDPOINT") or ""
    print(f"Using endpoint: {endpoint}")
    # Return AzureKeyCredential if AZURE_CONTENT_UNDERSTANDING_KEY is set, otherwise DefaultAzureCredential
    key = os.getenv("AZURE_CONTENT_UNDERSTANDING_KEY")
    credential = AzureKeyCredential(key) if key else DefaultAzureCredential()

    async with ContentUnderstandingClient(endpoint=endpoint, credential=credential) as client:
        analyzer_id = f"sdk_sample_video_{datetime.now().strftime('%Y%m%d')}_{datetime.now().strftime('%H%M%S')}_{uuid.uuid4().hex[:8]}"

        # Create a marketing video analyzer using object model
        print(f"Creating marketing video analyzer '{analyzer_id}'...")

        video_analyzer = ContentAnalyzer(
            base_analyzer_id="prebuilt-video",
            config=ContentAnalyzerConfig(
                return_details=True,
            ),
            models={"completion": "gpt-4.1"},  # Required when using field_schema
            description="Marketing video analyzer for result file demo",
            tags={"demo_type": "video_analysis"},
        )

        # Start the analyzer creation operation
        poller = await client.begin_create_analyzer(
            analyzer_id=analyzer_id,
            resource=video_analyzer,
        )

        # Wait for the analyzer to be created
        print(f"Waiting for analyzer creation to complete...")
        await poller.result()
        print(f"Analyzer '{analyzer_id}' created successfully!")

        # Use the FlightSimulator.mp4 video file from remote location
        video_file_url = "https://github.com/Azure-Samples/azure-ai-content-understanding-assets/raw/refs/heads/main/videos/sdk_samples/FlightSimulator.mp4"
        print(f"Using video file from URL: {video_file_url}")

        # Begin video analysis operation
        print(f"Starting video analysis with analyzer '{analyzer_id}'...")
        analysis_poller = await client.begin_analyze(analyzer_id=analyzer_id, inputs=[AnalyzeInput(url=video_file_url)])

        # Wait for analysis completion
        print(f"Waiting for video analysis to complete...")
        analysis_result = await analysis_poller.result()
        print(f"Video analysis completed successfully!")

        # Save the full analysis result to JSON for detailed inspection
        save_json_to_file(
            analysis_result.as_dict(),
            filename_prefix="get_result_file",
        )
        print("Analysis result saved to JSON file for detailed inspection")

        # Extract operation ID for get_result_file using the poller's details property
        analysis_operation_id = analysis_poller.operation_id
        print(f"Extracted analysis operation ID: {analysis_operation_id}")

        # Use the analysis result we already have from the poller to see what files are available
        print(f"Using analysis result to find available files...")
        operation_result: Any = analysis_result
        if operation_result is None:
            print("No analysis result available")
            return
        print(f"Analysis result contains {len(operation_result.contents)} contents")

        # Look for keyframe times in the analysis result
        keyframe_times_ms: list[int] = []
        for content in operation_result.contents:
            if isinstance(content, AudioVisualContent):
                video_content: AudioVisualContent = content
                print(f"KeyFrameTimesMs: {video_content.key_frame_times_ms}")
                keyframe_times_ms.extend(video_content.key_frame_times_ms or [])
                print(f"Found keyframes in video content")
                break
            else:
                print(f"Content is not an AudioVisualContent: {content}")

        if not keyframe_times_ms:
            print("No keyframe times found in the analysis result")
            return

        print(f"Found {len(keyframe_times_ms)} keyframe times in milliseconds")

        # Build keyframe filenames using the time values
        keyframe_files = [f"keyframes/{time_ms}" for time_ms in keyframe_times_ms]

        # Download and save a few keyframe images as examples (first, middle, last)
        if len(keyframe_files) >= 3:
            frames_to_download = {
                keyframe_files[0],
                keyframe_files[-1],
                keyframe_files[len(keyframe_files) // 2],
            }
        else:
            frames_to_download = set(keyframe_files)

        files_to_download = list(frames_to_download)
        print(f"Downloading {len(files_to_download)} keyframe images as examples: {files_to_download}")

        for keyframe_id in files_to_download:
            print(f"Getting result file: {keyframe_id}")

            # Get the result file (keyframe image)
            response: Any = await client.get_result_file(
                operation_id=analysis_operation_id,
                path=keyframe_id,
            )

            # Handle the response - it's an async iterator that needs to be collected
            from collections.abc import AsyncIterator

            assert isinstance(response, AsyncIterator), f"Expected AsyncIterator, got {type(response)}"

            # It's an async iterator, collect all bytes efficiently
            chunks: list[bytes] = []
            async for chunk in response:
                chunks.append(chunk)
            image_content = b"".join(chunks)

            print(f"Retrieved image file for {keyframe_id} ({len(image_content)} bytes)")

            # Save the image file
            saved_file_path = save_keyframe_image_to_file(
                image_content=image_content,
                keyframe_id=keyframe_id,
                test_name="get_result_file",
                test_py_file_dir=os.path.dirname(os.path.abspath(__file__)),
                identifier=analyzer_id,
            )
            print(f"Keyframe image saved to: {saved_file_path}")

        # Clean up the created analyzer (demo cleanup)
        print(f"Deleting analyzer '{analyzer_id}' (demo cleanup)...")
        await client.delete_analyzer(analyzer_id=analyzer_id)
        print(f"Analyzer '{analyzer_id}' deleted successfully!")

    # x-ms-original-file: 2025-11-01/ContentAnalyzers_GetResultFile.json
    # Manually close DefaultAzureCredential if it was used
    if isinstance(credential, DefaultAzureCredential):
        await credential.close()


if __name__ == "__main__":
    asyncio.run(main())
