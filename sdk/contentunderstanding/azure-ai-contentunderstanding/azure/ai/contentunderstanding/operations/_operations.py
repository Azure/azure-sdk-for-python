# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
from io import IOBase
import json
from typing import Any, Callable, Dict, IO, Iterator, List, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core import PipelineClient
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._configuration import ContentUnderstandingClientConfiguration
from .._utils.model_base import SdkJSONEncoder, _deserialize
from .._utils.serialization import Deserializer, Serializer

JSON = MutableMapping[str, Any]
_Unset: Any = object()
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_content_analyzers_get_operation_status_request(  # pylint: disable=name-too-long
    analyzer_id: str, operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/analyzers/{analyzerId}/operations/{operationId}"
    path_format_arguments = {
        "analyzerId": _SERIALIZER.url("analyzer_id", analyzer_id, "str"),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_analyzers_create_or_replace_request(  # pylint: disable=name-too-long
    analyzer_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/analyzers/{analyzerId}"
    path_format_arguments = {
        "analyzerId": _SERIALIZER.url("analyzer_id", analyzer_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_analyzers_update_request(analyzer_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/analyzers/{analyzerId}"
    path_format_arguments = {
        "analyzerId": _SERIALIZER.url("analyzer_id", analyzer_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_analyzers_get_request(analyzer_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/analyzers/{analyzerId}"
    path_format_arguments = {
        "analyzerId": _SERIALIZER.url("analyzer_id", analyzer_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_analyzers_delete_request(analyzer_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/analyzers/{analyzerId}"
    path_format_arguments = {
        "analyzerId": _SERIALIZER.url("analyzer_id", analyzer_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_analyzers_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/analyzers"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_analyzers_analyze_request(
    analyzer_id: str,
    *,
    string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
    processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/analyzers/{analyzerId}:analyze"
    path_format_arguments = {
        "analyzerId": _SERIALIZER.url("analyzer_id", analyzer_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if string_encoding is not None:
        _params["stringEncoding"] = _SERIALIZER.query("string_encoding", string_encoding, "str")
    if processing_location is not None:
        _params["processingLocation"] = _SERIALIZER.query("processing_location", processing_location, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_analyzers_analyze_binary_request(  # pylint: disable=name-too-long
    analyzer_id: str,
    *,
    string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
    processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/analyzers/{analyzerId}:analyze"
    path_format_arguments = {
        "analyzerId": _SERIALIZER.url("analyzer_id", analyzer_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if string_encoding is not None:
        _params["stringEncoding"] = _SERIALIZER.query("string_encoding", string_encoding, "str")
    if processing_location is not None:
        _params["processingLocation"] = _SERIALIZER.query("processing_location", processing_location, "str")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_analyzers_get_result_request(  # pylint: disable=name-too-long
    operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/analyzerResults/{operationId}"
    path_format_arguments = {
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_analyzers_get_result_file_request(  # pylint: disable=name-too-long
    operation_id: str, path: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "*/*")

    # Construct URL
    _url = "/analyzerResults/{operationId}/files/{path}"
    path_format_arguments = {
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
        "path": _SERIALIZER.url("path", path, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_create_request(person_directory_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_update_request(person_directory_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_get_request(person_directory_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_delete_request(person_directory_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_add_person_request(  # pylint: disable=name-too-long
    person_directory_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/persons"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_update_person_request(  # pylint: disable=name-too-long
    person_directory_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/persons/{personId}"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_get_person_request(  # pylint: disable=name-too-long
    person_directory_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/persons/{personId}"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_delete_person_request(  # pylint: disable=name-too-long
    person_directory_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/persons/{personId}"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_list_persons_request(  # pylint: disable=name-too-long
    person_directory_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/persons"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_add_face_request(  # pylint: disable=name-too-long
    person_directory_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/faces"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_update_face_request(  # pylint: disable=name-too-long
    person_directory_id: str, face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/faces/{faceId}"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
        "faceId": _SERIALIZER.url("face_id", face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_get_face_request(  # pylint: disable=name-too-long
    person_directory_id: str, face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/faces/{faceId}"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
        "faceId": _SERIALIZER.url("face_id", face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_delete_face_request(  # pylint: disable=name-too-long
    person_directory_id: str, face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/faces/{faceId}"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
        "faceId": _SERIALIZER.url("face_id", face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_list_faces_request(  # pylint: disable=name-too-long
    person_directory_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/faces"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_identify_person_request(  # pylint: disable=name-too-long
    person_directory_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/persons:identify"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_find_similar_faces_request(  # pylint: disable=name-too-long
    person_directory_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/faces:find"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directories_verify_person_request(  # pylint: disable=name-too-long
    person_directory_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/personDirectories/{personDirectoryId}/persons/{personId}:verify"
    path_format_arguments = {
        "personDirectoryId": _SERIALIZER.url("person_directory_id", person_directory_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_faces_detect_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/faces:detect"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_faces_compare_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/faces:compare"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_classifiers_get_operation_status_request(  # pylint: disable=name-too-long
    classifier_id: str, operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/classifiers/{classifierId}/operations/{operationId}"
    path_format_arguments = {
        "classifierId": _SERIALIZER.url("classifier_id", classifier_id, "str"),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_classifiers_create_or_replace_request(  # pylint: disable=name-too-long
    classifier_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/classifiers/{classifierId}"
    path_format_arguments = {
        "classifierId": _SERIALIZER.url("classifier_id", classifier_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_classifiers_update_request(classifier_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/classifiers/{classifierId}"
    path_format_arguments = {
        "classifierId": _SERIALIZER.url("classifier_id", classifier_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_classifiers_get_request(classifier_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/classifiers/{classifierId}"
    path_format_arguments = {
        "classifierId": _SERIALIZER.url("classifier_id", classifier_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_classifiers_delete_request(classifier_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/classifiers/{classifierId}"
    path_format_arguments = {
        "classifierId": _SERIALIZER.url("classifier_id", classifier_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_classifiers_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/classifiers"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_classifiers_classify_request(  # pylint: disable=name-too-long
    classifier_id: str,
    *,
    string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
    processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/classifiers/{classifierId}:classify"
    path_format_arguments = {
        "classifierId": _SERIALIZER.url("classifier_id", classifier_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if string_encoding is not None:
        _params["stringEncoding"] = _SERIALIZER.query("string_encoding", string_encoding, "str")
    if processing_location is not None:
        _params["processingLocation"] = _SERIALIZER.query("processing_location", processing_location, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_classifiers_classify_binary_request(  # pylint: disable=name-too-long
    classifier_id: str,
    *,
    string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
    processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/classifiers/{classifierId}:classify"
    path_format_arguments = {
        "classifierId": _SERIALIZER.url("classifier_id", classifier_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if string_encoding is not None:
        _params["stringEncoding"] = _SERIALIZER.query("string_encoding", string_encoding, "str")
    if processing_location is not None:
        _params["processingLocation"] = _SERIALIZER.query("processing_location", processing_location, "str")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_content_classifiers_get_result_request(  # pylint: disable=name-too-long
    operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/classifierResults/{operationId}"
    path_format_arguments = {
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class ContentAnalyzersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.contentunderstanding.ContentUnderstandingClient`'s
        :attr:`content_analyzers` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: ContentUnderstandingClientConfiguration = (
            input_args.pop(0) if input_args else kwargs.pop("config")
        )
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_operation_status(
        self, analyzer_id: str, operation_id: str, **kwargs: Any
    ) -> _models.ResourceOperationStatusContentAnalyzerContentAnalyzerError:
        """Get the status of an analyzer creation operation.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param operation_id: The unique ID of the operation. Required.
        :type operation_id: str
        :return: ResourceOperationStatusContentAnalyzerContentAnalyzerError. The
         ResourceOperationStatusContentAnalyzerContentAnalyzerError is compatible with MutableMapping
        :rtype:
         ~azure.ai.contentunderstanding.models.ResourceOperationStatusContentAnalyzerContentAnalyzerError
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ResourceOperationStatusContentAnalyzerContentAnalyzerError] = kwargs.pop("cls", None)

        _request = build_content_analyzers_get_operation_status_request(
            analyzer_id=analyzer_id,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(
                _models.ResourceOperationStatusContentAnalyzerContentAnalyzerError, response.json()
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_replace_initial(
        self, analyzer_id: str, resource: Union[_models.ContentAnalyzer, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_analyzers_create_or_replace_request(
            analyzer_id=analyzer_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        analyzer_id: str,
        resource: _models.ContentAnalyzer,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.ContentAnalyzer]:
        """Create a new analyzer asynchronously.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.contentunderstanding.models.ContentAnalyzer
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns ContentAnalyzer. The ContentAnalyzer is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ContentAnalyzer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self, analyzer_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.ContentAnalyzer]:
        """Create a new analyzer asynchronously.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns ContentAnalyzer. The ContentAnalyzer is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ContentAnalyzer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self, analyzer_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.ContentAnalyzer]:
        """Create a new analyzer asynchronously.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns ContentAnalyzer. The ContentAnalyzer is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ContentAnalyzer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create_or_replace(
        self, analyzer_id: str, resource: Union[_models.ContentAnalyzer, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.ContentAnalyzer]:
        """Create a new analyzer asynchronously.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Is one of the following types: ContentAnalyzer, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.contentunderstanding.models.ContentAnalyzer or JSON or IO[bytes]
        :return: An instance of LROPoller that returns ContentAnalyzer. The ContentAnalyzer is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ContentAnalyzer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ContentAnalyzer] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                analyzer_id=analyzer_id,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )

            deserialized = _deserialize(_models.ContentAnalyzer, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.ContentAnalyzer].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.ContentAnalyzer](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    def update(
        self,
        analyzer_id: str,
        resource: _models.ContentAnalyzer,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.ContentAnalyzer:
        """Update analyzer properties.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.contentunderstanding.models.ContentAnalyzer
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentAnalyzer. The ContentAnalyzer is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.ContentAnalyzer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(
        self, analyzer_id: str, resource: JSON, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.ContentAnalyzer:
        """Update analyzer properties.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentAnalyzer. The ContentAnalyzer is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.ContentAnalyzer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(
        self,
        analyzer_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.ContentAnalyzer:
        """Update analyzer properties.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentAnalyzer. The ContentAnalyzer is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.ContentAnalyzer
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update(
        self, analyzer_id: str, resource: Union[_models.ContentAnalyzer, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.ContentAnalyzer:
        """Update analyzer properties.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param resource: The resource instance. Is one of the following types: ContentAnalyzer, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.contentunderstanding.models.ContentAnalyzer or JSON or IO[bytes]
        :return: ContentAnalyzer. The ContentAnalyzer is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.ContentAnalyzer
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ContentAnalyzer] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_analyzers_update_request(
            analyzer_id=analyzer_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ContentAnalyzer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get(self, analyzer_id: str, **kwargs: Any) -> _models.ContentAnalyzer:
        """Get analyzer properties.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :return: ContentAnalyzer. The ContentAnalyzer is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.ContentAnalyzer
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ContentAnalyzer] = kwargs.pop("cls", None)

        _request = build_content_analyzers_get_request(
            analyzer_id=analyzer_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ContentAnalyzer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(self, analyzer_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete analyzer.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_content_analyzers_delete_request(
            analyzer_id=analyzer_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> ItemPaged["_models.ContentAnalyzer"]:
        """List analyzers.

        :return: An iterator like instance of ContentAnalyzer
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.contentunderstanding.models.ContentAnalyzer]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ContentAnalyzer]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_content_analyzers_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ContentAnalyzer], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _analyze_initial(
        self,
        analyzer_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        url: Optional[str] = None,
        data: Optional[bytes] = None,
        inputs: Optional[List[_models.AnalyzeInput]] = None,
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"data": data, "inputs": inputs, "url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_analyzers_analyze_request(
            analyzer_id=analyzer_id,
            string_encoding=string_encoding,
            processing_location=processing_location,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_analyze(
        self,
        analyzer_id: str,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        url: Optional[str] = None,
        data: Optional[bytes] = None,
        inputs: Optional[List[_models.AnalyzeInput]] = None,
        **kwargs: Any
    ) -> LROPoller[_models.AnalyzeResult]:
        """Extract content and fields from input.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~azure.ai.contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~azure.ai.contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword url: The URL of the primary input to analyze.  Only one of url or data should be
         specified. Default value is None.
        :paramtype url: str
        :keyword data: Base64-encoded binary content of the primary input to analyze.  Only one of url
         or data should be specified. Default value is None.
        :paramtype data: bytes
        :keyword inputs: Additional inputs to analyze.  Only supported in analyzers with mode=pro.
         Default value is None.
        :paramtype inputs: list[~azure.ai.contentunderstanding.models.AnalyzeInput]
        :return: An instance of LROPoller that returns AnalyzeResult. The AnalyzeResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.AnalyzeResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_analyze(
        self,
        analyzer_id: str,
        body: JSON,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AnalyzeResult]:
        """Extract content and fields from input.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param body: Required.
        :type body: JSON
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~azure.ai.contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~azure.ai.contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AnalyzeResult. The AnalyzeResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.AnalyzeResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_analyze(
        self,
        analyzer_id: str,
        body: IO[bytes],
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AnalyzeResult]:
        """Extract content and fields from input.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~azure.ai.contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~azure.ai.contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AnalyzeResult. The AnalyzeResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.AnalyzeResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_analyze(
        self,
        analyzer_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        url: Optional[str] = None,
        data: Optional[bytes] = None,
        inputs: Optional[List[_models.AnalyzeInput]] = None,
        **kwargs: Any
    ) -> LROPoller[_models.AnalyzeResult]:
        """Extract content and fields from input.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~azure.ai.contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~azure.ai.contentunderstanding.models.ProcessingLocation
        :keyword url: The URL of the primary input to analyze.  Only one of url or data should be
         specified. Default value is None.
        :paramtype url: str
        :keyword data: Base64-encoded binary content of the primary input to analyze.  Only one of url
         or data should be specified. Default value is None.
        :paramtype data: bytes
        :keyword inputs: Additional inputs to analyze.  Only supported in analyzers with mode=pro.
         Default value is None.
        :paramtype inputs: list[~azure.ai.contentunderstanding.models.AnalyzeInput]
        :return: An instance of LROPoller that returns AnalyzeResult. The AnalyzeResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.AnalyzeResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AnalyzeResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._analyze_initial(
                analyzer_id=analyzer_id,
                body=body,
                string_encoding=string_encoding,
                processing_location=processing_location,
                url=url,
                data=data,
                inputs=inputs,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )

            deserialized = _deserialize(_models.AnalyzeResult, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.AnalyzeResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.AnalyzeResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _analyze_binary_initial(
        self,
        analyzer_id: str,
        input: bytes,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type")
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _content = input

        _request = build_content_analyzers_analyze_binary_request(
            analyzer_id=analyzer_id,
            string_encoding=string_encoding,
            processing_location=processing_location,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_analyze_binary(
        self,
        analyzer_id: str,
        input: bytes,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        **kwargs: Any
    ) -> LROPoller[_models.AnalyzeResult]:
        """Extract content and fields from input.

        :param analyzer_id: The unique identifier of the analyzer. Required.
        :type analyzer_id: str
        :param input: The binary content of the document to analyze. Required.
        :type input: bytes
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~azure.ai.contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~azure.ai.contentunderstanding.models.ProcessingLocation
        :return: An instance of LROPoller that returns AnalyzeResult. The AnalyzeResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.AnalyzeResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type")
        cls: ClsType[_models.AnalyzeResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._analyze_binary_initial(
                analyzer_id=analyzer_id,
                input=input,
                string_encoding=string_encoding,
                processing_location=processing_location,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )

            deserialized = _deserialize(_models.AnalyzeResult, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.AnalyzeResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.AnalyzeResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def get_result(self, operation_id: str, **kwargs: Any) -> _models.OperationStatusAnalyzeResultError:
        """Get the result of an analysis operation.

        :param operation_id: The unique ID of the operation. Required.
        :type operation_id: str
        :return: OperationStatusAnalyzeResultError. The OperationStatusAnalyzeResultError is compatible
         with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.OperationStatusAnalyzeResultError
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.OperationStatusAnalyzeResultError] = kwargs.pop("cls", None)

        _request = build_content_analyzers_get_result_request(
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OperationStatusAnalyzeResultError, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_result_file(self, operation_id: str, path: str, **kwargs: Any) -> Iterator[bytes]:
        """Get a file associated with the result of an analysis operation.

        :param operation_id: Operation identifier. Required.
        :type operation_id: str
        :param path: File path. Required.
        :type path: str
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_content_analyzers_get_result_file_request(
            operation_id=operation_id,
            path=path,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class PersonDirectoriesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.contentunderstanding.ContentUnderstandingClient`'s
        :attr:`person_directories` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: ContentUnderstandingClientConfiguration = (
            input_args.pop(0) if input_args else kwargs.pop("config")
        )
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create(
        self,
        person_directory_id: str,
        resource: _models.PersonDirectory,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PersonDirectory:
        """Create a new person directory.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.contentunderstanding.models.PersonDirectory
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, person_directory_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectory:
        """Create a new person directory.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, person_directory_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectory:
        """Create a new person directory.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(
        self, person_directory_id: str, resource: Union[_models.PersonDirectory, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.PersonDirectory:
        """Create a new person directory.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Is one of the following types: PersonDirectory, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.contentunderstanding.models.PersonDirectory or JSON or IO[bytes]
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectory] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_create_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self,
        person_directory_id: str,
        resource: _models.PersonDirectory,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectory:
        """Update person directory properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.contentunderstanding.models.PersonDirectory
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(
        self,
        person_directory_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectory:
        """Update person directory properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(
        self,
        person_directory_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectory:
        """Update person directory properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update(
        self, person_directory_id: str, resource: Union[_models.PersonDirectory, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.PersonDirectory:
        """Update person directory properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param resource: The resource instance. Is one of the following types: PersonDirectory, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.contentunderstanding.models.PersonDirectory or JSON or IO[bytes]
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectory] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_update_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get(self, person_directory_id: str, **kwargs: Any) -> _models.PersonDirectory:
        """Get person directory properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :return: PersonDirectory. The PersonDirectory is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonDirectory] = kwargs.pop("cls", None)

        _request = build_person_directories_get_request(
            person_directory_id=person_directory_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(self, person_directory_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete person directory and all associated persons and faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_directories_delete_request(
            person_directory_id=person_directory_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> ItemPaged["_models.PersonDirectory"]:
        """List person directories.

        :return: An iterator like instance of PersonDirectory
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.contentunderstanding.models.PersonDirectory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PersonDirectory]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_person_directories_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PersonDirectory], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def add_person(
        self,
        person_directory_id: str,
        *,
        content_type: str = "application/json",
        tags: Optional[Dict[str, str]] = None,
        face_ids: Optional[List[str]] = None,
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Add a new person and optionally associate with existing faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword tags: Tags associated with the person. Default value is None.
        :paramtype tags: dict[str, str]
        :keyword face_ids: List of faces associated with the person. Default value is None.
        :paramtype face_ids: list[str]
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_person(
        self, person_directory_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Add a new person and optionally associate with existing faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_person(
        self, person_directory_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Add a new person and optionally associate with existing faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add_person(
        self,
        person_directory_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        tags: Optional[Dict[str, str]] = None,
        face_ids: Optional[List[str]] = None,
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Add a new person and optionally associate with existing faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword tags: Tags associated with the person. Default value is None.
        :paramtype tags: dict[str, str]
        :keyword face_ids: List of faces associated with the person. Default value is None.
        :paramtype face_ids: list[str]
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectoryPerson] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"faceIds": face_ids, "tags": tags}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_add_person_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_person(
        self,
        person_directory_id: str,
        person_id: str,
        resource: _models.PersonDirectoryPerson,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Update person properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.contentunderstanding.models.PersonDirectoryPerson
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_person(
        self,
        person_directory_id: str,
        person_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Update person properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_person(
        self,
        person_directory_id: str,
        person_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Update person properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_person(
        self,
        person_directory_id: str,
        person_id: str,
        resource: Union[_models.PersonDirectoryPerson, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PersonDirectoryPerson:
        """Update person properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Is one of the following types: PersonDirectoryPerson,
         JSON, IO[bytes] Required.
        :type resource: ~azure.ai.contentunderstanding.models.PersonDirectoryPerson or JSON or
         IO[bytes]
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectoryPerson] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_update_person_request(
            person_directory_id=person_directory_id,
            person_id=person_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_person(self, person_directory_id: str, person_id: str, **kwargs: Any) -> _models.PersonDirectoryPerson:
        """Get person properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonDirectoryPerson] = kwargs.pop("cls", None)

        _request = build_person_directories_get_person_request(
            person_directory_id=person_directory_id,
            person_id=person_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_person(  # pylint: disable=inconsistent-return-statements
        self, person_directory_id: str, person_id: str, **kwargs: Any
    ) -> None:
        """Delete person.  Any linked faces will be disassociated, but not deleted.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_directories_delete_person_request(
            person_directory_id=person_directory_id,
            person_id=person_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list_persons(self, person_directory_id: str, **kwargs: Any) -> ItemPaged["_models.PersonDirectoryPerson"]:
        """List persons.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :return: An iterator like instance of PersonDirectoryPerson
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.ai.contentunderstanding.models.PersonDirectoryPerson]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PersonDirectoryPerson]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_person_directories_list_persons_request(
                    person_directory_id=person_directory_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PersonDirectoryPerson], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def add_face(
        self,
        person_directory_id: str,
        *,
        face_source: _models.FaceSource,
        content_type: str = "application/json",
        person_id: Optional[str] = None,
        quality_threshold: Optional[Union[str, _models.QualityForRecognition]] = None,
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Add a new face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~azure.ai.contentunderstanding.models.FaceSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword person_id: Person identifier with which to associate the face. Default value is None.
        :paramtype person_id: str
        :keyword quality_threshold: Face quality threshold below which the face will not be added.
         Default is medium. Known values are: "low", "medium", and "high". Default value is None.
        :paramtype quality_threshold: str or
         ~azure.ai.contentunderstanding.models.QualityForRecognition
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_face(
        self, person_directory_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Add a new face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_face(
        self, person_directory_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Add a new face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add_face(
        self,
        person_directory_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_source: _models.FaceSource = _Unset,
        person_id: Optional[str] = None,
        quality_threshold: Optional[Union[str, _models.QualityForRecognition]] = None,
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Add a new face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~azure.ai.contentunderstanding.models.FaceSource
        :keyword person_id: Person identifier with which to associate the face. Default value is None.
        :paramtype person_id: str
        :keyword quality_threshold: Face quality threshold below which the face will not be added.
         Default is medium. Known values are: "low", "medium", and "high". Default value is None.
        :paramtype quality_threshold: str or
         ~azure.ai.contentunderstanding.models.QualityForRecognition
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectoryFace] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_source is _Unset:
                raise TypeError("missing required argument: face_source")
            body = {"faceSource": face_source, "personId": person_id, "qualityThreshold": quality_threshold}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_add_face_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_face(
        self,
        person_directory_id: str,
        face_id: str,
        resource: _models.PersonDirectoryFace,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Update face properties, such as modifying the association with a person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.contentunderstanding.models.PersonDirectoryFace
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_face(
        self,
        person_directory_id: str,
        face_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Update face properties, such as modifying the association with a person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_face(
        self,
        person_directory_id: str,
        face_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Update face properties, such as modifying the association with a person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_face(
        self,
        person_directory_id: str,
        face_id: str,
        resource: Union[_models.PersonDirectoryFace, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PersonDirectoryFace:
        """Update face properties, such as modifying the association with a person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :param resource: The resource instance. Is one of the following types: PersonDirectoryFace,
         JSON, IO[bytes] Required.
        :type resource: ~azure.ai.contentunderstanding.models.PersonDirectoryFace or JSON or IO[bytes]
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonDirectoryFace] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_update_face_request(
            person_directory_id=person_directory_id,
            face_id=face_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_face(self, person_directory_id: str, face_id: str, **kwargs: Any) -> _models.PersonDirectoryFace:
        """Get face properties.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonDirectoryFace] = kwargs.pop("cls", None)

        _request = build_person_directories_get_face_request(
            person_directory_id=person_directory_id,
            face_id=face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_face(  # pylint: disable=inconsistent-return-statements
        self, person_directory_id: str, face_id: str, **kwargs: Any
    ) -> None:
        """Delete face.  Any linked person will be disassociated, but not deleted.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param face_id: The unique identifier of the face. Required.
        :type face_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_directories_delete_face_request(
            person_directory_id=person_directory_id,
            face_id=face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list_faces(self, person_directory_id: str, **kwargs: Any) -> ItemPaged["_models.PersonDirectoryFace"]:
        """List faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :return: An iterator like instance of PersonDirectoryFace
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.contentunderstanding.models.PersonDirectoryFace]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PersonDirectoryFace]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_person_directories_list_faces_request(
                    person_directory_id=person_directory_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PersonDirectoryFace], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def identify_person(
        self,
        person_directory_id: str,
        *,
        face_source: _models.FaceSource,
        content_type: str = "application/json",
        max_person_candidates: Optional[int] = None,
        **kwargs: Any
    ) -> _models.IdentifyPersonResult:
        """Identify the person from a face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~azure.ai.contentunderstanding.models.FaceSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword max_person_candidates: Maximum number of person candidates to return (up to 10).
         Default value is None.
        :paramtype max_person_candidates: int
        :return: IdentifyPersonResult. The IdentifyPersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.IdentifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def identify_person(
        self, person_directory_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IdentifyPersonResult:
        """Identify the person from a face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IdentifyPersonResult. The IdentifyPersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.IdentifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def identify_person(
        self, person_directory_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IdentifyPersonResult:
        """Identify the person from a face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IdentifyPersonResult. The IdentifyPersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.IdentifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def identify_person(
        self,
        person_directory_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_source: _models.FaceSource = _Unset,
        max_person_candidates: Optional[int] = None,
        **kwargs: Any
    ) -> _models.IdentifyPersonResult:
        """Identify the person from a face.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~azure.ai.contentunderstanding.models.FaceSource
        :keyword max_person_candidates: Maximum number of person candidates to return (up to 10).
         Default value is None.
        :paramtype max_person_candidates: int
        :return: IdentifyPersonResult. The IdentifyPersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.IdentifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IdentifyPersonResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_source is _Unset:
                raise TypeError("missing required argument: face_source")
            body = {"faceSource": face_source, "maxPersonCandidates": max_person_candidates}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_identify_person_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IdentifyPersonResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def find_similar_faces(
        self,
        person_directory_id: str,
        *,
        content_type: str = "application/json",
        face_source: Optional[_models.FaceSource] = None,
        max_similar_faces: Optional[int] = None,
        **kwargs: Any
    ) -> _models.FindSimilarFacesResult:
        """Find similar faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword face_source: Source of the face. Default value is None.
        :paramtype face_source: ~azure.ai.contentunderstanding.models.FaceSource
        :keyword max_similar_faces: Maximum number of similar faces to return (up to 1000). Default
         value is None.
        :paramtype max_similar_faces: int
        :return: FindSimilarFacesResult. The FindSimilarFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.FindSimilarFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def find_similar_faces(
        self, person_directory_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FindSimilarFacesResult:
        """Find similar faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FindSimilarFacesResult. The FindSimilarFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.FindSimilarFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def find_similar_faces(
        self, person_directory_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FindSimilarFacesResult:
        """Find similar faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FindSimilarFacesResult. The FindSimilarFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.FindSimilarFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def find_similar_faces(
        self,
        person_directory_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_source: Optional[_models.FaceSource] = None,
        max_similar_faces: Optional[int] = None,
        **kwargs: Any
    ) -> _models.FindSimilarFacesResult:
        """Find similar faces.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_source: Source of the face. Default value is None.
        :paramtype face_source: ~azure.ai.contentunderstanding.models.FaceSource
        :keyword max_similar_faces: Maximum number of similar faces to return (up to 1000). Default
         value is None.
        :paramtype max_similar_faces: int
        :return: FindSimilarFacesResult. The FindSimilarFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.FindSimilarFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FindSimilarFacesResult] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"faceSource": face_source, "maxSimilarFaces": max_similar_faces}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_find_similar_faces_request(
            person_directory_id=person_directory_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FindSimilarFacesResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def verify_person(
        self,
        person_directory_id: str,
        person_id: str,
        *,
        face_source: _models.FaceSource,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VerifyPersonResult:
        """Verify if a face matches the person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~azure.ai.contentunderstanding.models.FaceSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyPersonResult. The VerifyPersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.VerifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def verify_person(
        self,
        person_directory_id: str,
        person_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VerifyPersonResult:
        """Verify if a face matches the person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyPersonResult. The VerifyPersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.VerifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def verify_person(
        self,
        person_directory_id: str,
        person_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.VerifyPersonResult:
        """Verify if a face matches the person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyPersonResult. The VerifyPersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.VerifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def verify_person(
        self,
        person_directory_id: str,
        person_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_source: _models.FaceSource = _Unset,
        **kwargs: Any
    ) -> _models.VerifyPersonResult:
        """Verify if a face matches the person.

        :param person_directory_id: The unique identifier of the person directory. Required.
        :type person_directory_id: str
        :param person_id: The unique identifier of the person. Required.
        :type person_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_source: Source of the face. Required.
        :paramtype face_source: ~azure.ai.contentunderstanding.models.FaceSource
        :return: VerifyPersonResult. The VerifyPersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.VerifyPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VerifyPersonResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_source is _Unset:
                raise TypeError("missing required argument: face_source")
            body = {"faceSource": face_source}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directories_verify_person_request(
            person_directory_id=person_directory_id,
            person_id=person_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VerifyPersonResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class FacesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.contentunderstanding.ContentUnderstandingClient`'s
        :attr:`faces` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: ContentUnderstandingClientConfiguration = (
            input_args.pop(0) if input_args else kwargs.pop("config")
        )
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def detect(
        self,
        *,
        content_type: str = "application/json",
        url: Optional[str] = None,
        data: Optional[bytes] = None,
        max_detected_faces: Optional[int] = None,
        **kwargs: Any
    ) -> _models.DetectFacesResult:
        """Detect faces in an image.

        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword url: Image URL.  Only one of url or data should be specified. Default value is None.
        :paramtype url: str
        :keyword data: Base64-encoded image data.  Only one of url or data should be specified. Default
         value is None.
        :paramtype data: bytes
        :keyword max_detected_faces: Maximum number of faces to return (up to 100). Default value is
         None.
        :paramtype max_detected_faces: int
        :return: DetectFacesResult. The DetectFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.DetectFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def detect(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> _models.DetectFacesResult:
        """Detect faces in an image.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DetectFacesResult. The DetectFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.DetectFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def detect(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DetectFacesResult:
        """Detect faces in an image.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DetectFacesResult. The DetectFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.DetectFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def detect(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        url: Optional[str] = None,
        data: Optional[bytes] = None,
        max_detected_faces: Optional[int] = None,
        **kwargs: Any
    ) -> _models.DetectFacesResult:
        """Detect faces in an image.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword url: Image URL.  Only one of url or data should be specified. Default value is None.
        :paramtype url: str
        :keyword data: Base64-encoded image data.  Only one of url or data should be specified. Default
         value is None.
        :paramtype data: bytes
        :keyword max_detected_faces: Maximum number of faces to return (up to 100). Default value is
         None.
        :paramtype max_detected_faces: int
        :return: DetectFacesResult. The DetectFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.DetectFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DetectFacesResult] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"data": data, "maxDetectedFaces": max_detected_faces, "url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_faces_detect_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DetectFacesResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def compare(
        self,
        *,
        face_source1: _models.FaceSource,
        face_source2: _models.FaceSource,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CompareFacesResult:
        """Compare the similarity between two faces.

        :keyword face_source1: First face to compare. Required.
        :paramtype face_source1: ~azure.ai.contentunderstanding.models.FaceSource
        :keyword face_source2: Second face to compare. Required.
        :paramtype face_source2: ~azure.ai.contentunderstanding.models.FaceSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CompareFacesResult. The CompareFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.CompareFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def compare(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CompareFacesResult:
        """Compare the similarity between two faces.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CompareFacesResult. The CompareFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.CompareFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def compare(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CompareFacesResult:
        """Compare the similarity between two faces.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CompareFacesResult. The CompareFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.CompareFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def compare(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_source1: _models.FaceSource = _Unset,
        face_source2: _models.FaceSource = _Unset,
        **kwargs: Any
    ) -> _models.CompareFacesResult:
        """Compare the similarity between two faces.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_source1: First face to compare. Required.
        :paramtype face_source1: ~azure.ai.contentunderstanding.models.FaceSource
        :keyword face_source2: Second face to compare. Required.
        :paramtype face_source2: ~azure.ai.contentunderstanding.models.FaceSource
        :return: CompareFacesResult. The CompareFacesResult is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.CompareFacesResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CompareFacesResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_source1 is _Unset:
                raise TypeError("missing required argument: face_source1")
            if face_source2 is _Unset:
                raise TypeError("missing required argument: face_source2")
            body = {"faceSource1": face_source1, "faceSource2": face_source2}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_faces_compare_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CompareFacesResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ContentClassifiersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.contentunderstanding.ContentUnderstandingClient`'s
        :attr:`content_classifiers` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: ContentUnderstandingClientConfiguration = (
            input_args.pop(0) if input_args else kwargs.pop("config")
        )
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_operation_status(
        self, classifier_id: str, operation_id: str, **kwargs: Any
    ) -> _models.ResourceOperationStatusContentClassifierContentClassifierError:
        """Get the status of a classifier creation operation.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param operation_id: The unique ID of the operation. Required.
        :type operation_id: str
        :return: ResourceOperationStatusContentClassifierContentClassifierError. The
         ResourceOperationStatusContentClassifierContentClassifierError is compatible with
         MutableMapping
        :rtype:
         ~azure.ai.contentunderstanding.models.ResourceOperationStatusContentClassifierContentClassifierError
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ResourceOperationStatusContentClassifierContentClassifierError] = kwargs.pop("cls", None)

        _request = build_content_classifiers_get_operation_status_request(
            classifier_id=classifier_id,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(
                _models.ResourceOperationStatusContentClassifierContentClassifierError, response.json()
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_replace_initial(
        self, classifier_id: str, resource: Union[_models.ContentClassifier, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_classifiers_create_or_replace_request(
            classifier_id=classifier_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        classifier_id: str,
        resource: _models.ContentClassifier,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.ContentClassifier]:
        """Create a new classifier asynchronously.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.contentunderstanding.models.ContentClassifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns ContentClassifier. The ContentClassifier is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ContentClassifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self, classifier_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.ContentClassifier]:
        """Create a new classifier asynchronously.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns ContentClassifier. The ContentClassifier is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ContentClassifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self, classifier_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.ContentClassifier]:
        """Create a new classifier asynchronously.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns ContentClassifier. The ContentClassifier is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ContentClassifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create_or_replace(
        self, classifier_id: str, resource: Union[_models.ContentClassifier, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.ContentClassifier]:
        """Create a new classifier asynchronously.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Is one of the following types: ContentClassifier, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.contentunderstanding.models.ContentClassifier or JSON or IO[bytes]
        :return: An instance of LROPoller that returns ContentClassifier. The ContentClassifier is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ContentClassifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ContentClassifier] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                classifier_id=classifier_id,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )

            deserialized = _deserialize(_models.ContentClassifier, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.ContentClassifier].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.ContentClassifier](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    def update(
        self,
        classifier_id: str,
        resource: _models.ContentClassifier,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.ContentClassifier:
        """Update classifier properties.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.contentunderstanding.models.ContentClassifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentClassifier. The ContentClassifier is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.ContentClassifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(
        self, classifier_id: str, resource: JSON, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.ContentClassifier:
        """Update classifier properties.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentClassifier. The ContentClassifier is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.ContentClassifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(
        self,
        classifier_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.ContentClassifier:
        """Update classifier properties.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ContentClassifier. The ContentClassifier is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.ContentClassifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update(
        self, classifier_id: str, resource: Union[_models.ContentClassifier, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.ContentClassifier:
        """Update classifier properties.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param resource: The resource instance. Is one of the following types: ContentClassifier, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.contentunderstanding.models.ContentClassifier or JSON or IO[bytes]
        :return: ContentClassifier. The ContentClassifier is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.ContentClassifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ContentClassifier] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_classifiers_update_request(
            classifier_id=classifier_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ContentClassifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get(self, classifier_id: str, **kwargs: Any) -> _models.ContentClassifier:
        """Get classifier properties.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :return: ContentClassifier. The ContentClassifier is compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.ContentClassifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ContentClassifier] = kwargs.pop("cls", None)

        _request = build_content_classifiers_get_request(
            classifier_id=classifier_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ContentClassifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(self, classifier_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete classifier.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_content_classifiers_delete_request(
            classifier_id=classifier_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> ItemPaged["_models.ContentClassifier"]:
        """List classifiers.

        :return: An iterator like instance of ContentClassifier
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.contentunderstanding.models.ContentClassifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ContentClassifier]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_content_classifiers_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ContentClassifier], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _classify_initial(
        self,
        classifier_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        url: Optional[str] = None,
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_content_classifiers_classify_request(
            classifier_id=classifier_id,
            string_encoding=string_encoding,
            processing_location=processing_location,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_classify(
        self,
        classifier_id: str,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        url: Optional[str] = None,
        **kwargs: Any
    ) -> LROPoller[_models.ClassifyResult]:
        """Classify content with optional splitting.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~azure.ai.contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~azure.ai.contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword url: The URL of the document to classify. Default value is None.
        :paramtype url: str
        :return: An instance of LROPoller that returns ClassifyResult. The ClassifyResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ClassifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_classify(
        self,
        classifier_id: str,
        body: JSON,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.ClassifyResult]:
        """Classify content with optional splitting.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param body: Required.
        :type body: JSON
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~azure.ai.contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~azure.ai.contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns ClassifyResult. The ClassifyResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ClassifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_classify(
        self,
        classifier_id: str,
        body: IO[bytes],
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.ClassifyResult]:
        """Classify content with optional splitting.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~azure.ai.contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~azure.ai.contentunderstanding.models.ProcessingLocation
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns ClassifyResult. The ClassifyResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ClassifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_classify(
        self,
        classifier_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        url: Optional[str] = None,
        **kwargs: Any
    ) -> LROPoller[_models.ClassifyResult]:
        """Classify content with optional splitting.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~azure.ai.contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~azure.ai.contentunderstanding.models.ProcessingLocation
        :keyword url: The URL of the document to classify. Default value is None.
        :paramtype url: str
        :return: An instance of LROPoller that returns ClassifyResult. The ClassifyResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ClassifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ClassifyResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._classify_initial(
                classifier_id=classifier_id,
                body=body,
                string_encoding=string_encoding,
                processing_location=processing_location,
                url=url,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )

            deserialized = _deserialize(_models.ClassifyResult, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.ClassifyResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.ClassifyResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _classify_binary_initial(
        self,
        classifier_id: str,
        input: bytes,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type")
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _content = input

        _request = build_content_classifiers_classify_binary_request(
            classifier_id=classifier_id,
            string_encoding=string_encoding,
            processing_location=processing_location,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_classify_binary(
        self,
        classifier_id: str,
        input: bytes,
        *,
        string_encoding: Optional[Union[str, _models.StringEncoding]] = None,
        processing_location: Optional[Union[str, _models.ProcessingLocation]] = None,
        **kwargs: Any
    ) -> LROPoller[_models.ClassifyResult]:
        """Classify content with optional splitting.

        :param classifier_id: The unique identifier of the classifier. Required.
        :type classifier_id: str
        :param input: The binary content of the document to classify. Required.
        :type input: bytes
        :keyword string_encoding: The encoding format for content spans in the response. Known values
         are: "codePoint", "utf16", and "utf8". Default value is None.
        :paramtype string_encoding: str or ~azure.ai.contentunderstanding.models.StringEncoding
        :keyword processing_location: The location where the data may be processed. Known values are:
         "geography", "dataZone", and "global". Default value is None.
        :paramtype processing_location: str or ~azure.ai.contentunderstanding.models.ProcessingLocation
        :return: An instance of LROPoller that returns ClassifyResult. The ClassifyResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.contentunderstanding.models.ClassifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type")
        cls: ClsType[_models.ClassifyResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._classify_binary_initial(
                classifier_id=classifier_id,
                input=input,
                string_encoding=string_encoding,
                processing_location=processing_location,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )

            deserialized = _deserialize(_models.ClassifyResult, response.json().get("result", {}))
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.ClassifyResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.ClassifyResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def get_result(self, operation_id: str, **kwargs: Any) -> _models.OperationStatusClassifyResultError:
        """Get the result of a classifier operation.

        :param operation_id: The unique ID of the operation. Required.
        :type operation_id: str
        :return: OperationStatusClassifyResultError. The OperationStatusClassifyResultError is
         compatible with MutableMapping
        :rtype: ~azure.ai.contentunderstanding.models.OperationStatusClassifyResultError
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.OperationStatusClassifyResultError] = kwargs.pop("cls", None)

        _request = build_content_classifiers_get_result_request(
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OperationStatusClassifyResultError, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
