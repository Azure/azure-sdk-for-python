# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import json
from typing import Any, Callable, Dict, Iterable, List, Optional, TypeVar
import urllib.parse

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, ResourceNotModifiedError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._model_base import AzureJSONEncoder, _deserialize
from .._serialization import Serializer
from .._vendor import SchemaRegistryClientMixinABC
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_schema_registry_list_schema_groups_request(
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop('api_version', _params.pop('api-version', "2022-10"))
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/$schemaGroups"

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_schema_registry_get_schema_by_id_request(
    id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop('api_version', _params.pop('api-version', "2022-10"))
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/$schemaGroups/$schemas/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'str'),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_schema_registry_list_schema_versions_request(
    group_name: str,
    name: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop('api_version', _params.pop('api-version', "2022-10"))
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/$schemaGroups/{groupName}/schemas/{name}/versions"
    path_format_arguments = {
        "groupName": _SERIALIZER.url("group_name", group_name, 'str'),
        "name": _SERIALIZER.url("name", name, 'str'),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_schema_registry_get_schema_by_version_request(
    group_name: str,
    name: str,
    schema_version: int,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop('api_version', _params.pop('api-version', "2022-10"))
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/$schemaGroups/{groupName}/schemas/{name}/versions/{schemaVersion}"
    path_format_arguments = {
        "groupName": _SERIALIZER.url("group_name", group_name, 'str'),
        "name": _SERIALIZER.url("name", name, 'str'),
        "schemaVersion": _SERIALIZER.url("schema_version", schema_version, 'int'),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_schema_registry_get_schema_id_by_content_request(
    group_name: str,
    name: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop('content_type')
    api_version: str = kwargs.pop('api_version', _params.pop('api-version', "2022-10"))
    # Construct URL
    _url = "/$schemaGroups/{groupName}/schemas/{name}:get-id"
    path_format_arguments = {
        "groupName": _SERIALIZER.url("group_name", group_name, 'str'),
        "name": _SERIALIZER.url("name", name, 'str'),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['content-type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_schema_registry_register_schema_request(
    group_name: str,
    name: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop('content_type')
    api_version: str = kwargs.pop('api_version', _params.pop('api-version', "2022-10"))
    # Construct URL
    _url = "/$schemaGroups/{groupName}/schemas/{name}"
    path_format_arguments = {
        "groupName": _SERIALIZER.url("group_name", group_name, 'str'),
        "name": _SERIALIZER.url("name", name, 'str'),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['content-type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )

class SchemaRegistryClientOperationsMixin(SchemaRegistryClientMixinABC):

    @distributed_trace
    def list_schema_groups(
        self,
        **kwargs: Any
    ) -> Iterable["_models.SchemaGroup"]:
        """Get list of schema groups.

        Gets the list of schema groups user is authorized to access.

        :return: An iterator like instance of SchemaGroup
        :rtype: ~azure.core.paging.ItemPaged[~azure.schemaregistry.models.SchemaGroup]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SchemaGroup]] = kwargs.pop(
            'cls', None
        )

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_schema_registry_list_schema_groups_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict({
                    key: [urllib.parse.quote(v) for v in value]    for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()})
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SchemaGroup], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem) # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(   # pylint: disable=protected-access
                request,
                stream=_stream,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                     response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_schema_by_id(
        self,
        id: str,
        **kwargs: Any
    ) -> bytes:
        """Get a registered schema by its unique ID reference.

        Gets a registered schema by its unique ID.  Azure Schema Registry guarantees that ID is unique
        within a namespace. Operation response type is based on serialization of schema requested.

        :param id: Schema ID that uniquely identifies a schema in the registry namespace. Required.
        :type id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[bytes] = kwargs.pop(
            'cls', None
        )

        
        request = build_schema_registry_get_schema_by_id_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(   # pylint: disable=protected-access
            request,
            stream=_stream,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                 response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['location']=self._deserialize('str', response.headers.get('location'))
        response_headers['schema-id']=self._deserialize('str', response.headers.get('schema-id'))
        response_headers['schema-id-location']=self._deserialize('str', response.headers.get('schema-id-location'))
        response_headers['schema-group-name']=self._deserialize('str', response.headers.get('schema-group-name'))
        response_headers['schema-name']=self._deserialize('str', response.headers.get('schema-name'))
        response_headers['schema-version']=self._deserialize('int', response.headers.get('schema-version'))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(
                bytes,
                response.json()
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers) # type: ignore

        return deserialized # type: ignore



    @distributed_trace
    def list_schema_versions(
        self,
        group_name: str,
        name: str,
        **kwargs: Any
    ) -> Iterable["_models.Version"]:
        """List schema versions.

        Gets the list of all versions of one schema.

        :param group_name: Name of schema group. Required.
        :type group_name: str
        :param name: Name of schema. Required.
        :type name: str
        :return: An iterator like instance of Version
        :rtype: ~azure.core.paging.ItemPaged[~azure.schemaregistry.models.Version]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Version]] = kwargs.pop(
            'cls', None
        )

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_schema_registry_list_schema_versions_request(
                    group_name=group_name,
                    name=name,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict({
                    key: [urllib.parse.quote(v) for v in value]    for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()})
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Version], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem) # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(   # pylint: disable=protected-access
                request,
                stream=_stream,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                     response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_schema_by_version(
        self,
        group_name: str,
        name: str,
        schema_version: int,
        **kwargs: Any
    ) -> bytes:
        """Get specific schema versions.

        Gets one specific version of one schema.

        :param group_name: Name of schema group. Required.
        :type group_name: str
        :param name: Name of schema. Required.
        :type name: str
        :param schema_version: Version number of specific schema. Required.
        :type schema_version: int
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[bytes] = kwargs.pop(
            'cls', None
        )

        
        request = build_schema_registry_get_schema_by_version_request(
            group_name=group_name,
            name=name,
            schema_version=schema_version,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(   # pylint: disable=protected-access
            request,
            stream=_stream,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                 response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['location']=self._deserialize('str', response.headers.get('location'))
        response_headers['schema-id']=self._deserialize('str', response.headers.get('schema-id'))
        response_headers['schema-id-location']=self._deserialize('str', response.headers.get('schema-id-location'))
        response_headers['schema-group-name']=self._deserialize('str', response.headers.get('schema-group-name'))
        response_headers['schema-name']=self._deserialize('str', response.headers.get('schema-name'))
        response_headers['schema-version']=self._deserialize('int', response.headers.get('schema-version'))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(
                bytes,
                response.json()
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers) # type: ignore

        return deserialized # type: ignore



    @distributed_trace
    def get_schema_id_by_content(  # pylint: disable=inconsistent-return-statements
        self,
        group_name: str,
        name: str,
        schema_content: bytes,
        **kwargs: Any
    ) -> None:
        """Get ID for existing schema.

        Gets the ID referencing an existing schema within the specified schema group, as matched by
        schema content comparison.

        :param group_name: Name of schema group. Required.
        :type group_name: str
        :param name: Name of schema. Required.
        :type name: str
        :param schema_content: String representation (UTF-8) of the registered schema. Required.
        :type schema_content: bytes
        :keyword content_type: The content type for given schema. Default value is "application/json;
         serialization=Avro".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop('content_type', _headers.pop('content-type', "application/json; serialization=Avro"))
        cls: ClsType[None] = kwargs.pop(
            'cls', None
        )

        _content = json.dumps(schema_content, cls=AzureJSONEncoder)  # type: ignore

        request = build_schema_registry_get_schema_id_by_content_request(
            group_name=group_name,
            name=name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(   # pylint: disable=protected-access
            request,
            stream=_stream,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                 response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['location']=self._deserialize('str', response.headers.get('location'))
        response_headers['schema-id']=self._deserialize('str', response.headers.get('schema-id'))
        response_headers['schema-id-location']=self._deserialize('str', response.headers.get('schema-id-location'))
        response_headers['schema-group-name']=self._deserialize('str', response.headers.get('schema-group-name'))
        response_headers['schema-name']=self._deserialize('str', response.headers.get('schema-name'))
        response_headers['schema-version']=self._deserialize('int', response.headers.get('schema-version'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def register_schema(  # pylint: disable=inconsistent-return-statements
        self,
        group_name: str,
        name: str,
        content: bytes,
        **kwargs: Any
    ) -> None:
        """Register new schema.

        Register new schema. If schema of specified name does not exist in specified group, schema is
        created at version 1. If schema of specified name exists already in specified group, schema is
        created at latest version + 1.

        :param group_name: Name of schema group. Required.
        :type group_name: str
        :param name: Name of schema. Required.
        :type name: str
        :param content: String representation (UTF-8) of the schema. Required.
        :type content: bytes
        :keyword content_type: The content type for given schema. Default value is "application/json;
         serialization=Avro".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop('content_type', _headers.pop('content-type', "application/json; serialization=Avro"))
        cls: ClsType[None] = kwargs.pop(
            'cls', None
        )

        _content = json.dumps(content, cls=AzureJSONEncoder)  # type: ignore

        request = build_schema_registry_register_schema_request(
            group_name=group_name,
            name=name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(   # pylint: disable=protected-access
            request,
            stream=_stream,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                 response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['location']=self._deserialize('str', response.headers.get('location'))
        response_headers['schema-id']=self._deserialize('str', response.headers.get('schema-id'))
        response_headers['schema-id-location']=self._deserialize('str', response.headers.get('schema-id-location'))
        response_headers['schema-group-name']=self._deserialize('str', response.headers.get('schema-group-name'))
        response_headers['schema-name']=self._deserialize('str', response.headers.get('schema-name'))
        response_headers['schema-version']=self._deserialize('int', response.headers.get('schema-version'))


        if cls:
            return cls(pipeline_response, None, response_headers)


