# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class AzureSchemaRegistryRestServiceOperationsMixin:

    async def get_groups(
        self,
        **kwargs
    ) -> List[str]:
        """Get all schema groups in namespace.

        Get list of schema groups.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of str, or the result of cls(response)
        :rtype: list[str]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List[str]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_groups.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('[str]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_groups.metadata = {'url': '/$schemagroups'}  # type: ignore

    async def get_schema_by_id(
        self,
        schema_id: str,
        **kwargs
    ) -> str:
        """Get schema by schema ID.

        Get schema by schema ID.

        :param schema_id: schema ID referencing specific schema in registry namespace.
        :type schema_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: str, or the result of cls(response)
        :rtype: str or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[str]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_schema_by_id.metadata['url']  # type: ignore
        path_format_arguments = {
            'schema-id': self._serialize.url("schema_id", schema_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        deserialized = None
        if response.status_code == 200:
            response_headers['Location']=self._deserialize('str', response.headers.get('Location'))
            response_headers['X-Schema-Type']=self._deserialize('str', response.headers.get('X-Schema-Type'))
            response_headers['X-Schema-Id']=self._deserialize('str', response.headers.get('X-Schema-Id'))
            response_headers['X-Schema-Id-Location']=self._deserialize('str', response.headers.get('X-Schema-Id-Location'))
            response_headers['X-Schema-Version']=self._deserialize('int', response.headers.get('X-Schema-Version'))
            deserialized = self._deserialize('str', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_schema_by_id.metadata = {'url': '/$schemagroups/getSchemaById/{schema-id}'}  # type: ignore

    async def get_group(
        self,
        group_name: str,
        **kwargs
    ) -> "models.SchemaGroup":
        """Get schema group description in registry namespace.

        Get schema group.

        :param group_name: schema group.
        :type group_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SchemaGroup, or the result of cls(response)
        :rtype: ~azure.schemaregistry._generated.models.SchemaGroup or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.SchemaGroup"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('SchemaGroup', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_group.metadata = {'url': '/$schemagroups/{group-name}'}  # type: ignore

    async def create_or_update_group(
        self,
        group_name: str,
        body: "models.SchemaGroup",
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Create or update schema group with specified schema type in registry namespace.

        Create or update a schema group.

        :param group_name: schema group.
        :type group_name: str
        :param body: schema group description.
        :type body: ~azure.schemaregistry._generated.models.SchemaGroup
        :param if_match: Specify an ETag value to perform update operation only on schema group with a
         matching Guid value. If a '*' is supplied then update is performed without ETag check.
         Supplying empty value will enforce the create-only behavior.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'SchemaGroup')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers['Location']=self._deserialize('str', response.headers.get('Location'))

        if cls:
            return cls(pipeline_response, None, response_headers)

    create_or_update_group.metadata = {'url': '/$schemagroups/{group-name}'}  # type: ignore

    async def delete_group(
        self,
        group_name: str,
        **kwargs
    ) -> None:
        """Delete schema group in schema registry namespace.

        Delete schema group.

        :param group_name: schema group.
        :type group_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_group.metadata = {'url': '/$schemagroups/{group-name}'}  # type: ignore

    async def get_schemas_by_group(
        self,
        group_name: str,
        **kwargs
    ) -> List[str]:
        """Returns schema by group name.

        Get schemas for group name.

        :param group_name: schema group.
        :type group_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of str, or the result of cls(response)
        :rtype: list[str] or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List[str]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_schemas_by_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        deserialized = None
        if response.status_code == 200:
            response_headers['X-Schema-Type']=self._deserialize('str', response.headers.get('X-Schema-Type'))
            deserialized = self._deserialize('[str]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_schemas_by_group.metadata = {'url': '/$schemagroups/{group-name}/schemas'}  # type: ignore

    async def delete_schemas_by_group(
        self,
        group_name: str,
        **kwargs
    ) -> None:
        """Deletes all schemas under specified group name.

        Deletes all schemas in group.

        :param group_name: schema group.
        :type group_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_schemas_by_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_schemas_by_group.metadata = {'url': '/$schemagroups/{group-name}/schemas'}  # type: ignore

    async def get_id_by_schema_content(
        self,
        group_name: str,
        schema_name: str,
        x_schema_type: str,
        body: str,
        **kwargs
    ) -> "models.SchemaId":
        """Get ID for schema with matching byte content and schema type.

        Get schema ID by schema content.

        :param group_name: schema group.
        :type group_name: str
        :param schema_name: schema name.
        :type schema_name: str
        :param x_schema_type:
        :type x_schema_type: str
        :param body: schema content.
        :type body: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SchemaId, or the result of cls(response)
        :rtype: ~azure.schemaregistry._generated.models.SchemaId or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.SchemaId"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.get_id_by_schema_content.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
            'schema-name': self._serialize.url("schema_name", schema_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['X-Schema-Type'] = self._serialize.header("x_schema_type", x_schema_type, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'str')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        deserialized = None
        if response.status_code == 200:
            response_headers['Location']=self._deserialize('str', response.headers.get('Location'))
            response_headers['X-Schema-Type']=self._deserialize('str', response.headers.get('X-Schema-Type'))
            response_headers['X-Schema-Id']=self._deserialize('str', response.headers.get('X-Schema-Id'))
            response_headers['X-Schema-Id-Location']=self._deserialize('str', response.headers.get('X-Schema-Id-Location'))
            response_headers['X-Schema-Version']=self._deserialize('int', response.headers.get('X-Schema-Version'))
            deserialized = self._deserialize('SchemaId', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_id_by_schema_content.metadata = {'url': '/$schemagroups/{group-name}/schemas/{schema-name}'}  # type: ignore

    async def create_schema(
        self,
        group_name: str,
        schema_name: str,
        x_schema_type: str,
        body: str,
        **kwargs
    ) -> "models.SchemaId":
        """Register schema. If schema of specified name does not exist in specified group, schema is created at version 1. If schema of specified name exists already in specified group, schema is created at latest version + 1. If schema with identical content already exists, existing schema's ID is returned.

        Register schema.

        :param group_name: schema group.
        :type group_name: str
        :param schema_name: schema name.
        :type schema_name: str
        :param x_schema_type:
        :type x_schema_type: str
        :param body: schema content.
        :type body: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SchemaId, or the result of cls(response)
        :rtype: ~azure.schemaregistry._generated.models.SchemaId or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.SchemaId"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_schema.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
            'schema-name': self._serialize.url("schema_name", schema_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['X-Schema-Type'] = self._serialize.header("x_schema_type", x_schema_type, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'str')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        deserialized = None
        if response.status_code == 200:
            response_headers['Location']=self._deserialize('str', response.headers.get('Location'))
            response_headers['X-Schema-Type']=self._deserialize('str', response.headers.get('X-Schema-Type'))
            response_headers['X-Schema-Id']=self._deserialize('str', response.headers.get('X-Schema-Id'))
            response_headers['X-Schema-Id-Location']=self._deserialize('str', response.headers.get('X-Schema-Id-Location'))
            response_headers['X-Schema-Version']=self._deserialize('int', response.headers.get('X-Schema-Version'))
            deserialized = self._deserialize('SchemaId', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    create_schema.metadata = {'url': '/$schemagroups/{group-name}/schemas/{schema-name}'}  # type: ignore

    async def get_latest_schema(
        self,
        group_name: str,
        schema_name: str,
        **kwargs
    ) -> str:
        """Get latest version of schema.

        Get latest version of schema.

        :param group_name: schema group.
        :type group_name: str
        :param schema_name: schema name.
        :type schema_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: str, or the result of cls(response)
        :rtype: str
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[str]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_latest_schema.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
            'schema-name': self._serialize.url("schema_name", schema_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))
        response_headers['X-Schema-Type']=self._deserialize('str', response.headers.get('X-Schema-Type'))
        response_headers['X-Schema-Id']=self._deserialize('str', response.headers.get('X-Schema-Id'))
        response_headers['X-Schema-Id-Location']=self._deserialize('str', response.headers.get('X-Schema-Id-Location'))
        response_headers['X-Schema-Version']=self._deserialize('int', response.headers.get('X-Schema-Version'))
        deserialized = self._deserialize('str', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_latest_schema.metadata = {'url': '/$schemagroups/{group-name}/schemas/{schema-name}'}  # type: ignore

    async def delete_schema(
        self,
        group_name: str,
        schema_name: str,
        **kwargs
    ) -> None:
        """Delete schema.

        Delete schema.

        :param group_name: schema group.
        :type group_name: str
        :param schema_name: schema name.
        :type schema_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_schema.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
            'schema-name': self._serialize.url("schema_name", schema_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_schema.metadata = {'url': '/$schemagroups/{group-name}/schemas/{schema-name}'}  # type: ignore

    async def get_schema_versions(
        self,
        group_name: str,
        schema_name: str,
        **kwargs
    ) -> List[int]:
        """Get list of versions for specified schema.

        Get list of versions.

        :param group_name: schema group.
        :type group_name: str
        :param schema_name: schema name.
        :type schema_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of int, or the result of cls(response)
        :rtype: list[int]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List[int]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_schema_versions.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
            'schema-name': self._serialize.url("schema_name", schema_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['X-Schema-Type']=self._deserialize('str', response.headers.get('X-Schema-Type'))
        deserialized = self._deserialize('[int]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_schema_versions.metadata = {'url': '/$schemagroups/{group-name}/schemas/{schema-name}/versions'}  # type: ignore

    async def get_schema_version(
        self,
        group_name: str,
        schema_name: str,
        version_number: int,
        **kwargs
    ) -> str:
        """Get specified version of schema.

        Get specified version of schema.

        :param group_name: schema group.
        :type group_name: str
        :param schema_name: schema name.
        :type schema_name: str
        :param version_number: version number.
        :type version_number: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: str, or the result of cls(response)
        :rtype: str or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[str]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_schema_version.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
            'schema-name': self._serialize.url("schema_name", schema_name, 'str'),
            'version-number': self._serialize.url("version_number", version_number, 'int'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        deserialized = None
        if response.status_code == 200:
            response_headers['Location']=self._deserialize('str', response.headers.get('Location'))
            response_headers['X-Schema-Type']=self._deserialize('str', response.headers.get('X-Schema-Type'))
            response_headers['X-Schema-Id']=self._deserialize('str', response.headers.get('X-Schema-Id'))
            response_headers['X-Schema-Id-Location']=self._deserialize('str', response.headers.get('X-Schema-Id-Location'))
            response_headers['X-Schema-Version']=self._deserialize('int', response.headers.get('X-Schema-Version'))
            deserialized = self._deserialize('str', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_schema_version.metadata = {'url': '/$schemagroups/{group-name}/schemas/{schema-name}/versions/{version-number}'}  # type: ignore

    async def delete_schema_version(
        self,
        group_name: str,
        schema_name: str,
        version_number: int,
        **kwargs
    ) -> None:
        """Delete specified version of schema.

        Delete specified version of schema.

        :param group_name: schema group.
        :type group_name: str
        :param schema_name: schema name.
        :type schema_name: str
        :param version_number: version number.
        :type version_number: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_schema_version.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-name': self._serialize.url("group_name", group_name, 'str'),
            'schema-name': self._serialize.url("schema_name", schema_name, 'str'),
            'version-number': self._serialize.url("version_number", version_number, 'int'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_schema_version.metadata = {'url': '/$schemagroups/{group-name}/schemas/{schema-name}/versions/{version-number}'}  # type: ignore
