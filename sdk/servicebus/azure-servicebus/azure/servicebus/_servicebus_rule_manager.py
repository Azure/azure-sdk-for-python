import functools
import threading
import time
from uamqp import AMQPClient
from uamqp.constants import SenderSettleMode
from uamqp.authentication.common import AMQPAuth
from typing import TYPE_CHECKING, Any, Optional, Union
from azure.core.paging import ItemPaged
from azure.servicebus._common.constants import (
    MGMT_REQUEST_ADD_RULE,
    MGMT_REQUEST_CORRELATION_FILTER,
    MGMT_REQUEST_EXPRESSION,
    MGMT_REQUEST_GET_RULES,
    MGMT_REQUEST_REMOVE_RULE,
    MGMT_REQUEST_RULE_DESCRIPTION,
    MGMT_REQUEST_RULE_NAME,
    MGMT_REQUEST_SKIP,
    MGMT_REQUEST_SQL_RULE_FILTER,
    MGMT_REQUEST_TOP,
    ServiceBusReceiveMode,
    ServiceBusToAMQPReceiveModeMap,
)
from azure.servicebus._common.receiver_mixins import ReceiverMixin
from azure.servicebus.management import (
    CorrelationRuleFilter,
    SqlRuleFilter,
    TrueRuleFilter,
    FalseRuleFilter,
    SqlRuleAction,
    RuleProperties,
)
from azure.servicebus._common.utils import create_authentication, get_receive_links, receive_trace_context_manager
from ._servicebus_session import ServiceBusSession
from ._base_handler import BaseHandler
from ._common import mgmt_handlers

if TYPE_CHECKING:
    from azure.core.credentials import (
        TokenCredential,
        AzureSasCredential,
        AzureNamedKeyCredential,
    )


class ServiceBusRuleManager(ReceiverMixin, BaseHandler):  # pylint: disable=too-many-instance-attributes
    """The ServiceBusRuleManager class defines a high level interface for
    managing rules on a specific topic subscription. The rule manager requires only Listen claims

    **Please use the `get_rule_manager` method of ~azure.servicebus.ServiceBusClient to create a
    ServiceBusRuleManager instance.**

    :ivar fully_qualified_namespace: The fully qualified host name for the Service Bus namespace.
     The namespace format is: `<yournamespace>.servicebus.windows.net`.
    :vartype fully_qualified_namespace: str
    :ivar entity_path: The path of the entity that the client connects to.
    :vartype entity_path: str

    :param str fully_qualified_namespace: The fully qualified host name for the Service Bus namespace.
     The namespace format is: `<yournamespace>.servicebus.windows.net`.
    :param credential: The credential object used for authentication which
     implements a particular interface for getting tokens. It accepts
     credential objects generated by the azure-identity library and objects that implement the
     `get_token(self, *scopes)` method, or alternatively, an AzureSasCredential can be provided too.
    :type credential: ~azure.core.credentials.TokenCredential or ~azure.core.credentials.AzureSasCredential
     or ~azure.core.credentials.AzureNamedKeyCredential
    :keyword str topic_name: The path of specific Service Bus Topic which contains the Subscription
     the client connects to.
    :keyword str subscription_name: The path of specific Service Bus Subscription under the
     specified Topic the client connects to.
    :keyword Optional[float] max_wait_time: The timeout in seconds between received messages after which the
     receiver will automatically stop receiving. The default value is None, meaning no timeout.
    :keyword receive_mode: The mode with which messages will be retrieved from the entity. The two options
     are PEEK_LOCK and RECEIVE_AND_DELETE. Messages received with PEEK_LOCK must be settled within a given
     lock period before they will be removed from the queue. Messages received with RECEIVE_AND_DELETE
     will be immediately removed from the queue, and cannot be subsequently abandoned or re-received
     if the client fails to process the message.
     The default mode is PEEK_LOCK.
    :paramtype receive_mode: Union[~azure.servicebus.ServiceBusReceiveMode, str]
    :keyword bool logging_enable: Whether to output network trace logs to the logger. Default is `False`.
    :keyword transport_type: The type of transport protocol that will be used for communicating with
     the Service Bus service. Default is `TransportType.Amqp`.
    :paramtype transport_type: ~azure.servicebus.TransportType
    :keyword Dict http_proxy: HTTP proxy settings. This must be a dictionary with the following
     keys: `'proxy_hostname'` (str value) and `'proxy_port'` (int value).
     Additionally the following keys may also be present: `'username', 'password'`.
    :keyword str user_agent: If specified, this will be added in front of the built-in user agent string.
    :keyword str client_identifier: A string-based identifier to uniquely identify the client instance.
      Service Bus will associate it with some error messages for easier correlation of errors.
      If not specified, a unique id will be generated.
    """

    def __init__(
        self,
        fully_qualified_namespace: str,
        credential: Union["TokenCredential", "AzureSasCredential", "AzureNamedKeyCredential"],
        *,
        topic_name: Optional[str] = None,
        subscription_name: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        if kwargs.get("entity_name"):
            super(ServiceBusRuleManager, self).__init__(
                fully_qualified_namespace=fully_qualified_namespace,
                credential=credential,
                topic_name=topic_name,
                subscription_name=subscription_name,
                **kwargs,
            )
        else:
            if topic_name and not subscription_name:
                raise ValueError("Subscription name is missing for the topic. Please specify subscription_name.")
            entity_name = topic_name
            if not entity_name:
                raise ValueError("Topic name is missing. Please specify queue_name/topic_name.")

            super(ServiceBusRuleManager, self).__init__(
                fully_qualified_namespace=fully_qualified_namespace,
                credential=credential,
                entity_name=entity_name,
                topic_name=topic_name,
                subscription_name=subscription_name,
                **kwargs,
            )

        self._populate_attributes(
            topic_name=topic_name,
            subscription_name=subscription_name,
            **kwargs,
        )
        self._session = self._session = None if self._session_id is None else ServiceBusSession(self._session_id, self)
        self._receive_context = threading.Event()

    def __iter__(self):
        return self._iter_contextual_wrapper()

    def _iter_contextual_wrapper(self, max_wait_time=None):
        """The purpose of this wrapper is to allow both state restoration (for multiple concurrent iteration)
        and per-iter argument passing that requires the former."""
        # pylint: disable=protected-access
        original_timeout = None
        while True:
            # This is not threadsafe, but gives us a way to handle if someone passes
            # different max_wait_times to different iterators and uses them in concert.
            if max_wait_time:
                original_timeout = self._handler._timeout
                self._handler._timeout = max_wait_time * 1000
            try:
                message = self._inner_next()
                links = get_receive_links(message)
                with receive_trace_context_manager(self, links=links):
                    yield message
            except StopIteration:
                break
            finally:
                if original_timeout:
                    try:
                        self._handler._timeout = original_timeout
                    except AttributeError:  # Handler may be disposed already.
                        pass

    def _inner_next(self):
        # We do this weird wrapping such that an imperitive next() call, and a generator-based iter both trace sanely.
        self._check_live()
        while True:
            try:
                return self._do_retryable_operation(self._iter_next)
            except StopIteration:
                self._message_iter = None
                raise

    def __next__(self):
        # Normally this would wrap the yield of the iter, but for a direct next call we just trace imperitively.
        try:
            self._receive_context.set()
            message = self._inner_next()
            links = get_receive_links(message)
            with receive_trace_context_manager(self, links=links):
                return message
        finally:
            self._receive_context.clear()

    next = __next__  # for python2.7

    def _iter_next(self):
        try:
            self._receive_context.set()
            self._open()
            if not self._message_iter:
                self._message_iter = self._handler.receive_messages_iter()
            uamqp_message = next(self._message_iter)
            message = self._build_message(uamqp_message)
            if (
                self._auto_lock_renewer
                and not self._session
                and self._receive_mode != ServiceBusReceiveMode.RECEIVE_AND_DELETE
            ):
                self._auto_lock_renewer.register(self, message)
            return message
        finally:
            self._receive_context.clear()

    @classmethod
    def _from_connection_string(cls, conn_str: str, **kwargs) -> "ServiceBusRuleManager":
        """Create a ServiceBusReceiver from a connection string.

        :param conn_str: The connection string of a Service Bus.
        :type conn_str: str
        :keyword str topic_name: The path of specific Service Bus Topic which contains the Subscription
         the client connects to.
        :keyword str subscription_name: The path of specific Service Bus Subscription under the
         specified Topic the client connects to.
        :keyword receive_mode: The mode with which messages will be retrieved from the entity. The two options
         are PEEK_LOCK and RECEIVE_AND_DELETE. Messages received with PEEK_LOCK must be settled within a given
         lock period before they will be removed from the queue. Messages received with RECEIVE_AND_DELETE
         will be immediately removed from the queue, and cannot be subsequently abandoned or re-received
         if the client fails to process the message.
         The default mode is PEEK_LOCK.
        :paramtype receive_mode: Union[~azure.servicebus.ServiceBusReceiveMode, str]
        :keyword Optional[float] max_wait_time: The timeout in seconds between received messages after which the
         receiver will automatically stop receiving. The default value is None, meaning no timeout.
        :keyword bool logging_enable: Whether to output network trace logs to the logger. Default is `False`.
        :keyword transport_type: The type of transport protocol that will be used for communicating with
         the Service Bus service. Default is `TransportType.Amqp`.
        :paramtype transport_type: ~azure.servicebus.TransportType
        :keyword Dict http_proxy: HTTP proxy settings. This must be a dictionary with the following
         keys: `'proxy_hostname'` (str value) and `'proxy_port'` (int value).
         Additionally the following keys may also be present: `'username', 'password'`.
        :keyword str user_agent: If specified, this will be added in front of the built-in user agent string.
        :rtype: ~azure.servicebus.ServiceBusRuleManager

        :raises ~azure.servicebus.ServiceBusAuthenticationError: Indicates an issue in token/identity validity.
        :raises ~azure.servicebus.ServiceBusAuthorizationError: Indicates an access/rights related failure.

        .. admonition:: Example:

            .. literalinclude:: ../samples/sync_samples/sample_code_servicebus.py
                :start-after: [START create_servicebus_receiver_from_conn_str_sync]
                :end-before: [END create_servicebus_receiver_from_conn_str_sync]
                :language: python
                :dedent: 4
                :caption: Create a new instance of the ServiceBusReceiver from connection string.

        """
        constructor_args = cls._convert_connection_string_to_kwargs(conn_str, **kwargs)
        if kwargs.get("queue_name") and kwargs.get("subscription_name"):
            raise ValueError("Queue entity does not have subscription.")

        if kwargs.get("topic_name") and not kwargs.get("subscription_name"):
            raise ValueError("Subscription name is missing for the topic. Please specify subscription_name.")
        return cls(**constructor_args)

    def _create_handler(self, auth):
        # type: (AMQPAuth) -> None
        self._handler = AMQPClient(
            self._get_source(),
            auth=auth,
            debug=self._config.logging_enable,
            properties=self._properties,
            error_policy=self._error_policy,
            client_name=self._name,
            on_attach=self._on_attach,
            encoding=self._config.encoding,
            receive_settle_mode=ServiceBusToAMQPReceiveModeMap[self._receive_mode],
            send_settle_mode=SenderSettleMode.Settled
            if self._receive_mode == ServiceBusReceiveMode.RECEIVE_AND_DELETE
            else None,
            # If prefetch is 1, then keep_alive coroutine serves as keep receiving for releasing messages
            keep_alive_interval=self._config.keep_alive if self._prefetch_count != 1 else 5,
        )
        if self._prefetch_count == 1:
            self._handler._message_received = self._enhanced_message_received  # pylint: disable=protected-access

    def _open(self):
        # pylint: disable=protected-access
        if self._running:
            return
        if self._handler and not self._handler._shutdown:
            self._handler.close()

        auth = None if self._connection else create_authentication(self)
        self._create_handler(auth)
        try:
            self._handler.open(connection=self._connection)
            while not self._handler.client_ready():
                time.sleep(0.05)
            self._running = True
        except:
            self._close_handler()
            raise

        if self._auto_lock_renewer and self._session:
            self._auto_lock_renewer.register(self, self.session)

    def _close_handler(self):
        self._message_iter = None
        super(ServiceBusRuleManager, self)._close_handler()

    def close(self):
        # type: () -> None
        super(ServiceBusRuleManager, self).close()
        self._message_iter = None  # pylint: disable=attribute-defined-outside-init

    def create_rule(
        self,
        rule_name: str,
        *,
        filter: Union[  # pylint: disable=redefined-builtin
            CorrelationRuleFilter, SqlRuleFilter, TrueRuleFilter, FalseRuleFilter
        ] = TrueRuleFilter(),
        action: Optional[SqlRuleAction] = None,
        **kwargs: Any,
    ):
        """Create a rule for a topic subscription.

        :param rule_name: Name of the rule.
        :type rule_name: str
        :keyword filter: The filter of the rule. The default value is ~azure.servicebus.management.TrueRuleFilter
        :paramtype filter: Union[~azure.servicebus.management.CorrelationRuleFilter,
         ~azure.servicebus.management.SqlRuleFilter]
        :keyword action: The action of the rule.
        :paramtype action: Optional[~azure.servicebus.management.SqlRuleAction]
        :rtype: None
        """
        if not rule_name:
            raise ValueError("rule name cannot be empty")

        if type(filter) in (SqlRuleFilter, TrueRuleFilter, FalseRuleFilter):
            rule_description = {
                MGMT_REQUEST_SQL_RULE_FILTER: {
                    MGMT_REQUEST_EXPRESSION: filter.sql_expression,
                }
            }

        else:
            rule_description = {MGMT_REQUEST_CORRELATION_FILTER: vars(filter)}

        message = {
            MGMT_REQUEST_RULE_NAME: rule_name,
            MGMT_REQUEST_RULE_DESCRIPTION: rule_description,
        }

        handler = functools.partial(mgmt_handlers.create_rule_op)

        self._mgmt_request_response_with_retry(MGMT_REQUEST_ADD_RULE, message, handler)

    def delete_rule(self, rule_name: str, **kwargs: Any) -> None:
        """Delete a topic subscription rule.

        :param str rule_name: The to-be-deleted rule.
        :rtype: None
        """
        if not rule_name:
            raise ValueError("rule name cannot be empty")

        message = {MGMT_REQUEST_RULE_NAME: rule_name}
        handler = functools.partial(mgmt_handlers.delete_rule_op)
        self._mgmt_request_response_with_retry(MGMT_REQUEST_REMOVE_RULE, message, handler)

    def list_rules(self, top: int = 10, skip: int = 0, **kwargs: Any) -> ItemPaged[RuleProperties]:
        """List the rules of a topic subscription.

        :param int top: The number of rules to fetch, default is 10
        :param int skip: The number of rules to skip, default is 0
        :returns: An iterable (auto-paging) response of RuleProperties.
        :rtype: ~azure.core.paging.ItemPaged[RuleProperties]
        """
        if top is None or top <= 0:
            raise ValueError("top must be a number greater than 0")

        if skip is None or skip < 0:
            raise ValueError("top must be a number greater than 0")

        message = {
            MGMT_REQUEST_TOP: top,
            MGMT_REQUEST_SKIP: skip,
        }

        handler = functools.partial(mgmt_handlers.list_rules_op)

        rules = self._mgmt_request_response_with_retry(MGMT_REQUEST_GET_RULES, message, handler)

        return ItemPaged(rules)

    @property
    def client_identifier(self) -> str:
        """
        Get the ServiceBusRuleManager client_identifier associated with the rule manager instance.

        :rtype: str
        """
        return self._name

    def __str__(self) -> str:
        return f"Receiver client id: {self.client_identifier}, entity: {self.entity_path}"
