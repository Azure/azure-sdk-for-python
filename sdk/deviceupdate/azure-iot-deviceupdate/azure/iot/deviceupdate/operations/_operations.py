# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, Callable, Dict, Iterable, List, Optional, TypeVar, Union, cast

from msrest import Serializer

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .._vendor import _format_url_section
if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any] # pylint: disable=unsubscriptable-object
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False

def build_device_update_list_updates_request(
    instance_id: str,
    *,
    search: Optional[str] = None,
    filter: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/updates"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    if search is not None:
        _params['search'] = _SERIALIZER.query("search", search, 'str')
    if filter is not None:
        _params['filter'] = _SERIALIZER.query("filter", filter, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_update_import_update_request_initial(
    instance_id: str,
    *,
    json: Optional[List[JSON]] = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/updates:import"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )


def build_device_update_get_update_request(
    instance_id: str,
    provider: str,
    name: str,
    version: str,
    *,
    if_none_match: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/updates/providers/{provider}/names/{name}/versions/{version}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "provider": _SERIALIZER.url("provider", provider, 'str'),
        "name": _SERIALIZER.url("name", name, 'str'),
        "version": _SERIALIZER.url("version", version, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_update_delete_update_request_initial(
    instance_id: str,
    provider: str,
    name: str,
    version: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/updates/providers/{provider}/names/{name}/versions/{version}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "provider": _SERIALIZER.url("provider", provider, 'str'),
        "name": _SERIALIZER.url("name", name, 'str'),
        "version": _SERIALIZER.url("version", version, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_update_list_providers_request(
    instance_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/updates/providers"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_update_list_names_request(
    instance_id: str,
    provider: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/updates/providers/{provider}/names"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "provider": _SERIALIZER.url("provider", provider, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_update_list_versions_request(
    instance_id: str,
    provider: str,
    name: str,
    *,
    filter: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/updates/providers/{provider}/names/{name}/versions"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "provider": _SERIALIZER.url("provider", provider, 'str'),
        "name": _SERIALIZER.url("name", name, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    if filter is not None:
        _params['filter'] = _SERIALIZER.query("filter", filter, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_update_list_files_request(
    instance_id: str,
    provider: str,
    name: str,
    version: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/updates/providers/{provider}/names/{name}/versions/{version}/files"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "provider": _SERIALIZER.url("provider", provider, 'str'),
        "name": _SERIALIZER.url("name", name, 'str'),
        "version": _SERIALIZER.url("version", version, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_update_get_file_request(
    instance_id: str,
    provider: str,
    name: str,
    version: str,
    file_id: str,
    *,
    if_none_match: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/updates/providers/{provider}/names/{name}/versions/{version}/files/{fileId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "provider": _SERIALIZER.url("provider", provider, 'str'),
        "name": _SERIALIZER.url("name", name, 'str'),
        "version": _SERIALIZER.url("version", version, 'str'),
        "fileId": _SERIALIZER.url("file_id", file_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_update_list_operations_request(
    instance_id: str,
    *,
    filter: Optional[str] = None,
    top: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/updates/operations"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if filter is not None:
        _params['filter'] = _SERIALIZER.query("filter", filter, 'str')
    if top is not None:
        _params['top'] = _SERIALIZER.query("top", top, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_update_get_operation_request(
    instance_id: str,
    operation_id: str,
    *,
    if_none_match: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/updates/operations/{operationId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "operationId": _SERIALIZER.url("operation_id", operation_id, 'str', max_length=256, min_length=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_device_classes_request(
    instance_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/deviceClasses"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_device_class_request(
    instance_id: str,
    device_class_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/deviceClasses/{deviceClassId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_update_device_class_request(
    instance_id: str,
    device_class_id: str,
    *,
    json: Optional[JSON] = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/deviceClasses/{deviceClassId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )


def build_device_management_delete_device_class_request(
    instance_id: str,
    device_class_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/deviceClasses/{deviceClassId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_installable_updates_for_device_class_request(
    instance_id: str,
    device_class_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/deviceClasses/{deviceClassId}/installableUpdates"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_devices_request(
    instance_id: str,
    *,
    filter: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/devices"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if filter is not None:
        _params['filter'] = _SERIALIZER.query("filter", filter, 'str')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_import_devices_request_initial(
    instance_id: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/devices:import"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )


def build_device_management_get_device_request(
    instance_id: str,
    device_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/devices/{deviceId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "deviceId": _SERIALIZER.url("device_id", device_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_device_module_request(
    instance_id: str,
    device_id: str,
    module_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/devices/{deviceId}/modules/{moduleId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "deviceId": _SERIALIZER.url("device_id", device_id, 'str'),
        "moduleId": _SERIALIZER.url("module_id", module_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_update_compliance_request(
    instance_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/updateCompliance"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_groups_request(
    instance_id: str,
    *,
    order_by: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if order_by is not None:
        _params['orderby'] = _SERIALIZER.query("order_by", order_by, 'str')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_group_request(
    instance_id: str,
    group_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_delete_group_request(
    instance_id: str,
    group_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_update_compliance_for_group_request(
    instance_id: str,
    group_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/updateCompliance"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_best_updates_for_group_request(
    instance_id: str,
    group_id: str,
    *,
    filter: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/bestUpdates"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if filter is not None:
        _params['filter'] = _SERIALIZER.query("filter", filter, 'str')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_deployments_for_group_request(
    instance_id: str,
    group_id: str,
    *,
    order_by: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deployments"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    if order_by is not None:
        _params['orderby'] = _SERIALIZER.query("order_by", order_by, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_deployment_request(
    instance_id: str,
    group_id: str,
    deployment_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deployments/{deploymentId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deploymentId": _SERIALIZER.url("deployment_id", deployment_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_create_or_update_deployment_request(
    instance_id: str,
    group_id: str,
    deployment_id: str,
    *,
    json: Optional[JSON] = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deployments/{deploymentId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deploymentId": _SERIALIZER.url("deployment_id", deployment_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )


def build_device_management_delete_deployment_request(
    instance_id: str,
    group_id: str,
    deployment_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deployments/{deploymentId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deploymentId": _SERIALIZER.url("deployment_id", deployment_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_deployment_status_request(
    instance_id: str,
    group_id: str,
    deployment_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deployments/{deploymentId}/status"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deploymentId": _SERIALIZER.url("deployment_id", deployment_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_device_class_subgroups_for_group_request(
    instance_id: str,
    group_id: str,
    *,
    filter: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if filter is not None:
        _params['filter'] = _SERIALIZER.query("filter", filter, 'str')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_device_class_subgroup_request(
    instance_id: str,
    group_id: str,
    device_class_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups/{deviceClassId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_delete_device_class_subgroup_request(
    instance_id: str,
    group_id: str,
    device_class_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups/{deviceClassId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_device_class_subgroup_update_compliance_request(
    instance_id: str,
    group_id: str,
    device_class_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups/{deviceClassId}/updateCompliance"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_best_updates_for_device_class_subgroup_request(
    instance_id: str,
    group_id: str,
    device_class_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups/{deviceClassId}/bestUpdates"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_deployments_for_device_class_subgroup_request(
    instance_id: str,
    group_id: str,
    device_class_id: str,
    *,
    order_by: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups/{deviceClassId}/deployments"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    if order_by is not None:
        _params['orderby'] = _SERIALIZER.query("order_by", order_by, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_deployment_for_device_class_subgroup_request(
    instance_id: str,
    group_id: str,
    device_class_id: str,
    deployment_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups/{deviceClassId}/deployments/{deploymentId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
        "deploymentId": _SERIALIZER.url("deployment_id", deployment_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_delete_deployment_for_device_class_subgroup_request(
    instance_id: str,
    group_id: str,
    device_class_id: str,
    deployment_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups/{deviceClassId}/deployments/{deploymentId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
        "deploymentId": _SERIALIZER.url("deployment_id", deployment_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_stop_deployment_request(
    instance_id: str,
    group_id: str,
    device_class_id: str,
    deployment_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups/{deviceClassId}/deployments/{deploymentId}:cancel"  # pylint: disable=line-too-long
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
        "deploymentId": _SERIALIZER.url("deployment_id", deployment_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_retry_deployment_request(
    instance_id: str,
    group_id: str,
    device_class_id: str,
    deployment_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups/{deviceClassId}/deployments/{deploymentId}:retry"  # pylint: disable=line-too-long
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
        "deploymentId": _SERIALIZER.url("deployment_id", deployment_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_device_class_subgroup_deployment_status_request(
    instance_id: str,
    group_id: str,
    device_class_id: str,
    deployment_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups/{deviceClassId}/deployments/{deploymentId}/status"  # pylint: disable=line-too-long
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
        "deploymentId": _SERIALIZER.url("deployment_id", deployment_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_device_states_for_device_class_subgroup_deployment_request(
    instance_id: str,
    group_id: str,
    device_class_id: str,
    deployment_id: str,
    *,
    filter: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/groups/{groupId}/deviceClassSubgroups/{deviceClassId}/deployments/{deploymentId}/devicestates"  # pylint: disable=line-too-long
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "groupId": _SERIALIZER.url("group_id", group_id, 'str'),
        "deviceClassId": _SERIALIZER.url("device_class_id", device_class_id, 'str'),
        "deploymentId": _SERIALIZER.url("deployment_id", deployment_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if filter is not None:
        _params['filter'] = _SERIALIZER.query("filter", filter, 'str')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_operation_request(
    instance_id: str,
    operation_id: str,
    *,
    if_none_match: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/operations/{operationId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "operationId": _SERIALIZER.url("operation_id", operation_id, 'str', max_length=256, min_length=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_operations_request(
    instance_id: str,
    *,
    filter: Optional[str] = None,
    top: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/operations"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if filter is not None:
        _params['filter'] = _SERIALIZER.query("filter", filter, 'str')
    if top is not None:
        _params['top'] = _SERIALIZER.query("top", top, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_start_log_collection_request(
    instance_id: str,
    log_collection_id: str,
    *,
    json: Optional[JSON] = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/deviceDiagnostics/logCollections/{operationId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "operationId": _SERIALIZER.url("log_collection_id", log_collection_id, 'str', max_length=256, min_length=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )


def build_device_management_get_log_collection_request(
    instance_id: str,
    log_collection_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/deviceDiagnostics/logCollections/{operationId}"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "operationId": _SERIALIZER.url("log_collection_id", log_collection_id, 'str', max_length=256, min_length=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_log_collections_request(
    instance_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/deviceDiagnostics/logCollections"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_get_log_collection_detailed_status_request(
    instance_id: str,
    operation_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/deviceDiagnostics/logCollections/{operationId}/detailedStatus"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
        "operationId": _SERIALIZER.url("operation_id", operation_id, 'str', max_length=256, min_length=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_device_management_list_device_health_request(
    instance_id: str,
    *,
    filter: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/deviceUpdate/{instanceId}/management/deviceDiagnostics/deviceHealth"
    path_format_arguments = {
        "instanceId": _SERIALIZER.url("instance_id", instance_id, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    _params['filter'] = _SERIALIZER.query("filter", filter, 'str')

    # Construct headers
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )

class DeviceUpdateOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.iot.deviceupdate.DeviceUpdateClient`'s
        :attr:`device_update` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace
    def list_updates(
        self,
        *,
        search: Optional[str] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get a list of all updates that have been imported to Device Update for IoT Hub.

        :keyword search: Request updates matching a free-text search expression. Default value is None.
        :paramtype search: str
        :keyword filter: Filter updates by its properties. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "compatibility": [
                                {
                                    "str": "str"  # Required. List of update
                                      compatibility information.
                                }
                            ],
                            "createdDateTime": "2020-02-20 00:00:00",  # Required. Date
                              and time in UTC when the update was created.
                            "description": "str",  # Optional. Update description
                              specified by creator.
                            "etag": "str",  # Optional. Update ETag.
                            "friendlyName": "str",  # Optional. Friendly update name
                              specified by importer.
                            "importedDateTime": "2020-02-20 00:00:00",  # Required. Date
                              and time in UTC when the update was imported.
                            "installedCriteria": "str",  # Optional. String interpreted
                              by Device Update client to determine if the update is installed on the
                              device. Deprecated in latest import manifest schema.
                            "instructions": {
                                "steps": [
                                    {
                                        "description": "str",  # Optional.
                                          Step description.
                                        "files": [
                                            "str"  # Optional. Collection
                                              of file names to be passed to handler during execution.
                                              Required if step type is inline.
                                        ],
                                        "handler": "str",  # Optional.
                                          Identity of handler that will execute this step. Required if
                                          step type is inline.
                                        "handlerProperties": {},  # Optional.
                                          Parameters to be passed to handler during execution.
                                        "type": "inline",  # Optional.
                                          Default value is "inline". Step type. Known values are:
                                          "Inline", "Reference". Default value: "inline".
                                        "updateId": {
                                            "name": "str",  # Required.
                                              Update name.
                                            "provider": "str",  #
                                              Required. Update provider.
                                            "version": "str"  # Required.
                                              Update version.
                                        }
                                    }
                                ]
                            },
                            "isDeployable": True,  # Optional. Default value is True.
                              Whether the update can be deployed to a device on its own.
                            "manifestVersion": "str",  # Required. Schema version of
                              manifest used to import the update.
                            "referencedBy": [
                                {
                                    "name": "str",  # Required. Update name.
                                    "provider": "str",  # Required. Update
                                      provider.
                                    "version": "str"  # Required. Update version.
                                }
                            ],
                            "scanResult": "str",  # Optional. Update aggregate scan
                              result (calculated from payload file scan results).
                            "updateId": {
                                "name": "str",  # Required. Update name.
                                "provider": "str",  # Required. Update provider.
                                "version": "str"  # Required. Update version.
                            },
                            "updateType": "str"  # Optional. Update type. Deprecated in
                              latest import manifest schema.
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_update_list_updates_request(
                    instance_id=self._config.instance_id,
                    api_version=api_version,
                    search=search,
                    filter=filter,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_update_list_updates_request(
                    instance_id=self._config.instance_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    def _import_update_initial(  # pylint: disable=inconsistent-return-statements
        self,
        update_to_import: List[JSON],
        **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = update_to_import

        request = build_device_update_import_update_request_initial(
            instance_id=self._config.instance_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def begin_import_update(  # pylint: disable=inconsistent-return-statements
        self,
        update_to_import: List[JSON],
        **kwargs: Any
    ) -> LROPoller[None]:
        """Import new update version. This is a long-running-operation; use Operation-Location response
        header value to check for operation status.

        :param update_to_import: The update to be imported.
        :type update_to_import: list[JSON]
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_to_import = [
                    {
                        "files": [
                            {
                                "filename": "str",  # Required. Update file name as
                                  specified inside import manifest.
                                "url": "str"  # Required. Azure Blob location from
                                  which the update file can be downloaded by Device Update for IoT Hub.
                                  This is typically a read-only SAS-protected blob URL with an
                                  expiration set to at least 4 hours.
                            }
                        ],
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "importManifest": {
                            "hashes": {
                                "str": "str"  # Required. A JSON object containing
                                  the hash(es) of the file. At least SHA256 hash is required. This
                                  object can be thought of as a set of key-value pairs where the key is
                                  the hash algorithm, and the value is the hash of the file calculated
                                  using that algorithm.
                            },
                            "sizeInBytes": 0.0,  # Required. File size in number of
                              bytes.
                            "url": "str"  # Required. Azure Blob location from which the
                              import manifest can be downloaded by Device Update for IoT Hub. This is
                              typically a read-only SAS-protected blob URL with an expiration set to at
                              least 4 hours.
                        }
                    }
                ]
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        polling = kwargs.pop('polling', True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._import_update_initial(  # type: ignore
                update_to_import=update_to_import,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x,y,z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True:
            polling_method = cast(PollingMethod, LROBasePolling(
                lro_delay,
                
                path_format_arguments=path_format_arguments,
                **kwargs
        ))  # type: PollingMethod
        elif polling is False: polling_method = cast(PollingMethod, NoPolling())
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)



    @distributed_trace
    def get_update(
        self,
        provider: str,
        name: str,
        version: str,
        *,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Get a specific update version.

        :param provider: Update provider.
        :type provider: str
        :param name: Update name.
        :type name: str
        :param version: Update version.
        :type version: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "compatibility": [
                        {
                            "str": "str"  # Required. List of update compatibility
                              information.
                        }
                    ],
                    "createdDateTime": "2020-02-20 00:00:00",  # Required. Date and time in UTC
                      when the update was created.
                    "description": "str",  # Optional. Update description specified by creator.
                    "etag": "str",  # Optional. Update ETag.
                    "friendlyName": "str",  # Optional. Friendly update name specified by
                      importer.
                    "importedDateTime": "2020-02-20 00:00:00",  # Required. Date and time in UTC
                      when the update was imported.
                    "installedCriteria": "str",  # Optional. String interpreted by Device Update
                      client to determine if the update is installed on the device. Deprecated in
                      latest import manifest schema.
                    "instructions": {
                        "steps": [
                            {
                                "description": "str",  # Optional. Step description.
                                "files": [
                                    "str"  # Optional. Collection of file names
                                      to be passed to handler during execution. Required if step type
                                      is inline.
                                ],
                                "handler": "str",  # Optional. Identity of handler
                                  that will execute this step. Required if step type is inline.
                                "handlerProperties": {},  # Optional. Parameters to
                                  be passed to handler during execution.
                                "type": "inline",  # Optional. Default value is
                                  "inline". Step type. Known values are: "Inline", "Reference". Default
                                  value: "inline".
                                "updateId": {
                                    "name": "str",  # Required. Update name.
                                    "provider": "str",  # Required. Update
                                      provider.
                                    "version": "str"  # Required. Update version.
                                }
                            }
                        ]
                    },
                    "isDeployable": True,  # Optional. Default value is True. Whether the update
                      can be deployed to a device on its own.
                    "manifestVersion": "str",  # Required. Schema version of manifest used to
                      import the update.
                    "referencedBy": [
                        {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    ],
                    "scanResult": "str",  # Optional. Update aggregate scan result (calculated
                      from payload file scan results).
                    "updateId": {
                        "name": "str",  # Required. Update name.
                        "provider": "str",  # Required. Update provider.
                        "version": "str"  # Required. Update version.
                    },
                    "updateType": "str"  # Optional. Update type. Deprecated in latest import
                      manifest schema.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_device_update_get_update_request(
            instance_id=self._config.instance_id,
            provider=provider,
            name=name,
            version=version,
            api_version=api_version,
            if_none_match=if_none_match,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 304]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    def _delete_update_initial(  # pylint: disable=inconsistent-return-statements
        self,
        provider: str,
        name: str,
        version: str,
        **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_device_update_delete_update_request_initial(
            instance_id=self._config.instance_id,
            provider=provider,
            name=name,
            version=version,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def begin_delete_update(  # pylint: disable=inconsistent-return-statements
        self,
        provider: str,
        name: str,
        version: str,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a specific update version. This is a long-running-operation; use Operation-Location
        response header value to check for operation status.

        :param provider: Update provider.
        :type provider: str
        :param name: Update name.
        :type name: str
        :param version: Update version.
        :type version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        polling = kwargs.pop('polling', True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._delete_update_initial(  # type: ignore
                provider=provider,
                name=name,
                version=version,
                api_version=api_version,
                cls=lambda x,y,z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True:
            polling_method = cast(PollingMethod, LROBasePolling(
                lro_delay,
                
                path_format_arguments=path_format_arguments,
                **kwargs
        ))  # type: PollingMethod
        elif polling is False: polling_method = cast(PollingMethod, NoPolling())
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)



    @distributed_trace
    def list_providers(
        self,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get a list of all update providers that have been imported to Device Update for IoT Hub.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        "str"  # Required. The collection of pageable items.
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_update_list_providers_request(
                    instance_id=self._config.instance_id,
                    api_version=api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_update_list_providers_request(
                    instance_id=self._config.instance_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def list_names(
        self,
        provider: str,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get a list of all update names that match the specified provider.

        :param provider: Update provider.
        :type provider: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        "str"  # Required. The collection of pageable items.
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_update_list_names_request(
                    instance_id=self._config.instance_id,
                    provider=provider,
                    api_version=api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_update_list_names_request(
                    instance_id=self._config.instance_id,
                    provider=provider,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def list_versions(
        self,
        provider: str,
        name: str,
        *,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get a list of all update versions that match the specified provider and name.

        :param provider: Update provider.
        :type provider: str
        :param name: Update name.
        :type name: str
        :keyword filter: Filter updates by its properties. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        "str"  # Required. The collection of pageable items.
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_update_list_versions_request(
                    instance_id=self._config.instance_id,
                    provider=provider,
                    name=name,
                    api_version=api_version,
                    filter=filter,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_update_list_versions_request(
                    instance_id=self._config.instance_id,
                    provider=provider,
                    name=name,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def list_files(
        self,
        provider: str,
        name: str,
        version: str,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get a list of all update file identifiers for the specified version.

        :param provider: Update provider.
        :type provider: str
        :param name: Update name.
        :type name: str
        :param version: Update version.
        :type version: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        "str"  # Required. The collection of pageable items.
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_update_list_files_request(
                    instance_id=self._config.instance_id,
                    provider=provider,
                    name=name,
                    version=version,
                    api_version=api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_update_list_files_request(
                    instance_id=self._config.instance_id,
                    provider=provider,
                    name=name,
                    version=version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_file(
        self,
        provider: str,
        name: str,
        version: str,
        file_id: str,
        *,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Get a specific update file from the version.

        :param provider: Update provider.
        :type provider: str
        :param name: Update name.
        :type name: str
        :param version: Update version.
        :type version: str
        :param file_id: File identifier.
        :type file_id: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "downloadHandler": {
                        "id": "str"  # Required. Download handler identifier.
                    },
                    "etag": "str",  # Optional. File ETag.
                    "fileId": "str",  # Required. File identity, generated by server at import
                      time.
                    "fileName": "str",  # Required. File name.
                    "hashes": {
                        "str": "str"  # Required. Mapping of hashing algorithm to base64
                          encoded hash values.
                    },
                    "mimeType": "str",  # Optional. File MIME type.
                    "properties": {
                        "str": "str"  # Optional. Optional file properties (not consumed by
                          service but pass-through to device).
                    },
                    "relatedFiles": [
                        {
                            "fileName": "str",  # Required. File name.
                            "hashes": {
                                "str": "str"  # Required. Mapping of hashing
                                  algorithm to base64 encoded hash values.
                            },
                            "mimeType": "str",  # Optional. File MIME type.
                            "properties": {
                                "str": "str"  # Optional. Optional file properties
                                  (not consumed by service but pass-through to device).
                            },
                            "scanDetails": "str",  # Optional. Anti-malware scan details.
                            "scanResult": "str",  # Optional. Anti-malware scan result.
                            "sizeInBytes": 0.0  # Required. File size in number of bytes.
                        }
                    ],
                    "scanDetails": "str",  # Optional. Anti-malware scan details.
                    "scanResult": "str",  # Optional. Anti-malware scan result.
                    "sizeInBytes": 0.0  # Required. File size in number of bytes.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_device_update_get_file_request(
            instance_id=self._config.instance_id,
            provider=provider,
            name=name,
            version=version,
            file_id=file_id,
            api_version=api_version,
            if_none_match=if_none_match,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 304]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace
    def list_operations(
        self,
        *,
        filter: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get a list of all import update operations. Completed operations are kept for 7 days before
        auto-deleted. Delete operations are not returned by this API version.

        :keyword filter: Restricts the set of operations returned. Only one specific filter is
         supported: "status eq 'NotStarted' or status eq 'Running'". Default value is None.
        :paramtype filter: str
        :keyword top: Specifies a non-negative integer n that limits the number of items returned from
         a collection. The service returns the number of available items up to but not greater than the
         specified value n. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "createdDateTime": "2020-02-20 00:00:00",  # Required. Date
                              and time in UTC when the operation was created.
                            "error": {
                                "code": "str",  # Required. Server defined error
                                  code.
                                "details": [
                                    ...
                                ],
                                "innererror": {
                                    "code": "str",  # Required. A more specific
                                      error code than what was provided by the containing error.
                                    "errorDetail": "str",  # Optional. The
                                      internal error or exception message.
                                    "innerError": ...,
                                    "message": "str"  # Optional. A
                                      human-readable representation of the error.
                                },
                                "message": "str",  # Required. A human-readable
                                  representation of the error.
                                "occurredDateTime": "2020-02-20 00:00:00",  #
                                  Optional. Date and time in UTC when the error occurred.
                                "target": "str"  # Optional. The target of the error.
                            },
                            "etag": "str",  # Optional. Operation ETag.
                            "lastActionDateTime": "2020-02-20 00:00:00",  # Required.
                              Date and time in UTC when the operation status was last updated.
                            "operationId": "str",  # Required. Operation Id.
                            "resourceLocation": "str",  # Optional. Location of the
                              imported update when operation is successful.
                            "status": "str",  # Required. Operation status. Known values
                              are: "NotStarted", "Running", "Succeeded", "Failed".
                            "traceId": "str",  # Optional. Operation correlation identity
                              that can used by Microsoft Support for troubleshooting.
                            "update": {
                                "description": "str",  # Optional. Update
                                  description.
                                "friendlyName": "str",  # Optional. Friendly update
                                  name.
                                "updateId": {
                                    "name": "str",  # Required. Update name.
                                    "provider": "str",  # Required. Update
                                      provider.
                                    "version": "str"  # Required. Update version.
                                }
                            }
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_update_list_operations_request(
                    instance_id=self._config.instance_id,
                    api_version=api_version,
                    filter=filter,
                    top=top,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_update_list_operations_request(
                    instance_id=self._config.instance_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_operation(
        self,
        operation_id: str,
        *,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Retrieve operation status.

        :param operation_id: Operation identifier.
        :type operation_id: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Required. Date and time in UTC
                      when the operation was created.
                    "error": {
                        "code": "str",  # Required. Server defined error code.
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",  # Required. A more specific error code than
                              what was provided by the containing error.
                            "errorDetail": "str",  # Optional. The internal error or
                              exception message.
                            "innerError": ...,
                            "message": "str"  # Optional. A human-readable representation
                              of the error.
                        },
                        "message": "str",  # Required. A human-readable representation of the
                          error.
                        "occurredDateTime": "2020-02-20 00:00:00",  # Optional. Date and time
                          in UTC when the error occurred.
                        "target": "str"  # Optional. The target of the error.
                    },
                    "etag": "str",  # Optional. Operation ETag.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Required. Date and time in
                      UTC when the operation status was last updated.
                    "operationId": "str",  # Required. Operation Id.
                    "resourceLocation": "str",  # Optional. Location of the imported update when
                      operation is successful.
                    "status": "str",  # Required. Operation status. Known values are:
                      "NotStarted", "Running", "Succeeded", "Failed".
                    "traceId": "str",  # Optional. Operation correlation identity that can used
                      by Microsoft Support for troubleshooting.
                    "update": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_device_update_get_operation_request(
            instance_id=self._config.instance_id,
            operation_id=operation_id,
            api_version=api_version,
            if_none_match=if_none_match,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 304]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers['Retry-After']=self._deserialize('str', response.headers.get('Retry-After'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized


class DeviceManagementOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.iot.deviceupdate.DeviceUpdateClient`'s
        :attr:`device_management` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace
    def list_device_classes(
        self,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets a list of all device classes (unique combinations of device manufacturer and model) for
        all devices connected to Device Update for IoT Hub.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "bestCompatibleUpdate": {
                                "description": "str",  # Optional. Update
                                  description.
                                "friendlyName": "str",  # Optional. Friendly update
                                  name.
                                "updateId": {
                                    "name": "str",  # Required. Update name.
                                    "provider": "str",  # Required. Update
                                      provider.
                                    "version": "str"  # Required. Update version.
                                }
                            },
                            "deviceClassId": "str",  # Required. The device class
                              identifier.
                            "deviceClassProperties": {
                                "compatProperties": {
                                    "str": "str"  # Required. The compat
                                      properties of the device class. This object can be thought of as
                                      a set of key-value pairs where the key is the name of the
                                      compatibility property and the value is the value of the
                                      compatibility property. There will always be at least 1 compat
                                      property.
                                },
                                "contractModel": {
                                    "id": "str",  # Required. The Device Update
                                      agent contract model Id of the device class. This is also used to
                                      calculate the device class Id.
                                    "name": "str"  # Required. The Device Update
                                      agent contract model name of the device class. Intended to be a
                                      more readable form of the contract model Id.
                                }
                            },
                            "friendlyName": "str"  # Optional. The device class friendly
                              name. This can be updated by callers after the device class has been
                              automatically created.
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_device_classes_request(
                    instance_id=self._config.instance_id,
                    api_version=api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_device_classes_request(
                    instance_id=self._config.instance_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_device_class(
        self,
        device_class_id: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the properties of a device class.

        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "bestCompatibleUpdate": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    },
                    "deviceClassId": "str",  # Required. The device class identifier.
                    "deviceClassProperties": {
                        "compatProperties": {
                            "str": "str"  # Required. The compat properties of the device
                              class. This object can be thought of as a set of key-value pairs where
                              the key is the name of the compatibility property and the value is the
                              value of the compatibility property. There will always be at least 1
                              compat property.
                        },
                        "contractModel": {
                            "id": "str",  # Required. The Device Update agent contract
                              model Id of the device class. This is also used to calculate the device
                              class Id.
                            "name": "str"  # Required. The Device Update agent contract
                              model name of the device class. Intended to be a more readable form of
                              the contract model Id.
                        }
                    },
                    "friendlyName": "str"  # Optional. The device class friendly name. This can
                      be updated by callers after the device class has been automatically created.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_device_class_request(
            instance_id=self._config.instance_id,
            device_class_id=device_class_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def update_device_class(
        self,
        device_class_id: str,
        device_class_patch: JSON,
        **kwargs: Any
    ) -> JSON:
        """Update device class details.

        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :param device_class_patch: The device class json merge patch body. Currently only supports
         patching friendlyName.
        :type device_class_patch: JSON
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                device_class_patch = {
                    "friendlyName": "str"  # Required. The device class friendly name.
                }

                # response body for status code(s): 200
                response.json() == {
                    "bestCompatibleUpdate": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    },
                    "deviceClassId": "str",  # Required. The device class identifier.
                    "deviceClassProperties": {
                        "compatProperties": {
                            "str": "str"  # Required. The compat properties of the device
                              class. This object can be thought of as a set of key-value pairs where
                              the key is the name of the compatibility property and the value is the
                              value of the compatibility property. There will always be at least 1
                              compat property.
                        },
                        "contractModel": {
                            "id": "str",  # Required. The Device Update agent contract
                              model Id of the device class. This is also used to calculate the device
                              class Id.
                            "name": "str"  # Required. The Device Update agent contract
                              model name of the device class. Intended to be a more readable form of
                              the contract model Id.
                        }
                    },
                    "friendlyName": "str"  # Optional. The device class friendly name. This can
                      be updated by callers after the device class has been automatically created.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/merge-patch+json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = device_class_patch

        request = build_device_management_update_device_class_request(
            instance_id=self._config.instance_id,
            device_class_id=device_class_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def delete_device_class(  # pylint: disable=inconsistent-return-statements
        self,
        device_class_id: str,
        **kwargs: Any
    ) -> None:
        """Deletes a device class. Device classes are created automatically when Device Update-enabled
        devices are connected to the hub but are not automatically cleaned up since they are referenced
        by DeviceClassSubgroups. If the user has deleted all DeviceClassSubgroups for a device class
        they can also delete the device class to remove the records from the system and to stop
        checking the compatibility of this device class with new updates. If a device is ever
        reconnected for this device class it will be re-created.

        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_device_management_delete_device_class_request(
            instance_id=self._config.instance_id,
            device_class_id=device_class_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace
    def list_installable_updates_for_device_class(
        self,
        device_class_id: str,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets a list of installable updates for a device class.

        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "description": "str",  # Optional. Update description.
                            "friendlyName": "str",  # Optional. Friendly update name.
                            "updateId": {
                                "name": "str",  # Required. Update name.
                                "provider": "str",  # Required. Update provider.
                                "version": "str"  # Required. Update version.
                            }
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_installable_updates_for_device_class_request(
                    instance_id=self._config.instance_id,
                    device_class_id=device_class_id,
                    api_version=api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_installable_updates_for_device_class_request(
                    instance_id=self._config.instance_id,
                    device_class_id=device_class_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def list_devices(
        self,
        *,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets a list of devices connected to Device Update for IoT Hub.

        :keyword filter: Restricts the set of devices returned. You can filter on GroupId,
         DeviceClassId, or GroupId and DeploymentStatus. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "deploymentStatus": "str",  # Optional. State of the device
                              in its last deployment. Known values are: "Succeeded", "InProgress",
                              "Canceled", "Failed".
                            "deviceClassId": "str",  # Required. Device class identity.
                            "deviceId": "str",  # Required. Device identity.
                            "groupId": "str",  # Optional. Device group identity.
                            "installedUpdate": {
                                "description": "str",  # Optional. Update
                                  description.
                                "friendlyName": "str",  # Optional. Friendly update
                                  name.
                                "updateId": {
                                    "name": "str",  # Required. Update name.
                                    "provider": "str",  # Required. Update
                                      provider.
                                    "version": "str"  # Required. Update version.
                                }
                            },
                            "lastAttemptedUpdate": {
                                "description": "str",  # Optional. Update
                                  description.
                                "friendlyName": "str",  # Optional. Friendly update
                                  name.
                                "updateId": {
                                    "name": "str",  # Required. Update name.
                                    "provider": "str",  # Required. Update
                                      provider.
                                    "version": "str"  # Required. Update version.
                                }
                            },
                            "lastDeploymentId": "str",  # Optional. The deployment
                              identifier for the last deployment to the device.
                            "lastInstallResult": {
                                "extendedResultCode": 0,  # Required. Install
                                  extended result code.
                                "resultCode": 0,  # Required. Install result code.
                                "resultDetails": "str",  # Optional. A string
                                  containing further details about the install result.
                                "stepResults": [
                                    {
                                        "description": "str",  # Optional.
                                          Step description.
                                        "extendedResultCode": 0,  # Required.
                                          Install extended result code.
                                        "resultCode": 0,  # Required. Install
                                          result code.
                                        "resultDetails": "str",  # Optional.
                                          A string containing further details about the install result.
                                        "update": {
                                            "description": "str",  #
                                              Optional. Update description.
                                            "friendlyName": "str",  #
                                              Optional. Friendly update name.
                                            "updateId": {
                                                "name": "str",  #
                                                  Required. Update name.
                                                "provider": "str",  #
                                                  Required. Update provider.
                                                "version": "str"  #
                                                  Required. Update version.
                                            }
                                        }
                                    }
                                ]
                            },
                            "moduleId": "str",  # Optional. Device module identity.
                            "onLatestUpdate": bool  # Required. Boolean flag indicating
                              whether the latest update is installed on the device.
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_devices_request(
                    instance_id=self._config.instance_id,
                    api_version=api_version,
                    filter=filter,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_devices_request(
                    instance_id=self._config.instance_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    def _import_devices_initial(  # pylint: disable=inconsistent-return-statements
        self,
        import_type: str,
        **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = import_type

        request = build_device_management_import_devices_request_initial(
            instance_id=self._config.instance_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def begin_import_devices(  # pylint: disable=inconsistent-return-statements
        self,
        import_type: str,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Import existing devices from IoT Hub. This is a long-running-operation; use Operation-Location
        response header value to check for operation status.

        :param import_type: The types of devices to import. Known values are: "Devices", "Modules", and
         "All".
        :type import_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        polling = kwargs.pop('polling', True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._import_devices_initial(  # type: ignore
                import_type=import_type,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x,y,z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True:
            polling_method = cast(PollingMethod, LROBasePolling(
                lro_delay,
                
                path_format_arguments=path_format_arguments,
                **kwargs
        ))  # type: PollingMethod
        elif polling is False: polling_method = cast(PollingMethod, NoPolling())
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)



    @distributed_trace
    def get_device(
        self,
        device_id: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the device properties and latest deployment status for a device connected to Device Update
        for IoT Hub.

        :param device_id: Device identifier in Azure IoT Hub.
        :type device_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "deploymentStatus": "str",  # Optional. State of the device in its last
                      deployment. Known values are: "Succeeded", "InProgress", "Canceled", "Failed".
                    "deviceClassId": "str",  # Required. Device class identity.
                    "deviceId": "str",  # Required. Device identity.
                    "groupId": "str",  # Optional. Device group identity.
                    "installedUpdate": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    },
                    "lastAttemptedUpdate": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    },
                    "lastDeploymentId": "str",  # Optional. The deployment identifier for the
                      last deployment to the device.
                    "lastInstallResult": {
                        "extendedResultCode": 0,  # Required. Install extended result code.
                        "resultCode": 0,  # Required. Install result code.
                        "resultDetails": "str",  # Optional. A string containing further
                          details about the install result.
                        "stepResults": [
                            {
                                "description": "str",  # Optional. Step description.
                                "extendedResultCode": 0,  # Required. Install
                                  extended result code.
                                "resultCode": 0,  # Required. Install result code.
                                "resultDetails": "str",  # Optional. A string
                                  containing further details about the install result.
                                "update": {
                                    "description": "str",  # Optional. Update
                                      description.
                                    "friendlyName": "str",  # Optional. Friendly
                                      update name.
                                    "updateId": {
                                        "name": "str",  # Required. Update
                                          name.
                                        "provider": "str",  # Required.
                                          Update provider.
                                        "version": "str"  # Required. Update
                                          version.
                                    }
                                }
                            }
                        ]
                    },
                    "moduleId": "str",  # Optional. Device module identity.
                    "onLatestUpdate": bool  # Required. Boolean flag indicating whether the
                      latest update is installed on the device.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_device_request(
            instance_id=self._config.instance_id,
            device_id=device_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def get_device_module(
        self,
        device_id: str,
        module_id: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the device module properties and latest deployment status for a device module connected to
        Device Update for IoT Hub.

        :param device_id: Device identifier in Azure IoT Hub.
        :type device_id: str
        :param module_id: Device module identifier in Azure IoT Hub.
        :type module_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "deploymentStatus": "str",  # Optional. State of the device in its last
                      deployment. Known values are: "Succeeded", "InProgress", "Canceled", "Failed".
                    "deviceClassId": "str",  # Required. Device class identity.
                    "deviceId": "str",  # Required. Device identity.
                    "groupId": "str",  # Optional. Device group identity.
                    "installedUpdate": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    },
                    "lastAttemptedUpdate": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    },
                    "lastDeploymentId": "str",  # Optional. The deployment identifier for the
                      last deployment to the device.
                    "lastInstallResult": {
                        "extendedResultCode": 0,  # Required. Install extended result code.
                        "resultCode": 0,  # Required. Install result code.
                        "resultDetails": "str",  # Optional. A string containing further
                          details about the install result.
                        "stepResults": [
                            {
                                "description": "str",  # Optional. Step description.
                                "extendedResultCode": 0,  # Required. Install
                                  extended result code.
                                "resultCode": 0,  # Required. Install result code.
                                "resultDetails": "str",  # Optional. A string
                                  containing further details about the install result.
                                "update": {
                                    "description": "str",  # Optional. Update
                                      description.
                                    "friendlyName": "str",  # Optional. Friendly
                                      update name.
                                    "updateId": {
                                        "name": "str",  # Required. Update
                                          name.
                                        "provider": "str",  # Required.
                                          Update provider.
                                        "version": "str"  # Required. Update
                                          version.
                                    }
                                }
                            }
                        ]
                    },
                    "moduleId": "str",  # Optional. Device module identity.
                    "onLatestUpdate": bool  # Required. Boolean flag indicating whether the
                      latest update is installed on the device.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_device_module_request(
            instance_id=self._config.instance_id,
            device_id=device_id,
            module_id=module_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def get_update_compliance(
        self,
        **kwargs: Any
    ) -> JSON:
        """Gets the breakdown of how many devices are on their latest update, have new updates available,
        or are in progress receiving new updates.

        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "newUpdatesAvailableDeviceCount": 0,  # Required. Number of devices with a
                      newer update available.
                    "onLatestUpdateDeviceCount": 0,  # Required. Number of devices on the latest
                      update.
                    "totalDeviceCount": 0,  # Required. Total number of devices.
                    "updatesInProgressDeviceCount": 0  # Required. Number of devices with update
                      in-progress.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_update_compliance_request(
            instance_id=self._config.instance_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def list_groups(
        self,
        *,
        order_by: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets a list of all device groups.  The $default group will always be returned first.

        :keyword order_by: Orders the set of groups returned. You can order by any combination of
         groupId, device count, created date, subgroupsWithNewUpdatesAvailableCount,
         subgroupsWithUpdatesInProgressCount, or subgroupsOnLatestUpdateCount. Default value is None.
        :paramtype order_by: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "createdDateTime": "str",  # Required. Date and time when the
                              update was created.
                            "deployments": [
                                "str"  # Optional. The active deployment Ids for the
                                  group.
                            ],
                            "deviceCount": 0,  # Optional. The number of devices in the
                              group.
                            "groupId": "str",  # Required. Group identity.
                            "groupType": "str",  # Required. Group type. Known values
                              are: "IoTHubTag", "DefaultNoTag".
                            "subgroupsWithNewUpdatesAvailableCount": 0,  # Optional. The
                              count of subgroups with new updates available.
                            "subgroupsWithOnLatestUpdateCount": 0,  # Optional. The count
                              of subgroups with devices on the latest update.
                            "subgroupsWithUpdatesInProgressCount": 0  # Optional. The
                              count of subgroups with updates in progress.
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_groups_request(
                    instance_id=self._config.instance_id,
                    api_version=api_version,
                    order_by=order_by,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_groups_request(
                    instance_id=self._config.instance_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_group(
        self,
        group_id: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the device group properties.

        :param group_id: Group identity.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "createdDateTime": "str",  # Required. Date and time when the update was
                      created.
                    "deployments": [
                        "str"  # Optional. The active deployment Ids for the group.
                    ],
                    "deviceCount": 0,  # Optional. The number of devices in the group.
                    "groupId": "str",  # Required. Group identity.
                    "groupType": "str",  # Required. Group type. Known values are: "IoTHubTag",
                      "DefaultNoTag".
                    "subgroupsWithNewUpdatesAvailableCount": 0,  # Optional. The count of
                      subgroups with new updates available.
                    "subgroupsWithOnLatestUpdateCount": 0,  # Optional. The count of subgroups
                      with devices on the latest update.
                    "subgroupsWithUpdatesInProgressCount": 0  # Optional. The count of subgroups
                      with updates in progress.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_group_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def delete_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        **kwargs: Any
    ) -> None:
        """Deletes a device group. This group is automatically created when a Device Update-enabled device
        is connected to the hub and reports its properties. Groups, subgroups, and deployments are not
        automatically cleaned up but are retained for history purposes. Users can call this method to
        delete a group if they do not need to retain any of the history of the group and no longer need
        it. If a device is ever connected again for this group after the group was deleted it will be
        automatically re-created but there will be no history.

        :param group_id: Group identity.
        :type group_id: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_device_management_delete_group_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace
    def get_update_compliance_for_group(
        self,
        group_id: str,
        **kwargs: Any
    ) -> JSON:
        """Get device group update compliance information such as how many devices are on their latest
        update, how many need new updates, and how many are in progress on receiving a new update.

        :param group_id: Group identity.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "newUpdatesAvailableDeviceCount": 0,  # Required. Number of devices with a
                      newer update available.
                    "onLatestUpdateDeviceCount": 0,  # Required. Number of devices on the latest
                      update.
                    "totalDeviceCount": 0,  # Required. Total number of devices.
                    "updatesInProgressDeviceCount": 0  # Required. Number of devices with update
                      in-progress.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_update_compliance_for_group_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def list_best_updates_for_group(
        self,
        group_id: str,
        *,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get the best available updates for a device group and a count of how many devices need each
        update.

        :param group_id: Group identity.
        :type group_id: str
        :keyword filter: Restricts the set of bestUpdates returned. You can filter on update Provider,
         Name and Version property. This filter is deprecated and should not be used. Default value is
         None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "deviceClassId": "str",  # Required. The device class
                              subgroup's device class Id.
                            "deviceCount": 0,  # Required. Total number of devices for
                              which the update is applicable.
                            "groupId": "str",  # Required. The group Id.
                            "update": {
                                "description": "str",  # Optional. Update
                                  description.
                                "friendlyName": "str",  # Optional. Friendly update
                                  name.
                                "updateId": {
                                    "name": "str",  # Required. Update name.
                                    "provider": "str",  # Required. Update
                                      provider.
                                    "version": "str"  # Required. Update version.
                                }
                            }
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_best_updates_for_group_request(
                    instance_id=self._config.instance_id,
                    group_id=group_id,
                    api_version=api_version,
                    filter=filter,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_best_updates_for_group_request(
                    instance_id=self._config.instance_id,
                    group_id=group_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def list_deployments_for_group(
        self,
        group_id: str,
        *,
        order_by: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets a list of deployments for a device group.

        :param group_id: Group identity.
        :type group_id: str
        :keyword order_by: Orders the set of deployments returned. You can order by start date. Default
         value is None.
        :paramtype order_by: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "deploymentId": "str",  # Required. The caller-provided
                              deployment identifier.
                            "deviceClassSubgroups": [
                                "str"  # Optional. The device class subgroups the
                                  deployment is compatible with and subgroup deployments have been
                                  created for. This is not provided by the caller during
                                  CreateOrUpdateDeployment but is automatically determined by Device
                                  Update.
                            ],
                            "groupId": "str",  # Required. The group identity for the
                              devices the deployment is intended to update.
                            "isCanceled": bool,  # Optional. Boolean flag indicating
                              whether the deployment was canceled.
                            "isCloudInitiatedRollback": bool,  # Optional. Boolean flag
                              indicating whether the deployment is a rollback deployment.
                            "isRetried": bool,  # Optional. Boolean flag indicating
                              whether the deployment has been retried.
                            "rollbackPolicy": {
                                "failure": {
                                    "devicesFailedCount": 0,  # Required. Number
                                      of devices that failed.
                                    "devicesFailedPercentage": 0  # Required.
                                      Percentage of devices that failed.
                                },
                                "update": {
                                    "description": "str",  # Optional. Update
                                      description.
                                    "friendlyName": "str",  # Optional. Friendly
                                      update name.
                                    "updateId": {
                                        "name": "str",  # Required. Update
                                          name.
                                        "provider": "str",  # Required.
                                          Update provider.
                                        "version": "str"  # Required. Update
                                          version.
                                    }
                                }
                            },
                            "startDateTime": "2020-02-20 00:00:00",  # Required. The
                              deployment start datetime.
                            "update": {
                                "description": "str",  # Optional. Update
                                  description.
                                "friendlyName": "str",  # Optional. Friendly update
                                  name.
                                "updateId": {
                                    "name": "str",  # Required. Update name.
                                    "provider": "str",  # Required. Update
                                      provider.
                                    "version": "str"  # Required. Update version.
                                }
                            }
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_deployments_for_group_request(
                    instance_id=self._config.instance_id,
                    group_id=group_id,
                    api_version=api_version,
                    order_by=order_by,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_deployments_for_group_request(
                    instance_id=self._config.instance_id,
                    group_id=group_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_deployment(
        self,
        group_id: str,
        deployment_id: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the deployment properties.

        :param group_id: Group identity.
        :type group_id: str
        :param deployment_id: Deployment identifier.
        :type deployment_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "deploymentId": "str",  # Required. The caller-provided deployment
                      identifier.
                    "deviceClassSubgroups": [
                        "str"  # Optional. The device class subgroups the deployment is
                          compatible with and subgroup deployments have been created for. This is not
                          provided by the caller during CreateOrUpdateDeployment but is automatically
                          determined by Device Update.
                    ],
                    "groupId": "str",  # Required. The group identity for the devices the
                      deployment is intended to update.
                    "isCanceled": bool,  # Optional. Boolean flag indicating whether the
                      deployment was canceled.
                    "isCloudInitiatedRollback": bool,  # Optional. Boolean flag indicating
                      whether the deployment is a rollback deployment.
                    "isRetried": bool,  # Optional. Boolean flag indicating whether the
                      deployment has been retried.
                    "rollbackPolicy": {
                        "failure": {
                            "devicesFailedCount": 0,  # Required. Number of devices that
                              failed.
                            "devicesFailedPercentage": 0  # Required. Percentage of
                              devices that failed.
                        },
                        "update": {
                            "description": "str",  # Optional. Update description.
                            "friendlyName": "str",  # Optional. Friendly update name.
                            "updateId": {
                                "name": "str",  # Required. Update name.
                                "provider": "str",  # Required. Update provider.
                                "version": "str"  # Required. Update version.
                            }
                        }
                    },
                    "startDateTime": "2020-02-20 00:00:00",  # Required. The deployment start
                      datetime.
                    "update": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_deployment_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            deployment_id=deployment_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def create_or_update_deployment(
        self,
        group_id: str,
        deployment_id: str,
        deployment: JSON,
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a deployment.

        :param group_id: Group identity.
        :type group_id: str
        :param deployment_id: Deployment identifier.
        :type deployment_id: str
        :param deployment: The deployment properties.
        :type deployment: JSON
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                deployment = {
                    "deploymentId": "str",  # Required. The caller-provided deployment
                      identifier.
                    "deviceClassSubgroups": [
                        "str"  # Optional. The device class subgroups the deployment is
                          compatible with and subgroup deployments have been created for. This is not
                          provided by the caller during CreateOrUpdateDeployment but is automatically
                          determined by Device Update.
                    ],
                    "groupId": "str",  # Required. The group identity for the devices the
                      deployment is intended to update.
                    "isCanceled": bool,  # Optional. Boolean flag indicating whether the
                      deployment was canceled.
                    "isCloudInitiatedRollback": bool,  # Optional. Boolean flag indicating
                      whether the deployment is a rollback deployment.
                    "isRetried": bool,  # Optional. Boolean flag indicating whether the
                      deployment has been retried.
                    "rollbackPolicy": {
                        "failure": {
                            "devicesFailedCount": 0,  # Required. Number of devices that
                              failed.
                            "devicesFailedPercentage": 0  # Required. Percentage of
                              devices that failed.
                        },
                        "update": {
                            "description": "str",  # Optional. Update description.
                            "friendlyName": "str",  # Optional. Friendly update name.
                            "updateId": {
                                "name": "str",  # Required. Update name.
                                "provider": "str",  # Required. Update provider.
                                "version": "str"  # Required. Update version.
                            }
                        }
                    },
                    "startDateTime": "2020-02-20 00:00:00",  # Required. The deployment start
                      datetime.
                    "update": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    }
                }

                # response body for status code(s): 200
                response.json() == {
                    "deploymentId": "str",  # Required. The caller-provided deployment
                      identifier.
                    "deviceClassSubgroups": [
                        "str"  # Optional. The device class subgroups the deployment is
                          compatible with and subgroup deployments have been created for. This is not
                          provided by the caller during CreateOrUpdateDeployment but is automatically
                          determined by Device Update.
                    ],
                    "groupId": "str",  # Required. The group identity for the devices the
                      deployment is intended to update.
                    "isCanceled": bool,  # Optional. Boolean flag indicating whether the
                      deployment was canceled.
                    "isCloudInitiatedRollback": bool,  # Optional. Boolean flag indicating
                      whether the deployment is a rollback deployment.
                    "isRetried": bool,  # Optional. Boolean flag indicating whether the
                      deployment has been retried.
                    "rollbackPolicy": {
                        "failure": {
                            "devicesFailedCount": 0,  # Required. Number of devices that
                              failed.
                            "devicesFailedPercentage": 0  # Required. Percentage of
                              devices that failed.
                        },
                        "update": {
                            "description": "str",  # Optional. Update description.
                            "friendlyName": "str",  # Optional. Friendly update name.
                            "updateId": {
                                "name": "str",  # Required. Update name.
                                "provider": "str",  # Required. Update provider.
                                "version": "str"  # Required. Update version.
                            }
                        }
                    },
                    "startDateTime": "2020-02-20 00:00:00",  # Required. The deployment start
                      datetime.
                    "update": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = deployment

        request = build_device_management_create_or_update_deployment_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            deployment_id=deployment_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def delete_deployment(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        deployment_id: str,
        **kwargs: Any
    ) -> None:
        """Deletes a deployment.

        :param group_id: Group identity.
        :type group_id: str
        :param deployment_id: Deployment identifier.
        :type deployment_id: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_device_management_delete_deployment_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            deployment_id=deployment_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace
    def get_deployment_status(
        self,
        group_id: str,
        deployment_id: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the status of a deployment including a breakdown of how many devices in the deployment are
        in progress, completed, or failed.

        :param group_id: Group identity.
        :type group_id: str
        :param deployment_id: Deployment identifier.
        :type deployment_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "deploymentState": "str",  # Required. The state of the deployment. Known
                      values are: "Active", "ActiveWithSubgroupFailures", "Failed", "Inactive",
                      "Canceled".
                    "error": {
                        "code": "str",  # Required. Server defined error code.
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",  # Required. A more specific error code than
                              what was provided by the containing error.
                            "errorDetail": "str",  # Optional. The internal error or
                              exception message.
                            "innerError": ...,
                            "message": "str"  # Optional. A human-readable representation
                              of the error.
                        },
                        "message": "str",  # Required. A human-readable representation of the
                          error.
                        "occurredDateTime": "2020-02-20 00:00:00",  # Optional. Date and time
                          in UTC when the error occurred.
                        "target": "str"  # Optional. The target of the error.
                    },
                    "groupId": "str",  # Required. The group identity.
                    "subgroupStatus": [
                        {
                            "deploymentState": "str",  # Required. The state of the
                              subgroup deployment. Known values are: "Active", "Failed", "Inactive",
                              "Canceled".
                            "deviceClassId": "str",  # Required. The device class
                              subgroup identity.
                            "devicesCanceledCount": 0,  # Optional. The number of devices
                              which have had their deployment canceled.
                            "devicesCompletedFailedCount": 0,  # Optional. The number of
                              devices that have completed deployment with a failure.
                            "devicesCompletedSucceededCount": 0,  # Optional. The number
                              of devices which have successfully completed deployment.
                            "devicesInProgressCount": 0,  # Optional. The number of
                              devices that are currently in deployment.
                            "error": {
                                "code": "str",  # Required. Server defined error
                                  code.
                                "details": [
                                    ...
                                ],
                                "innererror": {
                                    "code": "str",  # Required. A more specific
                                      error code than what was provided by the containing error.
                                    "errorDetail": "str",  # Optional. The
                                      internal error or exception message.
                                    "innerError": ...,
                                    "message": "str"  # Optional. A
                                      human-readable representation of the error.
                                },
                                "message": "str",  # Required. A human-readable
                                  representation of the error.
                                "occurredDateTime": "2020-02-20 00:00:00",  #
                                  Optional. Date and time in UTC when the error occurred.
                                "target": "str"  # Optional. The target of the error.
                            },
                            "groupId": "str",  # Required. The group identity.
                            "totalDevices": 0  # Optional. The total number of devices in
                              the deployment.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_deployment_status_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            deployment_id=deployment_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def list_device_class_subgroups_for_group(
        self,
        group_id: str,
        *,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get the device class subgroups for the group.

        :param group_id: Group identity.
        :type group_id: str
        :keyword filter: Restricts the set of device class subgroups returned. You can filter on compat
         properties by name and value. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "createdDateTime": "str",  # Required. Date and time when the
                              device class subgroup was created.
                            "deploymentId": "str",  # Optional. The active deployment Id
                              for the device class subgroup.
                            "deviceClassId": "str",  # Required. Device class subgroup
                              identity.
                            "deviceCount": 0,  # Optional. The number of devices in the
                              device class subgroup.
                            "groupId": "str"  # Required. Group identity.
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_device_class_subgroups_for_group_request(
                    instance_id=self._config.instance_id,
                    group_id=group_id,
                    api_version=api_version,
                    filter=filter,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_device_class_subgroups_for_group_request(
                    instance_id=self._config.instance_id,
                    group_id=group_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_device_class_subgroup(
        self,
        group_id: str,
        device_class_id: str,
        **kwargs: Any
    ) -> JSON:
        """Gets device class subgroup details.

        :param group_id: Group identity.
        :type group_id: str
        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "createdDateTime": "str",  # Required. Date and time when the device class
                      subgroup was created.
                    "deploymentId": "str",  # Optional. The active deployment Id for the device
                      class subgroup.
                    "deviceClassId": "str",  # Required. Device class subgroup identity.
                    "deviceCount": 0,  # Optional. The number of devices in the device class
                      subgroup.
                    "groupId": "str"  # Required. Group identity.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_device_class_subgroup_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            device_class_id=device_class_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def delete_device_class_subgroup(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        device_class_id: str,
        **kwargs: Any
    ) -> None:
        """Deletes a device class subgroup.

        :param group_id: Group identity.
        :type group_id: str
        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_device_management_delete_device_class_subgroup_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            device_class_id=device_class_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace
    def get_device_class_subgroup_update_compliance(
        self,
        group_id: str,
        device_class_id: str,
        **kwargs: Any
    ) -> JSON:
        """Get device class subgroup update compliance information such as how many devices are on their
        latest update, how many need new updates, and how many are in progress on receiving a new
        update.

        :param group_id: Group identity.
        :type group_id: str
        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "newUpdatesAvailableDeviceCount": 0,  # Required. Number of devices with a
                      newer update available.
                    "onLatestUpdateDeviceCount": 0,  # Required. Number of devices on the latest
                      update.
                    "totalDeviceCount": 0,  # Required. Total number of devices.
                    "updatesInProgressDeviceCount": 0  # Required. Number of devices with update
                      in-progress.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_device_class_subgroup_update_compliance_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            device_class_id=device_class_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def get_best_updates_for_device_class_subgroup(
        self,
        group_id: str,
        device_class_id: str,
        **kwargs: Any
    ) -> JSON:
        """Get the best available update for a device class subgroup and a count of how many devices need
        this update.

        :param group_id: Group identity.
        :type group_id: str
        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "deviceClassId": "str",  # Required. The device class subgroup's device class
                      Id.
                    "deviceCount": 0,  # Required. Total number of devices for which the update
                      is applicable.
                    "groupId": "str",  # Required. The group Id.
                    "update": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_best_updates_for_device_class_subgroup_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            device_class_id=device_class_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def list_deployments_for_device_class_subgroup(
        self,
        group_id: str,
        device_class_id: str,
        *,
        order_by: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets a list of deployments for a device class subgroup.

        :param group_id: Group identity.
        :type group_id: str
        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :keyword order_by: Orders the set of deployments returned. You can order by start date. Default
         value is None.
        :paramtype order_by: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "deploymentId": "str",  # Required. The caller-provided
                              deployment identifier.
                            "deviceClassSubgroups": [
                                "str"  # Optional. The device class subgroups the
                                  deployment is compatible with and subgroup deployments have been
                                  created for. This is not provided by the caller during
                                  CreateOrUpdateDeployment but is automatically determined by Device
                                  Update.
                            ],
                            "groupId": "str",  # Required. The group identity for the
                              devices the deployment is intended to update.
                            "isCanceled": bool,  # Optional. Boolean flag indicating
                              whether the deployment was canceled.
                            "isCloudInitiatedRollback": bool,  # Optional. Boolean flag
                              indicating whether the deployment is a rollback deployment.
                            "isRetried": bool,  # Optional. Boolean flag indicating
                              whether the deployment has been retried.
                            "rollbackPolicy": {
                                "failure": {
                                    "devicesFailedCount": 0,  # Required. Number
                                      of devices that failed.
                                    "devicesFailedPercentage": 0  # Required.
                                      Percentage of devices that failed.
                                },
                                "update": {
                                    "description": "str",  # Optional. Update
                                      description.
                                    "friendlyName": "str",  # Optional. Friendly
                                      update name.
                                    "updateId": {
                                        "name": "str",  # Required. Update
                                          name.
                                        "provider": "str",  # Required.
                                          Update provider.
                                        "version": "str"  # Required. Update
                                          version.
                                    }
                                }
                            },
                            "startDateTime": "2020-02-20 00:00:00",  # Required. The
                              deployment start datetime.
                            "update": {
                                "description": "str",  # Optional. Update
                                  description.
                                "friendlyName": "str",  # Optional. Friendly update
                                  name.
                                "updateId": {
                                    "name": "str",  # Required. Update name.
                                    "provider": "str",  # Required. Update
                                      provider.
                                    "version": "str"  # Required. Update version.
                                }
                            }
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_deployments_for_device_class_subgroup_request(
                    instance_id=self._config.instance_id,
                    group_id=group_id,
                    device_class_id=device_class_id,
                    api_version=api_version,
                    order_by=order_by,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_deployments_for_device_class_subgroup_request(
                    instance_id=self._config.instance_id,
                    group_id=group_id,
                    device_class_id=device_class_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_deployment_for_device_class_subgroup(
        self,
        group_id: str,
        device_class_id: str,
        deployment_id: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the deployment properties.

        :param group_id: Group identity.
        :type group_id: str
        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :param deployment_id: Deployment identifier.
        :type deployment_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "deploymentId": "str",  # Required. The caller-provided deployment
                      identifier.
                    "deviceClassSubgroups": [
                        "str"  # Optional. The device class subgroups the deployment is
                          compatible with and subgroup deployments have been created for. This is not
                          provided by the caller during CreateOrUpdateDeployment but is automatically
                          determined by Device Update.
                    ],
                    "groupId": "str",  # Required. The group identity for the devices the
                      deployment is intended to update.
                    "isCanceled": bool,  # Optional. Boolean flag indicating whether the
                      deployment was canceled.
                    "isCloudInitiatedRollback": bool,  # Optional. Boolean flag indicating
                      whether the deployment is a rollback deployment.
                    "isRetried": bool,  # Optional. Boolean flag indicating whether the
                      deployment has been retried.
                    "rollbackPolicy": {
                        "failure": {
                            "devicesFailedCount": 0,  # Required. Number of devices that
                              failed.
                            "devicesFailedPercentage": 0  # Required. Percentage of
                              devices that failed.
                        },
                        "update": {
                            "description": "str",  # Optional. Update description.
                            "friendlyName": "str",  # Optional. Friendly update name.
                            "updateId": {
                                "name": "str",  # Required. Update name.
                                "provider": "str",  # Required. Update provider.
                                "version": "str"  # Required. Update version.
                            }
                        }
                    },
                    "startDateTime": "2020-02-20 00:00:00",  # Required. The deployment start
                      datetime.
                    "update": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_deployment_for_device_class_subgroup_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            device_class_id=device_class_id,
            deployment_id=deployment_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def delete_deployment_for_device_class_subgroup(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        device_class_id: str,
        deployment_id: str,
        **kwargs: Any
    ) -> None:
        """Deletes a device class subgroup deployment.

        :param group_id: Group identity.
        :type group_id: str
        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :param deployment_id: Deployment identifier.
        :type deployment_id: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_device_management_delete_deployment_for_device_class_subgroup_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            device_class_id=device_class_id,
            deployment_id=deployment_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace
    def stop_deployment(
        self,
        group_id: str,
        device_class_id: str,
        deployment_id: str,
        **kwargs: Any
    ) -> JSON:
        """Stops a deployment.

        :param group_id: Group identity.
        :type group_id: str
        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :param deployment_id: Deployment identifier.
        :type deployment_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "deploymentId": "str",  # Required. The caller-provided deployment
                      identifier.
                    "deviceClassSubgroups": [
                        "str"  # Optional. The device class subgroups the deployment is
                          compatible with and subgroup deployments have been created for. This is not
                          provided by the caller during CreateOrUpdateDeployment but is automatically
                          determined by Device Update.
                    ],
                    "groupId": "str",  # Required. The group identity for the devices the
                      deployment is intended to update.
                    "isCanceled": bool,  # Optional. Boolean flag indicating whether the
                      deployment was canceled.
                    "isCloudInitiatedRollback": bool,  # Optional. Boolean flag indicating
                      whether the deployment is a rollback deployment.
                    "isRetried": bool,  # Optional. Boolean flag indicating whether the
                      deployment has been retried.
                    "rollbackPolicy": {
                        "failure": {
                            "devicesFailedCount": 0,  # Required. Number of devices that
                              failed.
                            "devicesFailedPercentage": 0  # Required. Percentage of
                              devices that failed.
                        },
                        "update": {
                            "description": "str",  # Optional. Update description.
                            "friendlyName": "str",  # Optional. Friendly update name.
                            "updateId": {
                                "name": "str",  # Required. Update name.
                                "provider": "str",  # Required. Update provider.
                                "version": "str"  # Required. Update version.
                            }
                        }
                    },
                    "startDateTime": "2020-02-20 00:00:00",  # Required. The deployment start
                      datetime.
                    "update": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_stop_deployment_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            device_class_id=device_class_id,
            deployment_id=deployment_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def retry_deployment(
        self,
        group_id: str,
        device_class_id: str,
        deployment_id: str,
        **kwargs: Any
    ) -> JSON:
        """Retries a deployment with failed devices.

        :param group_id: Group identity.
        :type group_id: str
        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :param deployment_id: Deployment identifier.
        :type deployment_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "deploymentId": "str",  # Required. The caller-provided deployment
                      identifier.
                    "deviceClassSubgroups": [
                        "str"  # Optional. The device class subgroups the deployment is
                          compatible with and subgroup deployments have been created for. This is not
                          provided by the caller during CreateOrUpdateDeployment but is automatically
                          determined by Device Update.
                    ],
                    "groupId": "str",  # Required. The group identity for the devices the
                      deployment is intended to update.
                    "isCanceled": bool,  # Optional. Boolean flag indicating whether the
                      deployment was canceled.
                    "isCloudInitiatedRollback": bool,  # Optional. Boolean flag indicating
                      whether the deployment is a rollback deployment.
                    "isRetried": bool,  # Optional. Boolean flag indicating whether the
                      deployment has been retried.
                    "rollbackPolicy": {
                        "failure": {
                            "devicesFailedCount": 0,  # Required. Number of devices that
                              failed.
                            "devicesFailedPercentage": 0  # Required. Percentage of
                              devices that failed.
                        },
                        "update": {
                            "description": "str",  # Optional. Update description.
                            "friendlyName": "str",  # Optional. Friendly update name.
                            "updateId": {
                                "name": "str",  # Required. Update name.
                                "provider": "str",  # Required. Update provider.
                                "version": "str"  # Required. Update version.
                            }
                        }
                    },
                    "startDateTime": "2020-02-20 00:00:00",  # Required. The deployment start
                      datetime.
                    "update": {
                        "description": "str",  # Optional. Update description.
                        "friendlyName": "str",  # Optional. Friendly update name.
                        "updateId": {
                            "name": "str",  # Required. Update name.
                            "provider": "str",  # Required. Update provider.
                            "version": "str"  # Required. Update version.
                        }
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_retry_deployment_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            device_class_id=device_class_id,
            deployment_id=deployment_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def get_device_class_subgroup_deployment_status(
        self,
        group_id: str,
        device_class_id: str,
        deployment_id: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the status of a deployment including a breakdown of how many devices in the deployment are
        in progress, completed, or failed.

        :param group_id: Group identity.
        :type group_id: str
        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :param deployment_id: Deployment identifier.
        :type deployment_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "deploymentState": "str",  # Required. The state of the subgroup deployment.
                      Known values are: "Active", "Failed", "Inactive", "Canceled".
                    "deviceClassId": "str",  # Required. The device class subgroup identity.
                    "devicesCanceledCount": 0,  # Optional. The number of devices which have had
                      their deployment canceled.
                    "devicesCompletedFailedCount": 0,  # Optional. The number of devices that
                      have completed deployment with a failure.
                    "devicesCompletedSucceededCount": 0,  # Optional. The number of devices which
                      have successfully completed deployment.
                    "devicesInProgressCount": 0,  # Optional. The number of devices that are
                      currently in deployment.
                    "error": {
                        "code": "str",  # Required. Server defined error code.
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",  # Required. A more specific error code than
                              what was provided by the containing error.
                            "errorDetail": "str",  # Optional. The internal error or
                              exception message.
                            "innerError": ...,
                            "message": "str"  # Optional. A human-readable representation
                              of the error.
                        },
                        "message": "str",  # Required. A human-readable representation of the
                          error.
                        "occurredDateTime": "2020-02-20 00:00:00",  # Optional. Date and time
                          in UTC when the error occurred.
                        "target": "str"  # Optional. The target of the error.
                    },
                    "groupId": "str",  # Required. The group identity.
                    "totalDevices": 0  # Optional. The total number of devices in the deployment.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_device_class_subgroup_deployment_status_request(
            instance_id=self._config.instance_id,
            group_id=group_id,
            device_class_id=device_class_id,
            deployment_id=deployment_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def list_device_states_for_device_class_subgroup_deployment(
        self,
        group_id: str,
        device_class_id: str,
        deployment_id: str,
        *,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets a list of devices in a deployment along with their state. Useful for getting a list of
        failed devices.

        :param group_id: Group identity.
        :type group_id: str
        :param device_class_id: Device class identifier.
        :type device_class_id: str
        :param deployment_id: Deployment identifier.
        :type deployment_id: str
        :keyword filter: Restricts the set of deployment device states returned. You can filter on
         deviceId and moduleId and/or deviceState. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "deviceId": "str",  # Required. Device identity.
                            "deviceState": "str",  # Required. Deployment device state.
                              Known values are: "Succeeded", "InProgress", "Canceled", "Failed".
                            "moduleId": "str",  # Optional. Device module identity.
                            "movedOnToNewDeployment": bool,  # Required. Boolean flag
                              indicating whether this device is in a newer deployment and can no longer
                              retry this deployment.
                            "retryCount": 0  # Required. The number of times this
                              deployment has been retried on this device.
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_device_states_for_device_class_subgroup_deployment_request(
                    instance_id=self._config.instance_id,
                    group_id=group_id,
                    device_class_id=device_class_id,
                    deployment_id=deployment_id,
                    api_version=api_version,
                    filter=filter,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_device_states_for_device_class_subgroup_deployment_request(
                    instance_id=self._config.instance_id,
                    group_id=group_id,
                    device_class_id=device_class_id,
                    deployment_id=deployment_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_operation(
        self,
        operation_id: str,
        *,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Retrieve operation status.

        :param operation_id: Operation identifier.
        :type operation_id: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Required. Date and time in UTC
                      when the operation was created.
                    "error": {
                        "code": "str",  # Required. Server defined error code.
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",  # Required. A more specific error code than
                              what was provided by the containing error.
                            "errorDetail": "str",  # Optional. The internal error or
                              exception message.
                            "innerError": ...,
                            "message": "str"  # Optional. A human-readable representation
                              of the error.
                        },
                        "message": "str",  # Required. A human-readable representation of the
                          error.
                        "occurredDateTime": "2020-02-20 00:00:00",  # Optional. Date and time
                          in UTC when the error occurred.
                        "target": "str"  # Optional. The target of the error.
                    },
                    "etag": "str",  # Optional. Operation ETag.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Required. Date and time in
                      UTC when the operation status was last updated.
                    "operationId": "str",  # Required. Operation Id.
                    "status": "str",  # Required. Operation status. Known values are:
                      "NotStarted", "Running", "Succeeded", "Failed".
                    "traceId": "str"  # Optional. Operation correlation identity that can used by
                      Microsoft Support for troubleshooting.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_device_management_get_operation_request(
            instance_id=self._config.instance_id,
            operation_id=operation_id,
            api_version=api_version,
            if_none_match=if_none_match,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 304]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers['Retry-After']=self._deserialize('str', response.headers.get('Retry-After'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized



    @distributed_trace
    def list_operations(
        self,
        *,
        filter: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get a list of all device import operations. Completed operations are kept for 7 days before
        auto-deleted.

        :keyword filter: Restricts the set of operations returned. Only one specific filter is
         supported: "status eq 'NotStarted' or status eq 'Running'". Default value is None.
        :paramtype filter: str
        :keyword top: Specifies a non-negative integer n that limits the number of items returned from
         a collection. The service returns the number of available items up to but not greater than the
         specified value n. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "createdDateTime": "2020-02-20 00:00:00",  # Required. Date
                              and time in UTC when the operation was created.
                            "error": {
                                "code": "str",  # Required. Server defined error
                                  code.
                                "details": [
                                    ...
                                ],
                                "innererror": {
                                    "code": "str",  # Required. A more specific
                                      error code than what was provided by the containing error.
                                    "errorDetail": "str",  # Optional. The
                                      internal error or exception message.
                                    "innerError": ...,
                                    "message": "str"  # Optional. A
                                      human-readable representation of the error.
                                },
                                "message": "str",  # Required. A human-readable
                                  representation of the error.
                                "occurredDateTime": "2020-02-20 00:00:00",  #
                                  Optional. Date and time in UTC when the error occurred.
                                "target": "str"  # Optional. The target of the error.
                            },
                            "etag": "str",  # Optional. Operation ETag.
                            "lastActionDateTime": "2020-02-20 00:00:00",  # Required.
                              Date and time in UTC when the operation status was last updated.
                            "operationId": "str",  # Required. Operation Id.
                            "status": "str",  # Required. Operation status. Known values
                              are: "NotStarted", "Running", "Succeeded", "Failed".
                            "traceId": "str"  # Optional. Operation correlation identity
                              that can used by Microsoft Support for troubleshooting.
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_operations_request(
                    instance_id=self._config.instance_id,
                    api_version=api_version,
                    filter=filter,
                    top=top,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_operations_request(
                    instance_id=self._config.instance_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def start_log_collection(
        self,
        log_collection_id: str,
        log_collection: JSON,
        **kwargs: Any
    ) -> JSON:
        """Start the device diagnostics log collection on specified devices.

        :param log_collection_id: Log collection identifier.
        :type log_collection_id: str
        :param log_collection: The log collection properties.
        :type log_collection: JSON
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                log_collection = {
                    "createdDateTime": "str",  # Optional. The timestamp when the operation was
                      created.
                    "description": "str",  # Optional. Description of the diagnostics operation.
                    "deviceList": [
                        {
                            "deviceId": "str",  # Required. Device Id.
                            "moduleId": "str"  # Optional. Module Id.
                        }
                    ],
                    "lastActionDateTime": "str",  # Optional. A timestamp for when the current
                      state was entered.
                    "operationId": "str",  # Optional. The log collection id.
                    "status": "str"  # Optional. Operation status. Known values are:
                      "NotStarted", "Running", "Succeeded", "Failed".
                }

                # response body for status code(s): 201
                response.json() == {
                    "createdDateTime": "str",  # Optional. The timestamp when the operation was
                      created.
                    "description": "str",  # Optional. Description of the diagnostics operation.
                    "deviceList": [
                        {
                            "deviceId": "str",  # Required. Device Id.
                            "moduleId": "str"  # Optional. Module Id.
                        }
                    ],
                    "lastActionDateTime": "str",  # Optional. A timestamp for when the current
                      state was entered.
                    "operationId": "str",  # Optional. The log collection id.
                    "status": "str"  # Optional. Operation status. Known values are:
                      "NotStarted", "Running", "Succeeded", "Failed".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = log_collection

        request = build_device_management_start_log_collection_request(
            instance_id=self._config.instance_id,
            log_collection_id=log_collection_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def get_log_collection(
        self,
        log_collection_id: str,
        **kwargs: Any
    ) -> JSON:
        """Get the device diagnostics log collection.

        :param log_collection_id: Log collection identifier.
        :type log_collection_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "createdDateTime": "str",  # Optional. The timestamp when the operation was
                      created.
                    "description": "str",  # Optional. Description of the diagnostics operation.
                    "deviceList": [
                        {
                            "deviceId": "str",  # Required. Device Id.
                            "moduleId": "str"  # Optional. Module Id.
                        }
                    ],
                    "lastActionDateTime": "str",  # Optional. A timestamp for when the current
                      state was entered.
                    "operationId": "str",  # Optional. The log collection id.
                    "status": "str"  # Optional. Operation status. Known values are:
                      "NotStarted", "Running", "Succeeded", "Failed".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_log_collection_request(
            instance_id=self._config.instance_id,
            log_collection_id=log_collection_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def list_log_collections(
        self,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get all device diagnostics log collections.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "createdDateTime": "str",  # Optional. The timestamp when the
                              operation was created.
                            "description": "str",  # Optional. Description of the
                              diagnostics operation.
                            "deviceList": [
                                {
                                    "deviceId": "str",  # Required. Device Id.
                                    "moduleId": "str"  # Optional. Module Id.
                                }
                            ],
                            "lastActionDateTime": "str",  # Optional. A timestamp for
                              when the current state was entered.
                            "operationId": "str",  # Optional. The log collection id.
                            "status": "str"  # Optional. Operation status. Known values
                              are: "NotStarted", "Running", "Succeeded", "Failed".
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_log_collections_request(
                    instance_id=self._config.instance_id,
                    api_version=api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_log_collections_request(
                    instance_id=self._config.instance_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_log_collection_detailed_status(
        self,
        operation_id: str,
        **kwargs: Any
    ) -> JSON:
        """Get log collection with detailed status.

        :param operation_id: Operation identifier.
        :type operation_id: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "createdDateTime": "str",  # Optional. The timestamp when the operation was
                      created.
                    "description": "str",  # Optional. Device diagnostics operation description.
                    "deviceStatus": [
                        {
                            "deviceId": "str",  # Required. Device id.
                            "extendedResultCode": "str",  # Optional. Log upload extended
                              result code.
                            "logLocation": "str",  # Optional. Log upload location.
                            "moduleId": "str",  # Optional. Module id.
                            "resultCode": "str",  # Optional. Log upload result code.
                            "status": "str"  # Required. Log upload status. Known values
                              are: "NotStarted", "Running", "Succeeded", "Failed".
                        }
                    ],
                    "lastActionDateTime": "str",  # Optional. A timestamp for when the current
                      state was entered.
                    "operationId": "str",  # Optional. The device diagnostics operation id.
                    "status": "str"  # Optional. Operation status. Known values are:
                      "NotStarted", "Running", "Succeeded", "Failed".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_device_management_get_log_collection_detailed_status_request(
            instance_id=self._config.instance_id,
            operation_id=operation_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def list_device_health(
        self,
        *,
        filter: str,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get list of device health.

        :keyword filter: Filter list by specified properties.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. The link to the next page of items.
                    "value": [
                        {
                            "deviceId": "str",  # Required. Device id.
                            "digitalTwinModelId": "str",  # Optional. Digital twin model
                              Id.
                            "healthChecks": [
                                {
                                    "name": "str",  # Optional. Health check
                                      name.
                                    "result": "str"  # Optional. Health check
                                      result. Known values are: "success", "userError".
                                }
                            ],
                            "moduleId": "str",  # Optional. Module id.
                            "state": "str"  # Required. Aggregate device health state.
                              Known values are: "healthy", "unhealthy".
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-07-01-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_device_management_list_device_health_request(
                    instance_id=self._config.instance_id,
                    api_version=api_version,
                    filter=filter,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_device_management_list_device_health_request(
                    instance_id=self._config.instance_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )

