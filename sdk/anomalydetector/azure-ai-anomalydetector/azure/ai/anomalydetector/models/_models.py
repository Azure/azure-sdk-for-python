# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model
from msrest.exceptions import HttpOperationError


class AlignPolicy(Model):
    """AlignPolicy.

    :param align_mode: An optional field, indicating how we align different
     variables to the same time-range. Either Inner or Outer. Possible values
     include: 'Inner', 'Outer'
    :type align_mode: str or ~azure.ai.anomalydetector.models.AlignMode
    :param fill_na_method: An optional field, indicating how missing values
     will be filled. One of Previous, Subsequent, Linear, Zero, Fixed, and
     NotFill. Cannot be set to NotFill, when the alignMode is Outer. Possible
     values include: 'Previous', 'Subsequent', 'Linear', 'Zero', 'Fixed',
     'NotFill'
    :type fill_na_method: str or ~azure.ai.anomalydetector.models.FillNAMethod
    :param padding_value: An optional field. Required when fillNAMethod is
     Fixed.
    :type padding_value: float
    """

    _attribute_map = {
        'align_mode': {'key': 'alignMode', 'type': 'AlignMode'},
        'fill_na_method': {'key': 'fillNAMethod', 'type': 'str'},
        'padding_value': {'key': 'paddingValue', 'type': 'float'},
    }

    def __init__(self, **kwargs):
        super(AlignPolicy, self).__init__(**kwargs)
        self.align_mode = kwargs.get('align_mode', None)
        self.fill_na_method = kwargs.get('fill_na_method', None)
        self.padding_value = kwargs.get('padding_value', None)


class AnomalyDetectorError(Model):
    """Error information returned by the API.

    :param code: The error code.
    :type code: object
    :param message: A message explaining the error reported by the service.
    :type message: str
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'object'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AnomalyDetectorError, self).__init__(**kwargs)
        self.code = kwargs.get('code', None)
        self.message = kwargs.get('message', None)


class AnomalyDetectorErrorException(HttpOperationError):
    """Server responsed with exception of type: 'AnomalyDetectorError'.

    :param deserialize: A deserializer
    :param response: Server response to be deserialized.
    """

    def __init__(self, deserialize, response, *args):

        super(AnomalyDetectorErrorException, self).__init__(deserialize, response, 'AnomalyDetectorError', *args)


class AnomalyInterpretation(Model):
    """AnomalyInterpretation.

    :param variable:
    :type variable: str
    :param contribution_score:
    :type contribution_score: float
    :param correlation_changes:
    :type correlation_changes:
     ~azure.ai.anomalydetector.models.CorrelationChanges
    """

    _attribute_map = {
        'variable': {'key': 'variable', 'type': 'str'},
        'contribution_score': {'key': 'contributionScore', 'type': 'float'},
        'correlation_changes': {'key': 'correlationChanges', 'type': 'CorrelationChanges'},
    }

    def __init__(self, **kwargs):
        super(AnomalyInterpretation, self).__init__(**kwargs)
        self.variable = kwargs.get('variable', None)
        self.contribution_score = kwargs.get('contribution_score', None)
        self.correlation_changes = kwargs.get('correlation_changes', None)


class AnomalyState(Model):
    """AnomalyState.

    All required parameters must be populated in order to send to Azure.

    :param timestamp: Required. timestamp
    :type timestamp: datetime
    :param value:
    :type value: ~azure.ai.anomalydetector.models.AnomalyValue
    :param errors: Error message for the current timestamp
    :type errors: list[~azure.ai.anomalydetector.models.ErrorResponse]
    """

    _validation = {
        'timestamp': {'required': True},
    }

    _attribute_map = {
        'timestamp': {'key': 'timestamp', 'type': 'iso-8601'},
        'value': {'key': 'value', 'type': 'AnomalyValue'},
        'errors': {'key': 'errors', 'type': '[ErrorResponse]'},
    }

    def __init__(self, **kwargs):
        super(AnomalyState, self).__init__(**kwargs)
        self.timestamp = kwargs.get('timestamp', None)
        self.value = kwargs.get('value', None)
        self.errors = kwargs.get('errors', None)


class AnomalyValue(Model):
    """AnomalyValue.

    All required parameters must be populated in order to send to Azure.

    :param is_anomaly: Required. True if an anomaly is detected at the current
     timestamp.
    :type is_anomaly: bool
    :param severity: Required. Indicates the significance of the anomaly. The
     higher the severity, the more significant the anomaly.
    :type severity: float
    :param score: Required. Raw score from the model.
    :type score: float
    :param interpretation:
    :type interpretation:
     list[~azure.ai.anomalydetector.models.AnomalyInterpretation]
    """

    _validation = {
        'is_anomaly': {'required': True},
        'severity': {'required': True, 'maximum': 1, 'minimum': 0},
        'score': {'required': True, 'maximum': 2, 'minimum': 0},
    }

    _attribute_map = {
        'is_anomaly': {'key': 'isAnomaly', 'type': 'bool'},
        'severity': {'key': 'severity', 'type': 'float'},
        'score': {'key': 'score', 'type': 'float'},
        'interpretation': {'key': 'interpretation', 'type': '[AnomalyInterpretation]'},
    }

    def __init__(self, **kwargs):
        super(AnomalyValue, self).__init__(**kwargs)
        self.is_anomaly = kwargs.get('is_anomaly', None)
        self.severity = kwargs.get('severity', None)
        self.score = kwargs.get('score', None)
        self.interpretation = kwargs.get('interpretation', None)


class ChangePointDetectRequest(Model):
    """The request of change point detection.

    All required parameters must be populated in order to send to Azure.

    :param series: Required. Time series data points. Points should be sorted
     by timestamp in ascending order to match the change point detection
     result.
    :type series: list[~azure.ai.anomalydetector.models.TimeSeriesPoint]
    :param granularity: Required. Can only be one of yearly, monthly, weekly,
     daily, hourly, minutely or secondly. Granularity is used for verify
     whether input series is valid. Possible values include: 'yearly',
     'monthly', 'weekly', 'daily', 'hourly', 'perMinute', 'perSecond',
     'microsecond', 'none'
    :type granularity: str or ~azure.ai.anomalydetector.models.TimeGranularity
    :param custom_interval: Custom Interval is used to set non-standard time
     interval, for example, if the series is 5 minutes, request can be set as
     {"granularity":"minutely", "customInterval":5}.
    :type custom_interval: int
    :param period: Optional argument, periodic value of a time series. If the
     value is null or does not present, the API will determine the period
     automatically.
    :type period: int
    :param stable_trend_window: Optional argument, advanced model parameter, a
     default stableTrendWindow will be used in detection.
    :type stable_trend_window: int
    :param threshold: Optional argument, advanced model parameter, between
     0.0-1.0, the lower the value is, the larger the trend error will be which
     means less change point will be accepted.
    :type threshold: float
    """

    _validation = {
        'series': {'required': True},
        'granularity': {'required': True},
    }

    _attribute_map = {
        'series': {'key': 'series', 'type': '[TimeSeriesPoint]'},
        'granularity': {'key': 'granularity', 'type': 'TimeGranularity'},
        'custom_interval': {'key': 'customInterval', 'type': 'int'},
        'period': {'key': 'period', 'type': 'int'},
        'stable_trend_window': {'key': 'stableTrendWindow', 'type': 'int'},
        'threshold': {'key': 'threshold', 'type': 'float'},
    }

    def __init__(self, **kwargs):
        super(ChangePointDetectRequest, self).__init__(**kwargs)
        self.series = kwargs.get('series', None)
        self.granularity = kwargs.get('granularity', None)
        self.custom_interval = kwargs.get('custom_interval', None)
        self.period = kwargs.get('period', None)
        self.stable_trend_window = kwargs.get('stable_trend_window', None)
        self.threshold = kwargs.get('threshold', None)


class ChangePointDetectResponse(Model):
    """The response of change point detection.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar period: Frequency extracted from the series, zero means no recurrent
     pattern has been found.
    :vartype period: int
    :param is_change_point: isChangePoint contains change point properties for
     each input point. True means an anomaly either negative or positive has
     been detected. The index of the array is consistent with the input series.
    :type is_change_point: list[bool]
    :param confidence_scores: the change point confidence of each point
    :type confidence_scores: list[float]
    """

    _validation = {
        'period': {'readonly': True},
    }

    _attribute_map = {
        'period': {'key': 'period', 'type': 'int'},
        'is_change_point': {'key': 'isChangePoint', 'type': '[bool]'},
        'confidence_scores': {'key': 'confidenceScores', 'type': '[float]'},
    }

    def __init__(self, **kwargs):
        super(ChangePointDetectResponse, self).__init__(**kwargs)
        self.period = None
        self.is_change_point = kwargs.get('is_change_point', None)
        self.confidence_scores = kwargs.get('confidence_scores', None)


class CorrelationChanges(Model):
    """CorrelationChanges.

    :param changed_variables: correlated variables
    :type changed_variables: list[str]
    :param changed_values: changes in correlation
    :type changed_values: list[float]
    """

    _attribute_map = {
        'changed_variables': {'key': 'changedVariables', 'type': '[str]'},
        'changed_values': {'key': 'changedValues', 'type': '[float]'},
    }

    def __init__(self, **kwargs):
        super(CorrelationChanges, self).__init__(**kwargs)
        self.changed_variables = kwargs.get('changed_variables', None)
        self.changed_values = kwargs.get('changed_values', None)


class DetectionRequest(Model):
    """Detection request.

    All required parameters must be populated in order to send to Azure.

    :param source: Required. Source link to the input variables. Each variable
     should be a csv with two columns, `timestamp` and `value`. The file name
     of the variable will be used as its name. The variables used in detection
     should be exactly the same with those used in the training phase.
    :type source: str
    :param start_time: Required. A required field, indicating the start time
     of data for detection. Should be date-time.
    :type start_time: datetime
    :param end_time: Required. A required field, indicating the end time of
     data for detection. Should be date-time.
    :type end_time: datetime
    """

    _validation = {
        'source': {'required': True},
        'start_time': {'required': True},
        'end_time': {'required': True},
    }

    _attribute_map = {
        'source': {'key': 'source', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
    }

    def __init__(self, **kwargs):
        super(DetectionRequest, self).__init__(**kwargs)
        self.source = kwargs.get('source', None)
        self.start_time = kwargs.get('start_time', None)
        self.end_time = kwargs.get('end_time', None)


class DetectionResult(Model):
    """Response of the given resultId.

    All required parameters must be populated in order to send to Azure.

    :param result_id: Required.
    :type result_id: str
    :param summary: Required.
    :type summary: ~azure.ai.anomalydetector.models.DetectionResultSummary
    :param results: Required. Detection result for each timestamp.
    :type results: list[~azure.ai.anomalydetector.models.AnomalyState]
    """

    _validation = {
        'result_id': {'required': True},
        'summary': {'required': True},
        'results': {'required': True},
    }

    _attribute_map = {
        'result_id': {'key': 'resultId', 'type': 'str'},
        'summary': {'key': 'summary', 'type': 'DetectionResultSummary'},
        'results': {'key': 'results', 'type': '[AnomalyState]'},
    }

    def __init__(self, **kwargs):
        super(DetectionResult, self).__init__(**kwargs)
        self.result_id = kwargs.get('result_id', None)
        self.summary = kwargs.get('summary', None)
        self.results = kwargs.get('results', None)


class DetectionResultSummary(Model):
    """DetectionResultSummary.

    All required parameters must be populated in order to send to Azure.

    :param status: Required. Status of detection results. One of CREATED,
     RUNNING, READY, and FAILED. Possible values include: 'CREATED', 'RUNNING',
     'READY', 'FAILED'
    :type status: str or ~azure.ai.anomalydetector.models.DetectionStatus
    :param errors: Error message when detection is failed.
    :type errors: list[~azure.ai.anomalydetector.models.ErrorResponse]
    :param variable_states:
    :type variable_states:
     list[~azure.ai.anomalydetector.models.VariableState]
    :param setup_info: Required.
    :type setup_info: ~azure.ai.anomalydetector.models.DetectionRequest
    """

    _validation = {
        'status': {'required': True},
        'setup_info': {'required': True},
    }

    _attribute_map = {
        'status': {'key': 'status', 'type': 'DetectionStatus'},
        'errors': {'key': 'errors', 'type': '[ErrorResponse]'},
        'variable_states': {'key': 'variableStates', 'type': '[VariableState]'},
        'setup_info': {'key': 'setupInfo', 'type': 'DetectionRequest'},
    }

    def __init__(self, **kwargs):
        super(DetectionResultSummary, self).__init__(**kwargs)
        self.status = kwargs.get('status', None)
        self.errors = kwargs.get('errors', None)
        self.variable_states = kwargs.get('variable_states', None)
        self.setup_info = kwargs.get('setup_info', None)


class DetectRequest(Model):
    """The request of entire or last anomaly detection.

    All required parameters must be populated in order to send to Azure.

    :param series: Required. Time series data points. Points should be sorted
     by timestamp in ascending order to match the anomaly detection result. If
     the data is not sorted correctly or there is duplicated timestamp, the API
     will not work. In such case, an error message will be returned.
    :type series: list[~azure.ai.anomalydetector.models.TimeSeriesPoint]
    :param granularity: Possible values include: 'yearly', 'monthly',
     'weekly', 'daily', 'hourly', 'perMinute', 'perSecond', 'microsecond',
     'none'
    :type granularity: str or ~azure.ai.anomalydetector.models.TimeGranularity
    :param custom_interval: Custom Interval is used to set non-standard time
     interval, for example, if the series is 5 minutes, request can be set as
     {"granularity":"minutely", "customInterval":5}.
    :type custom_interval: int
    :param period: Optional argument, periodic value of a time series. If the
     value is null or does not present, the API will determine the period
     automatically.
    :type period: int
    :param max_anomaly_ratio: Optional argument, advanced model parameter, max
     anomaly ratio in a time series.
    :type max_anomaly_ratio: float
    :param sensitivity: Optional argument, advanced model parameter, between
     0-99, the lower the value is, the larger the margin value will be which
     means less anomalies will be accepted.
    :type sensitivity: int
    :param impute_mode: Used to specify how to deal with missing values in the
     input series, it's used when granularity is not "none". Possible values
     include: 'auto', 'previous', 'linear', 'fixed', 'zero', 'notFill'
    :type impute_mode: str or ~azure.ai.anomalydetector.models.ImputeMode
    :param impute_fixed_value: Used to specify the value to fill, it's used
     when granularity is not "none" and imputeMode is "fixed".
    :type impute_fixed_value: float
    """

    _validation = {
        'series': {'required': True},
    }

    _attribute_map = {
        'series': {'key': 'series', 'type': '[TimeSeriesPoint]'},
        'granularity': {'key': 'granularity', 'type': 'TimeGranularity'},
        'custom_interval': {'key': 'customInterval', 'type': 'int'},
        'period': {'key': 'period', 'type': 'int'},
        'max_anomaly_ratio': {'key': 'maxAnomalyRatio', 'type': 'float'},
        'sensitivity': {'key': 'sensitivity', 'type': 'int'},
        'impute_mode': {'key': 'imputeMode', 'type': 'str'},
        'impute_fixed_value': {'key': 'imputeFixedValue', 'type': 'float'},
    }

    def __init__(self, **kwargs):
        super(DetectRequest, self).__init__(**kwargs)
        self.series = kwargs.get('series', None)
        self.granularity = kwargs.get('granularity', None)
        self.custom_interval = kwargs.get('custom_interval', None)
        self.period = kwargs.get('period', None)
        self.max_anomaly_ratio = kwargs.get('max_anomaly_ratio', None)
        self.sensitivity = kwargs.get('sensitivity', None)
        self.impute_mode = kwargs.get('impute_mode', None)
        self.impute_fixed_value = kwargs.get('impute_fixed_value', None)


class DiagnosticsInfo(Model):
    """DiagnosticsInfo.

    :param model_state:
    :type model_state: ~azure.ai.anomalydetector.models.ModelState
    :param variable_states:
    :type variable_states:
     list[~azure.ai.anomalydetector.models.VariableState]
    """

    _attribute_map = {
        'model_state': {'key': 'modelState', 'type': 'ModelState'},
        'variable_states': {'key': 'variableStates', 'type': '[VariableState]'},
    }

    def __init__(self, **kwargs):
        super(DiagnosticsInfo, self).__init__(**kwargs)
        self.model_state = kwargs.get('model_state', None)
        self.variable_states = kwargs.get('variable_states', None)


class EntireDetectResponse(Model):
    """The response of entire anomaly detection.

    All required parameters must be populated in order to send to Azure.

    :param period: Required. Frequency extracted from the series, zero means
     no recurrent pattern has been found.
    :type period: int
    :param expected_values: Required. ExpectedValues contain expected value
     for each input point. The index of the array is consistent with the input
     series.
    :type expected_values: list[float]
    :param upper_margins: Required. UpperMargins contain upper margin of each
     input point. UpperMargin is used to calculate upperBoundary, which equals
     to expectedValue + (100 - marginScale)*upperMargin. Anomalies in response
     can be filtered by upperBoundary and lowerBoundary. By adjusting
     marginScale value, less significant anomalies can be filtered in client
     side. The index of the array is consistent with the input series.
    :type upper_margins: list[float]
    :param lower_margins: Required. LowerMargins contain lower margin of each
     input point. LowerMargin is used to calculate lowerBoundary, which equals
     to expectedValue - (100 - marginScale)*lowerMargin. Points between the
     boundary can be marked as normal ones in client side. The index of the
     array is consistent with the input series.
    :type lower_margins: list[float]
    :param is_anomaly: Required. IsAnomaly contains anomaly properties for
     each input point. True means an anomaly either negative or positive has
     been detected. The index of the array is consistent with the input series.
    :type is_anomaly: list[bool]
    :param is_negative_anomaly: Required. IsNegativeAnomaly contains anomaly
     status in negative direction for each input point. True means a negative
     anomaly has been detected. A negative anomaly means the point is detected
     as an anomaly and its real value is smaller than the expected one. The
     index of the array is consistent with the input series.
    :type is_negative_anomaly: list[bool]
    :param is_positive_anomaly: Required. IsPositiveAnomaly contain anomaly
     status in positive direction for each input point. True means a positive
     anomaly has been detected. A positive anomaly means the point is detected
     as an anomaly and its real value is larger than the expected one. The
     index of the array is consistent with the input series.
    :type is_positive_anomaly: list[bool]
    :param severity: The severity score for each input point. The larger the
     value is, the more sever the anomaly is. For normal points, the "severity"
     is always 0.
    :type severity: list[float]
    """

    _validation = {
        'period': {'required': True},
        'expected_values': {'required': True},
        'upper_margins': {'required': True},
        'lower_margins': {'required': True},
        'is_anomaly': {'required': True},
        'is_negative_anomaly': {'required': True},
        'is_positive_anomaly': {'required': True},
    }

    _attribute_map = {
        'period': {'key': 'period', 'type': 'int'},
        'expected_values': {'key': 'expectedValues', 'type': '[float]'},
        'upper_margins': {'key': 'upperMargins', 'type': '[float]'},
        'lower_margins': {'key': 'lowerMargins', 'type': '[float]'},
        'is_anomaly': {'key': 'isAnomaly', 'type': '[bool]'},
        'is_negative_anomaly': {'key': 'isNegativeAnomaly', 'type': '[bool]'},
        'is_positive_anomaly': {'key': 'isPositiveAnomaly', 'type': '[bool]'},
        'severity': {'key': 'severity', 'type': '[float]'},
    }

    def __init__(self, **kwargs):
        super(EntireDetectResponse, self).__init__(**kwargs)
        self.period = kwargs.get('period', None)
        self.expected_values = kwargs.get('expected_values', None)
        self.upper_margins = kwargs.get('upper_margins', None)
        self.lower_margins = kwargs.get('lower_margins', None)
        self.is_anomaly = kwargs.get('is_anomaly', None)
        self.is_negative_anomaly = kwargs.get('is_negative_anomaly', None)
        self.is_positive_anomaly = kwargs.get('is_positive_anomaly', None)
        self.severity = kwargs.get('severity', None)


class ErrorResponse(Model):
    """ErrorResponse.

    All required parameters must be populated in order to send to Azure.

    :param code: Required. The error code.
    :type code: str
    :param message: Required. The message explaining the error reported by the
     service.
    :type message: str
    """

    _validation = {
        'code': {'required': True},
        'message': {'required': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ErrorResponse, self).__init__(**kwargs)
        self.code = kwargs.get('code', None)
        self.message = kwargs.get('message', None)


class ErrorResponseException(HttpOperationError):
    """Server responsed with exception of type: 'ErrorResponse'.

    :param deserialize: A deserializer
    :param response: Server response to be deserialized.
    """

    def __init__(self, deserialize, response, *args):

        super(ErrorResponseException, self).__init__(deserialize, response, 'ErrorResponse', *args)


class LastDetectionRequest(Model):
    """LastDetectionRequest.

    All required parameters must be populated in order to send to Azure.

    :param variables: Required. variables
    :type variables: list[~azure.ai.anomalydetector.models.VariableValues]
    :param detecting_points: Required. number of timestamps on which the model
     detects
    :type detecting_points: int
    """

    _validation = {
        'variables': {'required': True},
        'detecting_points': {'required': True},
    }

    _attribute_map = {
        'variables': {'key': 'variables', 'type': '[VariableValues]'},
        'detecting_points': {'key': 'detectingPoints', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(LastDetectionRequest, self).__init__(**kwargs)
        self.variables = kwargs.get('variables', None)
        self.detecting_points = kwargs.get('detecting_points', None)


class LastDetectionResult(Model):
    """LastDetectionResult.

    :param variable_states:
    :type variable_states:
     list[~azure.ai.anomalydetector.models.VariableState]
    :param results:
    :type results: list[~azure.ai.anomalydetector.models.AnomalyState]
    """

    _attribute_map = {
        'variable_states': {'key': 'variableStates', 'type': '[VariableState]'},
        'results': {'key': 'results', 'type': '[AnomalyState]'},
    }

    def __init__(self, **kwargs):
        super(LastDetectionResult, self).__init__(**kwargs)
        self.variable_states = kwargs.get('variable_states', None)
        self.results = kwargs.get('results', None)


class LastDetectResponse(Model):
    """The response of last anomaly detection.

    All required parameters must be populated in order to send to Azure.

    :param period: Required. Frequency extracted from the series, zero means
     no recurrent pattern has been found.
    :type period: int
    :param suggested_window: Required. Suggested input series points needed
     for detecting the latest point.
    :type suggested_window: int
    :param expected_value: Required. Expected value of the latest point.
    :type expected_value: float
    :param upper_margin: Required. Upper margin of the latest point.
     UpperMargin is used to calculate upperBoundary, which equals to
     expectedValue + (100 - marginScale)*upperMargin. If the value of latest
     point is between upperBoundary and lowerBoundary, it should be treated as
     normal value. By adjusting marginScale value, anomaly status of latest
     point can be changed.
    :type upper_margin: float
    :param lower_margin: Required. Lower margin of the latest point.
     LowerMargin is used to calculate lowerBoundary, which equals to
     expectedValue - (100 - marginScale)*lowerMargin.
    :type lower_margin: float
    :param is_anomaly: Required. Anomaly status of the latest point, true
     means the latest point is an anomaly either in negative direction or
     positive direction.
    :type is_anomaly: bool
    :param is_negative_anomaly: Required. Anomaly status in negative direction
     of the latest point. True means the latest point is an anomaly and its
     real value is smaller than the expected one.
    :type is_negative_anomaly: bool
    :param is_positive_anomaly: Required. Anomaly status in positive direction
     of the latest point. True means the latest point is an anomaly and its
     real value is larger than the expected one.
    :type is_positive_anomaly: bool
    :param severity: The severity score for the last input point. The larger
     the value is, the more sever the anomaly is. For normal points, the
     "severity" is always 0.
    :type severity: float
    """

    _validation = {
        'period': {'required': True},
        'suggested_window': {'required': True},
        'expected_value': {'required': True},
        'upper_margin': {'required': True},
        'lower_margin': {'required': True},
        'is_anomaly': {'required': True},
        'is_negative_anomaly': {'required': True},
        'is_positive_anomaly': {'required': True},
    }

    _attribute_map = {
        'period': {'key': 'period', 'type': 'int'},
        'suggested_window': {'key': 'suggestedWindow', 'type': 'int'},
        'expected_value': {'key': 'expectedValue', 'type': 'float'},
        'upper_margin': {'key': 'upperMargin', 'type': 'float'},
        'lower_margin': {'key': 'lowerMargin', 'type': 'float'},
        'is_anomaly': {'key': 'isAnomaly', 'type': 'bool'},
        'is_negative_anomaly': {'key': 'isNegativeAnomaly', 'type': 'bool'},
        'is_positive_anomaly': {'key': 'isPositiveAnomaly', 'type': 'bool'},
        'severity': {'key': 'severity', 'type': 'float'},
    }

    def __init__(self, **kwargs):
        super(LastDetectResponse, self).__init__(**kwargs)
        self.period = kwargs.get('period', None)
        self.suggested_window = kwargs.get('suggested_window', None)
        self.expected_value = kwargs.get('expected_value', None)
        self.upper_margin = kwargs.get('upper_margin', None)
        self.lower_margin = kwargs.get('lower_margin', None)
        self.is_anomaly = kwargs.get('is_anomaly', None)
        self.is_negative_anomaly = kwargs.get('is_negative_anomaly', None)
        self.is_positive_anomaly = kwargs.get('is_positive_anomaly', None)
        self.severity = kwargs.get('severity', None)


class Model(Model):
    """Response of getting a model.

    All required parameters must be populated in order to send to Azure.

    :param model_id: Required. Model identifier.
    :type model_id: str
    :param created_time: Required. Date and time (UTC) when the model was
     created.
    :type created_time: datetime
    :param last_updated_time: Required. Date and time (UTC) when the model was
     last updated.
    :type last_updated_time: datetime
    :param model_info:
    :type model_info: ~azure.ai.anomalydetector.models.ModelInfo
    """

    _validation = {
        'model_id': {'required': True},
        'created_time': {'required': True},
        'last_updated_time': {'required': True},
    }

    _attribute_map = {
        'model_id': {'key': 'modelId', 'type': 'str'},
        'created_time': {'key': 'createdTime', 'type': 'iso-8601'},
        'last_updated_time': {'key': 'lastUpdatedTime', 'type': 'iso-8601'},
        'model_info': {'key': 'modelInfo', 'type': 'ModelInfo'},
    }

    def __init__(self, **kwargs):
        super(Model, self).__init__(**kwargs)
        self.model_id = kwargs.get('model_id', None)
        self.created_time = kwargs.get('created_time', None)
        self.last_updated_time = kwargs.get('last_updated_time', None)
        self.model_info = kwargs.get('model_info', None)


class ModelInfo(Model):
    """Train result of a model including status, errors and diagnose info for
    model and variables.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param sliding_window: An optional field, indicating how many previous
     points will be used to compute the anomaly score of the subsequent point.
    :type sliding_window: int
    :param align_policy:
    :type align_policy: ~azure.ai.anomalydetector.models.AlignPolicy
    :param source: Required. Source link to the input variables. Each variable
     should be a csv file with two columns, `timestamp` and `value`. By
     default, the file name of the variable will be used as its variable name.
    :type source: str
    :param start_time: Required. A required field, indicating the start time
     of training data. Should be date-time.
    :type start_time: datetime
    :param end_time: Required. A required field, indicating the end time of
     training data. Should be date-time.
    :type end_time: datetime
    :param display_name: An optional field. The name of the model whose
     maximum length is 24.
    :type display_name: str
    :param status: Possible values include: 'CREATED', 'RUNNING', 'READY',
     'FAILED'
    :type status: str or ~azure.ai.anomalydetector.models.ModelStatus
    :ivar errors: Error messages when failed to create a model.
    :vartype errors: list[~azure.ai.anomalydetector.models.ErrorResponse]
    :param diagnostics_info:
    :type diagnostics_info: ~azure.ai.anomalydetector.models.DiagnosticsInfo
    """

    _validation = {
        'source': {'required': True},
        'start_time': {'required': True},
        'end_time': {'required': True},
        'display_name': {'max_length': 24},
        'errors': {'readonly': True},
    }

    _attribute_map = {
        'sliding_window': {'key': 'slidingWindow', 'type': 'int'},
        'align_policy': {'key': 'alignPolicy', 'type': 'AlignPolicy'},
        'source': {'key': 'source', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
        'display_name': {'key': 'displayName', 'type': 'str'},
        'status': {'key': 'status', 'type': 'ModelStatus'},
        'errors': {'key': 'errors', 'type': '[ErrorResponse]'},
        'diagnostics_info': {'key': 'diagnosticsInfo', 'type': 'DiagnosticsInfo'},
    }

    def __init__(self, **kwargs):
        super(ModelInfo, self).__init__(**kwargs)
        self.sliding_window = kwargs.get('sliding_window', None)
        self.align_policy = kwargs.get('align_policy', None)
        self.source = kwargs.get('source', None)
        self.start_time = kwargs.get('start_time', None)
        self.end_time = kwargs.get('end_time', None)
        self.display_name = kwargs.get('display_name', None)
        self.status = kwargs.get('status', None)
        self.errors = None
        self.diagnostics_info = kwargs.get('diagnostics_info', None)


class ModelList(Model):
    """Response of listing models.

    All required parameters must be populated in order to send to Azure.

    :param models_property: Required. List of models
    :type models_property:
     list[~azure.ai.anomalydetector.models.ModelSnapshot]
    :param current_count: Required. Current count of trained multivariate
     models.
    :type current_count: int
    :param max_count: Required. Max number of models that can be trained for
     this subscription.
    :type max_count: int
    :param next_link: The link to fetch more models.
    :type next_link: str
    """

    _validation = {
        'models_property': {'required': True},
        'current_count': {'required': True},
        'max_count': {'required': True},
    }

    _attribute_map = {
        'models_property': {'key': 'models', 'type': '[ModelSnapshot]'},
        'current_count': {'key': 'currentCount', 'type': 'int'},
        'max_count': {'key': 'maxCount', 'type': 'int'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ModelList, self).__init__(**kwargs)
        self.models_property = kwargs.get('models_property', None)
        self.current_count = kwargs.get('current_count', None)
        self.max_count = kwargs.get('max_count', None)
        self.next_link = kwargs.get('next_link', None)


class ModelSnapshot(Model):
    """ModelSnapshot.

    All required parameters must be populated in order to send to Azure.

    :param model_id: Required. Model identifier.
    :type model_id: str
    :param created_time: Required. Date and time (UTC) when the model was
     created.
    :type created_time: datetime
    :param last_updated_time: Required. Date and time (UTC) when the model was
     last updated.
    :type last_updated_time: datetime
    :param status: Required. Possible values include: 'CREATED', 'RUNNING',
     'READY', 'FAILED'
    :type status: str or ~azure.ai.anomalydetector.models.ModelStatus
    :param display_name:
    :type display_name: str
    :param variables_count: Required. Total number of variables.
    :type variables_count: int
    """

    _validation = {
        'model_id': {'required': True},
        'created_time': {'required': True},
        'last_updated_time': {'required': True},
        'status': {'required': True},
        'variables_count': {'required': True},
    }

    _attribute_map = {
        'model_id': {'key': 'modelId', 'type': 'str'},
        'created_time': {'key': 'createdTime', 'type': 'iso-8601'},
        'last_updated_time': {'key': 'lastUpdatedTime', 'type': 'iso-8601'},
        'status': {'key': 'status', 'type': 'ModelStatus'},
        'display_name': {'key': 'displayName', 'type': 'str'},
        'variables_count': {'key': 'variablesCount', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(ModelSnapshot, self).__init__(**kwargs)
        self.model_id = kwargs.get('model_id', None)
        self.created_time = kwargs.get('created_time', None)
        self.last_updated_time = kwargs.get('last_updated_time', None)
        self.status = kwargs.get('status', None)
        self.display_name = kwargs.get('display_name', None)
        self.variables_count = kwargs.get('variables_count', None)


class ModelState(Model):
    """ModelState.

    :param epoch_ids: Epoch id
    :type epoch_ids: list[int]
    :param train_losses:
    :type train_losses: list[float]
    :param validation_losses:
    :type validation_losses: list[float]
    :param latencies_in_seconds:
    :type latencies_in_seconds: list[float]
    """

    _attribute_map = {
        'epoch_ids': {'key': 'epochIds', 'type': '[int]'},
        'train_losses': {'key': 'trainLosses', 'type': '[float]'},
        'validation_losses': {'key': 'validationLosses', 'type': '[float]'},
        'latencies_in_seconds': {'key': 'latenciesInSeconds', 'type': '[float]'},
    }

    def __init__(self, **kwargs):
        super(ModelState, self).__init__(**kwargs)
        self.epoch_ids = kwargs.get('epoch_ids', None)
        self.train_losses = kwargs.get('train_losses', None)
        self.validation_losses = kwargs.get('validation_losses', None)
        self.latencies_in_seconds = kwargs.get('latencies_in_seconds', None)


class TimeSeriesPoint(Model):
    """The definition of input timeseries points.

    All required parameters must be populated in order to send to Azure.

    :param timestamp: Optional argument, timestamp of a data point (ISO8601
     format).
    :type timestamp: datetime
    :param value: Required. The measurement of that point, should be float.
    :type value: float
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'timestamp': {'key': 'timestamp', 'type': 'iso-8601'},
        'value': {'key': 'value', 'type': 'float'},
    }

    def __init__(self, **kwargs):
        super(TimeSeriesPoint, self).__init__(**kwargs)
        self.timestamp = kwargs.get('timestamp', None)
        self.value = kwargs.get('value', None)


class VariableState(Model):
    """VariableState.

    :param variable: Variable name.
    :type variable: str
    :param filled_na_ratio: Proportion of NaN values filled of the variable.
    :type filled_na_ratio: float
    :param effective_count: Number of effective points counted.
    :type effective_count: int
    :param start_time: Start time of the variable.
    :type start_time: datetime
    :param end_time: End time of the variable.
    :type end_time: datetime
    """

    _validation = {
        'filled_na_ratio': {'maximum': 1, 'minimum': 0},
    }

    _attribute_map = {
        'variable': {'key': 'variable', 'type': 'str'},
        'filled_na_ratio': {'key': 'filledNARatio', 'type': 'float'},
        'effective_count': {'key': 'effectiveCount', 'type': 'int'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
    }

    def __init__(self, **kwargs):
        super(VariableState, self).__init__(**kwargs)
        self.variable = kwargs.get('variable', None)
        self.filled_na_ratio = kwargs.get('filled_na_ratio', None)
        self.effective_count = kwargs.get('effective_count', None)
        self.start_time = kwargs.get('start_time', None)
        self.end_time = kwargs.get('end_time', None)


class VariableValues(Model):
    """VariableValues.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. variable name
    :type name: str
    :param timestamps: Required. timestamps
    :type timestamps: list[str]
    :param values: Required. values
    :type values: list[float]
    """

    _validation = {
        'name': {'required': True},
        'timestamps': {'required': True},
        'values': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'timestamps': {'key': 'timestamps', 'type': '[str]'},
        'values': {'key': 'values', 'type': '[float]'},
    }

    def __init__(self, **kwargs):
        super(VariableValues, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.timestamps = kwargs.get('timestamps', None)
        self.values = kwargs.get('values', None)
