# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.pipeline import ClientRawResponse
from .. import models


class AnomalyDetectorClientOperationsMixin(object):

    def detect_entire_series(
            self, body, custom_headers=None, raw=False, **operation_config):
        """Detect anomalies for the entire series in batch.

        This operation generates a model with an entire series, each point is
        detected with the same model. With this method, points before and after
        a certain point are used to determine whether it is an anomaly. The
        entire detection can give user an overall status of the time series.

        :param body: Time series points and period if needed. Advanced model
         parameters can also be set in the request.
        :type body: ~azure.ai.anomalydetector.models.DetectRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EntireDetectResponse or ClientRawResponse if raw=true
        :rtype: ~azure.ai.anomalydetector.models.EntireDetectResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`AnomalyDetectorErrorException<azure.ai.anomalydetector.models.AnomalyDetectorErrorException>`
        """
        # Construct URL
        url = self.detect_entire_series.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'ApiVersion': self._serialize.url("self.api_version", self.api_version, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(body, 'DetectRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.AnomalyDetectorErrorException(self._deserialize, response)

        header_dict = {}
        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('EntireDetectResponse', response)
            header_dict = {
                'x-ms-error-code': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    detect_entire_series.metadata = {'url': '/timeseries/entire/detect'}

    def detect_last_point(
            self, body, custom_headers=None, raw=False, **operation_config):
        """Detect anomaly status of the latest point in time series.

        This operation generates a model using points before the latest one.
        With this method, only historical points are used to determine whether
        the target point is an anomaly. The latest point detecting operation
        matches the scenario of real-time monitoring of business metrics.

        :param body: Time series points and period if needed. Advanced model
         parameters can also be set in the request.
        :type body: ~azure.ai.anomalydetector.models.DetectRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: LastDetectResponse or ClientRawResponse if raw=true
        :rtype: ~azure.ai.anomalydetector.models.LastDetectResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`AnomalyDetectorErrorException<azure.ai.anomalydetector.models.AnomalyDetectorErrorException>`
        """
        # Construct URL
        url = self.detect_last_point.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'ApiVersion': self._serialize.url("self.api_version", self.api_version, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(body, 'DetectRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.AnomalyDetectorErrorException(self._deserialize, response)

        header_dict = {}
        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('LastDetectResponse', response)
            header_dict = {
                'x-ms-error-code': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    detect_last_point.metadata = {'url': '/timeseries/last/detect'}

    def detect_change_point(
            self, body, custom_headers=None, raw=False, **operation_config):
        """Detect change point for the entire series.

        Evaluate change point score of every series point.

        :param body: Time series points and granularity is needed. Advanced
         model parameters can also be set in the request if needed.
        :type body: ~azure.ai.anomalydetector.models.ChangePointDetectRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ChangePointDetectResponse or ClientRawResponse if raw=true
        :rtype: ~azure.ai.anomalydetector.models.ChangePointDetectResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`AnomalyDetectorErrorException<azure.ai.anomalydetector.models.AnomalyDetectorErrorException>`
        """
        # Construct URL
        url = self.detect_change_point.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'ApiVersion': self._serialize.url("self.api_version", self.api_version, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(body, 'ChangePointDetectRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.AnomalyDetectorErrorException(self._deserialize, response)

        header_dict = {}
        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ChangePointDetectResponse', response)
            header_dict = {
                'x-ms-error-code': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    detect_change_point.metadata = {'url': '/timeseries/changepoint/detect'}

    def train_multivariate_model(
            self, body, custom_headers=None, raw=False, **operation_config):
        """Train a Multivariate Anomaly Detection Model.

        Create and train a multivariate anomaly detection model. The request
        must include a source parameter to indicate an externally accessible
        Azure storage Uri (preferably a Shared Access Signature Uri). All
        time-series used in generate the model must be zipped into one single
        file. Each time-series will be in a single CSV file in which the first
        column is timestamp and the second column is value.

        :param body: Training request
        :type body: ~azure.ai.anomalydetector.models.ModelInfo
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorResponseException<azure.ai.anomalydetector.models.ErrorResponseException>`
        """
        # Construct URL
        url = self.train_multivariate_model.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'ApiVersion': self._serialize.url("self.api_version", self.api_version, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(body, 'ModelInfo')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [201]:
            raise models.ErrorResponseException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            client_raw_response.add_headers({
                'Location': 'str',
                'x-ms-error-code': 'str',
            })
            return client_raw_response
    train_multivariate_model.metadata = {'url': '/multivariate/models'}

    def list_multivariate_model(
            self, skip=0, top=5, custom_headers=None, raw=False, **operation_config):
        """List Multivariate Models.

        List models of a subscription.

        :param skip: $skip indicates how many models will be skipped.
        :type skip: int
        :param top: $top indicates how many models will be fetched.
        :type top: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ModelList or ClientRawResponse if raw=true
        :rtype: ~azure.ai.anomalydetector.models.ModelList or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorResponseException<azure.ai.anomalydetector.models.ErrorResponseException>`
        """
        # Construct URL
        url = self.list_multivariate_model.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'ApiVersion': self._serialize.url("self.api_version", self.api_version, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if skip is not None:
            query_parameters['$skip'] = self._serialize.query("skip", skip, 'int')
        if top is not None:
            query_parameters['$top'] = self._serialize.query("top", top, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorResponseException(self._deserialize, response)

        header_dict = {}
        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ModelList', response)
            header_dict = {
                'x-ms-error-code': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    list_multivariate_model.metadata = {'url': '/multivariate/models'}

    def get_multivariate_model(
            self, model_id, custom_headers=None, raw=False, **operation_config):
        """Get Multivariate Model.

        Get detailed information of multivariate model, including the training
        status and variables used in the model.

        :param model_id: Model identifier.
        :type model_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Model or ClientRawResponse if raw=true
        :rtype: ~azure.ai.anomalydetector.models.Model or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorResponseException<azure.ai.anomalydetector.models.ErrorResponseException>`
        """
        # Construct URL
        url = self.get_multivariate_model.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'ApiVersion': self._serialize.url("self.api_version", self.api_version, 'str', skip_quote=True),
            'modelId': self._serialize.url("model_id", model_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorResponseException(self._deserialize, response)

        header_dict = {}
        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('Model', response)
            header_dict = {
                'x-ms-error-code': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_multivariate_model.metadata = {'url': '/multivariate/models/{modelId}'}

    def delete_multivariate_model(
            self, model_id, custom_headers=None, raw=False, **operation_config):
        """Delete Multivariate Model.

        Delete an existing multivariate model according to the modelId.

        :param model_id: Model identifier.
        :type model_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorResponseException<azure.ai.anomalydetector.models.ErrorResponseException>`
        """
        # Construct URL
        url = self.delete_multivariate_model.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'ApiVersion': self._serialize.url("self.api_version", self.api_version, 'str', skip_quote=True),
            'modelId': self._serialize.url("model_id", model_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise models.ErrorResponseException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            client_raw_response.add_headers({
                'x-ms-error-code': 'str',
            })
            return client_raw_response
    delete_multivariate_model.metadata = {'url': '/multivariate/models/{modelId}'}

    def detect_anomaly(
            self, model_id, body, custom_headers=None, raw=False, **operation_config):
        """Detect Multivariate Anomaly.

        Submit detection multivariate anomaly task with the trained model of
        modelId, the input schema should be the same with the training request.
        Thus request will be complete asynchronously and will return a resultId
        for querying the detection result.The request should be a source link
        to indicate an externally accessible Azure storage Uri (preferably a
        Shared Access Signature Uri). All time-series used in generate the
        model must be zipped into one single file. Each time-series will be as
        follows: the first column is timestamp and the second column is value.

        :param model_id: Model identifier.
        :type model_id: str
        :param body: Detect anomaly request
        :type body: ~azure.ai.anomalydetector.models.DetectionRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorResponseException<azure.ai.anomalydetector.models.ErrorResponseException>`
        """
        # Construct URL
        url = self.detect_anomaly.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'ApiVersion': self._serialize.url("self.api_version", self.api_version, 'str', skip_quote=True),
            'modelId': self._serialize.url("model_id", model_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(body, 'DetectionRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [201]:
            raise models.ErrorResponseException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            client_raw_response.add_headers({
                'Location': 'str',
                'x-ms-error-code': 'str',
            })
            return client_raw_response
    detect_anomaly.metadata = {'url': '/multivariate/models/{modelId}/detect'}

    def get_detection_result(
            self, result_id, custom_headers=None, raw=False, **operation_config):
        """Get Multivariate Anomaly Detection Result.

        Get multivariate anomaly detection result based on resultId returned by
        the DetectAnomalyAsync api.

        :param result_id: Result identifier.
        :type result_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DetectionResult or ClientRawResponse if raw=true
        :rtype: ~azure.ai.anomalydetector.models.DetectionResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorResponseException<azure.ai.anomalydetector.models.ErrorResponseException>`
        """
        # Construct URL
        url = self.get_detection_result.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'ApiVersion': self._serialize.url("self.api_version", self.api_version, 'str', skip_quote=True),
            'resultId': self._serialize.url("result_id", result_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorResponseException(self._deserialize, response)

        header_dict = {}
        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DetectionResult', response)
            header_dict = {
                'x-ms-error-code': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_detection_result.metadata = {'url': '/multivariate/results/{resultId}'}

    def export_model(
            self, model_id, custom_headers=None, raw=False, **operation_config):
        """Export Multivariate Anomaly Detection Model as Zip file.

        Export multivariate anomaly detection model based on modelId.

        :param model_id: Model identifier.
        :type model_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or ClientRawResponse if raw=true
        :rtype: str or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorResponseException<azure.ai.anomalydetector.models.ErrorResponseException>`
        """
        # Construct URL
        url = self.export_model.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'ApiVersion': self._serialize.url("self.api_version", self.api_version, 'str', skip_quote=True),
            'modelId': self._serialize.url("model_id", model_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorResponseException(self._deserialize, response)

        header_dict = {}
        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('str', response)
            header_dict = {
                'x-ms-error-code': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    export_model.metadata = {'url': '/multivariate/models/{modelId}/export'}

    def last_detect_anomaly(
            self, model_id, body, custom_headers=None, raw=False, **operation_config):
        """Detect anomalies in the last a few points of the request body.

        Synchronized API for anomaly detection.

        :param model_id: Model identifier.
        :type model_id: str
        :param body: Request for last detection.
        :type body: ~azure.ai.anomalydetector.models.LastDetectionRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: LastDetectionResult or ClientRawResponse if raw=true
        :rtype: ~azure.ai.anomalydetector.models.LastDetectionResult or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorResponseException<azure.ai.anomalydetector.models.ErrorResponseException>`
        """
        # Construct URL
        url = self.last_detect_anomaly.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'ApiVersion': self._serialize.url("self.api_version", self.api_version, 'str', skip_quote=True),
            'modelId': self._serialize.url("model_id", model_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(body, 'LastDetectionRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorResponseException(self._deserialize, response)

        header_dict = {}
        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('LastDetectionResult', response)
            header_dict = {
                'x-ms-error-code': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    last_detect_anomaly.metadata = {'url': '/multivariate/models/{modelId}/last/detect'}
