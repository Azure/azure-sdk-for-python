# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import Any, AsyncIterable, Callable, Dict, Generic, IO, Optional, TypeVar
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async

from ... import models as _models
from ..._vendor import _convert_request
from ...operations._anomaly_detector_client_operations import build_delete_multivariate_model_request, build_detect_anomaly_request, build_detect_change_point_request, build_detect_entire_series_request, build_detect_last_point_request, build_export_model_request, build_get_detection_result_request, build_get_multivariate_model_request, build_last_detect_anomaly_request, build_list_multivariate_model_request, build_train_multivariate_model_request
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class AnomalyDetectorClientOperationsMixin:

    @distributed_trace_async
    async def detect_entire_series(
        self,
        body: "_models.DetectRequest",
        **kwargs: Any
    ) -> "_models.EntireDetectResponse":
        """Detect anomalies for the entire series in batch.

        This operation generates a model with an entire series, each point is detected with the same
        model. With this method, points before and after a certain point are used to determine whether
        it is an anomaly. The entire detection can give user an overall status of the time series.

        :param body: Time series points and period if needed. Advanced model parameters can also be set
         in the request.
        :type body: ~azure.ai.anomalydetector.models.DetectRequest
        :keyword api_version: Anomaly Detector API version (for example, v1.0). The default value is
         "v1.1-preview.1". Note that overriding this default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: EntireDetectResponse, or the result of cls(response)
        :rtype: ~azure.ai.anomalydetector.models.EntireDetectResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.EntireDetectResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "v1.1-preview.1")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'DetectRequest')

        request = build_detect_entire_series_request(
            content_type=content_type,
            json=_json,
            template_url=self.detect_entire_series.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.AnomalyDetectorError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('EntireDetectResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    detect_entire_series.metadata = {'url': '/timeseries/entire/detect'}  # type: ignore


    @distributed_trace_async
    async def detect_last_point(
        self,
        body: "_models.DetectRequest",
        **kwargs: Any
    ) -> "_models.LastDetectResponse":
        """Detect anomaly status of the latest point in time series.

        This operation generates a model using points before the latest one. With this method, only
        historical points are used to determine whether the target point is an anomaly. The latest
        point detecting operation matches the scenario of real-time monitoring of business metrics.

        :param body: Time series points and period if needed. Advanced model parameters can also be set
         in the request.
        :type body: ~azure.ai.anomalydetector.models.DetectRequest
        :keyword api_version: Anomaly Detector API version (for example, v1.0). The default value is
         "v1.1-preview.1". Note that overriding this default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LastDetectResponse, or the result of cls(response)
        :rtype: ~azure.ai.anomalydetector.models.LastDetectResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.LastDetectResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "v1.1-preview.1")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'DetectRequest')

        request = build_detect_last_point_request(
            content_type=content_type,
            json=_json,
            template_url=self.detect_last_point.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.AnomalyDetectorError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('LastDetectResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    detect_last_point.metadata = {'url': '/timeseries/last/detect'}  # type: ignore


    @distributed_trace_async
    async def detect_change_point(
        self,
        body: "_models.ChangePointDetectRequest",
        **kwargs: Any
    ) -> "_models.ChangePointDetectResponse":
        """Detect change point for the entire series.

        Evaluate change point score of every series point.

        :param body: Time series points and granularity is needed. Advanced model parameters can also
         be set in the request if needed.
        :type body: ~azure.ai.anomalydetector.models.ChangePointDetectRequest
        :keyword api_version: Anomaly Detector API version (for example, v1.0). The default value is
         "v1.1-preview.1". Note that overriding this default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ChangePointDetectResponse, or the result of cls(response)
        :rtype: ~azure.ai.anomalydetector.models.ChangePointDetectResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ChangePointDetectResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "v1.1-preview.1")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'ChangePointDetectRequest')

        request = build_detect_change_point_request(
            content_type=content_type,
            json=_json,
            template_url=self.detect_change_point.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.AnomalyDetectorError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('ChangePointDetectResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    detect_change_point.metadata = {'url': '/timeseries/changepoint/detect'}  # type: ignore


    @distributed_trace_async
    async def train_multivariate_model(
        self,
        body: "_models.ModelInfo",
        **kwargs: Any
    ) -> None:
        """Train a Multivariate Anomaly Detection Model.

        Create and train a multivariate anomaly detection model. The request must include a source
        parameter to indicate an externally accessible Azure storage Uri (preferably a Shared Access
        Signature Uri). All time-series used in generate the model must be zipped into one single file.
        Each time-series will be in a single CSV file in which the first column is timestamp and the
        second column is value.

        :param body: Training request.
        :type body: ~azure.ai.anomalydetector.models.ModelInfo
        :keyword api_version: Anomaly Detector API version (for example, v1.0). The default value is
         "v1.1-preview.1". Note that overriding this default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "v1.1-preview.1")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'ModelInfo')

        request = build_train_multivariate_model_request(
            content_type=content_type,
            json=_json,
            template_url=self.train_multivariate_model.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    train_multivariate_model.metadata = {'url': '/multivariate/models'}  # type: ignore


    @distributed_trace
    def list_multivariate_model(
        self,
        skip: Optional[int] = 0,
        top: Optional[int] = 5,
        **kwargs: Any
    ) -> AsyncIterable["_models.ModelList"]:
        """List Multivariate Models.

        List models of a subscription.

        :param skip: $skip indicates how many models will be skipped.
        :type skip: int
        :param top: $top indicates how many models will be fetched.
        :type top: int
        :keyword api_version: Anomaly Detector API version (for example, v1.0). The default value is
         "v1.1-preview.1". Note that overriding this default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either ModelList or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.ai.anomalydetector.models.ModelList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "v1.1-preview.1")  # type: str

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ModelList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_multivariate_model_request(
                    skip=skip,
                    top=top,
                    template_url=self.list_multivariate_model.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                    "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_list_multivariate_model_request(
                    skip=skip,
                    top=top,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                    "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                    "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("ModelList", pipeline_response)
            list_of_elem = deserialized.models
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_multivariate_model.metadata = {'url': '/multivariate/models'}  # type: ignore

    @distributed_trace_async
    async def get_multivariate_model(
        self,
        model_id: str,
        **kwargs: Any
    ) -> "_models.Model":
        """Get Multivariate Model.

        Get detailed information of multivariate model, including the training status and variables
        used in the model.

        :param model_id: Model identifier.
        :type model_id: str
        :keyword api_version: Anomaly Detector API version (for example, v1.0). The default value is
         "v1.1-preview.1". Note that overriding this default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Model, or the result of cls(response)
        :rtype: ~azure.ai.anomalydetector.models.Model
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Model"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "v1.1-preview.1")  # type: str

        
        request = build_get_multivariate_model_request(
            model_id=model_id,
            template_url=self.get_multivariate_model.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('Model', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_multivariate_model.metadata = {'url': '/multivariate/models/{modelId}'}  # type: ignore


    @distributed_trace_async
    async def delete_multivariate_model(
        self,
        model_id: str,
        **kwargs: Any
    ) -> None:
        """Delete Multivariate Model.

        Delete an existing multivariate model according to the modelId.

        :param model_id: Model identifier.
        :type model_id: str
        :keyword api_version: Anomaly Detector API version (for example, v1.0). The default value is
         "v1.1-preview.1". Note that overriding this default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "v1.1-preview.1")  # type: str

        
        request = build_delete_multivariate_model_request(
            model_id=model_id,
            template_url=self.delete_multivariate_model.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_multivariate_model.metadata = {'url': '/multivariate/models/{modelId}'}  # type: ignore


    @distributed_trace_async
    async def detect_anomaly(
        self,
        model_id: str,
        body: "_models.DetectionRequest",
        **kwargs: Any
    ) -> None:
        """Detect Multivariate Anomaly.

        Submit detection multivariate anomaly task with the trained model of modelId, the input schema
        should be the same with the training request. Thus request will be complete asynchronously and
        will return a resultId for querying the detection result.The request should be a source link to
        indicate an externally accessible Azure storage Uri (preferably a Shared Access Signature Uri).
        All time-series used in generate the model must be zipped into one single file. Each
        time-series will be as follows: the first column is timestamp and the second column is value.

        :param model_id: Model identifier.
        :type model_id: str
        :param body: Detect anomaly request.
        :type body: ~azure.ai.anomalydetector.models.DetectionRequest
        :keyword api_version: Anomaly Detector API version (for example, v1.0). The default value is
         "v1.1-preview.1". Note that overriding this default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "v1.1-preview.1")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'DetectionRequest')

        request = build_detect_anomaly_request(
            model_id=model_id,
            content_type=content_type,
            json=_json,
            template_url=self.detect_anomaly.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    detect_anomaly.metadata = {'url': '/multivariate/models/{modelId}/detect'}  # type: ignore


    @distributed_trace_async
    async def get_detection_result(
        self,
        result_id: str,
        **kwargs: Any
    ) -> "_models.DetectionResult":
        """Get Multivariate Anomaly Detection Result.

        Get multivariate anomaly detection result based on resultId returned by the DetectAnomalyAsync
        api.

        :param result_id: Result identifier.
        :type result_id: str
        :keyword api_version: Anomaly Detector API version (for example, v1.0). The default value is
         "v1.1-preview.1". Note that overriding this default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DetectionResult, or the result of cls(response)
        :rtype: ~azure.ai.anomalydetector.models.DetectionResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DetectionResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "v1.1-preview.1")  # type: str

        
        request = build_get_detection_result_request(
            result_id=result_id,
            template_url=self.get_detection_result.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DetectionResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_detection_result.metadata = {'url': '/multivariate/results/{resultId}'}  # type: ignore


    @distributed_trace_async
    async def export_model(
        self,
        model_id: str,
        **kwargs: Any
    ) -> IO:
        """Export Multivariate Anomaly Detection Model as Zip file.

        Export multivariate anomaly detection model based on modelId.

        :param model_id: Model identifier.
        :type model_id: str
        :keyword api_version: Anomaly Detector API version (for example, v1.0). The default value is
         "v1.1-preview.1". Note that overriding this default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "v1.1-preview.1")  # type: str

        
        request = build_export_model_request(
            model_id=model_id,
            template_url=self.export_model.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    export_model.metadata = {'url': '/multivariate/models/{modelId}/export'}  # type: ignore


    @distributed_trace_async
    async def last_detect_anomaly(
        self,
        model_id: str,
        body: "_models.LastDetectionRequest",
        **kwargs: Any
    ) -> "_models.LastDetectionResult":
        """Detect anomalies in the last a few points of the request body.

        Synchronized API for anomaly detection.

        :param model_id: Model identifier.
        :type model_id: str
        :param body: Request for last detection.
        :type body: ~azure.ai.anomalydetector.models.LastDetectionRequest
        :keyword api_version: Anomaly Detector API version (for example, v1.0). The default value is
         "v1.1-preview.1". Note that overriding this default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LastDetectionResult, or the result of cls(response)
        :rtype: ~azure.ai.anomalydetector.models.LastDetectionResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.LastDetectionResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "v1.1-preview.1")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'LastDetectionRequest')

        request = build_last_detect_anomaly_request(
            model_id=model_id,
            content_type=content_type,
            json=_json,
            template_url=self.last_detect_anomaly.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            "ApiVersion": self._serialize.url("api_version", api_version, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('LastDetectionResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    last_detect_anomaly.metadata = {'url': '/multivariate/models/{modelId}/last/detect'}  # type: ignore

