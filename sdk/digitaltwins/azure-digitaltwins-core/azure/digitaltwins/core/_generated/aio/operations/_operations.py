# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
from io import IOBase
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core import AsyncPipelineClient, MatchConditions
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceModifiedError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ..._utils.serialization import Deserializer, Serializer
from ...operations._operations import (
    build_digital_twin_models_add_request,
    build_digital_twin_models_delete_request,
    build_digital_twin_models_get_by_id_request,
    build_digital_twin_models_list_request,
    build_digital_twin_models_update_request,
    build_digital_twins_add_relationship_request,
    build_digital_twins_add_request,
    build_digital_twins_delete_relationship_request,
    build_digital_twins_delete_request,
    build_digital_twins_get_by_id_request,
    build_digital_twins_get_component_request,
    build_digital_twins_get_relationship_by_id_request,
    build_digital_twins_list_incoming_relationships_request,
    build_digital_twins_list_relationships_request,
    build_digital_twins_send_component_telemetry_request,
    build_digital_twins_send_telemetry_request,
    build_digital_twins_update_component_request,
    build_digital_twins_update_relationship_request,
    build_digital_twins_update_request,
    build_event_routes_add_request,
    build_event_routes_delete_request,
    build_event_routes_get_by_id_request,
    build_event_routes_list_request,
    build_query_query_twins_request,
)
from .._configuration import AzureDigitalTwinsAPIConfiguration

JSON = MutableMapping[str, Any]
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class DigitalTwinModelsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.digitaltwins.core.aio.AzureDigitalTwinsAPI`'s
        :attr:`digital_twin_models` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AzureDigitalTwinsAPIConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def add(
        self,
        models: List[JSON],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[JSON]:
        """Uploads one or more models. When any error occurs, no models are uploaded.
        Status codes:


        * 201 Created
        * 400 Bad Request

          * DTDLParserError - The models provided are not valid DTDL.
          * InvalidArgument - The model id is invalid.
          * LimitExceeded - The maximum number of model ids allowed in 'dependenciesFor' has been
        reached.
          * ModelVersionNotSupported - The version of DTDL used is not supported.

        * 409 Conflict

          * ModelAlreadyExists - The model provided already exists.

        :param models: An array of models to add. Required.
        :type models: list[JSON]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                models = [
                    {}
                ]

                # response body for status code(s): 201
                response == [
                    {
                        "id": "str",
                        "decommissioned": False,
                        "description": {
                            "str": "str"
                        },
                        "displayName": {
                            "str": "str"
                        },
                        "model": {},
                        "uploadTime": "2020-02-20 00:00:00"
                    }
                ]
        """

    @overload
    async def add(
        self,
        models: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[JSON]:
        """Uploads one or more models. When any error occurs, no models are uploaded.
        Status codes:


        * 201 Created
        * 400 Bad Request

          * DTDLParserError - The models provided are not valid DTDL.
          * InvalidArgument - The model id is invalid.
          * LimitExceeded - The maximum number of model ids allowed in 'dependenciesFor' has been
        reached.
          * ModelVersionNotSupported - The version of DTDL used is not supported.

        * 409 Conflict

          * ModelAlreadyExists - The model provided already exists.

        :param models: An array of models to add. Required.
        :type models: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == [
                    {
                        "id": "str",
                        "decommissioned": False,
                        "description": {
                            "str": "str"
                        },
                        "displayName": {
                            "str": "str"
                        },
                        "model": {},
                        "uploadTime": "2020-02-20 00:00:00"
                    }
                ]
        """

    @distributed_trace_async
    async def add(
        self,
        models: Union[List[JSON], IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Uploads one or more models. When any error occurs, no models are uploaded.
        Status codes:


        * 201 Created
        * 400 Bad Request

          * DTDLParserError - The models provided are not valid DTDL.
          * InvalidArgument - The model id is invalid.
          * LimitExceeded - The maximum number of model ids allowed in 'dependenciesFor' has been
        reached.
          * ModelVersionNotSupported - The version of DTDL used is not supported.

        * 409 Conflict

          * ModelAlreadyExists - The model provided already exists.

        :param models: An array of models to add. Is either a [JSON] type or a IO[bytes] type.
         Required.
        :type models: list[JSON] or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == [
                    {
                        "id": "str",
                        "decommissioned": False,
                        "description": {
                            "str": "str"
                        },
                        "displayName": {
                            "str": "str"
                        },
                        "model": {},
                        "uploadTime": "2020-02-20 00:00:00"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(models, (IOBase, bytes)):
            _content = models
        else:
            _json = models

        _request = build_digital_twin_models_add_request(
            traceparent=traceparent,
            tracestate=tracestate,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace
    def list(
        self,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        dependencies_for: Optional[List[str]] = None,
        include_model_definition: bool = False,
        max_items_per_page: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncItemPaged[JSON]:
        """Retrieves model metadata and, optionally, model definitions.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * LimitExceeded - The maximum number of model ids allowed in 'dependenciesFor' has been
        reached.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword dependencies_for: The set of the models which will have their dependencies retrieved.
         If omitted, all models are retrieved. Default value is None.
        :paramtype dependencies_for: list[str]
        :keyword include_model_definition: When true the model definition will be returned as part of
         the result. Default value is False.
        :paramtype include_model_definition: bool
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "decommissioned": False,
                    "description": {
                        "str": "str"
                    },
                    "displayName": {
                        "str": "str"
                    },
                    "model": {},
                    "uploadTime": "2020-02-20 00:00:00"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_digital_twin_models_list_request(
                    traceparent=traceparent,
                    tracestate=tracestate,
                    dependencies_for=dependencies_for,
                    include_model_definition=include_model_definition,
                    max_items_per_page=max_items_per_page,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized.get("value", [])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_by_id(
        self,
        id: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        include_model_definition: bool = False,
        **kwargs: Any
    ) -> JSON:
        """Retrieves model metadata and optionally the model definition.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * MissingArgument - The model id was not provided.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        :param id: The id for the model. The id is globally unique and case sensitive. Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword include_model_definition: When true the model definition will be returned as part of
         the result. Default value is False.
        :paramtype include_model_definition: bool
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "decommissioned": False,
                    "description": {
                        "str": "str"
                    },
                    "displayName": {
                        "str": "str"
                    },
                    "model": {},
                    "uploadTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_digital_twin_models_get_by_id_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            include_model_definition=include_model_definition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update(
        self,
        id: str,
        update_model: List[JSON],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        **kwargs: Any
    ) -> None:
        """Updates the metadata for a model.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * MissingArgument - The model id was not provided.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        * 409 Conflict

          * ModelReferencesNotDecommissioned - The model refers to models that are not decommissioned.

        :param id: The id for the model. The id is globally unique and case sensitive. Required.
        :type id: str
        :param update_model: An update specification described by JSON Patch. Only the decommissioned
         property can be replaced. Required.
        :type update_model: list[JSON]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_model = [
                    {}
                ]
        """

    @overload
    async def update(
        self,
        id: str,
        update_model: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        **kwargs: Any
    ) -> None:
        """Updates the metadata for a model.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * MissingArgument - The model id was not provided.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        * 409 Conflict

          * ModelReferencesNotDecommissioned - The model refers to models that are not decommissioned.

        :param id: The id for the model. The id is globally unique and case sensitive. Required.
        :type id: str
        :param update_model: An update specification described by JSON Patch. Only the decommissioned
         property can be replaced. Required.
        :type update_model: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        id: str,
        update_model: Union[List[JSON], IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Updates the metadata for a model.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * MissingArgument - The model id was not provided.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        * 409 Conflict

          * ModelReferencesNotDecommissioned - The model refers to models that are not decommissioned.

        :param id: The id for the model. The id is globally unique and case sensitive. Required.
        :type id: str
        :param update_model: An update specification described by JSON Patch. Only the decommissioned
         property can be replaced. Is either a [JSON] type or a IO[bytes] type. Required.
        :type update_model: list[JSON] or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json-patch+json"
        _json = None
        _content = None
        if isinstance(update_model, (IOBase, bytes)):
            _content = update_model
        else:
            _json = update_model

        _request = build_digital_twin_models_update_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete(
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Deletes a model. A model can only be deleted if no other models reference it.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * MissingArgument - The model id was not provided.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        * 409 Conflict

          * ModelReferencesNotDeleted - The model refers to models that are not deleted.

        :param id: The id for the model. The id is globally unique and case sensitive. Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_digital_twin_models_delete_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class QueryOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.digitaltwins.core.aio.AzureDigitalTwinsAPI`'s
        :attr:`query` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AzureDigitalTwinsAPIConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def query_twins(
        self,
        query_specification: JSON,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        max_items_per_page: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Executes a query that allows traversing relationships and filtering by property values.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * BadRequest - The continuation token is invalid.
          * SqlQueryError - The query contains some errors.
          * TimeoutError - The query execution timed out after 60 seconds. Try simplifying the query or
        adding conditions to reduce the result size.
          * 429 Too Many Requests
          * QuotaReachedError - The maximum query rate limit has been reached.

        :param query_specification: The query specification to execute. Required.
        :type query_specification: JSON
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                query_specification = {
                    "continuationToken": "str",
                    "query": "str"
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {}
                    ],
                    "continuationToken": "str"
                }
        """

    @overload
    async def query_twins(
        self,
        query_specification: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        max_items_per_page: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Executes a query that allows traversing relationships and filtering by property values.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * BadRequest - The continuation token is invalid.
          * SqlQueryError - The query contains some errors.
          * TimeoutError - The query execution timed out after 60 seconds. Try simplifying the query or
        adding conditions to reduce the result size.
          * 429 Too Many Requests
          * QuotaReachedError - The maximum query rate limit has been reached.

        :param query_specification: The query specification to execute. Required.
        :type query_specification: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {}
                    ],
                    "continuationToken": "str"
                }
        """

    @distributed_trace_async
    async def query_twins(
        self,
        query_specification: Union[JSON, IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        max_items_per_page: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Executes a query that allows traversing relationships and filtering by property values.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * BadRequest - The continuation token is invalid.
          * SqlQueryError - The query contains some errors.
          * TimeoutError - The query execution timed out after 60 seconds. Try simplifying the query or
        adding conditions to reduce the result size.
          * 429 Too Many Requests
          * QuotaReachedError - The maximum query rate limit has been reached.

        :param query_specification: The query specification to execute. Is either a JSON type or a
         IO[bytes] type. Required.
        :type query_specification: JSON or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                query_specification = {
                    "continuationToken": "str",
                    "query": "str"
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {}
                    ],
                    "continuationToken": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(query_specification, (IOBase, bytes)):
            _content = query_specification
        else:
            _json = query_specification

        _request = build_query_query_twins_request(
            traceparent=traceparent,
            tracestate=tracestate,
            max_items_per_page=max_items_per_page,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["query-charge"] = self._deserialize("float", response.headers.get("query-charge"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class DigitalTwinsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.digitaltwins.core.aio.AzureDigitalTwinsAPI`'s
        :attr:`digital_twins` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AzureDigitalTwinsAPIConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_by_id(
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Retrieves a digital twin.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_digital_twins_get_by_id_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def add(
        self,
        id: str,
        twin: JSON,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> JSON:
        """Adds or replaces a digital twin.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id or payload is invalid.
          * ModelDecommissioned - The model for the digital twin is decommissioned.
          * TwinLimitReached - The maximum number of digital twins allowed has been reached.
          * ValidationFailed - The digital twin payload is not valid.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param twin: The digital twin instance being added. If provided, the $dtId property is ignored.
         Required.
        :type twin: JSON
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _json = twin

        _request = build_digital_twins_add_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete(
        self,
        id: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a digital twin. All relationships referencing the digital twin must already be deleted.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id is invalid.
          * RelationshipsNotDeleted - The digital twin contains relationships.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_digital_twins_delete_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update(
        self,
        id: str,
        patch_document: List[JSON],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Required.
        :type patch_document: list[JSON]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                patch_document = [
                    {}
                ]
        """

    @overload
    async def update(
        self,
        id: str,
        patch_document: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Required.
        :type patch_document: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        id: str,
        patch_document: Union[List[JSON], IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Is either a [JSON] type or a IO[bytes] type. Required.
        :type patch_document: list[JSON] or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json-patch+json"
        _json = None
        _content = None
        if isinstance(patch_document, (IOBase, bytes)):
            _content = patch_document
        else:
            _json = patch_document

        _request = build_digital_twins_update_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def get_relationship_by_id(
        self,
        id: str,
        relationship_id: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieves a relationship between two digital twins.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id or relationship id is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * RelationshipNotFound - The relationship was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_digital_twins_get_relationship_by_id_request(
            id=id,
            relationship_id=relationship_id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def add_relationship(
        self,
        id: str,
        relationship_id: str,
        relationship: JSON,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> JSON:
        """Adds a relationship between two digital twins.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id, relationship id, or payload is invalid.
          * InvalidRelationship - The relationship is invalid.
          * OperationNotAllowed - The relationship cannot connect to the same digital twin.
          * ValidationFailed - The relationship content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * TargetTwinNotFound - The digital twin target of the relationship was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :param relationship: The data for the relationship. Required.
        :type relationship: JSON
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _json = relationship

        _request = build_digital_twins_add_relationship_request(
            id=id,
            relationship_id=relationship_id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_relationship(
        self,
        id: str,
        relationship_id: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a relationship between two digital twins.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or relationship id is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * RelationshipNotFound - The relationship was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_digital_twins_delete_relationship_request(
            id=id,
            relationship_id=relationship_id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_relationship(
        self,
        id: str,
        relationship_id: str,
        patch_document: List[JSON],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates the properties on a relationship between two digital twins.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or relationship id is invalid.
          * InvalidRelationship - The relationship is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - The relationship content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * RelationshipNotFound - The relationship was not found.

        * 409 Conflict

          * RelationshipAlreadyExists - The relationship already exists.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :param patch_document: JSON Patch description of the update to the relationship properties.
         Required.
        :type patch_document: list[JSON]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                patch_document = [
                    {}
                ]
        """

    @overload
    async def update_relationship(
        self,
        id: str,
        relationship_id: str,
        patch_document: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates the properties on a relationship between two digital twins.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or relationship id is invalid.
          * InvalidRelationship - The relationship is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - The relationship content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * RelationshipNotFound - The relationship was not found.

        * 409 Conflict

          * RelationshipAlreadyExists - The relationship already exists.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :param patch_document: JSON Patch description of the update to the relationship properties.
         Required.
        :type patch_document: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_relationship(
        self,
        id: str,
        relationship_id: str,
        patch_document: Union[List[JSON], IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates the properties on a relationship between two digital twins.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or relationship id is invalid.
          * InvalidRelationship - The relationship is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - The relationship content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * RelationshipNotFound - The relationship was not found.

        * 409 Conflict

          * RelationshipAlreadyExists - The relationship already exists.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :param patch_document: JSON Patch description of the update to the relationship properties. Is
         either a [JSON] type or a IO[bytes] type. Required.
        :type patch_document: list[JSON] or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json-patch+json"
        _json = None
        _content = None
        if isinstance(patch_document, (IOBase, bytes)):
            _content = patch_document
        else:
            _json = patch_document

        _request = build_digital_twins_update_relationship_request(
            id=id,
            relationship_id=relationship_id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list_relationships(
        self,
        id: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        relationship_name: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncItemPaged[JSON]:
        """Retrieves the relationships from a digital twin.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword relationship_name: The name of the relationship. Default value is None.
        :paramtype relationship_name: str
        :return: An iterator like instance of JSON
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {}
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_digital_twins_list_relationships_request(
                    id=id,
                    traceparent=traceparent,
                    tracestate=tracestate,
                    relationship_name=relationship_name,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized.get("value", [])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_incoming_relationships(
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> AsyncItemPaged[JSON]:
        """Retrieves all incoming relationship for a digital twin.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "$relationshipId": "str",
                    "$relationshipLink": "str",
                    "$relationshipName": "str",
                    "$sourceId": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_digital_twins_list_incoming_relationships_request(
                    id=id,
                    traceparent=traceparent,
                    tracestate=tracestate,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized.get("value", [])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def send_telemetry(
        self,
        id: str,
        telemetry: JSON,
        *,
        message_id: str,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        telemetry_source_time: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Sends telemetry on behalf of a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or message id is invalid.
          * ValidationFailed - The telemetry content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param telemetry: The telemetry measurements to send from the digital twin. Required.
        :type telemetry: JSON
        :keyword message_id: A unique message identifier (in the scope of the digital twin id) that is
         commonly used for de-duplicating messages. Required.
        :paramtype message_id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword telemetry_source_time: An RFC 3339 timestamp that identifies the time the telemetry
         was measured. Default value is None.
        :paramtype telemetry_source_time: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _json = telemetry

        _request = build_digital_twins_send_telemetry_request(
            id=id,
            message_id=message_id,
            traceparent=traceparent,
            tracestate=tracestate,
            telemetry_source_time=telemetry_source_time,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def send_component_telemetry(
        self,
        id: str,
        component_path: str,
        telemetry: JSON,
        *,
        message_id: str,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        telemetry_source_time: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Sends telemetry on behalf of a component in a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id, message id, or component path is invalid.
          * ValidationFailed - The telemetry content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * ComponentNotFound - The component path was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param component_path: The name of the DTDL component. Required.
        :type component_path: str
        :param telemetry: The telemetry measurements to send from the digital twin's component.
         Required.
        :type telemetry: JSON
        :keyword message_id: A unique message identifier (in the scope of the digital twin id) that is
         commonly used for de-duplicating messages. Required.
        :paramtype message_id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword telemetry_source_time: An RFC 3339 timestamp that identifies the time the telemetry
         was measured. Default value is None.
        :paramtype telemetry_source_time: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _json = telemetry

        _request = build_digital_twins_send_component_telemetry_request(
            id=id,
            component_path=component_path,
            message_id=message_id,
            traceparent=traceparent,
            tracestate=tracestate,
            telemetry_source_time=telemetry_source_time,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_component(
        self,
        id: str,
        component_path: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieves a component from a digital twin.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id or component path is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * ComponentNotFound - The component path was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param component_path: The name of the DTDL component. Required.
        :type component_path: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_digital_twins_get_component_request(
            id=id,
            component_path=component_path,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_component(
        self,
        id: str,
        component_path: str,
        patch_document: List[JSON],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a component on a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id, component path, or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param component_path: The name of the DTDL component. Required.
        :type component_path: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Required.
        :type patch_document: list[JSON]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                patch_document = [
                    {}
                ]
        """

    @overload
    async def update_component(
        self,
        id: str,
        component_path: str,
        patch_document: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a component on a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id, component path, or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param component_path: The name of the DTDL component. Required.
        :type component_path: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Required.
        :type patch_document: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_component(
        self,
        id: str,
        component_path: str,
        patch_document: Union[List[JSON], IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a component on a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id, component path, or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param component_path: The name of the DTDL component. Required.
        :type component_path: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Is either a [JSON] type or a IO[bytes] type. Required.
        :type patch_document: list[JSON] or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json-patch+json"
        _json = None
        _content = None
        if isinstance(patch_document, (IOBase, bytes)):
            _content = patch_document
        else:
            _json = patch_document

        _request = build_digital_twins_update_component_request(
            id=id,
            component_path=component_path,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class EventRoutesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.digitaltwins.core.aio.AzureDigitalTwinsAPI`'s
        :attr:`event_routes` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AzureDigitalTwinsAPIConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        max_items_per_page: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncItemPaged[JSON]:
        """Retrieves all event routes.
        Status codes:


        * 200 OK.

        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endpointName": "str",
                    "filter": "str",
                    "id": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_event_routes_list_request(
                    traceparent=traceparent,
                    tracestate=tracestate,
                    max_items_per_page=max_items_per_page,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized.get("value", [])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_by_id(
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Retrieves an event route.
        Status codes:


        * 200 OK
        * 404 Not Found

          * EventRouteNotFound - The event route was not found.

        :param id: The id for an event route. The id is unique within event routes and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endpointName": "str",
                    "filter": "str",
                    "id": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_event_routes_get_by_id_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def add(
        self,
        id: str,
        event_route: JSON,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Adds or replaces an event route.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * EventRouteEndpointInvalid - The endpoint provided does not exist or is not active.
          * EventRouteFilterInvalid - The event route filter is invalid.
          * EventRouteIdInvalid - The event route id is invalid.
          * LimitExceeded - The maximum number of event routes allowed has been reached.

        :param id: The id for an event route. The id is unique within event routes and case sensitive.
         Required.
        :type id: str
        :param event_route: The event route data. Required.
        :type event_route: JSON
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                event_route = {
                    "endpointName": "str",
                    "filter": "str",
                    "id": "str"
                }
        """

    @overload
    async def add(
        self,
        id: str,
        event_route: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Adds or replaces an event route.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * EventRouteEndpointInvalid - The endpoint provided does not exist or is not active.
          * EventRouteFilterInvalid - The event route filter is invalid.
          * EventRouteIdInvalid - The event route id is invalid.
          * LimitExceeded - The maximum number of event routes allowed has been reached.

        :param id: The id for an event route. The id is unique within event routes and case sensitive.
         Required.
        :type id: str
        :param event_route: The event route data. Required.
        :type event_route: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add(
        self,
        id: str,
        event_route: Union[JSON, IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Adds or replaces an event route.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * EventRouteEndpointInvalid - The endpoint provided does not exist or is not active.
          * EventRouteFilterInvalid - The event route filter is invalid.
          * EventRouteIdInvalid - The event route id is invalid.
          * LimitExceeded - The maximum number of event routes allowed has been reached.

        :param id: The id for an event route. The id is unique within event routes and case sensitive.
         Required.
        :type id: str
        :param event_route: The event route data. Is either a JSON type or a IO[bytes] type. Required.
        :type event_route: JSON or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                event_route = {
                    "endpointName": "str",
                    "filter": "str",
                    "id": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(event_route, (IOBase, bytes)):
            _content = event_route
        else:
            _json = event_route

        _request = build_event_routes_add_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete(
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Deletes an event route.
        Status codes:


        * 204 No Content
        * 404 Not Found

          * EventRouteNotFound - The event route was not found.

        :param id: The id for an event route. The id is unique within event routes and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_event_routes_delete_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore
