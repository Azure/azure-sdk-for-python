# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
from io import IOBase
from typing import Any, Callable, Dict, IO, Iterator, List, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core import MatchConditions, PipelineClient
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceModifiedError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .._configuration import AzureDigitalTwinsAPIConfiguration
from .._utils.serialization import Deserializer, Serializer
from .._utils.utils import prep_if_match, prep_if_none_match

JSON = MutableMapping[str, Any]
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_digital_twin_models_add_request(
    *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twin_models_list_request(
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    dependencies_for: Optional[List[str]] = None,
    include_model_definition: bool = False,
    max_items_per_page: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models"

    # Construct parameters
    if dependencies_for is not None:
        _params["dependenciesFor"] = [
            _SERIALIZER.query("dependencies_for", q, "str") if q is not None else "" for q in dependencies_for
        ]
    if include_model_definition is not None:
        _params["includeModelDefinition"] = _SERIALIZER.query(
            "include_model_definition", include_model_definition, "bool"
        )
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if max_items_per_page is not None:
        _headers["max-items-per-page"] = _SERIALIZER.header("max_items_per_page", max_items_per_page, "int")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twin_models_get_by_id_request(  # pylint: disable=name-too-long
    id: str,
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    include_model_definition: bool = False,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if include_model_definition is not None:
        _params["includeModelDefinition"] = _SERIALIZER.query(
            "include_model_definition", include_model_definition, "bool"
        )
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twin_models_update_request(
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twin_models_delete_request(
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_query_query_twins_request(
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    max_items_per_page: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/query"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if max_items_per_page is not None:
        _headers["max-items-per-page"] = _SERIALIZER.header("max_items_per_page", max_items_per_page, "int")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twins_get_by_id_request(
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twins_add_request(
    id: str,
    *,
    json: JSON,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_digital_twins_delete_request(
    id: str,
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twins_update_request(
    id: str,
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twins_get_relationship_by_id_request(  # pylint: disable=name-too-long
    id: str, relationship_id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}/relationships/{relationshipId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
        "relationshipId": _SERIALIZER.url("relationship_id", relationship_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twins_add_relationship_request(  # pylint: disable=name-too-long
    id: str,
    relationship_id: str,
    *,
    json: JSON,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}/relationships/{relationshipId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
        "relationshipId": _SERIALIZER.url("relationship_id", relationship_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_digital_twins_delete_relationship_request(  # pylint: disable=name-too-long
    id: str,
    relationship_id: str,
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}/relationships/{relationshipId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
        "relationshipId": _SERIALIZER.url("relationship_id", relationship_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twins_update_relationship_request(  # pylint: disable=name-too-long
    id: str,
    relationship_id: str,
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}/relationships/{relationshipId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
        "relationshipId": _SERIALIZER.url("relationship_id", relationship_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twins_list_relationships_request(  # pylint: disable=name-too-long
    id: str,
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    relationship_name: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}/relationships"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if relationship_name is not None:
        _params["relationshipName"] = _SERIALIZER.query("relationship_name", relationship_name, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twins_list_incoming_relationships_request(  # pylint: disable=name-too-long
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}/incomingrelationships"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twins_send_telemetry_request(  # pylint: disable=name-too-long
    id: str,
    *,
    message_id: str,
    json: JSON,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    telemetry_source_time: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}/telemetry"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Message-Id"] = _SERIALIZER.header("message_id", message_id, "str")
    if telemetry_source_time is not None:
        _headers["Telemetry-Source-Time"] = _SERIALIZER.header("telemetry_source_time", telemetry_source_time, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_digital_twins_send_component_telemetry_request(  # pylint: disable=name-too-long
    id: str,
    component_path: str,
    *,
    message_id: str,
    json: JSON,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    telemetry_source_time: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}/components/{componentPath}/telemetry"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
        "componentPath": _SERIALIZER.url("component_path", component_path, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Message-Id"] = _SERIALIZER.header("message_id", message_id, "str")
    if telemetry_source_time is not None:
        _headers["Telemetry-Source-Time"] = _SERIALIZER.header("telemetry_source_time", telemetry_source_time, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_digital_twins_get_component_request(  # pylint: disable=name-too-long
    id: str, component_path: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}/components/{componentPath}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
        "componentPath": _SERIALIZER.url("component_path", component_path, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_digital_twins_update_component_request(  # pylint: disable=name-too-long
    id: str,
    component_path: str,
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/digitaltwins/{id}/components/{componentPath}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
        "componentPath": _SERIALIZER.url("component_path", component_path, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_event_routes_list_request(
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    max_items_per_page: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/eventroutes"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if max_items_per_page is not None:
        _headers["max-items-per-page"] = _SERIALIZER.header("max_items_per_page", max_items_per_page, "int")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_event_routes_get_by_id_request(
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/eventroutes/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_event_routes_add_request(
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/eventroutes/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_event_routes_delete_request(
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/eventroutes/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_import_jobs_list_request(
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    max_items_per_page: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/jobs/imports"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if max_items_per_page is not None:
        _headers["max-items-per-page"] = _SERIALIZER.header("max_items_per_page", max_items_per_page, "int")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_import_jobs_add_request(
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/jobs/imports/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_import_jobs_get_by_id_request(
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/jobs/imports/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_import_jobs_delete_request(
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/jobs/imports/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_import_jobs_cancel_request(
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/jobs/imports/{id}/cancel"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_delete_jobs_add_request(
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    operation_id: Optional[str] = None,
    timeout_in_minutes: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/jobs/deletions"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if timeout_in_minutes is not None:
        _params["timeoutInMinutes"] = _SERIALIZER.query("timeout_in_minutes", timeout_in_minutes, "int")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if operation_id is not None:
        _headers["operation-id"] = _SERIALIZER.header("operation_id", operation_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_delete_jobs_list_request(
    *,
    traceparent: Optional[str] = None,
    tracestate: Optional[str] = None,
    max_items_per_page: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/jobs/deletions"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    if max_items_per_page is not None:
        _headers["max-items-per-page"] = _SERIALIZER.header("max_items_per_page", max_items_per_page, "int")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_delete_jobs_get_by_id_request(
    id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-31"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/jobs/deletions/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if traceparent is not None:
        _headers["traceparent"] = _SERIALIZER.header("traceparent", traceparent, "str")
    if tracestate is not None:
        _headers["tracestate"] = _SERIALIZER.header("tracestate", tracestate, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class DigitalTwinModelsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.digitaltwins.core.AzureDigitalTwinsAPI`'s
        :attr:`digital_twin_models` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AzureDigitalTwinsAPIConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def add(
        self,
        models: List[JSON],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[JSON]:
        """Uploads one or more models. When any error occurs, no models are uploaded.
        Status codes:


        * 201 Created
        * 400 Bad Request

          * DTDLParserError - The models provided are not valid DTDL.
          * InvalidArgument - The model id is invalid.
          * LimitExceeded - The maximum number of model ids allowed in 'dependenciesFor' has been
        reached.
          * ModelVersionNotSupported - The version of DTDL used is not supported.

        * 409 Conflict

          * ModelAlreadyExists - The model provided already exists.

        :param models: An array of models to add. Required.
        :type models: list[JSON]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                models = [
                    {}
                ]

                # response body for status code(s): 201
                response == [
                    {
                        "id": "str",
                        "decommissioned": False,
                        "description": {
                            "str": "str"
                        },
                        "displayName": {
                            "str": "str"
                        },
                        "model": {},
                        "uploadTime": "2020-02-20 00:00:00"
                    }
                ]
        """

    @overload
    def add(
        self,
        models: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[JSON]:
        """Uploads one or more models. When any error occurs, no models are uploaded.
        Status codes:


        * 201 Created
        * 400 Bad Request

          * DTDLParserError - The models provided are not valid DTDL.
          * InvalidArgument - The model id is invalid.
          * LimitExceeded - The maximum number of model ids allowed in 'dependenciesFor' has been
        reached.
          * ModelVersionNotSupported - The version of DTDL used is not supported.

        * 409 Conflict

          * ModelAlreadyExists - The model provided already exists.

        :param models: An array of models to add. Required.
        :type models: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == [
                    {
                        "id": "str",
                        "decommissioned": False,
                        "description": {
                            "str": "str"
                        },
                        "displayName": {
                            "str": "str"
                        },
                        "model": {},
                        "uploadTime": "2020-02-20 00:00:00"
                    }
                ]
        """

    @distributed_trace
    def add(
        self,
        models: Union[List[JSON], IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Uploads one or more models. When any error occurs, no models are uploaded.
        Status codes:


        * 201 Created
        * 400 Bad Request

          * DTDLParserError - The models provided are not valid DTDL.
          * InvalidArgument - The model id is invalid.
          * LimitExceeded - The maximum number of model ids allowed in 'dependenciesFor' has been
        reached.
          * ModelVersionNotSupported - The version of DTDL used is not supported.

        * 409 Conflict

          * ModelAlreadyExists - The model provided already exists.

        :param models: An array of models to add. Is either a [JSON] type or a IO[bytes] type.
         Required.
        :type models: list[JSON] or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == [
                    {
                        "id": "str",
                        "decommissioned": False,
                        "description": {
                            "str": "str"
                        },
                        "displayName": {
                            "str": "str"
                        },
                        "model": {},
                        "uploadTime": "2020-02-20 00:00:00"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(models, (IOBase, bytes)):
            _content = models
        else:
            _json = models

        _request = build_digital_twin_models_add_request(
            traceparent=traceparent,
            tracestate=tracestate,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace
    def list(
        self,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        dependencies_for: Optional[List[str]] = None,
        include_model_definition: bool = False,
        max_items_per_page: Optional[int] = None,
        **kwargs: Any
    ) -> ItemPaged[JSON]:
        """Retrieves model metadata and, optionally, model definitions.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * LimitExceeded - The maximum number of model ids allowed in 'dependenciesFor' has been
        reached.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword dependencies_for: If specified, only return the set of the specified models along with
         their dependencies. If omitted, all models are retrieved. Default value is None.
        :paramtype dependencies_for: list[str]
        :keyword include_model_definition: When true the model definition will be returned as part of
         the result. Default value is False.
        :paramtype include_model_definition: bool
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "decommissioned": False,
                    "description": {
                        "str": "str"
                    },
                    "displayName": {
                        "str": "str"
                    },
                    "model": {},
                    "uploadTime": "2020-02-20 00:00:00"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_digital_twin_models_list_request(
                    traceparent=traceparent,
                    tracestate=tracestate,
                    dependencies_for=dependencies_for,
                    include_model_definition=include_model_definition,
                    max_items_per_page=max_items_per_page,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized.get("value", [])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_by_id(
        self,
        id: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        include_model_definition: bool = False,
        **kwargs: Any
    ) -> JSON:
        """Retrieves model metadata and optionally the model definition.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * MissingArgument - The model id was not provided.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        :param id: The id for the model. The id is globally unique and case sensitive. Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword include_model_definition: When true the model definition will be returned as part of
         the result. Default value is False.
        :paramtype include_model_definition: bool
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "decommissioned": False,
                    "description": {
                        "str": "str"
                    },
                    "displayName": {
                        "str": "str"
                    },
                    "model": {},
                    "uploadTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_digital_twin_models_get_by_id_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            include_model_definition=include_model_definition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def update(
        self,
        id: str,
        update_model: List[JSON],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        **kwargs: Any
    ) -> None:
        """Updates the metadata for a model.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * MissingArgument - The model id was not provided.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        * 409 Conflict

          * ModelReferencesNotDecommissioned - The model refers to models that are not decommissioned.

        :param id: The id for the model. The id is globally unique and case sensitive. Required.
        :type id: str
        :param update_model: An update specification described by JSON Patch. Only the decommissioned
         property can be replaced. Required.
        :type update_model: list[JSON]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_model = [
                    {}
                ]
        """

    @overload
    def update(
        self,
        id: str,
        update_model: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        **kwargs: Any
    ) -> None:
        """Updates the metadata for a model.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * MissingArgument - The model id was not provided.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        * 409 Conflict

          * ModelReferencesNotDecommissioned - The model refers to models that are not decommissioned.

        :param id: The id for the model. The id is globally unique and case sensitive. Required.
        :type id: str
        :param update_model: An update specification described by JSON Patch. Only the decommissioned
         property can be replaced. Required.
        :type update_model: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        update_model: Union[List[JSON], IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Updates the metadata for a model.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * MissingArgument - The model id was not provided.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        * 409 Conflict

          * ModelReferencesNotDecommissioned - The model refers to models that are not decommissioned.

        :param id: The id for the model. The id is globally unique and case sensitive. Required.
        :type id: str
        :param update_model: An update specification described by JSON Patch. Only the decommissioned
         property can be replaced. Is either a [JSON] type or a IO[bytes] type. Required.
        :type update_model: list[JSON] or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json-patch+json"
        _json = None
        _content = None
        if isinstance(update_model, (IOBase, bytes)):
            _content = update_model
        else:
            _json = update_model

        _request = build_digital_twin_models_update_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Deletes a model. A model can only be deleted if no other models reference it.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The model id is invalid.
          * MissingArgument - The model id was not provided.

        * 404 Not Found

          * ModelNotFound - The model was not found.

        * 409 Conflict

          * ModelReferencesNotDeleted - The model refers to models that are not deleted.

        :param id: The id for the model. The id is globally unique and case sensitive. Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_digital_twin_models_delete_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class QueryOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.digitaltwins.core.AzureDigitalTwinsAPI`'s
        :attr:`query` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AzureDigitalTwinsAPIConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def query_twins(
        self,
        query_specification: JSON,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        max_items_per_page: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Executes a query that allows traversing relationships and filtering by property values.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * BadRequest - The continuation token is invalid.
          * SqlQueryError - The query contains some errors.
          * TimeoutError - The query execution timed out after 60 seconds. Try simplifying the query or
        adding conditions to reduce the result size.
          * 429 Too Many Requests
          * QuotaReachedError - The maximum query rate limit has been reached.

        :param query_specification: The query specification to execute. Required.
        :type query_specification: JSON
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                query_specification = {
                    "continuationToken": "str",
                    "query": "str"
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {}
                    ],
                    "continuationToken": "str"
                }
        """

    @overload
    def query_twins(
        self,
        query_specification: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        max_items_per_page: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Executes a query that allows traversing relationships and filtering by property values.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * BadRequest - The continuation token is invalid.
          * SqlQueryError - The query contains some errors.
          * TimeoutError - The query execution timed out after 60 seconds. Try simplifying the query or
        adding conditions to reduce the result size.
          * 429 Too Many Requests
          * QuotaReachedError - The maximum query rate limit has been reached.

        :param query_specification: The query specification to execute. Required.
        :type query_specification: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {}
                    ],
                    "continuationToken": "str"
                }
        """

    @distributed_trace
    def query_twins(
        self,
        query_specification: Union[JSON, IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        max_items_per_page: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Executes a query that allows traversing relationships and filtering by property values.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * BadRequest - The continuation token is invalid.
          * SqlQueryError - The query contains some errors.
          * TimeoutError - The query execution timed out after 60 seconds. Try simplifying the query or
        adding conditions to reduce the result size.
          * 429 Too Many Requests
          * QuotaReachedError - The maximum query rate limit has been reached.

        :param query_specification: The query specification to execute. Is either a JSON type or a
         IO[bytes] type. Required.
        :type query_specification: JSON or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                query_specification = {
                    "continuationToken": "str",
                    "query": "str"
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {}
                    ],
                    "continuationToken": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(query_specification, (IOBase, bytes)):
            _content = query_specification
        else:
            _json = query_specification

        _request = build_query_query_twins_request(
            traceparent=traceparent,
            tracestate=tracestate,
            max_items_per_page=max_items_per_page,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["query-charge"] = self._deserialize("float", response.headers.get("query-charge"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class DigitalTwinsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.digitaltwins.core.AzureDigitalTwinsAPI`'s
        :attr:`digital_twins` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AzureDigitalTwinsAPIConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_by_id(
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> Dict[str, Any]:
        """Retrieves a digital twin.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "str": {}
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_digital_twins_get_by_id_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Dict[str, Any], deserialized), response_headers)  # type: ignore

        return cast(Dict[str, Any], deserialized)  # type: ignore

    @distributed_trace
    def add(
        self,
        id: str,
        twin: JSON,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Adds or replaces a digital twin.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id or payload is invalid.
          * ModelDecommissioned - The model for the digital twin is decommissioned.
          * TwinLimitReached - The maximum number of digital twins allowed has been reached.
          * ValidationFailed - The digital twin payload is not valid.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param twin: The digital twin instance being added. If provided, the $dtId property is ignored.
         Required.
        :type twin: JSON
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "str": {}
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _json = twin

        _request = build_digital_twins_add_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Dict[str, Any], deserialized), response_headers)  # type: ignore

        return cast(Dict[str, Any], deserialized)  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a digital twin. All relationships referencing the digital twin must already be deleted.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id is invalid.
          * RelationshipsNotDeleted - The digital twin contains relationships.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_digital_twins_delete_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def update(
        self,
        id: str,
        patch_document: List[JSON],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Required.
        :type patch_document: list[JSON]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                patch_document = [
                    {}
                ]
        """

    @overload
    def update(
        self,
        id: str,
        patch_document: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Required.
        :type patch_document: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        patch_document: Union[List[JSON], IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Is either a [JSON] type or a IO[bytes] type. Required.
        :type patch_document: list[JSON] or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json-patch+json"
        _json = None
        _content = None
        if isinstance(patch_document, (IOBase, bytes)):
            _content = patch_document
        else:
            _json = patch_document

        _request = build_digital_twins_update_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def get_relationship_by_id(
        self,
        id: str,
        relationship_id: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Retrieves a relationship between two digital twins.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id or relationship id is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * RelationshipNotFound - The relationship was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "str": {}
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_digital_twins_get_relationship_by_id_request(
            id=id,
            relationship_id=relationship_id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Dict[str, Any], deserialized), response_headers)  # type: ignore

        return cast(Dict[str, Any], deserialized)  # type: ignore

    @distributed_trace
    def add_relationship(
        self,
        id: str,
        relationship_id: str,
        relationship: JSON,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Adds a relationship between two digital twins.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id, relationship id, or payload is invalid.
          * InvalidRelationship - The relationship is invalid.
          * OperationNotAllowed - The relationship cannot connect to the same digital twin.
          * ValidationFailed - The relationship content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * TargetTwinNotFound - The digital twin target of the relationship was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :param relationship: The data for the relationship. Required.
        :type relationship: JSON
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "str": {}
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _json = relationship

        _request = build_digital_twins_add_relationship_request(
            id=id,
            relationship_id=relationship_id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Dict[str, Any], deserialized), response_headers)  # type: ignore

        return cast(Dict[str, Any], deserialized)  # type: ignore

    @distributed_trace
    def delete_relationship(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        relationship_id: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a relationship between two digital twins.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or relationship id is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * RelationshipNotFound - The relationship was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_digital_twins_delete_relationship_request(
            id=id,
            relationship_id=relationship_id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def update_relationship(
        self,
        id: str,
        relationship_id: str,
        patch_document: List[JSON],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates the properties on a relationship between two digital twins.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or relationship id is invalid.
          * InvalidRelationship - The relationship is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - The relationship content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * RelationshipNotFound - The relationship was not found.

        * 409 Conflict

          * RelationshipAlreadyExists - The relationship already exists.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :param patch_document: JSON Patch description of the update to the relationship properties.
         Required.
        :type patch_document: list[JSON]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                patch_document = [
                    {}
                ]
        """

    @overload
    def update_relationship(
        self,
        id: str,
        relationship_id: str,
        patch_document: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates the properties on a relationship between two digital twins.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or relationship id is invalid.
          * InvalidRelationship - The relationship is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - The relationship content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * RelationshipNotFound - The relationship was not found.

        * 409 Conflict

          * RelationshipAlreadyExists - The relationship already exists.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :param patch_document: JSON Patch description of the update to the relationship properties.
         Required.
        :type patch_document: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_relationship(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        relationship_id: str,
        patch_document: Union[List[JSON], IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates the properties on a relationship between two digital twins.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or relationship id is invalid.
          * InvalidRelationship - The relationship is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - The relationship content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * RelationshipNotFound - The relationship was not found.

        * 409 Conflict

          * RelationshipAlreadyExists - The relationship already exists.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param relationship_id: The id of the relationship. The id is unique within the digital twin
         and case sensitive. Required.
        :type relationship_id: str
        :param patch_document: JSON Patch description of the update to the relationship properties. Is
         either a [JSON] type or a IO[bytes] type. Required.
        :type patch_document: list[JSON] or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json-patch+json"
        _json = None
        _content = None
        if isinstance(patch_document, (IOBase, bytes)):
            _content = patch_document
        else:
            _json = patch_document

        _request = build_digital_twins_update_relationship_request(
            id=id,
            relationship_id=relationship_id,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list_relationships(
        self,
        id: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        relationship_name: Optional[str] = None,
        **kwargs: Any
    ) -> ItemPaged[JSON]:
        """Retrieves the relationships from a digital twin.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword relationship_name: The name of the relationship. Default value is None.
        :paramtype relationship_name: str
        :return: An iterator like instance of JSON
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {}
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_digital_twins_list_relationships_request(
                    id=id,
                    traceparent=traceparent,
                    tracestate=tracestate,
                    relationship_name=relationship_name,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized.get("value", [])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_incoming_relationships(
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> ItemPaged[JSON]:
        """Retrieves all incoming relationship for a digital twin.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "$relationshipId": "str",
                    "$relationshipLink": "str",
                    "$relationshipName": "str",
                    "$sourceId": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_digital_twins_list_incoming_relationships_request(
                    id=id,
                    traceparent=traceparent,
                    tracestate=tracestate,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized.get("value", [])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def send_telemetry(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        telemetry: JSON,
        *,
        message_id: str,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        telemetry_source_time: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Sends telemetry on behalf of a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id or message id is invalid.
          * ValidationFailed - The telemetry content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param telemetry: The telemetry measurements to send from the digital twin. Required.
        :type telemetry: JSON
        :keyword message_id: A unique message identifier (in the scope of the digital twin id) that is
         commonly used for de-duplicating messages. Required.
        :paramtype message_id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword telemetry_source_time: An RFC 3339 timestamp that identifies the time the telemetry
         was measured. Default value is None.
        :paramtype telemetry_source_time: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _json = telemetry

        _request = build_digital_twins_send_telemetry_request(
            id=id,
            message_id=message_id,
            traceparent=traceparent,
            tracestate=tracestate,
            telemetry_source_time=telemetry_source_time,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def send_component_telemetry(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        component_path: str,
        telemetry: JSON,
        *,
        message_id: str,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        telemetry_source_time: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Sends telemetry on behalf of a component in a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id, message id, or component path is invalid.
          * ValidationFailed - The telemetry content is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * ComponentNotFound - The component path was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param component_path: The name of the DTDL component. Required.
        :type component_path: str
        :param telemetry: The telemetry measurements to send from the digital twin's component.
         Required.
        :type telemetry: JSON
        :keyword message_id: A unique message identifier (in the scope of the digital twin id) that is
         commonly used for de-duplicating messages. Required.
        :paramtype message_id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword telemetry_source_time: An RFC 3339 timestamp that identifies the time the telemetry
         was measured. Default value is None.
        :paramtype telemetry_source_time: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _json = telemetry

        _request = build_digital_twins_send_component_telemetry_request(
            id=id,
            component_path=component_path,
            message_id=message_id,
            traceparent=traceparent,
            tracestate=tracestate,
            telemetry_source_time=telemetry_source_time,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_component(
        self,
        id: str,
        component_path: str,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Retrieves a component from a digital twin.
        Status codes:


        * 200 OK
        * 400 Bad Request

          * InvalidArgument - The digital twin id or component path is invalid.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.
          * ComponentNotFound - The component path was not found.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param component_path: The name of the DTDL component. Required.
        :type component_path: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "str": {}
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_digital_twins_get_component_request(
            id=id,
            component_path=component_path,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Dict[str, Any], deserialized), response_headers)  # type: ignore

        return cast(Dict[str, Any], deserialized)  # type: ignore

    @overload
    def update_component(
        self,
        id: str,
        component_path: str,
        patch_document: List[JSON],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a component on a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id, component path, or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param component_path: The name of the DTDL component. Required.
        :type component_path: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Required.
        :type patch_document: list[JSON]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                patch_document = [
                    {}
                ]
        """

    @overload
    def update_component(
        self,
        id: str,
        component_path: str,
        patch_document: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json-patch+json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a component on a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id, component path, or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param component_path: The name of the DTDL component. Required.
        :type component_path: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Required.
        :type patch_document: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json-patch+json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_component(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        component_path: str,
        patch_document: Union[List[JSON], IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Updates a component on a digital twin.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * InvalidArgument - The digital twin id, component path, or payload is invalid.
          * JsonPatchInvalid - The JSON Patch provided is invalid.
          * ValidationFailed - Applying the patch results in an invalid digital twin.

        * 404 Not Found

          * DigitalTwinNotFound - The digital twin was not found.

        * 412 Precondition Failed

          * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.

        :param id: The id of the digital twin. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param component_path: The name of the DTDL component. Required.
        :type component_path: str
        :param patch_document: An update specification described by JSON Patch. Updates to property
         values and $model elements may happen in the same request. Operations are limited to add,
         replace and remove. Is either a [JSON] type or a IO[bytes] type. Required.
        :type patch_document: list[JSON] or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json-patch+json"
        _json = None
        _content = None
        if isinstance(patch_document, (IOBase, bytes)):
            _content = patch_document
        else:
            _json = patch_document

        _request = build_digital_twins_update_component_request(
            id=id,
            component_path=component_path,
            traceparent=traceparent,
            tracestate=tracestate,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class EventRoutesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.digitaltwins.core.AzureDigitalTwinsAPI`'s
        :attr:`event_routes` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AzureDigitalTwinsAPIConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        max_items_per_page: Optional[int] = None,
        **kwargs: Any
    ) -> ItemPaged[JSON]:
        """Retrieves all event routes.
        Status codes:


        * 200 OK.

        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endpointName": "str",
                    "filter": "str",
                    "id": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_event_routes_list_request(
                    traceparent=traceparent,
                    tracestate=tracestate,
                    max_items_per_page=max_items_per_page,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized.get("value", [])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_by_id(
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Retrieves an event route.
        Status codes:


        * 200 OK
        * 404 Not Found

          * EventRouteNotFound - The event route was not found.

        :param id: The id for an event route. The id is unique within event routes and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endpointName": "str",
                    "filter": "str",
                    "id": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_event_routes_get_by_id_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def add(
        self,
        id: str,
        event_route: JSON,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Adds or replaces an event route.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * EventRouteEndpointInvalid - The endpoint provided does not exist or is not active.
          * EventRouteFilterInvalid - The event route filter is invalid.
          * EventRouteIdInvalid - The event route id is invalid.
          * LimitExceeded - The maximum number of event routes allowed has been reached.

        :param id: The id for an event route. The id is unique within event routes and case sensitive.
         Required.
        :type id: str
        :param event_route: The event route data. Required.
        :type event_route: JSON
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                event_route = {
                    "endpointName": "str",
                    "filter": "str",
                    "id": "str"
                }
        """

    @overload
    def add(
        self,
        id: str,
        event_route: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Adds or replaces an event route.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * EventRouteEndpointInvalid - The endpoint provided does not exist or is not active.
          * EventRouteFilterInvalid - The event route filter is invalid.
          * EventRouteIdInvalid - The event route id is invalid.
          * LimitExceeded - The maximum number of event routes allowed has been reached.

        :param id: The id for an event route. The id is unique within event routes and case sensitive.
         Required.
        :type id: str
        :param event_route: The event route data. Required.
        :type event_route: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        event_route: Union[JSON, IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Adds or replaces an event route.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * EventRouteEndpointInvalid - The endpoint provided does not exist or is not active.
          * EventRouteFilterInvalid - The event route filter is invalid.
          * EventRouteIdInvalid - The event route id is invalid.
          * LimitExceeded - The maximum number of event routes allowed has been reached.

        :param id: The id for an event route. The id is unique within event routes and case sensitive.
         Required.
        :type id: str
        :param event_route: The event route data. Is either a JSON type or a IO[bytes] type. Required.
        :type event_route: JSON or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                event_route = {
                    "endpointName": "str",
                    "filter": "str",
                    "id": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(event_route, (IOBase, bytes)):
            _content = event_route
        else:
            _json = event_route

        _request = build_event_routes_add_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Deletes an event route.
        Status codes:


        * 204 No Content
        * 404 Not Found

          * EventRouteNotFound - The event route was not found.

        :param id: The id for an event route. The id is unique within event routes and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_event_routes_delete_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class ImportJobsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.digitaltwins.core.AzureDigitalTwinsAPI`'s
        :attr:`import_jobs` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AzureDigitalTwinsAPIConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        max_items_per_page: Optional[int] = None,
        **kwargs: Any
    ) -> ItemPaged[JSON]:
        """Retrieves all import jobs.
        Status codes:


        * 200 OK.

        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "inputBlobUri": "str",
                    "outputBlobUri": "str",
                    "createdDateTime": "2020-02-20 00:00:00",
                    "error": {
                        "code": "str",
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",
                            "innererror": ...
                        },
                        "message": "str"
                    },
                    "finishedDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "lastActionDateTime": "2020-02-20 00:00:00",
                    "purgeDateTime": "2020-02-20 00:00:00",
                    "status": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_import_jobs_list_request(
                    traceparent=traceparent,
                    tracestate=tracestate,
                    max_items_per_page=max_items_per_page,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized.get("value", [])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def add(
        self,
        id: str,
        import_job: JSON,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates an import job.
        Status codes:


        * 201 Created
        * 400 Bad Request

          * JobLimitReached - The maximum number of import jobs allowed has been reached.
          * ValidationFailed - The import job request is not valid.

        :param id: The id for the import job. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param import_job: The import job being added. Required.
        :type import_job: JSON
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                import_job = {
                    "inputBlobUri": "str",
                    "outputBlobUri": "str",
                    "createdDateTime": "2020-02-20 00:00:00",
                    "error": {
                        "code": "str",
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",
                            "innererror": ...
                        },
                        "message": "str"
                    },
                    "finishedDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "lastActionDateTime": "2020-02-20 00:00:00",
                    "purgeDateTime": "2020-02-20 00:00:00",
                    "status": "str"
                }

                # response body for status code(s): 201
                response == {
                    "inputBlobUri": "str",
                    "outputBlobUri": "str",
                    "createdDateTime": "2020-02-20 00:00:00",
                    "error": {
                        "code": "str",
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",
                            "innererror": ...
                        },
                        "message": "str"
                    },
                    "finishedDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "lastActionDateTime": "2020-02-20 00:00:00",
                    "purgeDateTime": "2020-02-20 00:00:00",
                    "status": "str"
                }
        """

    @overload
    def add(
        self,
        id: str,
        import_job: IO[bytes],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates an import job.
        Status codes:


        * 201 Created
        * 400 Bad Request

          * JobLimitReached - The maximum number of import jobs allowed has been reached.
          * ValidationFailed - The import job request is not valid.

        :param id: The id for the import job. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param import_job: The import job being added. Required.
        :type import_job: IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "inputBlobUri": "str",
                    "outputBlobUri": "str",
                    "createdDateTime": "2020-02-20 00:00:00",
                    "error": {
                        "code": "str",
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",
                            "innererror": ...
                        },
                        "message": "str"
                    },
                    "finishedDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "lastActionDateTime": "2020-02-20 00:00:00",
                    "purgeDateTime": "2020-02-20 00:00:00",
                    "status": "str"
                }
        """

    @distributed_trace
    def add(
        self,
        id: str,
        import_job: Union[JSON, IO[bytes]],
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Creates an import job.
        Status codes:


        * 201 Created
        * 400 Bad Request

          * JobLimitReached - The maximum number of import jobs allowed has been reached.
          * ValidationFailed - The import job request is not valid.

        :param id: The id for the import job. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :param import_job: The import job being added. Is either a JSON type or a IO[bytes] type.
         Required.
        :type import_job: JSON or IO[bytes]
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                import_job = {
                    "inputBlobUri": "str",
                    "outputBlobUri": "str",
                    "createdDateTime": "2020-02-20 00:00:00",
                    "error": {
                        "code": "str",
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",
                            "innererror": ...
                        },
                        "message": "str"
                    },
                    "finishedDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "lastActionDateTime": "2020-02-20 00:00:00",
                    "purgeDateTime": "2020-02-20 00:00:00",
                    "status": "str"
                }

                # response body for status code(s): 201
                response == {
                    "inputBlobUri": "str",
                    "outputBlobUri": "str",
                    "createdDateTime": "2020-02-20 00:00:00",
                    "error": {
                        "code": "str",
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",
                            "innererror": ...
                        },
                        "message": "str"
                    },
                    "finishedDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "lastActionDateTime": "2020-02-20 00:00:00",
                    "purgeDateTime": "2020-02-20 00:00:00",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(import_job, (IOBase, bytes)):
            _content = import_job
        else:
            _json = import_job

        _request = build_import_jobs_add_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get_by_id(
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Retrieves an import job.
        Status codes:


        * 200 OK
        * 404 Not Found

          * ImportJobNotFound - The import job was not found.

        :param id: The id for the import job. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "inputBlobUri": "str",
                    "outputBlobUri": "str",
                    "createdDateTime": "2020-02-20 00:00:00",
                    "error": {
                        "code": "str",
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",
                            "innererror": ...
                        },
                        "message": "str"
                    },
                    "finishedDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "lastActionDateTime": "2020-02-20 00:00:00",
                    "purgeDateTime": "2020-02-20 00:00:00",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_import_jobs_get_by_id_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Deletes an import job. This is simply used to remove a job id, so it may be reused later. It
        can not be used to stop entities from being imported.
        Status codes:


        * 204 No Content
        * 400 Bad Request

          * ValidationFailed - The import job request is not valid.

        :param id: The id for the import job. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_import_jobs_delete_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def cancel(
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Cancels an import job that is currently running. Service will stop any import operations
        triggered by the current import job that are in progress, and go to a cancelled state. Please
        note that this will leave your instance in an unknown state as there won't be any rollback
        operation.
        Status codes:


        * 200 Request Accepted
        * 400 Bad Request

          * ValidationFailed - The import job request is not valid.

        :param id: The id for the import job. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "inputBlobUri": "str",
                    "outputBlobUri": "str",
                    "createdDateTime": "2020-02-20 00:00:00",
                    "error": {
                        "code": "str",
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",
                            "innererror": ...
                        },
                        "message": "str"
                    },
                    "finishedDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "lastActionDateTime": "2020-02-20 00:00:00",
                    "purgeDateTime": "2020-02-20 00:00:00",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_import_jobs_cancel_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class DeleteJobsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.digitaltwins.core.AzureDigitalTwinsAPI`'s
        :attr:`delete_jobs` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AzureDigitalTwinsAPIConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _add_initial(
        self, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_delete_jobs_add_request(
            traceparent=traceparent,
            tracestate=tracestate,
            operation_id=self._config.operation_id,
            timeout_in_minutes=self._config.timeout_in_minutes,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, cast(Iterator[bytes], deserialized), response_headers)  # type: ignore

        return cast(Iterator[bytes], deserialized)  # type: ignore

    @distributed_trace
    def begin_add(
        self, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Initiates a job which deletes all models, twins, and relationships on the instance. Does not
        delete any other types of entities.
        Status codes:


        * 202 Created
        * 400 Bad Request

          * JobLimitReached - The maximum number of delete jobs allowed has been reached.
          * ValidationFailed - Operation-Id already exists.

        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",
                    "error": {
                        "code": "str",
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",
                            "innererror": ...
                        },
                        "message": "str"
                    },
                    "finishedDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "purgeDateTime": "2020-02-20 00:00:00",
                    "status": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._add_initial(
                traceparent=traceparent,
                tracestate=tracestate,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(
        self,
        *,
        traceparent: Optional[str] = None,
        tracestate: Optional[str] = None,
        max_items_per_page: Optional[int] = None,
        **kwargs: Any
    ) -> ItemPaged[JSON]:
        """Retrieves all deletion jobs. This may be useful to find a delete job that was previously
        requested, or to view a history of delete jobs that have run or are currently running on the
        instance.
        Status codes:


        * 200 OK.

        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :keyword max_items_per_page: The maximum number of items to retrieve per request. The server
         may choose to return less than the requested number. Default value is None.
        :paramtype max_items_per_page: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",
                    "error": {
                        "code": "str",
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",
                            "innererror": ...
                        },
                        "message": "str"
                    },
                    "finishedDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "purgeDateTime": "2020-02-20 00:00:00",
                    "status": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_delete_jobs_list_request(
                    traceparent=traceparent,
                    tracestate=tracestate,
                    max_items_per_page=max_items_per_page,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized.get("value", [])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_by_id(
        self, id: str, *, traceparent: Optional[str] = None, tracestate: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Retrieves a delete job.
        Status codes:


        * 200 OK
        * 404 Not Found

          * DeleteJobNotFound - The delete job was not found.

        :param id: The id for the delete job. The id is unique within the service and case sensitive.
         Required.
        :type id: str
        :keyword traceparent: Identifies the request in a distributed tracing system. Default value is
         None.
        :paramtype traceparent: str
        :keyword tracestate: Provides vendor-specific trace identification information and is a
         companion to traceparent. Default value is None.
        :paramtype tracestate: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",
                    "error": {
                        "code": "str",
                        "details": [
                            ...
                        ],
                        "innererror": {
                            "code": "str",
                            "innererror": ...
                        },
                        "message": "str"
                    },
                    "finishedDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "purgeDateTime": "2020-02-20 00:00:00",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_delete_jobs_get_by_id_request(
            id=id,
            traceparent=traceparent,
            tracestate=tracestate,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore
