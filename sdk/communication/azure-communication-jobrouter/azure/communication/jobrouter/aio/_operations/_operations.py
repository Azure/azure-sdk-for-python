# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from io import IOBase
import json
import sys
from typing import Any, AsyncIterable, Callable, Dict, IO, List, Optional, Type, TypeVar, Union, overload
import urllib.parse

from azure.core import MatchConditions
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceModifiedError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import SdkJSONEncoder, _deserialize
from ..._operations._operations import (
    build_job_router_accept_job_offer_request,
    build_job_router_administration_delete_classification_policy_request,
    build_job_router_administration_delete_distribution_policy_request,
    build_job_router_administration_delete_exception_policy_request,
    build_job_router_administration_delete_queue_request,
    build_job_router_administration_get_classification_policy_request,
    build_job_router_administration_get_distribution_policy_request,
    build_job_router_administration_get_exception_policy_request,
    build_job_router_administration_get_queue_request,
    build_job_router_administration_list_classification_policies_request,
    build_job_router_administration_list_distribution_policies_request,
    build_job_router_administration_list_exception_policies_request,
    build_job_router_administration_list_queues_request,
    build_job_router_administration_upsert_classification_policy_request,
    build_job_router_administration_upsert_distribution_policy_request,
    build_job_router_administration_upsert_exception_policy_request,
    build_job_router_administration_upsert_queue_request,
    build_job_router_cancel_job_request,
    build_job_router_close_job_request,
    build_job_router_complete_job_request,
    build_job_router_decline_job_offer_request,
    build_job_router_delete_job_request,
    build_job_router_delete_worker_request,
    build_job_router_get_job_request,
    build_job_router_get_queue_position_request,
    build_job_router_get_queue_statistics_request,
    build_job_router_get_worker_request,
    build_job_router_list_jobs_request,
    build_job_router_list_workers_request,
    build_job_router_reclassify_job_request,
    build_job_router_unassign_job_request,
    build_job_router_upsert_job_request,
    build_job_router_upsert_worker_request,
)
from .._vendor import JobRouterAdministrationClientMixinABC, JobRouterClientMixinABC

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class JobRouterAdministrationClientOperationsMixin(  # pylint: disable=name-too-long
    JobRouterAdministrationClientMixinABC
):

    @overload
    async def upsert_distribution_policy(
        self,
        distribution_policy_id: str,
        resource: _models.DistributionPolicy,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.DistributionPolicy:
        """Creates or updates a distribution policy.

        Creates or updates a distribution policy.

        :param distribution_policy_id: Id of a distribution policy. Required.
        :type distribution_policy_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.communication.jobrouter.models.DistributionPolicy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: DistributionPolicy. The DistributionPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.DistributionPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "mode": distribution_mode,
                    "name": "str",
                    "offerExpiresAfterSeconds": 0.0
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "mode": distribution_mode,
                    "name": "str",
                    "offerExpiresAfterSeconds": 0.0
                }
        """

    @overload
    async def upsert_distribution_policy(
        self,
        distribution_policy_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.DistributionPolicy:
        """Creates or updates a distribution policy.

        Creates or updates a distribution policy.

        :param distribution_policy_id: Id of a distribution policy. Required.
        :type distribution_policy_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: DistributionPolicy. The DistributionPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.DistributionPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "mode": distribution_mode,
                    "name": "str",
                    "offerExpiresAfterSeconds": 0.0
                }
        """

    @overload
    async def upsert_distribution_policy(
        self,
        distribution_policy_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.DistributionPolicy:
        """Creates or updates a distribution policy.

        Creates or updates a distribution policy.

        :param distribution_policy_id: Id of a distribution policy. Required.
        :type distribution_policy_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: DistributionPolicy. The DistributionPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.DistributionPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "mode": distribution_mode,
                    "name": "str",
                    "offerExpiresAfterSeconds": 0.0
                }
        """

    @distributed_trace_async
    async def upsert_distribution_policy(
        self,
        distribution_policy_id: str,
        resource: Union[_models.DistributionPolicy, JSON, IO[bytes]],
        *,
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.DistributionPolicy:
        """Creates or updates a distribution policy.

        Creates or updates a distribution policy.

        :param distribution_policy_id: Id of a distribution policy. Required.
        :type distribution_policy_id: str
        :param resource: The resource instance. Is one of the following types: DistributionPolicy,
         JSON, IO[bytes] Required.
        :type resource: ~azure.communication.jobrouter.models.DistributionPolicy or JSON or IO[bytes]
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: DistributionPolicy. The DistributionPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.DistributionPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "mode": distribution_mode,
                    "name": "str",
                    "offerExpiresAfterSeconds": 0.0
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "mode": distribution_mode,
                    "name": "str",
                    "offerExpiresAfterSeconds": 0.0
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DistributionPolicy] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_job_router_administration_upsert_distribution_policy_request(
            distribution_policy_id=distribution_policy_id,
            if_unmodified_since=if_unmodified_since,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.DistributionPolicy, response.json())

        if response.status_code == 201:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.DistributionPolicy, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_distribution_policy(self, distribution_policy_id: str, **kwargs: Any) -> _models.DistributionPolicy:
        """Retrieves an existing distribution policy by Id.

        Retrieves an existing distribution policy by Id.

        :param distribution_policy_id: Id of a distribution policy. Required.
        :type distribution_policy_id: str
        :return: DistributionPolicy. The DistributionPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.DistributionPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "mode": distribution_mode,
                    "name": "str",
                    "offerExpiresAfterSeconds": 0.0
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DistributionPolicy] = kwargs.pop("cls", None)

        _request = build_job_router_administration_get_distribution_policy_request(
            distribution_policy_id=distribution_policy_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DistributionPolicy, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_distribution_policies(self, **kwargs: Any) -> AsyncIterable["_models.DistributionPolicy"]:
        """Retrieves existing distribution policies.

        Retrieves existing distribution policies.

        :return: An iterator like instance of DistributionPolicy
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.communication.jobrouter.models.DistributionPolicy]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "bestWorker":
                distribution_mode = {
                    "kind": "bestWorker",
                    "bypassSelectors": bool,
                    "maxConcurrentOffers": 0,
                    "minConcurrentOffers": 0,
                    "scoringRule": router_rule,
                    "scoringRuleOptions": {
                        "batchSize": 0,
                        "descendingOrder": bool,
                        "isBatchScoringEnabled": bool,
                        "scoringParameters": [
                            "str"
                        ]
                    }
                }

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "mode": distribution_mode,
                    "name": "str",
                    "offerExpiresAfterSeconds": 0.0
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        maxpagesize = kwargs.pop("maxpagesize", None)
        cls: ClsType[List[_models.DistributionPolicy]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_job_router_administration_list_distribution_policies_request(
                    maxpagesize=maxpagesize,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DistributionPolicy], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete_distribution_policy(  # pylint: disable=inconsistent-return-statements
        self, distribution_policy_id: str, **kwargs: Any
    ) -> None:
        """Delete a distribution policy by Id.

        Delete a distribution policy by Id.

        :param distribution_policy_id: Id of a distribution policy. Required.
        :type distribution_policy_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_job_router_administration_delete_distribution_policy_request(
            distribution_policy_id=distribution_policy_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def upsert_classification_policy(
        self,
        classification_policy_id: str,
        resource: _models.ClassificationPolicy,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.ClassificationPolicy:
        """Creates or updates a classification policy.

        Creates or updates a classification policy.

        :param classification_policy_id: Id of a classification policy. Required.
        :type classification_policy_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.communication.jobrouter.models.ClassificationPolicy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: ClassificationPolicy. The ClassificationPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.ClassificationPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "fallbackQueueId": "str",
                    "name": "str",
                    "prioritizationRule": router_rule,
                    "queueSelectorAttachments": [
                        queue_selector_attachment
                    ],
                    "workerSelectorAttachments": [
                        worker_selector_attachment
                    ]
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "fallbackQueueId": "str",
                    "name": "str",
                    "prioritizationRule": router_rule,
                    "queueSelectorAttachments": [
                        queue_selector_attachment
                    ],
                    "workerSelectorAttachments": [
                        worker_selector_attachment
                    ]
                }
        """

    @overload
    async def upsert_classification_policy(
        self,
        classification_policy_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.ClassificationPolicy:
        """Creates or updates a classification policy.

        Creates or updates a classification policy.

        :param classification_policy_id: Id of a classification policy. Required.
        :type classification_policy_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: ClassificationPolicy. The ClassificationPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.ClassificationPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "fallbackQueueId": "str",
                    "name": "str",
                    "prioritizationRule": router_rule,
                    "queueSelectorAttachments": [
                        queue_selector_attachment
                    ],
                    "workerSelectorAttachments": [
                        worker_selector_attachment
                    ]
                }
        """

    @overload
    async def upsert_classification_policy(
        self,
        classification_policy_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.ClassificationPolicy:
        """Creates or updates a classification policy.

        Creates or updates a classification policy.

        :param classification_policy_id: Id of a classification policy. Required.
        :type classification_policy_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: ClassificationPolicy. The ClassificationPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.ClassificationPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "fallbackQueueId": "str",
                    "name": "str",
                    "prioritizationRule": router_rule,
                    "queueSelectorAttachments": [
                        queue_selector_attachment
                    ],
                    "workerSelectorAttachments": [
                        worker_selector_attachment
                    ]
                }
        """

    @distributed_trace_async
    async def upsert_classification_policy(
        self,
        classification_policy_id: str,
        resource: Union[_models.ClassificationPolicy, JSON, IO[bytes]],
        *,
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.ClassificationPolicy:
        """Creates or updates a classification policy.

        Creates or updates a classification policy.

        :param classification_policy_id: Id of a classification policy. Required.
        :type classification_policy_id: str
        :param resource: The resource instance. Is one of the following types: ClassificationPolicy,
         JSON, IO[bytes] Required.
        :type resource: ~azure.communication.jobrouter.models.ClassificationPolicy or JSON or IO[bytes]
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: ClassificationPolicy. The ClassificationPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.ClassificationPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "fallbackQueueId": "str",
                    "name": "str",
                    "prioritizationRule": router_rule,
                    "queueSelectorAttachments": [
                        queue_selector_attachment
                    ],
                    "workerSelectorAttachments": [
                        worker_selector_attachment
                    ]
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "fallbackQueueId": "str",
                    "name": "str",
                    "prioritizationRule": router_rule,
                    "queueSelectorAttachments": [
                        queue_selector_attachment
                    ],
                    "workerSelectorAttachments": [
                        worker_selector_attachment
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ClassificationPolicy] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_job_router_administration_upsert_classification_policy_request(
            classification_policy_id=classification_policy_id,
            if_unmodified_since=if_unmodified_since,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ClassificationPolicy, response.json())

        if response.status_code == 201:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ClassificationPolicy, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_classification_policy(
        self, classification_policy_id: str, **kwargs: Any
    ) -> _models.ClassificationPolicy:
        """Retrieves an existing classification policy by Id.

        Retrieves an existing classification policy by Id.

        :param classification_policy_id: Id of a classification policy. Required.
        :type classification_policy_id: str
        :return: ClassificationPolicy. The ClassificationPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.ClassificationPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "fallbackQueueId": "str",
                    "name": "str",
                    "prioritizationRule": router_rule,
                    "queueSelectorAttachments": [
                        queue_selector_attachment
                    ],
                    "workerSelectorAttachments": [
                        worker_selector_attachment
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ClassificationPolicy] = kwargs.pop("cls", None)

        _request = build_job_router_administration_get_classification_policy_request(
            classification_policy_id=classification_policy_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ClassificationPolicy, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_classification_policies(self, **kwargs: Any) -> AsyncIterable["_models.ClassificationPolicy"]:
        """Retrieves existing classification policies.

        Retrieves existing classification policies.

        :return: An iterator like instance of ClassificationPolicy
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.communication.jobrouter.models.ClassificationPolicy]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "directMap":
                router_rule = {
                    "kind": "directMap"
                }

                # JSON input template for discriminator value "expression":
                router_rule = {
                    "expression": "str",
                    "kind": "expression",
                    "language": "str"
                }

                # JSON input template for discriminator value "function":
                router_rule = {
                    "functionUri": "str",
                    "kind": "function",
                    "credential": {
                        "appKey": "str",
                        "clientId": "str",
                        "functionKey": "str"
                    }
                }

                # JSON input template for discriminator value "static":
                router_rule = {
                    "kind": "static",
                    "value": {}
                }

                # JSON input template for discriminator value "webhook":
                router_rule = {
                    "kind": "webhook",
                    "authorizationServerUri": "str",
                    "clientCredential": {
                        "clientId": "str",
                        "clientSecret": "str"
                    },
                    "webhookUri": "str"
                }

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "fallbackQueueId": "str",
                    "name": "str",
                    "prioritizationRule": router_rule,
                    "queueSelectorAttachments": [
                        queue_selector_attachment
                    ],
                    "workerSelectorAttachments": [
                        worker_selector_attachment
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        maxpagesize = kwargs.pop("maxpagesize", None)
        cls: ClsType[List[_models.ClassificationPolicy]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_job_router_administration_list_classification_policies_request(
                    maxpagesize=maxpagesize,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ClassificationPolicy], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete_classification_policy(  # pylint: disable=inconsistent-return-statements
        self, classification_policy_id: str, **kwargs: Any
    ) -> None:
        """Delete a classification policy by Id.

        Delete a classification policy by Id.

        :param classification_policy_id: Id of a classification policy. Required.
        :type classification_policy_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_job_router_administration_delete_classification_policy_request(
            classification_policy_id=classification_policy_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def upsert_exception_policy(
        self,
        exception_policy_id: str,
        resource: _models.ExceptionPolicy,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.ExceptionPolicy:
        """Creates or updates a exception policy.

        Creates or updates a exception policy.

        :param exception_policy_id: Id of an exception policy. Required.
        :type exception_policy_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.communication.jobrouter.models.ExceptionPolicy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: ExceptionPolicy. The ExceptionPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.ExceptionPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "exceptionRules": [
                        {
                            "actions": [
                                exception_action
                            ],
                            "id": "str",
                            "trigger": exception_trigger
                        }
                    ],
                    "name": "str"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "exceptionRules": [
                        {
                            "actions": [
                                exception_action
                            ],
                            "id": "str",
                            "trigger": exception_trigger
                        }
                    ],
                    "name": "str"
                }
        """

    @overload
    async def upsert_exception_policy(
        self,
        exception_policy_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.ExceptionPolicy:
        """Creates or updates a exception policy.

        Creates or updates a exception policy.

        :param exception_policy_id: Id of an exception policy. Required.
        :type exception_policy_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: ExceptionPolicy. The ExceptionPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.ExceptionPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "exceptionRules": [
                        {
                            "actions": [
                                exception_action
                            ],
                            "id": "str",
                            "trigger": exception_trigger
                        }
                    ],
                    "name": "str"
                }
        """

    @overload
    async def upsert_exception_policy(
        self,
        exception_policy_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.ExceptionPolicy:
        """Creates or updates a exception policy.

        Creates or updates a exception policy.

        :param exception_policy_id: Id of an exception policy. Required.
        :type exception_policy_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: ExceptionPolicy. The ExceptionPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.ExceptionPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "exceptionRules": [
                        {
                            "actions": [
                                exception_action
                            ],
                            "id": "str",
                            "trigger": exception_trigger
                        }
                    ],
                    "name": "str"
                }
        """

    @distributed_trace_async
    async def upsert_exception_policy(
        self,
        exception_policy_id: str,
        resource: Union[_models.ExceptionPolicy, JSON, IO[bytes]],
        *,
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.ExceptionPolicy:
        """Creates or updates a exception policy.

        Creates or updates a exception policy.

        :param exception_policy_id: Id of an exception policy. Required.
        :type exception_policy_id: str
        :param resource: The resource instance. Is one of the following types: ExceptionPolicy, JSON,
         IO[bytes] Required.
        :type resource: ~azure.communication.jobrouter.models.ExceptionPolicy or JSON or IO[bytes]
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: ExceptionPolicy. The ExceptionPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.ExceptionPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "exceptionRules": [
                        {
                            "actions": [
                                exception_action
                            ],
                            "id": "str",
                            "trigger": exception_trigger
                        }
                    ],
                    "name": "str"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "exceptionRules": [
                        {
                            "actions": [
                                exception_action
                            ],
                            "id": "str",
                            "trigger": exception_trigger
                        }
                    ],
                    "name": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ExceptionPolicy] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_job_router_administration_upsert_exception_policy_request(
            exception_policy_id=exception_policy_id,
            if_unmodified_since=if_unmodified_since,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ExceptionPolicy, response.json())

        if response.status_code == 201:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ExceptionPolicy, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_exception_policy(self, exception_policy_id: str, **kwargs: Any) -> _models.ExceptionPolicy:
        """Retrieves an existing exception policy by Id.

        Retrieves an existing exception policy by Id.

        :param exception_policy_id: Id of an exception policy. Required.
        :type exception_policy_id: str
        :return: ExceptionPolicy. The ExceptionPolicy is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.ExceptionPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "exceptionRules": [
                        {
                            "actions": [
                                exception_action
                            ],
                            "id": "str",
                            "trigger": exception_trigger
                        }
                    ],
                    "name": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ExceptionPolicy] = kwargs.pop("cls", None)

        _request = build_job_router_administration_get_exception_policy_request(
            exception_policy_id=exception_policy_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ExceptionPolicy, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_exception_policies(self, **kwargs: Any) -> AsyncIterable["_models.ExceptionPolicy"]:
        """Retrieves existing exception policies.

        Retrieves existing exception policies.

        :return: An iterator like instance of ExceptionPolicy
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.communication.jobrouter.models.ExceptionPolicy]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "exceptionRules": [
                        {
                            "actions": [
                                exception_action
                            ],
                            "id": "str",
                            "trigger": exception_trigger
                        }
                    ],
                    "name": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        maxpagesize = kwargs.pop("maxpagesize", None)
        cls: ClsType[List[_models.ExceptionPolicy]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_job_router_administration_list_exception_policies_request(
                    maxpagesize=maxpagesize,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ExceptionPolicy], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete_exception_policy(  # pylint: disable=inconsistent-return-statements
        self, exception_policy_id: str, **kwargs: Any
    ) -> None:
        """Deletes a exception policy by Id.

        Deletes a exception policy by Id.

        :param exception_policy_id: Id of an exception policy. Required.
        :type exception_policy_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_job_router_administration_delete_exception_policy_request(
            exception_policy_id=exception_policy_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def upsert_queue(
        self,
        queue_id: str,
        resource: _models.RouterQueue,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterQueue:
        """Creates or updates a queue.

        Creates or updates a queue.

        :param queue_id: Id of a queue. Required.
        :type queue_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.communication.jobrouter.models.RouterQueue
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterQueue. The RouterQueue is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterQueue
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "distributionPolicyId": "str",
                    "exceptionPolicyId": "str",
                    "labels": {
                        "str": {}
                    },
                    "name": "str"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "distributionPolicyId": "str",
                    "exceptionPolicyId": "str",
                    "labels": {
                        "str": {}
                    },
                    "name": "str"
                }
        """

    @overload
    async def upsert_queue(
        self,
        queue_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterQueue:
        """Creates or updates a queue.

        Creates or updates a queue.

        :param queue_id: Id of a queue. Required.
        :type queue_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterQueue. The RouterQueue is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterQueue
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "distributionPolicyId": "str",
                    "exceptionPolicyId": "str",
                    "labels": {
                        "str": {}
                    },
                    "name": "str"
                }
        """

    @overload
    async def upsert_queue(
        self,
        queue_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterQueue:
        """Creates or updates a queue.

        Creates or updates a queue.

        :param queue_id: Id of a queue. Required.
        :type queue_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterQueue. The RouterQueue is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterQueue
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "distributionPolicyId": "str",
                    "exceptionPolicyId": "str",
                    "labels": {
                        "str": {}
                    },
                    "name": "str"
                }
        """

    @distributed_trace_async
    async def upsert_queue(
        self,
        queue_id: str,
        resource: Union[_models.RouterQueue, JSON, IO[bytes]],
        *,
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterQueue:
        """Creates or updates a queue.

        Creates or updates a queue.

        :param queue_id: Id of a queue. Required.
        :type queue_id: str
        :param resource: The resource instance. Is one of the following types: RouterQueue, JSON,
         IO[bytes] Required.
        :type resource: ~azure.communication.jobrouter.models.RouterQueue or JSON or IO[bytes]
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterQueue. The RouterQueue is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterQueue
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "distributionPolicyId": "str",
                    "exceptionPolicyId": "str",
                    "labels": {
                        "str": {}
                    },
                    "name": "str"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "distributionPolicyId": "str",
                    "exceptionPolicyId": "str",
                    "labels": {
                        "str": {}
                    },
                    "name": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RouterQueue] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_job_router_administration_upsert_queue_request(
            queue_id=queue_id,
            if_unmodified_since=if_unmodified_since,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.RouterQueue, response.json())

        if response.status_code == 201:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.RouterQueue, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_queue(self, queue_id: str, **kwargs: Any) -> _models.RouterQueue:
        """Retrieves an existing queue by Id.

        Retrieves an existing queue by Id.

        :param queue_id: Id of a queue. Required.
        :type queue_id: str
        :return: RouterQueue. The RouterQueue is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterQueue
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "distributionPolicyId": "str",
                    "exceptionPolicyId": "str",
                    "labels": {
                        "str": {}
                    },
                    "name": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RouterQueue] = kwargs.pop("cls", None)

        _request = build_job_router_administration_get_queue_request(
            queue_id=queue_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RouterQueue, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_queues(self, **kwargs: Any) -> AsyncIterable["_models.RouterQueue"]:
        """Retrieves existing queues.

        Retrieves existing queues.

        :return: An iterator like instance of RouterQueue
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.communication.jobrouter.models.RouterQueue]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "distributionPolicyId": "str",
                    "exceptionPolicyId": "str",
                    "labels": {
                        "str": {}
                    },
                    "name": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        maxpagesize = kwargs.pop("maxpagesize", None)
        cls: ClsType[List[_models.RouterQueue]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_job_router_administration_list_queues_request(
                    maxpagesize=maxpagesize,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.RouterQueue], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete_queue(  # pylint: disable=inconsistent-return-statements
        self, queue_id: str, **kwargs: Any
    ) -> None:
        """Deletes a queue by Id.

        Deletes a queue by Id.

        :param queue_id: Id of a queue. Required.
        :type queue_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_job_router_administration_delete_queue_request(
            queue_id=queue_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class JobRouterClientOperationsMixin(JobRouterClientMixinABC):

    @overload
    async def upsert_job(
        self,
        job_id: str,
        resource: _models.RouterJob,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterJob:
        """Creates or updates a router job.

        Creates or updates a router job.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.communication.jobrouter.models.RouterJob
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterJob. The RouterJob is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterJob
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "assignments": {
                        "str": {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "closedAt": "2020-02-20 00:00:00",
                            "completedAt": "2020-02-20 00:00:00",
                            "workerId": "str"
                        }
                    },
                    "attachedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "channelId": "str",
                    "channelReference": "str",
                    "classificationPolicyId": "str",
                    "dispositionCode": "str",
                    "enqueuedAt": "2020-02-20 00:00:00",
                    "labels": {
                        "str": {}
                    },
                    "matchingMode": job_matching_mode,
                    "notes": [
                        {
                            "message": "str",
                            "addedAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "priority": 0,
                    "queueId": "str",
                    "requestedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "scheduledAt": "2020-02-20 00:00:00",
                    "status": "str",
                    "tags": {
                        "str": {}
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignments": {
                        "str": {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "closedAt": "2020-02-20 00:00:00",
                            "completedAt": "2020-02-20 00:00:00",
                            "workerId": "str"
                        }
                    },
                    "attachedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "channelId": "str",
                    "channelReference": "str",
                    "classificationPolicyId": "str",
                    "dispositionCode": "str",
                    "enqueuedAt": "2020-02-20 00:00:00",
                    "labels": {
                        "str": {}
                    },
                    "matchingMode": job_matching_mode,
                    "notes": [
                        {
                            "message": "str",
                            "addedAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "priority": 0,
                    "queueId": "str",
                    "requestedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "scheduledAt": "2020-02-20 00:00:00",
                    "status": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """

    @overload
    async def upsert_job(
        self,
        job_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterJob:
        """Creates or updates a router job.

        Creates or updates a router job.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterJob. The RouterJob is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterJob
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignments": {
                        "str": {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "closedAt": "2020-02-20 00:00:00",
                            "completedAt": "2020-02-20 00:00:00",
                            "workerId": "str"
                        }
                    },
                    "attachedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "channelId": "str",
                    "channelReference": "str",
                    "classificationPolicyId": "str",
                    "dispositionCode": "str",
                    "enqueuedAt": "2020-02-20 00:00:00",
                    "labels": {
                        "str": {}
                    },
                    "matchingMode": job_matching_mode,
                    "notes": [
                        {
                            "message": "str",
                            "addedAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "priority": 0,
                    "queueId": "str",
                    "requestedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "scheduledAt": "2020-02-20 00:00:00",
                    "status": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """

    @overload
    async def upsert_job(
        self,
        job_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterJob:
        """Creates or updates a router job.

        Creates or updates a router job.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterJob. The RouterJob is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterJob
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignments": {
                        "str": {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "closedAt": "2020-02-20 00:00:00",
                            "completedAt": "2020-02-20 00:00:00",
                            "workerId": "str"
                        }
                    },
                    "attachedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "channelId": "str",
                    "channelReference": "str",
                    "classificationPolicyId": "str",
                    "dispositionCode": "str",
                    "enqueuedAt": "2020-02-20 00:00:00",
                    "labels": {
                        "str": {}
                    },
                    "matchingMode": job_matching_mode,
                    "notes": [
                        {
                            "message": "str",
                            "addedAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "priority": 0,
                    "queueId": "str",
                    "requestedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "scheduledAt": "2020-02-20 00:00:00",
                    "status": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """

    @distributed_trace_async
    async def upsert_job(
        self,
        job_id: str,
        resource: Union[_models.RouterJob, JSON, IO[bytes]],
        *,
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterJob:
        """Creates or updates a router job.

        Creates or updates a router job.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param resource: The resource instance. Is one of the following types: RouterJob, JSON,
         IO[bytes] Required.
        :type resource: ~azure.communication.jobrouter.models.RouterJob or JSON or IO[bytes]
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterJob. The RouterJob is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterJob
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "assignments": {
                        "str": {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "closedAt": "2020-02-20 00:00:00",
                            "completedAt": "2020-02-20 00:00:00",
                            "workerId": "str"
                        }
                    },
                    "attachedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "channelId": "str",
                    "channelReference": "str",
                    "classificationPolicyId": "str",
                    "dispositionCode": "str",
                    "enqueuedAt": "2020-02-20 00:00:00",
                    "labels": {
                        "str": {}
                    },
                    "matchingMode": job_matching_mode,
                    "notes": [
                        {
                            "message": "str",
                            "addedAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "priority": 0,
                    "queueId": "str",
                    "requestedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "scheduledAt": "2020-02-20 00:00:00",
                    "status": "str",
                    "tags": {
                        "str": {}
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignments": {
                        "str": {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "closedAt": "2020-02-20 00:00:00",
                            "completedAt": "2020-02-20 00:00:00",
                            "workerId": "str"
                        }
                    },
                    "attachedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "channelId": "str",
                    "channelReference": "str",
                    "classificationPolicyId": "str",
                    "dispositionCode": "str",
                    "enqueuedAt": "2020-02-20 00:00:00",
                    "labels": {
                        "str": {}
                    },
                    "matchingMode": job_matching_mode,
                    "notes": [
                        {
                            "message": "str",
                            "addedAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "priority": 0,
                    "queueId": "str",
                    "requestedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "scheduledAt": "2020-02-20 00:00:00",
                    "status": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RouterJob] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_job_router_upsert_job_request(
            job_id=job_id,
            if_unmodified_since=if_unmodified_since,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.RouterJob, response.json())

        if response.status_code == 201:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.RouterJob, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_job(self, job_id: str, **kwargs: Any) -> _models.RouterJob:
        """Retrieves an existing job by Id.

        Retrieves an existing job by Id.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :return: RouterJob. The RouterJob is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterJob
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignments": {
                        "str": {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "closedAt": "2020-02-20 00:00:00",
                            "completedAt": "2020-02-20 00:00:00",
                            "workerId": "str"
                        }
                    },
                    "attachedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "channelId": "str",
                    "channelReference": "str",
                    "classificationPolicyId": "str",
                    "dispositionCode": "str",
                    "enqueuedAt": "2020-02-20 00:00:00",
                    "labels": {
                        "str": {}
                    },
                    "matchingMode": job_matching_mode,
                    "notes": [
                        {
                            "message": "str",
                            "addedAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "priority": 0,
                    "queueId": "str",
                    "requestedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "scheduledAt": "2020-02-20 00:00:00",
                    "status": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RouterJob] = kwargs.pop("cls", None)

        _request = build_job_router_get_job_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RouterJob, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_job(self, job_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes a job and all of its traces.

        Deletes a job and all of its traces.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_job_router_delete_job_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def _reclassify_job(  # pylint: disable=protected-access
        self,
        job_id: str,
        options: Optional[_models._models.ReclassifyJobOptions] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models._models.ReclassifyJobResult: ...
    @overload
    async def _reclassify_job(  # pylint: disable=protected-access
        self, job_id: str, options: Optional[JSON] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models._models.ReclassifyJobResult: ...
    @overload
    async def _reclassify_job(  # pylint: disable=protected-access
        self, job_id: str, options: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models._models.ReclassifyJobResult: ...

    @distributed_trace_async
    async def _reclassify_job(  # pylint: disable=protected-access
        self,
        job_id: str,
        options: Optional[Union[_models._models.ReclassifyJobOptions, JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models._models.ReclassifyJobResult:
        """Reclassify a job.

        Reclassify a job.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param options: Request object for reclassifying a job. Is one of the following types:
         ReclassifyJobOptions, JSON, IO[bytes] Default value is None.
        :type options: ~azure.communication.jobrouter.models._models.ReclassifyJobOptions or JSON or
         IO[bytes]
        :return: ReclassifyJobResult. The ReclassifyJobResult is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models._models.ReclassifyJobResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                options = {}
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models._models.ReclassifyJobResult] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        content_type = content_type or "application/json"
        _content = None
        if isinstance(options, (IOBase, bytes)):
            _content = options
        else:
            if options is not None:
                _content = json.dumps(options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_job_router_reclassify_job_request(
            job_id=job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(
                _models._models.ReclassifyJobResult, response.json()  # pylint: disable=protected-access
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def _cancel_job(  # pylint: disable=protected-access
        self,
        job_id: str,
        options: Optional[_models.CancelJobOptions] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models._models.CancelJobResult: ...
    @overload
    async def _cancel_job(  # pylint: disable=protected-access
        self, job_id: str, options: Optional[JSON] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models._models.CancelJobResult: ...
    @overload
    async def _cancel_job(  # pylint: disable=protected-access
        self, job_id: str, options: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models._models.CancelJobResult: ...

    @distributed_trace_async
    async def _cancel_job(  # pylint: disable=protected-access
        self, job_id: str, options: Optional[Union[_models.CancelJobOptions, JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> _models._models.CancelJobResult:
        """Submits request to cancel an existing job by Id while supplying free-form cancellation reason.

        Submits request to cancel an existing job by Id while supplying free-form cancellation reason.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param options: Request model for cancelling job. Is one of the following types:
         CancelJobOptions, JSON, IO[bytes] Default value is None.
        :type options: ~azure.communication.jobrouter.models.CancelJobOptions or JSON or IO[bytes]
        :return: CancelJobResult. The CancelJobResult is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models._models.CancelJobResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                options = {
                    "dispositionCode": "str",
                    "note": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models._models.CancelJobResult] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        content_type = content_type or "application/json"
        _content = None
        if isinstance(options, (IOBase, bytes)):
            _content = options
        else:
            if options is not None:
                _content = json.dumps(options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_job_router_cancel_job_request(
            job_id=job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(
                _models._models.CancelJobResult, response.json()  # pylint: disable=protected-access
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def _complete_job(  # pylint: disable=protected-access
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[_models.CompleteJobOptions] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models._models.CompleteJobResult: ...
    @overload
    async def _complete_job(  # pylint: disable=protected-access
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models._models.CompleteJobResult: ...
    @overload
    async def _complete_job(  # pylint: disable=protected-access
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models._models.CompleteJobResult: ...

    @distributed_trace_async
    async def _complete_job(  # pylint: disable=protected-access
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[Union[_models.CompleteJobOptions, JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models._models.CompleteJobResult:
        """Completes an assigned job.

        Completes an assigned job.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param assignment_id: Id of a job assignment. Required.
        :type assignment_id: str
        :param options: Request model for completing job. Is one of the following types:
         CompleteJobOptions, JSON, IO[bytes] Default value is None.
        :type options: ~azure.communication.jobrouter.models.CompleteJobOptions or JSON or IO[bytes]
        :return: CompleteJobResult. The CompleteJobResult is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models._models.CompleteJobResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                options = {
                    "note": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models._models.CompleteJobResult] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        content_type = content_type or "application/json"
        _content = None
        if isinstance(options, (IOBase, bytes)):
            _content = options
        else:
            if options is not None:
                _content = json.dumps(options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_job_router_complete_job_request(
            job_id=job_id,
            assignment_id=assignment_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(
                _models._models.CompleteJobResult, response.json()  # pylint: disable=protected-access
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def _close_job(  # pylint: disable=protected-access
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[_models.CloseJobOptions] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models._models.CloseJobResult: ...
    @overload
    async def _close_job(  # pylint: disable=protected-access
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models._models.CloseJobResult: ...
    @overload
    async def _close_job(  # pylint: disable=protected-access
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models._models.CloseJobResult: ...

    @distributed_trace_async
    async def _close_job(  # pylint: disable=protected-access
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[Union[_models.CloseJobOptions, JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models._models.CloseJobResult:
        """Closes a completed job.

        Closes a completed job.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param assignment_id: Id of a job assignment. Required.
        :type assignment_id: str
        :param options: Request model for closing job. Is one of the following types: CloseJobOptions,
         JSON, IO[bytes] Default value is None.
        :type options: ~azure.communication.jobrouter.models.CloseJobOptions or JSON or IO[bytes]
        :return: CloseJobResult. The CloseJobResult is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models._models.CloseJobResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                options = {
                    "closeAt": "2020-02-20 00:00:00",
                    "dispositionCode": "str",
                    "note": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models._models.CloseJobResult] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        content_type = content_type or "application/json"
        _content = None
        if isinstance(options, (IOBase, bytes)):
            _content = options
        else:
            if options is not None:
                _content = json.dumps(options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_job_router_close_job_request(
            job_id=job_id,
            assignment_id=assignment_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(
                _models._models.CloseJobResult, response.json()  # pylint: disable=protected-access
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_jobs(
        self,
        *,
        status: Optional[Union[str, _models.RouterJobStatusSelector]] = None,
        queue_id: Optional[str] = None,
        channel_id: Optional[str] = None,
        classification_policy_id: Optional[str] = None,
        scheduled_before: Optional[datetime.datetime] = None,
        scheduled_after: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.RouterJob"]:
        """Retrieves list of jobs based on filter parameters.

        Retrieves list of jobs based on filter parameters.

        :keyword status: If specified, filter jobs by status. Known values are: "all",
         "pendingClassification", "queued", "assigned", "completed", "closed", "cancelled",
         "classificationFailed", "created", "pendingSchedule", "scheduled", "scheduleFailed",
         "waitingForActivation", and "active". Default value is None.
        :paramtype status: str or ~azure.communication.jobrouter.models.RouterJobStatusSelector
        :keyword queue_id: If specified, filter jobs by queue. Default value is None.
        :paramtype queue_id: str
        :keyword channel_id: If specified, filter jobs by channel. Default value is None.
        :paramtype channel_id: str
        :keyword classification_policy_id: If specified, filter jobs by classificationPolicy. Default
         value is None.
        :paramtype classification_policy_id: str
        :keyword scheduled_before: If specified, filter on jobs that was scheduled before or at given
         timestamp. Range: (-Inf, scheduledBefore]. Default value is None.
        :paramtype scheduled_before: ~datetime.datetime
        :keyword scheduled_after: If specified, filter on jobs that was scheduled at or after given
         value. Range: [scheduledAfter, +Inf). Default value is None.
        :paramtype scheduled_after: ~datetime.datetime
        :return: An iterator like instance of RouterJob
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.communication.jobrouter.models.RouterJob]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "kind":

                # JSON input template for discriminator value "queueAndMatch":
                job_matching_mode = {
                    "kind": "queueAndMatch"
                }

                # JSON input template for discriminator value "scheduleAndSuspend":
                job_matching_mode = {
                    "kind": "scheduleAndSuspend",
                    "scheduleAt": "2020-02-20 00:00:00"
                }

                # JSON input template for discriminator value "suspend":
                job_matching_mode = {
                    "kind": "suspend"
                }

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignments": {
                        "str": {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "closedAt": "2020-02-20 00:00:00",
                            "completedAt": "2020-02-20 00:00:00",
                            "workerId": "str"
                        }
                    },
                    "attachedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "channelId": "str",
                    "channelReference": "str",
                    "classificationPolicyId": "str",
                    "dispositionCode": "str",
                    "enqueuedAt": "2020-02-20 00:00:00",
                    "labels": {
                        "str": {}
                    },
                    "matchingMode": job_matching_mode,
                    "notes": [
                        {
                            "message": "str",
                            "addedAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "priority": 0,
                    "queueId": "str",
                    "requestedWorkerSelectors": [
                        {
                            "key": "str",
                            "labelOperator": "str",
                            "expedite": bool,
                            "expiresAfterSeconds": 0.0,
                            "expiresAt": "2020-02-20 00:00:00",
                            "status": "str",
                            "value": {}
                        }
                    ],
                    "scheduledAt": "2020-02-20 00:00:00",
                    "status": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        maxpagesize = kwargs.pop("maxpagesize", None)
        cls: ClsType[List[_models.RouterJob]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_job_router_list_jobs_request(
                    maxpagesize=maxpagesize,
                    status=status,
                    queue_id=queue_id,
                    channel_id=channel_id,
                    classification_policy_id=classification_policy_id,
                    scheduled_before=scheduled_before,
                    scheduled_after=scheduled_after,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.RouterJob], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_queue_position(self, job_id: str, **kwargs: Any) -> _models.RouterJobPositionDetails:
        """Gets a job's position details.

        Gets a job's position details.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: RouterJobPositionDetails. The RouterJobPositionDetails is compatible with
         MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterJobPositionDetails
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "estimatedWaitTimeMinutes": 0.0,
                    "jobId": "str",
                    "position": 0,
                    "queueId": "str",
                    "queueLength": 0
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RouterJobPositionDetails] = kwargs.pop("cls", None)

        _request = build_job_router_get_queue_position_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RouterJobPositionDetails, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def unassign_job(
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[_models.UnassignJobOptions] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.UnassignJobResult:
        """Unassign a job.

        Unassign a job.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param assignment_id: Id of a job assignment. Required.
        :type assignment_id: str
        :param options: Request body for unassign route. Default value is None.
        :type options: ~azure.communication.jobrouter.models.UnassignJobOptions
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: UnassignJobResult. The UnassignJobResult is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.UnassignJobResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                options = {
                    "suspendMatching": bool
                }

                # response body for status code(s): 200
                response == {
                    "jobId": "str",
                    "unassignmentCount": 0
                }
        """

    @overload
    async def unassign_job(
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.UnassignJobResult:
        """Unassign a job.

        Unassign a job.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param assignment_id: Id of a job assignment. Required.
        :type assignment_id: str
        :param options: Request body for unassign route. Default value is None.
        :type options: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: UnassignJobResult. The UnassignJobResult is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.UnassignJobResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "jobId": "str",
                    "unassignmentCount": 0
                }
        """

    @overload
    async def unassign_job(
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.UnassignJobResult:
        """Unassign a job.

        Unassign a job.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param assignment_id: Id of a job assignment. Required.
        :type assignment_id: str
        :param options: Request body for unassign route. Default value is None.
        :type options: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: UnassignJobResult. The UnassignJobResult is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.UnassignJobResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "jobId": "str",
                    "unassignmentCount": 0
                }
        """

    @distributed_trace_async
    async def unassign_job(
        self,
        job_id: str,
        assignment_id: str,
        options: Optional[Union[_models.UnassignJobOptions, JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.UnassignJobResult:
        """Unassign a job.

        Unassign a job.

        :param job_id: Id of a job. Required.
        :type job_id: str
        :param assignment_id: Id of a job assignment. Required.
        :type assignment_id: str
        :param options: Request body for unassign route. Is one of the following types:
         UnassignJobOptions, JSON, IO[bytes] Default value is None.
        :type options: ~azure.communication.jobrouter.models.UnassignJobOptions or JSON or IO[bytes]
        :return: UnassignJobResult. The UnassignJobResult is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.UnassignJobResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                options = {
                    "suspendMatching": bool
                }

                # response body for status code(s): 200
                response == {
                    "jobId": "str",
                    "unassignmentCount": 0
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.UnassignJobResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(options, (IOBase, bytes)):
            _content = options
        else:
            if options is not None:
                _content = json.dumps(options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_job_router_unassign_job_request(
            job_id=job_id,
            assignment_id=assignment_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.UnassignJobResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def accept_job_offer(self, worker_id: str, offer_id: str, **kwargs: Any) -> _models.AcceptJobOfferResult:
        """Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job
        already.

        Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job
        already.

        :param worker_id: Id of a worker. Required.
        :type worker_id: str
        :param offer_id: Id of an offer. Required.
        :type offer_id: str
        :return: AcceptJobOfferResult. The AcceptJobOfferResult is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.AcceptJobOfferResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "assignmentId": "str",
                    "jobId": "str",
                    "workerId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AcceptJobOfferResult] = kwargs.pop("cls", None)

        _request = build_job_router_accept_job_offer_request(
            worker_id=worker_id,
            offer_id=offer_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AcceptJobOfferResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def _decline_job_offer(  # pylint: disable=protected-access
        self,
        worker_id: str,
        offer_id: str,
        options: Optional[_models.DeclineJobOfferOptions] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models._models.DeclineJobOfferResult: ...
    @overload
    async def _decline_job_offer(  # pylint: disable=protected-access
        self,
        worker_id: str,
        offer_id: str,
        options: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models._models.DeclineJobOfferResult: ...
    @overload
    async def _decline_job_offer(  # pylint: disable=protected-access
        self,
        worker_id: str,
        offer_id: str,
        options: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models._models.DeclineJobOfferResult: ...

    @distributed_trace_async
    async def _decline_job_offer(  # pylint: disable=protected-access
        self,
        worker_id: str,
        offer_id: str,
        options: Optional[Union[_models.DeclineJobOfferOptions, JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models._models.DeclineJobOfferResult:
        """Declines an offer to work on a job.

        Declines an offer to work on a job.

        :param worker_id: Id of a worker. Required.
        :type worker_id: str
        :param offer_id: Id of an offer. Required.
        :type offer_id: str
        :param options: Request model for declining offer. Is one of the following types:
         DeclineJobOfferOptions, JSON, IO[bytes] Default value is None.
        :type options: ~azure.communication.jobrouter.models.DeclineJobOfferOptions or JSON or
         IO[bytes]
        :return: DeclineJobOfferResult. The DeclineJobOfferResult is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models._models.DeclineJobOfferResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                options = {
                    "retryOfferAt": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models._models.DeclineJobOfferResult] = kwargs.pop(  # pylint: disable=protected-access
            "cls", None
        )

        content_type = content_type or "application/json"
        _content = None
        if isinstance(options, (IOBase, bytes)):
            _content = options
        else:
            if options is not None:
                _content = json.dumps(options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_job_router_decline_job_offer_request(
            worker_id=worker_id,
            offer_id=offer_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(
                _models._models.DeclineJobOfferResult, response.json()  # pylint: disable=protected-access
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_queue_statistics(self, queue_id: str, **kwargs: Any) -> _models.RouterQueueStatistics:
        """Retrieves a queue's statistics.

        Retrieves a queue's statistics.

        :param queue_id: Id of the queue to retrieve statistics. Required.
        :type queue_id: str
        :return: RouterQueueStatistics. The RouterQueueStatistics is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterQueueStatistics
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "length": 0,
                    "queueId": "str",
                    "estimatedWaitTimeMinutes": {
                        "str": 0.0
                    },
                    "longestJobWaitTimeMinutes": 0.0
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RouterQueueStatistics] = kwargs.pop("cls", None)

        _request = build_job_router_get_queue_statistics_request(
            queue_id=queue_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RouterQueueStatistics, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upsert_worker(
        self,
        worker_id: str,
        resource: _models.RouterWorker,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterWorker:
        """Creates or updates a worker.

        Creates or updates a worker.

        :param worker_id: Id of a worker. Required.
        :type worker_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.communication.jobrouter.models.RouterWorker
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterWorker. The RouterWorker is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterWorker
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "assignedJobs": [
                        {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "capacityCost": 0,
                            "jobId": "str"
                        }
                    ],
                    "availableForOffers": bool,
                    "capacity": 0,
                    "channels": [
                        {
                            "capacityCostPerJob": 0,
                            "channelId": "str",
                            "maxNumberOfJobs": 0
                        }
                    ],
                    "labels": {
                        "str": {}
                    },
                    "loadRatio": 0.0,
                    "maxConcurrentOffers": 0,
                    "offers": [
                        {
                            "capacityCost": 0,
                            "jobId": "str",
                            "offerId": "str",
                            "expiresAt": "2020-02-20 00:00:00",
                            "offeredAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "queues": [
                        "str"
                    ],
                    "state": "str",
                    "tags": {
                        "str": {}
                    }
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignedJobs": [
                        {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "capacityCost": 0,
                            "jobId": "str"
                        }
                    ],
                    "availableForOffers": bool,
                    "capacity": 0,
                    "channels": [
                        {
                            "capacityCostPerJob": 0,
                            "channelId": "str",
                            "maxNumberOfJobs": 0
                        }
                    ],
                    "labels": {
                        "str": {}
                    },
                    "loadRatio": 0.0,
                    "maxConcurrentOffers": 0,
                    "offers": [
                        {
                            "capacityCost": 0,
                            "jobId": "str",
                            "offerId": "str",
                            "expiresAt": "2020-02-20 00:00:00",
                            "offeredAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "queues": [
                        "str"
                    ],
                    "state": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """

    @overload
    async def upsert_worker(
        self,
        worker_id: str,
        resource: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterWorker:
        """Creates or updates a worker.

        Creates or updates a worker.

        :param worker_id: Id of a worker. Required.
        :type worker_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterWorker. The RouterWorker is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterWorker
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignedJobs": [
                        {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "capacityCost": 0,
                            "jobId": "str"
                        }
                    ],
                    "availableForOffers": bool,
                    "capacity": 0,
                    "channels": [
                        {
                            "capacityCostPerJob": 0,
                            "channelId": "str",
                            "maxNumberOfJobs": 0
                        }
                    ],
                    "labels": {
                        "str": {}
                    },
                    "loadRatio": 0.0,
                    "maxConcurrentOffers": 0,
                    "offers": [
                        {
                            "capacityCost": 0,
                            "jobId": "str",
                            "offerId": "str",
                            "expiresAt": "2020-02-20 00:00:00",
                            "offeredAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "queues": [
                        "str"
                    ],
                    "state": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """

    @overload
    async def upsert_worker(
        self,
        worker_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterWorker:
        """Creates or updates a worker.

        Creates or updates a worker.

        :param worker_id: Id of a worker. Required.
        :type worker_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterWorker. The RouterWorker is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterWorker
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignedJobs": [
                        {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "capacityCost": 0,
                            "jobId": "str"
                        }
                    ],
                    "availableForOffers": bool,
                    "capacity": 0,
                    "channels": [
                        {
                            "capacityCostPerJob": 0,
                            "channelId": "str",
                            "maxNumberOfJobs": 0
                        }
                    ],
                    "labels": {
                        "str": {}
                    },
                    "loadRatio": 0.0,
                    "maxConcurrentOffers": 0,
                    "offers": [
                        {
                            "capacityCost": 0,
                            "jobId": "str",
                            "offerId": "str",
                            "expiresAt": "2020-02-20 00:00:00",
                            "offeredAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "queues": [
                        "str"
                    ],
                    "state": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """

    @distributed_trace_async
    async def upsert_worker(
        self,
        worker_id: str,
        resource: Union[_models.RouterWorker, JSON, IO[bytes]],
        *,
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.RouterWorker:
        """Creates or updates a worker.

        Creates or updates a worker.

        :param worker_id: Id of a worker. Required.
        :type worker_id: str
        :param resource: The resource instance. Is one of the following types: RouterWorker, JSON,
         IO[bytes] Required.
        :type resource: ~azure.communication.jobrouter.models.RouterWorker or JSON or IO[bytes]
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: RouterWorker. The RouterWorker is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterWorker
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "etag": "str",
                    "id": "str",
                    "assignedJobs": [
                        {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "capacityCost": 0,
                            "jobId": "str"
                        }
                    ],
                    "availableForOffers": bool,
                    "capacity": 0,
                    "channels": [
                        {
                            "capacityCostPerJob": 0,
                            "channelId": "str",
                            "maxNumberOfJobs": 0
                        }
                    ],
                    "labels": {
                        "str": {}
                    },
                    "loadRatio": 0.0,
                    "maxConcurrentOffers": 0,
                    "offers": [
                        {
                            "capacityCost": 0,
                            "jobId": "str",
                            "offerId": "str",
                            "expiresAt": "2020-02-20 00:00:00",
                            "offeredAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "queues": [
                        "str"
                    ],
                    "state": "str",
                    "tags": {
                        "str": {}
                    }
                }

                # response body for status code(s): 201, 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignedJobs": [
                        {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "capacityCost": 0,
                            "jobId": "str"
                        }
                    ],
                    "availableForOffers": bool,
                    "capacity": 0,
                    "channels": [
                        {
                            "capacityCostPerJob": 0,
                            "channelId": "str",
                            "maxNumberOfJobs": 0
                        }
                    ],
                    "labels": {
                        "str": {}
                    },
                    "loadRatio": 0.0,
                    "maxConcurrentOffers": 0,
                    "offers": [
                        {
                            "capacityCost": 0,
                            "jobId": "str",
                            "offerId": "str",
                            "expiresAt": "2020-02-20 00:00:00",
                            "offeredAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "queues": [
                        "str"
                    ],
                    "state": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RouterWorker] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_job_router_upsert_worker_request(
            worker_id=worker_id,
            if_unmodified_since=if_unmodified_since,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.RouterWorker, response.json())

        if response.status_code == 201:
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.RouterWorker, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_worker(self, worker_id: str, **kwargs: Any) -> _models.RouterWorker:
        """Retrieves an existing worker by Id.

        Retrieves an existing worker by Id.

        :param worker_id: Id of a worker. Required.
        :type worker_id: str
        :return: RouterWorker. The RouterWorker is compatible with MutableMapping
        :rtype: ~azure.communication.jobrouter.models.RouterWorker
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignedJobs": [
                        {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "capacityCost": 0,
                            "jobId": "str"
                        }
                    ],
                    "availableForOffers": bool,
                    "capacity": 0,
                    "channels": [
                        {
                            "capacityCostPerJob": 0,
                            "channelId": "str",
                            "maxNumberOfJobs": 0
                        }
                    ],
                    "labels": {
                        "str": {}
                    },
                    "loadRatio": 0.0,
                    "maxConcurrentOffers": 0,
                    "offers": [
                        {
                            "capacityCost": 0,
                            "jobId": "str",
                            "offerId": "str",
                            "expiresAt": "2020-02-20 00:00:00",
                            "offeredAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "queues": [
                        "str"
                    ],
                    "state": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RouterWorker] = kwargs.pop("cls", None)

        _request = build_job_router_get_worker_request(
            worker_id=worker_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RouterWorker, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_worker(  # pylint: disable=inconsistent-return-statements
        self, worker_id: str, **kwargs: Any
    ) -> None:
        """Deletes a worker and all of its traces.

        Deletes a worker and all of its traces.

        :param worker_id: Id of a worker. Required.
        :type worker_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_job_router_delete_worker_request(
            worker_id=worker_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_workers(
        self,
        *,
        state: Optional[Union[str, _models.RouterWorkerStateSelector]] = None,
        channel_id: Optional[str] = None,
        queue_id: Optional[str] = None,
        has_capacity: Optional[bool] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.RouterWorker"]:
        """Retrieves existing workers.

        Retrieves existing workers.

        :keyword state: If specified, select workers by worker state. Known values are: "active",
         "draining", "inactive", and "all". Default value is None.
        :paramtype state: str or ~azure.communication.jobrouter.models.RouterWorkerStateSelector
        :keyword channel_id: If specified, select workers who have a channel configuration with this
         channel. Default value is None.
        :paramtype channel_id: str
        :keyword queue_id: If specified, select workers who are assigned to this queue. Default value
         is None.
        :paramtype queue_id: str
        :keyword has_capacity: If set to true, select only workers who have capacity for the channel
         specified by ``channelId`` or for any channel if ``channelId`` not specified. If set to false,
         then will return all workers including workers without any capacity for jobs. Defaults to
         false. Default value is None.
        :paramtype has_capacity: bool
        :return: An iterator like instance of RouterWorker
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.communication.jobrouter.models.RouterWorker]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",
                    "id": "str",
                    "assignedJobs": [
                        {
                            "assignedAt": "2020-02-20 00:00:00",
                            "assignmentId": "str",
                            "capacityCost": 0,
                            "jobId": "str"
                        }
                    ],
                    "availableForOffers": bool,
                    "capacity": 0,
                    "channels": [
                        {
                            "capacityCostPerJob": 0,
                            "channelId": "str",
                            "maxNumberOfJobs": 0
                        }
                    ],
                    "labels": {
                        "str": {}
                    },
                    "loadRatio": 0.0,
                    "maxConcurrentOffers": 0,
                    "offers": [
                        {
                            "capacityCost": 0,
                            "jobId": "str",
                            "offerId": "str",
                            "expiresAt": "2020-02-20 00:00:00",
                            "offeredAt": "2020-02-20 00:00:00"
                        }
                    ],
                    "queues": [
                        "str"
                    ],
                    "state": "str",
                    "tags": {
                        "str": {}
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        maxpagesize = kwargs.pop("maxpagesize", None)
        cls: ClsType[List[_models.RouterWorker]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_job_router_list_workers_request(
                    maxpagesize=maxpagesize,
                    state=state,
                    channel_id=channel_id,
                    queue_id=queue_id,
                    has_capacity=has_capacity,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.RouterWorker], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)
