# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.polling.async_base_polling import AsyncLROBasePolling
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async

from ... import models as _models
from ...operations._operations import build_question_answering_projects_add_feedback_request, build_question_answering_projects_create_project_request, build_question_answering_projects_delete_project_request, build_question_answering_projects_deploy_project_request_initial, build_question_answering_projects_export_request_initial, build_question_answering_projects_get_delete_status_request, build_question_answering_projects_get_deploy_status_request, build_question_answering_projects_get_export_status_request, build_question_answering_projects_get_import_status_request, build_question_answering_projects_get_project_details_request, build_question_answering_projects_get_qnas_request, build_question_answering_projects_get_sources_request, build_question_answering_projects_get_synonyms_request, build_question_answering_projects_get_update_qnas_status_request, build_question_answering_projects_get_update_sources_status_request, build_question_answering_projects_import_method_request_initial, build_question_answering_projects_list_deployments_request, build_question_answering_projects_list_projects_request, build_question_answering_projects_update_qnas_request_initial, build_question_answering_projects_update_sources_request_initial, build_question_answering_projects_update_synonyms_request
T = TypeVar('T')
JSONType = Any
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class QuestionAnsweringProjectsOperations:
    """QuestionAnsweringProjectsOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.ai.language.questionanswering.projects.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace
    def list_projects(
        self,
        *,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.ProjectsMetadata"]:
        """Gets all projects for a user.

        Gets all projects for a user.

        :keyword top: The maximum number of resources to return from the collection.
        :paramtype top: int
        :keyword skip: An offset into the collection of the first resource to be returned.
        :paramtype skip: int
        :keyword maxpagesize: The maximum number of resources to include in a single response.
        :paramtype maxpagesize: int
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of ProjectsMetadata
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.language.questionanswering.projects.models.ProjectsMetadata]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ProjectsMetadata"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_question_answering_projects_list_projects_request(
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_projects.metadata['url'],
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_question_answering_projects_list_projects_request(
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("ProjectsMetadata", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_projects.metadata = {'url': '/query-knowledgebases/projects'}  # type: ignore

    @distributed_trace_async
    async def get_project_details(
        self,
        project_name: str,
        **kwargs: Any
    ) -> "_models.ProjectMetadata":
        """Get the requested project metadata.

        Get the requested project metadata.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: ProjectMetadata
        :rtype: ~azure.ai.language.questionanswering.projects.models.ProjectMetadata
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ProjectMetadata"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_project_details_request(
            project_name=project_name,
            api_version=api_version,
            template_url=self.get_project_details.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('ProjectMetadata', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_details.metadata = {'url': '/query-knowledgebases/projects/{projectName}'}  # type: ignore


    @distributed_trace_async
    async def create_project(
        self,
        project_name: str,
        body: "_models.CreateProjectOptions",
        **kwargs: Any
    ) -> "_models.ProjectMetadata":
        """Create or update a project.

        Create or update a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: Parameters needed to create the project.
        :type body: ~azure.ai.language.questionanswering.projects.models.CreateProjectOptions
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: ProjectMetadata
        :rtype: ~azure.ai.language.questionanswering.projects.models.ProjectMetadata
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ProjectMetadata"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'CreateProjectOptions')

        request = build_question_answering_projects_create_project_request(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            template_url=self.create_project.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if response.status_code == 200:
            deserialized = self._deserialize('ProjectMetadata', pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize('ProjectMetadata', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project.metadata = {'url': '/query-knowledgebases/projects/{projectName}'}  # type: ignore


    @distributed_trace_async
    async def delete_project(
        self,
        project_name: str,
        **kwargs: Any
    ) -> None:
        """Delete the project.

        Delete the project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_delete_project_request(
            project_name=project_name,
            api_version=api_version,
            template_url=self.delete_project.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    delete_project.metadata = {'url': '/query-knowledgebases/projects/{projectName}'}  # type: ignore


    @distributed_trace_async
    async def get_delete_status(
        self,
        job_id: str,
        **kwargs: Any
    ) -> "_models.JobState":
        """Gets the status of a Project delete job.

        Gets the status of a Project delete job.

        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.JobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_delete_status_request(
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_delete_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('JobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_delete_status.metadata = {'url': '/query-knowledgebases/projects/deletion-jobs/{jobId}'}  # type: ignore


    async def _export_initial(
        self,
        project_name: str,
        *,
        format: Optional[Union[str, "_models.Format"]] = "json",
        asset_kind: Optional[Union[str, "_models.Enum4"]] = None,
        **kwargs: Any
    ) -> None:
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_export_request_initial(
            project_name=project_name,
            api_version=api_version,
            format=format,
            asset_kind=asset_kind,
            template_url=self._export_initial.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    _export_initial.metadata = {'url': '/query-knowledgebases/projects/{projectName}/:export'}  # type: ignore


    @distributed_trace_async
    async def begin_export(
        self,
        project_name: str,
        *,
        format: Optional[Union[str, "_models.Format"]] = "json",
        asset_kind: Optional[Union[str, "_models.Enum4"]] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Export project metadata and assets.

        Export project metadata and assets.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword format: Knowledge base Import or Export format.
        :paramtype format: str or ~azure.ai.language.questionanswering.projects.models.Format
        :keyword asset_kind: Kind of the asset of the project.
        :paramtype asset_kind: str or ~azure.ai.language.questionanswering.projects.models.Enum4
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
         for this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        polling = kwargs.pop('polling', True)  # type: Union[bool, azure.core.polling.AsyncPollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._export_initial(
                project_name=project_name,
                format=format,
                asset_kind=asset_kind,
                api_version=api_version,
                cls=lambda x,y,z: x,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True: polling_method = AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
        elif polling is False: polling_method = AsyncNoPolling()
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    begin_export.metadata = {'url': '/query-knowledgebases/projects/{projectName}/:export'}  # type: ignore

    @distributed_trace_async
    async def get_export_status(
        self,
        project_name: str,
        job_id: str,
        **kwargs: Any
    ) -> "_models.ExportJobState":
        """Gets the status of an Export job, once job completes, returns the project metadata, and assets.

        Gets the status of an Export job, once job completes, returns the project metadata, and assets.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: ExportJobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.ExportJobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ExportJobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_export_status_request(
            project_name=project_name,
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_export_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('ExportJobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_export_status.metadata = {'url': '/query-knowledgebases/projects/{projectName}/export/jobs/{jobId}'}  # type: ignore


    async def _import_method_initial(
        self,
        project_name: str,
        body: Optional["_models.ImportJobOptions"] = None,
        *,
        format: Optional[Union[str, "_models.Format"]] = "json",
        asset_kind: Optional[Union[str, "_models.Enum4"]] = None,
        **kwargs: Any
    ) -> None:
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            json = self._serialize.body(body, 'ImportJobOptions')
        else:
            json = None

        request = build_question_answering_projects_import_method_request_initial(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            format=format,
            asset_kind=asset_kind,
            template_url=self._import_method_initial.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    _import_method_initial.metadata = {'url': '/query-knowledgebases/projects/{projectName}/:import'}  # type: ignore


    @distributed_trace_async
    async def begin_import_method(
        self,
        project_name: str,
        body: Optional["_models.ImportJobOptions"] = None,
        *,
        format: Optional[Union[str, "_models.Format"]] = "json",
        asset_kind: Optional[Union[str, "_models.Enum4"]] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Import project assets.

        Import project assets.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: Project assets the needs to be imported.
        :type body: ~azure.ai.language.questionanswering.projects.models.ImportJobOptions
        :keyword format: Knowledge base Import or Export format.
        :paramtype format: str or ~azure.ai.language.questionanswering.projects.models.Format
        :keyword asset_kind: Kind of the asset of the project.
        :paramtype asset_kind: str or ~azure.ai.language.questionanswering.projects.models.Enum4
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
         for this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]
        polling = kwargs.pop('polling', True)  # type: Union[bool, azure.core.polling.AsyncPollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._import_method_initial(
                project_name=project_name,
                body=body,
                format=format,
                asset_kind=asset_kind,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x,y,z: x,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True: polling_method = AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
        elif polling is False: polling_method = AsyncNoPolling()
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    begin_import_method.metadata = {'url': '/query-knowledgebases/projects/{projectName}/:import'}  # type: ignore

    @distributed_trace_async
    async def get_import_status(
        self,
        project_name: str,
        job_id: str,
        **kwargs: Any
    ) -> "_models.JobState":
        """Gets the status of an Import job.

        Gets the status of an Import job.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.JobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_import_status_request(
            project_name=project_name,
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_import_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('JobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_import_status.metadata = {'url': '/query-knowledgebases/projects/{projectName}/import/jobs/{jobId}'}  # type: ignore


    async def _deploy_project_initial(
        self,
        project_name: str,
        deployment_name: str,
        **kwargs: Any
    ) -> None:
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_deploy_project_request_initial(
            project_name=project_name,
            deployment_name=deployment_name,
            api_version=api_version,
            template_url=self._deploy_project_initial.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    _deploy_project_initial.metadata = {'url': '/query-knowledgebases/projects/{projectName}/deployments/{deploymentName}'}  # type: ignore


    @distributed_trace_async
    async def begin_deploy_project(
        self,
        project_name: str,
        deployment_name: str,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deploy project to production.

        Deploy project to production.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param deployment_name: The name of the specific deployment of the project to use.
        :type deployment_name: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
         for this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        polling = kwargs.pop('polling', True)  # type: Union[bool, azure.core.polling.AsyncPollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._deploy_project_initial(
                project_name=project_name,
                deployment_name=deployment_name,
                api_version=api_version,
                cls=lambda x,y,z: x,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True: polling_method = AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
        elif polling is False: polling_method = AsyncNoPolling()
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    begin_deploy_project.metadata = {'url': '/query-knowledgebases/projects/{projectName}/deployments/{deploymentName}'}  # type: ignore

    @distributed_trace_async
    async def get_deploy_status(
        self,
        project_name: str,
        deployment_name: str,
        job_id: str,
        **kwargs: Any
    ) -> "_models.JobState":
        """Gets the status of a Deploy job.

        Gets the status of a Deploy job.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param deployment_name: The name of the specific deployment of the project to use.
        :type deployment_name: str
        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.JobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_deploy_status_request(
            project_name=project_name,
            deployment_name=deployment_name,
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_deploy_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('JobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_deploy_status.metadata = {'url': '/query-knowledgebases/projects/{projectName}/deployments/{deploymentName}/jobs/{jobId}'}  # type: ignore


    @distributed_trace
    def list_deployments(
        self,
        project_name: str,
        *,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.ProjectDeployments"]:
        """List all deployments of a project.

        List all deployments of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword top: The maximum number of resources to return from the collection.
        :paramtype top: int
        :keyword skip: An offset into the collection of the first resource to be returned.
        :paramtype skip: int
        :keyword maxpagesize: The maximum number of resources to include in a single response.
        :paramtype maxpagesize: int
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of ProjectDeployments
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.language.questionanswering.projects.models.ProjectDeployments]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ProjectDeployments"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_question_answering_projects_list_deployments_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_deployments.metadata['url'],
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_question_answering_projects_list_deployments_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("ProjectDeployments", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_deployments.metadata = {'url': '/query-knowledgebases/projects/{projectName}/deployments'}  # type: ignore

    @distributed_trace
    def get_synonyms(
        self,
        project_name: str,
        *,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.SynonymAssets"]:
        """Gets all the synonyms of a project.

        Gets all the synonyms of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword top: The maximum number of resources to return from the collection.
        :paramtype top: int
        :keyword skip: An offset into the collection of the first resource to be returned.
        :paramtype skip: int
        :keyword maxpagesize: The maximum number of resources to include in a single response.
        :paramtype maxpagesize: int
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of SynonymAssets
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.language.questionanswering.projects.models.SynonymAssets]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SynonymAssets"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_question_answering_projects_get_synonyms_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_synonyms.metadata['url'],
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_question_answering_projects_get_synonyms_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("SynonymAssets", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    get_synonyms.metadata = {'url': '/query-knowledgebases/projects/{projectName}/synonyms'}  # type: ignore

    @distributed_trace_async
    async def update_synonyms(
        self,
        project_name: str,
        body: "_models.SynonymAssets",
        **kwargs: Any
    ) -> None:
        """Updates all the synonyms of a project.

        Updates all the synonyms of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: All the synonyms of a project.
        :type body: ~azure.ai.language.questionanswering.projects.models.SynonymAssets
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'SynonymAssets')

        request = build_question_answering_projects_update_synonyms_request(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            template_url=self.update_synonyms.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    update_synonyms.metadata = {'url': '/query-knowledgebases/projects/{projectName}/synonyms'}  # type: ignore


    @distributed_trace
    def get_sources(
        self,
        project_name: str,
        *,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.QnaSources"]:
        """Gets all the sources of a project.

        Gets all the sources of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword top: The maximum number of resources to return from the collection.
        :paramtype top: int
        :keyword skip: An offset into the collection of the first resource to be returned.
        :paramtype skip: int
        :keyword maxpagesize: The maximum number of resources to include in a single response.
        :paramtype maxpagesize: int
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of QnaSources
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.language.questionanswering.projects.models.QnaSources]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.QnaSources"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_question_answering_projects_get_sources_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_sources.metadata['url'],
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_question_answering_projects_get_sources_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("QnaSources", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    get_sources.metadata = {'url': '/query-knowledgebases/projects/{projectName}/sources'}  # type: ignore

    async def _update_sources_initial(
        self,
        project_name: str,
        body: List["_models.UpdateSourceRecord"],
        **kwargs: Any
    ) -> None:
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, '[UpdateSourceRecord]')

        request = build_question_answering_projects_update_sources_request_initial(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            template_url=self._update_sources_initial.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    _update_sources_initial.metadata = {'url': '/query-knowledgebases/projects/{projectName}/sources'}  # type: ignore


    @distributed_trace_async
    async def begin_update_sources(
        self,
        project_name: str,
        body: List["_models.UpdateSourceRecord"],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Updates the sources of a project.

        Updates the sources of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: Update sources parameters of a project.
        :type body: list[~azure.ai.language.questionanswering.projects.models.UpdateSourceRecord]
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
         for this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]
        polling = kwargs.pop('polling', True)  # type: Union[bool, azure.core.polling.AsyncPollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_sources_initial(
                project_name=project_name,
                body=body,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x,y,z: x,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True: polling_method = AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
        elif polling is False: polling_method = AsyncNoPolling()
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    begin_update_sources.metadata = {'url': '/query-knowledgebases/projects/{projectName}/sources'}  # type: ignore

    @distributed_trace_async
    async def get_update_sources_status(
        self,
        project_name: str,
        job_id: str,
        **kwargs: Any
    ) -> "_models.JobState":
        """Gets the status of update sources job.

        Gets the status of update sources job.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.JobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_update_sources_status_request(
            project_name=project_name,
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_update_sources_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('JobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_update_sources_status.metadata = {'url': '/query-knowledgebases/projects/{projectName}/sources/jobs/{jobId}'}  # type: ignore


    @distributed_trace
    def get_qnas(
        self,
        project_name: str,
        *,
        source: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.QnaAssets"]:
        """Gets all the QnAs of a project.

        Gets all the QnAs of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword source: Source of the QnA.
        :paramtype source: str
        :keyword top: The maximum number of resources to return from the collection.
        :paramtype top: int
        :keyword skip: An offset into the collection of the first resource to be returned.
        :paramtype skip: int
        :keyword maxpagesize: The maximum number of resources to include in a single response.
        :paramtype maxpagesize: int
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of QnaAssets
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.language.questionanswering.projects.models.QnaAssets]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.QnaAssets"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_question_answering_projects_get_qnas_request(
                    project_name=project_name,
                    api_version=api_version,
                    source=source,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_qnas.metadata['url'],
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_question_answering_projects_get_qnas_request(
                    project_name=project_name,
                    api_version=api_version,
                    source=source,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("QnaAssets", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    get_qnas.metadata = {'url': '/query-knowledgebases/projects/{projectName}/qnas'}  # type: ignore

    async def _update_qnas_initial(
        self,
        project_name: str,
        body: List["_models.UpdateQnaRecord"],
        **kwargs: Any
    ) -> None:
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, '[UpdateQnaRecord]')

        request = build_question_answering_projects_update_qnas_request_initial(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            template_url=self._update_qnas_initial.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    _update_qnas_initial.metadata = {'url': '/query-knowledgebases/projects/{projectName}/qnas'}  # type: ignore


    @distributed_trace_async
    async def begin_update_qnas(
        self,
        project_name: str,
        body: List["_models.UpdateQnaRecord"],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Updates the QnAs of a project.

        Updates the QnAs of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: Update QnAs parameters of a project.
        :type body: list[~azure.ai.language.questionanswering.projects.models.UpdateQnaRecord]
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
         for this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]
        polling = kwargs.pop('polling', True)  # type: Union[bool, azure.core.polling.AsyncPollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_qnas_initial(
                project_name=project_name,
                body=body,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x,y,z: x,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True: polling_method = AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
        elif polling is False: polling_method = AsyncNoPolling()
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    begin_update_qnas.metadata = {'url': '/query-knowledgebases/projects/{projectName}/qnas'}  # type: ignore

    @distributed_trace_async
    async def get_update_qnas_status(
        self,
        project_name: str,
        job_id: str,
        **kwargs: Any
    ) -> "_models.JobState":
        """Gets the status of update QnAs job.

        Gets the status of update QnAs job.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.JobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_update_qnas_status_request(
            project_name=project_name,
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_update_qnas_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('JobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_update_qnas_status.metadata = {'url': '/query-knowledgebases/projects/{projectName}/qnas/jobs/{jobId}'}  # type: ignore


    @distributed_trace_async
    async def add_feedback(
        self,
        project_name: str,
        body: "_models.ActiveLearningFeedback",
        **kwargs: Any
    ) -> None:
        """Update Active Learning feedback.

        Update Active Learning feedback.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: Feedback for Active Learning.
        :type body: ~azure.ai.language.questionanswering.projects.models.ActiveLearningFeedback
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'ActiveLearningFeedback')

        request = build_question_answering_projects_add_feedback_request(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            template_url=self.add_feedback.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    add_feedback.metadata = {'url': '/query-knowledgebases/projects/{projectName}/feedback'}  # type: ignore

