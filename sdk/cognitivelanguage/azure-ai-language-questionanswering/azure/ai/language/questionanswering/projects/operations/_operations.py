# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from msrest import Serializer

from .. import models as _models
from .._vendor import _format_url_section

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, List, Optional, TypeVar, Union
    T = TypeVar('T')
    JSONType = Any
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False
# fmt: off

def build_question_answering_projects_list_projects_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    top = kwargs.pop('top', None)  # type: Optional[int]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    if top is not None:
        query_parameters['top'] = _SERIALIZER.query("top", top, 'int')
    if skip is not None:
        query_parameters['skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_get_project_details_request(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_create_project_request(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_delete_project_request(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_get_delete_status_request(
    job_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/deletion-jobs/{jobId}')
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_export_request_initial(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    format = kwargs.pop('format', "json")  # type: Optional[Union[str, "_models.Format"]]
    asset_kind = kwargs.pop('asset_kind', None)  # type: Optional[Union[str, "_models.Enum4"]]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/:export')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    if format is not None:
        query_parameters['format'] = _SERIALIZER.query("format", format, 'str')
    if asset_kind is not None:
        query_parameters['assetKind'] = _SERIALIZER.query("asset_kind", asset_kind, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_get_export_status_request(
    project_name,  # type: str
    job_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/export/jobs/{jobId}')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
        "jobId": _SERIALIZER.url("job_id", job_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_import_method_request_initial(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    format = kwargs.pop('format', "json")  # type: Optional[Union[str, "_models.Format"]]
    asset_kind = kwargs.pop('asset_kind', None)  # type: Optional[Union[str, "_models.Enum4"]]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/:import')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    if format is not None:
        query_parameters['format'] = _SERIALIZER.query("format", format, 'str')
    if asset_kind is not None:
        query_parameters['assetKind'] = _SERIALIZER.query("asset_kind", asset_kind, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_get_import_status_request(
    project_name,  # type: str
    job_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/import/jobs/{jobId}')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
        "jobId": _SERIALIZER.url("job_id", job_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_deploy_project_request_initial(
    project_name,  # type: str
    deployment_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/deployments/{deploymentName}')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
        "deploymentName": _SERIALIZER.url("deployment_name", deployment_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_get_deploy_status_request(
    project_name,  # type: str
    deployment_name,  # type: str
    job_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/deployments/{deploymentName}/jobs/{jobId}')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
        "deploymentName": _SERIALIZER.url("deployment_name", deployment_name, 'str'),
        "jobId": _SERIALIZER.url("job_id", job_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_list_deployments_request(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    top = kwargs.pop('top', None)  # type: Optional[int]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/deployments')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    if top is not None:
        query_parameters['top'] = _SERIALIZER.query("top", top, 'int')
    if skip is not None:
        query_parameters['skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_get_synonyms_request(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    top = kwargs.pop('top', None)  # type: Optional[int]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/synonyms')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    if top is not None:
        query_parameters['top'] = _SERIALIZER.query("top", top, 'int')
    if skip is not None:
        query_parameters['skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_update_synonyms_request(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/synonyms')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_get_sources_request(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    top = kwargs.pop('top', None)  # type: Optional[int]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/sources')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    if top is not None:
        query_parameters['top'] = _SERIALIZER.query("top", top, 'int')
    if skip is not None:
        query_parameters['skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_update_sources_request_initial(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/sources')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_get_update_sources_status_request(
    project_name,  # type: str
    job_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/sources/jobs/{jobId}')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
        "jobId": _SERIALIZER.url("job_id", job_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_get_qnas_request(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    source = kwargs.pop('source', None)  # type: Optional[str]
    top = kwargs.pop('top', None)  # type: Optional[int]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/qnas')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')
    if source is not None:
        query_parameters['source'] = _SERIALIZER.query("source", source, 'str')
    if top is not None:
        query_parameters['top'] = _SERIALIZER.query("top", top, 'int')
    if skip is not None:
        query_parameters['skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_update_qnas_request_initial(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/qnas')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_get_update_qnas_status_request(
    project_name,  # type: str
    job_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/qnas/jobs/{jobId}')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
        "jobId": _SERIALIZER.url("job_id", job_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_projects_add_feedback_request(
    project_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/query-knowledgebases/projects/{projectName}/feedback')
    path_format_arguments = {
        "projectName": _SERIALIZER.url("project_name", project_name, 'str', max_length=100, min_length=0),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )

# fmt: on
class QuestionAnsweringProjectsOperations(object):
    """QuestionAnsweringProjectsOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.ai.language.questionanswering.projects.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace
    def list_projects(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProjectsMetadata"]
        """Gets all projects for a user.

        Gets all projects for a user.

        :keyword top: The maximum number of resources to return from the collection.
        :paramtype top: int
        :keyword skip: An offset into the collection of the first resource to be returned.
        :paramtype skip: int
        :keyword maxpagesize: The maximum number of resources to include in a single response.
        :paramtype maxpagesize: int
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of ProjectsMetadata
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.ai.language.questionanswering.projects.models.ProjectsMetadata]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        top = kwargs.pop('top', None)  # type: Optional[int]
        skip = kwargs.pop('skip', None)  # type: Optional[int]
        maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ProjectsMetadata"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_question_answering_projects_list_projects_request(
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_projects.metadata['url'],
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_question_answering_projects_list_projects_request(
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("ProjectsMetadata", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    list_projects.metadata = {'url': '/query-knowledgebases/projects'}  # type: ignore

    @distributed_trace
    def get_project_details(
        self,
        project_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.ProjectMetadata"
        """Get the requested project metadata.

        Get the requested project metadata.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: ProjectMetadata
        :rtype: ~azure.ai.language.questionanswering.projects.models.ProjectMetadata
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ProjectMetadata"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_project_details_request(
            project_name=project_name,
            api_version=api_version,
            template_url=self.get_project_details.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('ProjectMetadata', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_details.metadata = {'url': '/query-knowledgebases/projects/{projectName}'}  # type: ignore


    @distributed_trace
    def create_project(
        self,
        project_name,  # type: str
        body,  # type: "_models.CreateProjectOptions"
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.ProjectMetadata"
        """Create or update a project.

        Create or update a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: Parameters needed to create the project.
        :type body: ~azure.ai.language.questionanswering.projects.models.CreateProjectOptions
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: ProjectMetadata
        :rtype: ~azure.ai.language.questionanswering.projects.models.ProjectMetadata
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ProjectMetadata"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'CreateProjectOptions')

        request = build_question_answering_projects_create_project_request(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            template_url=self.create_project.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if response.status_code == 200:
            deserialized = self._deserialize('ProjectMetadata', pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize('ProjectMetadata', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project.metadata = {'url': '/query-knowledgebases/projects/{projectName}'}  # type: ignore


    @distributed_trace
    def delete_project(
        self,
        project_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete the project.

        Delete the project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_delete_project_request(
            project_name=project_name,
            api_version=api_version,
            template_url=self.delete_project.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    delete_project.metadata = {'url': '/query-knowledgebases/projects/{projectName}'}  # type: ignore


    @distributed_trace
    def get_delete_status(
        self,
        job_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.JobState"
        """Gets the status of a Project delete job.

        Gets the status of a Project delete job.

        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.JobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_delete_status_request(
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_delete_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('JobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_delete_status.metadata = {'url': '/query-knowledgebases/projects/deletion-jobs/{jobId}'}  # type: ignore


    def _export_initial(
        self,
        project_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        format = kwargs.pop('format', "json")  # type: Optional[Union[str, "_models.Format"]]
        asset_kind = kwargs.pop('asset_kind', None)  # type: Optional[Union[str, "_models.Enum4"]]

        
        request = build_question_answering_projects_export_request_initial(
            project_name=project_name,
            api_version=api_version,
            format=format,
            asset_kind=asset_kind,
            template_url=self._export_initial.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    _export_initial.metadata = {'url': '/query-knowledgebases/projects/{projectName}/:export'}  # type: ignore


    @distributed_trace
    def begin_export(
        self,
        project_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller[None]
        """Export project metadata and assets.

        Export project metadata and assets.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword format: Knowledge base Import or Export format.
        :paramtype format: str or ~azure.ai.language.questionanswering.projects.models.Format
        :keyword asset_kind: Kind of the asset of the project.
        :paramtype asset_kind: str or ~azure.ai.language.questionanswering.projects.models.Enum4
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        format = kwargs.pop('format', "json")  # type: Optional[Union[str, "_models.Format"]]
        asset_kind = kwargs.pop('asset_kind', None)  # type: Optional[Union[str, "_models.Enum4"]]
        polling = kwargs.pop('polling', True)  # type: Union[bool, azure.core.polling.PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._export_initial(
                project_name=project_name,
                format=format,
                asset_kind=asset_kind,
                api_version=api_version,
                cls=lambda x,y,z: x,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True: polling_method = LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    begin_export.metadata = {'url': '/query-knowledgebases/projects/{projectName}/:export'}  # type: ignore

    @distributed_trace
    def get_export_status(
        self,
        project_name,  # type: str
        job_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.ExportJobState"
        """Gets the status of an Export job, once job completes, returns the project metadata, and assets.

        Gets the status of an Export job, once job completes, returns the project metadata, and assets.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: ExportJobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.ExportJobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ExportJobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_export_status_request(
            project_name=project_name,
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_export_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('ExportJobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_export_status.metadata = {'url': '/query-knowledgebases/projects/{projectName}/export/jobs/{jobId}'}  # type: ignore


    def _import_method_initial(
        self,
        project_name,  # type: str
        body=None,  # type: Optional["_models.ImportJobOptions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]
        format = kwargs.pop('format', "json")  # type: Optional[Union[str, "_models.Format"]]
        asset_kind = kwargs.pop('asset_kind', None)  # type: Optional[Union[str, "_models.Enum4"]]

        if body is not None:
            json = self._serialize.body(body, 'ImportJobOptions')
        else:
            json = None

        request = build_question_answering_projects_import_method_request_initial(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            format=format,
            asset_kind=asset_kind,
            template_url=self._import_method_initial.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    _import_method_initial.metadata = {'url': '/query-knowledgebases/projects/{projectName}/:import'}  # type: ignore


    @distributed_trace
    def begin_import_method(
        self,
        project_name,  # type: str
        body=None,  # type: Optional["_models.ImportJobOptions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller[None]
        """Import project assets.

        Import project assets.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: Project assets the needs to be imported.
        :type body: ~azure.ai.language.questionanswering.projects.models.ImportJobOptions
        :keyword format: Knowledge base Import or Export format.
        :paramtype format: str or ~azure.ai.language.questionanswering.projects.models.Format
        :keyword asset_kind: Kind of the asset of the project.
        :paramtype asset_kind: str or ~azure.ai.language.questionanswering.projects.models.Enum4
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]
        format = kwargs.pop('format', "json")  # type: Optional[Union[str, "_models.Format"]]
        asset_kind = kwargs.pop('asset_kind', None)  # type: Optional[Union[str, "_models.Enum4"]]
        polling = kwargs.pop('polling', True)  # type: Union[bool, azure.core.polling.PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._import_method_initial(
                project_name=project_name,
                body=body,
                format=format,
                asset_kind=asset_kind,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x,y,z: x,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True: polling_method = LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    begin_import_method.metadata = {'url': '/query-knowledgebases/projects/{projectName}/:import'}  # type: ignore

    @distributed_trace
    def get_import_status(
        self,
        project_name,  # type: str
        job_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.JobState"
        """Gets the status of an Import job.

        Gets the status of an Import job.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.JobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_import_status_request(
            project_name=project_name,
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_import_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('JobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_import_status.metadata = {'url': '/query-knowledgebases/projects/{projectName}/import/jobs/{jobId}'}  # type: ignore


    def _deploy_project_initial(
        self,
        project_name,  # type: str
        deployment_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_deploy_project_request_initial(
            project_name=project_name,
            deployment_name=deployment_name,
            api_version=api_version,
            template_url=self._deploy_project_initial.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    _deploy_project_initial.metadata = {'url': '/query-knowledgebases/projects/{projectName}/deployments/{deploymentName}'}  # type: ignore


    @distributed_trace
    def begin_deploy_project(
        self,
        project_name,  # type: str
        deployment_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller[None]
        """Deploy project to production.

        Deploy project to production.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param deployment_name: The name of the specific deployment of the project to use.
        :type deployment_name: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        polling = kwargs.pop('polling', True)  # type: Union[bool, azure.core.polling.PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._deploy_project_initial(
                project_name=project_name,
                deployment_name=deployment_name,
                api_version=api_version,
                cls=lambda x,y,z: x,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True: polling_method = LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    begin_deploy_project.metadata = {'url': '/query-knowledgebases/projects/{projectName}/deployments/{deploymentName}'}  # type: ignore

    @distributed_trace
    def get_deploy_status(
        self,
        project_name,  # type: str
        deployment_name,  # type: str
        job_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.JobState"
        """Gets the status of a Deploy job.

        Gets the status of a Deploy job.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param deployment_name: The name of the specific deployment of the project to use.
        :type deployment_name: str
        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.JobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_deploy_status_request(
            project_name=project_name,
            deployment_name=deployment_name,
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_deploy_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('JobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_deploy_status.metadata = {'url': '/query-knowledgebases/projects/{projectName}/deployments/{deploymentName}/jobs/{jobId}'}  # type: ignore


    @distributed_trace
    def list_deployments(
        self,
        project_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProjectDeployments"]
        """List all deployments of a project.

        List all deployments of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword top: The maximum number of resources to return from the collection.
        :paramtype top: int
        :keyword skip: An offset into the collection of the first resource to be returned.
        :paramtype skip: int
        :keyword maxpagesize: The maximum number of resources to include in a single response.
        :paramtype maxpagesize: int
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of ProjectDeployments
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.ai.language.questionanswering.projects.models.ProjectDeployments]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        top = kwargs.pop('top', None)  # type: Optional[int]
        skip = kwargs.pop('skip', None)  # type: Optional[int]
        maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ProjectDeployments"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_question_answering_projects_list_deployments_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_deployments.metadata['url'],
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_question_answering_projects_list_deployments_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("ProjectDeployments", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    list_deployments.metadata = {'url': '/query-knowledgebases/projects/{projectName}/deployments'}  # type: ignore

    @distributed_trace
    def get_synonyms(
        self,
        project_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.SynonymAssets"]
        """Gets all the synonyms of a project.

        Gets all the synonyms of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword top: The maximum number of resources to return from the collection.
        :paramtype top: int
        :keyword skip: An offset into the collection of the first resource to be returned.
        :paramtype skip: int
        :keyword maxpagesize: The maximum number of resources to include in a single response.
        :paramtype maxpagesize: int
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of SynonymAssets
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.ai.language.questionanswering.projects.models.SynonymAssets]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        top = kwargs.pop('top', None)  # type: Optional[int]
        skip = kwargs.pop('skip', None)  # type: Optional[int]
        maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SynonymAssets"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_question_answering_projects_get_synonyms_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_synonyms.metadata['url'],
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_question_answering_projects_get_synonyms_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("SynonymAssets", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_synonyms.metadata = {'url': '/query-knowledgebases/projects/{projectName}/synonyms'}  # type: ignore

    @distributed_trace
    def update_synonyms(
        self,
        project_name,  # type: str
        body,  # type: "_models.SynonymAssets"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Updates all the synonyms of a project.

        Updates all the synonyms of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: All the synonyms of a project.
        :type body: ~azure.ai.language.questionanswering.projects.models.SynonymAssets
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'SynonymAssets')

        request = build_question_answering_projects_update_synonyms_request(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            template_url=self.update_synonyms.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    update_synonyms.metadata = {'url': '/query-knowledgebases/projects/{projectName}/synonyms'}  # type: ignore


    @distributed_trace
    def get_sources(
        self,
        project_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.QnaSources"]
        """Gets all the sources of a project.

        Gets all the sources of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword top: The maximum number of resources to return from the collection.
        :paramtype top: int
        :keyword skip: An offset into the collection of the first resource to be returned.
        :paramtype skip: int
        :keyword maxpagesize: The maximum number of resources to include in a single response.
        :paramtype maxpagesize: int
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of QnaSources
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.ai.language.questionanswering.projects.models.QnaSources]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        top = kwargs.pop('top', None)  # type: Optional[int]
        skip = kwargs.pop('skip', None)  # type: Optional[int]
        maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.QnaSources"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_question_answering_projects_get_sources_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_sources.metadata['url'],
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_question_answering_projects_get_sources_request(
                    project_name=project_name,
                    api_version=api_version,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("QnaSources", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_sources.metadata = {'url': '/query-knowledgebases/projects/{projectName}/sources'}  # type: ignore

    def _update_sources_initial(
        self,
        project_name,  # type: str
        body,  # type: List["_models.UpdateSourceRecord"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, '[UpdateSourceRecord]')

        request = build_question_answering_projects_update_sources_request_initial(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            template_url=self._update_sources_initial.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    _update_sources_initial.metadata = {'url': '/query-knowledgebases/projects/{projectName}/sources'}  # type: ignore


    @distributed_trace
    def begin_update_sources(
        self,
        project_name,  # type: str
        body,  # type: List["_models.UpdateSourceRecord"]
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller[None]
        """Updates the sources of a project.

        Updates the sources of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: Update sources parameters of a project.
        :type body: list[~azure.ai.language.questionanswering.projects.models.UpdateSourceRecord]
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]
        polling = kwargs.pop('polling', True)  # type: Union[bool, azure.core.polling.PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._update_sources_initial(
                project_name=project_name,
                body=body,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x,y,z: x,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True: polling_method = LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    begin_update_sources.metadata = {'url': '/query-knowledgebases/projects/{projectName}/sources'}  # type: ignore

    @distributed_trace
    def get_update_sources_status(
        self,
        project_name,  # type: str
        job_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.JobState"
        """Gets the status of update sources job.

        Gets the status of update sources job.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.JobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_update_sources_status_request(
            project_name=project_name,
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_update_sources_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('JobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_update_sources_status.metadata = {'url': '/query-knowledgebases/projects/{projectName}/sources/jobs/{jobId}'}  # type: ignore


    @distributed_trace
    def get_qnas(
        self,
        project_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.QnaAssets"]
        """Gets all the QnAs of a project.

        Gets all the QnAs of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :keyword source: Source of the QnA.
        :paramtype source: str
        :keyword top: The maximum number of resources to return from the collection.
        :paramtype top: int
        :keyword skip: An offset into the collection of the first resource to be returned.
        :paramtype skip: int
        :keyword maxpagesize: The maximum number of resources to include in a single response.
        :paramtype maxpagesize: int
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of QnaAssets
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.ai.language.questionanswering.projects.models.QnaAssets]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        source = kwargs.pop('source', None)  # type: Optional[str]
        top = kwargs.pop('top', None)  # type: Optional[int]
        skip = kwargs.pop('skip', None)  # type: Optional[int]
        maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.QnaAssets"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_question_answering_projects_get_qnas_request(
                    project_name=project_name,
                    api_version=api_version,
                    source=source,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_qnas.metadata['url'],
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_question_answering_projects_get_qnas_request(
                    project_name=project_name,
                    api_version=api_version,
                    source=source,
                    top=top,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("QnaAssets", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_qnas.metadata = {'url': '/query-knowledgebases/projects/{projectName}/qnas'}  # type: ignore

    def _update_qnas_initial(
        self,
        project_name,  # type: str
        body,  # type: List["_models.UpdateQnaRecord"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, '[UpdateQnaRecord]')

        request = build_question_answering_projects_update_qnas_request_initial(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            template_url=self._update_qnas_initial.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    _update_qnas_initial.metadata = {'url': '/query-knowledgebases/projects/{projectName}/qnas'}  # type: ignore


    @distributed_trace
    def begin_update_qnas(
        self,
        project_name,  # type: str
        body,  # type: List["_models.UpdateQnaRecord"]
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller[None]
        """Updates the QnAs of a project.

        Updates the QnAs of a project.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: Update QnAs parameters of a project.
        :type body: list[~azure.ai.language.questionanswering.projects.models.UpdateQnaRecord]
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]
        polling = kwargs.pop('polling', True)  # type: Union[bool, azure.core.polling.PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._update_qnas_initial(
                project_name=project_name,
                body=body,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x,y,z: x,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})


        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }

        if polling is True: polling_method = LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    begin_update_qnas.metadata = {'url': '/query-knowledgebases/projects/{projectName}/qnas'}  # type: ignore

    @distributed_trace
    def get_update_qnas_status(
        self,
        project_name,  # type: str
        job_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.JobState"
        """Gets the status of update QnAs job.

        Gets the status of update QnAs job.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param job_id: Job ID.
        :type job_id: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JobState
        :rtype: ~azure.ai.language.questionanswering.projects.models.JobState
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobState"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str

        
        request = build_question_answering_projects_get_update_qnas_status_request(
            project_name=project_name,
            job_id=job_id,
            api_version=api_version,
            template_url=self.get_update_qnas_status.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('JobState', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_update_qnas_status.metadata = {'url': '/query-knowledgebases/projects/{projectName}/qnas/jobs/{jobId}'}  # type: ignore


    @distributed_trace
    def add_feedback(
        self,
        project_name,  # type: str
        body,  # type: "_models.ActiveLearningFeedback"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update Active Learning feedback.

        Update Active Learning feedback.

        :param project_name: The name of the project to use.
        :type project_name: str
        :param body: Feedback for Active Learning.
        :type body: ~azure.ai.language.questionanswering.projects.models.ActiveLearningFeedback
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'ActiveLearningFeedback')

        request = build_question_answering_projects_add_feedback_request(
            project_name=project_name,
            api_version=api_version,
            content_type=content_type,
            json=json,
            template_url=self.add_feedback.metadata['url'],
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    add_feedback.metadata = {'url': '/query-knowledgebases/projects/{projectName}/feedback'}  # type: ignore

