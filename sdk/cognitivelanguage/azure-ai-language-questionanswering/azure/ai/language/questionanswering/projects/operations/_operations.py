# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from msrest import Serializer

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Optional, TypeVar
    T = TypeVar('T')
    JSONType = Any
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False
# fmt: off

def build_question_answering_runtime_get_answers_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    project_name = kwargs.pop('project_name')  # type: str
    deployment_name = kwargs.pop('deployment_name')  # type: str

    accept = "application/json"
    # Construct URL
    url = '/:query-knowledgebases'

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['projectName'] = _SERIALIZER.query("project_name", project_name, 'str')
    query_parameters['deploymentName'] = _SERIALIZER.query("deployment_name", deployment_name, 'str')
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_question_answering_runtime_get_answers_from_text_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = '/:query-text'

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )

# fmt: on
class QuestionAnsweringRuntimeOperations(object):
    """QuestionAnsweringRuntimeOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace
    def get_answers(
        self,
        knowledge_base_query_options,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Answers the specified question using your knowledge base. It is the runtime API for Custom
        Question Answering.

        Answers the specified question using your knowledge base. It is the runtime API for Custom
        Question Answering.

        :param knowledge_base_query_options: Post body of the request.
        :type knowledge_base_query_options: JSONType
        :keyword project_name: The name of the project to use.
        :paramtype project_name: str
        :keyword deployment_name: The name of the specific deployment of the project to use.
        :paramtype deployment_name: str
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                knowledge_base_query_options = {
                    "answerSpanRequest": {
                        "confidenceScoreThreshold": 0.0,  # Optional. Minimum threshold score required to include an answer span, value ranges from 0 to 1.
                        "enable": True,  # Default value is True. Enable or disable Answer Span prediction. Has constant value: True.
                        "topAnswersWithSpan": 0  # Optional. Number of Top answers to be considered for span prediction from 1 to 10.
                    },
                    "confidenceScoreThreshold": 0.0,  # Optional. Minimum threshold score for answers, value ranges from 0 to 1.
                    "context": {
                        "previousQnaId": 0,  # Required. Previous turn top answer result QnA ID.
                        "previousUserQuery": "str"  # Optional. Previous user query.
                    },
                    "filters": {
                        "logicalOperation": "str",  # Optional. Logical operation used to join metadata filter with source filter. Possible values include: "AND", "OR".
                        "metadataFilter": {
                            "logicalOperation": "str",  # Optional. Operation used to join metadata filters. Possible values include: "AND", "OR".
                            "metadata": [
                                {
                                    "key": "str",  # Required. Metadata Key from Metadata dictionary used in the QnA.
                                    "value": "str"  # Required. Metadata Value from Metadata dictionary used in the QnA.
                                }
                            ]
                        },
                        "sourceFilter": [
                            "str"  # Optional. Find QnAs that are associated with any of the given list of sources in knowledge base.
                        ]
                    },
                    "includeUnstructuredSources": bool,  # Optional. (Optional) Flag to enable Query over Unstructured Sources.
                    "qnaId": 0,  # Optional. Exact QnA ID to fetch from the knowledge base, this field takes priority over question.
                    "question": "str",  # Optional. User question to query against the knowledge base.
                    "rankerType": "str",  # Optional. Type of ranker to be used. Possible values include: "QuestionOnly", "Default".
                    "top": 0,  # Optional. Max number of answers to be returned for the question.
                    "userId": "str"  # Optional. Unique identifier for the user.
                }

                # response body for status code(s): 200
                response.json() == {
                    "answers": [
                        {
                            "answer": "str",  # Optional. Answer text.
                            "answerSpan": {
                                "confidenceScore": 0.0,  # Optional. Predicted score of answer span, value ranges from 0 to 1.
                                "length": 0,  # Optional. The length of the answer span.
                                "offset": 0,  # Optional. The answer span offset from the start of answer.
                                "text": "str"  # Optional. Predicted text of answer span.
                            },
                            "confidenceScore": 0.0,  # Optional. Answer confidence score, value ranges from 0 to 1.
                            "dialog": {
                                "isContextOnly": bool,  # Optional. To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as search result for queries without context; otherwise, if false, ignores context and includes this QnA in search result.
                                "prompts": [
                                    {
                                        "displayOrder": 0,  # Optional. Index of the prompt - used in ordering of the prompts.
                                        "displayText": "str",  # Optional. Text displayed to represent a follow up question prompt.
                                        "qnaId": 0  # Optional. QnA ID corresponding to the prompt.
                                    }
                                ]
                            },
                            "id": 0,  # Optional. ID of the QnA result.
                            "metadata": {
                                "str": "str"  # Optional. Metadata associated with the answer, useful to categorize or filter question answers.
                            },
                            "questions": [
                                "str"  # Optional. List of questions associated with the answer.
                            ],
                            "source": "str"  # Optional. Source of QnA result.
                        }
                    ]
                }
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[JSONType]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]
        project_name = kwargs.pop('project_name')  # type: str
        deployment_name = kwargs.pop('deployment_name')  # type: str

        _json = knowledge_base_query_options

        request = build_question_answering_runtime_get_answers_request(
            api_version=api_version,
            content_type=content_type,
            project_name=project_name,
            deployment_name=deployment_name,
            json=_json,
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_answers.metadata = {'url': '/:query-knowledgebases'}  # type: ignore


    @distributed_trace
    def get_answers_from_text(
        self,
        text_query_options,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Answers the specified question using the provided text in the body. It is the runtime API for
        Prebuilt Question Answering.

        Answers the specified question using the provided text in the body. It is the runtime API for
        Prebuilt Question Answering.

        :param text_query_options: Post body of the request.
        :type text_query_options: JSONType
        :keyword api_version: Api Version. The default value is "2021-10-01". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                text_query_options = {
                    "language": "str",  # Optional. Language of the text records. This is BCP-47 representation of a language. For example, use "en" for English; "es" for Spanish etc. If not set, use "en" for English as default.
                    "question": "str",  # Required. User question to query against the given text records.
                    "records": [
                        {
                            "id": "str",  # Required. Unique identifier for the text record.
                            "text": "str"  # Required. Text contents of the record.
                        }
                    ],
                    "stringIndexType": "TextElements_v8"  # Optional. Default value is "TextElements_v8". Specifies the method used to interpret string offsets.  Defaults to Text Elements (Graphemes) according to Unicode v8.0.0. For additional information see https://aka.ms/text-analytics-offsets. Possible values include: "TextElements_v8", "UnicodeCodePoint", "Utf16CodeUnit". Default value: "TextElements_v8".
                }

                # response body for status code(s): 200
                response.json() == {
                    "answers": [
                        {
                            "answer": "str",  # Optional. Answer.
                            "answerSpan": {
                                "confidenceScore": 0.0,  # Optional. Predicted score of answer span, value ranges from 0 to 1.
                                "length": 0,  # Optional. The length of the answer span.
                                "offset": 0,  # Optional. The answer span offset from the start of answer.
                                "text": "str"  # Optional. Predicted text of answer span.
                            },
                            "confidenceScore": 0.0,  # Optional. answer confidence score, value ranges from 0 to 1.
                            "id": "str",  # Optional. record ID.
                            "length": 0,  # Optional. The length of the sentence.
                            "offset": 0  # Optional. The sentence offset from the start of the document.
                        }
                    ]
                }
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[JSONType]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        api_version = kwargs.pop('api_version', "2021-10-01")  # type: str
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = text_query_options

        request = build_question_answering_runtime_get_answers_from_text_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_answers_from_text.metadata = {'url': '/:query-text'}  # type: ignore

