# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import pytest
from devtools_testutils.aio import recorded_by_proxy_async
from testpreparer import QuestionAnsweringAuthoringPreparer
from testpreparer_async import QuestionAnsweringAuthoringClientTestBaseAsync


@pytest.mark.skip("you may need to update the auto-generated test case before run it")
class TestQuestionAnsweringAuthoringAsync(QuestionAnsweringAuthoringClientTestBaseAsync):
    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_list_projects(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = client.list_projects()
        result = [r async for r in response]
        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_get_project_details(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await client.get_project_details(
            project_name="str",
        )

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_create_project(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await client.create_project(
            project_name="str",
            body={
                "projectName": "str",
                "configureSemanticRanking": bool,
                "createdDateTime": "2020-02-20 00:00:00",
                "description": "str",
                "language": "str",
                "lastDeployedDateTime": "2020-02-20 00:00:00",
                "lastModifiedDateTime": "2020-02-20 00:00:00",
                "multilingualResource": bool,
                "settings": {"defaultAnswer": "str"},
            },
        )

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_begin_delete_project(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await (
            await client.begin_delete_project(
                project_name="str",
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_get_delete_status(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await client.get_delete_status(
            job_id="str",
        )

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_begin_export(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await (
            await client.begin_export(
                project_name="str",
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_get_export_status(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await client.get_export_status(
            project_name="str",
            job_id="str",
        )

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_begin_import_method(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await (
            await client.begin_import_method(
                project_name="str",
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_begin_import_from_files(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await (
            await client.begin_import_from_files(
                project_name="str",
                body={"files": ["filetype"]},
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_get_import_status(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await client.get_import_status(
            project_name="str",
            job_id="str",
        )

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_begin_deploy_project(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await (
            await client.begin_deploy_project(
                project_name="str",
                deployment_name="str",
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_get_deploy_status(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await client.get_deploy_status(
            project_name="str",
            deployment_name="str",
            job_id="str",
        )

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_list_deployments(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = client.list_deployments(
            project_name="str",
        )
        result = [r async for r in response]
        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_get_synonyms(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = client.get_synonyms(
            project_name="str",
        )
        result = [r async for r in response]
        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_update_synonyms(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await client.update_synonyms(
            project_name="str",
            body={"value": [{"alterations": ["str"]}], "nextLink": "str"},
        )

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_get_sources(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = client.get_sources(
            project_name="str",
        )
        result = [r async for r in response]
        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_begin_update_sources(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await (
            await client.begin_update_sources(
                project_name="str",
                body=[
                    {
                        "op": "str",
                        "value": {
                            "source": "str",
                            "sourceKind": "str",
                            "sourceUri": "str",
                            "contentStructureKind": "str",
                            "displayName": "str",
                            "refresh": bool,
                        },
                    }
                ],
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_begin_update_sources_from_files(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await (
            await client.begin_update_sources_from_files(
                project_name="str",
                body={
                    "fileOperations": [
                        {"fileName": "str", "operation": "str", "fileDisplayName": "str", "refresh": bool}
                    ],
                    "files": ["filetype"],
                },
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_get_update_sources_status(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await client.get_update_sources_status(
            project_name="str",
            job_id="str",
        )

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_get_qnas(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = client.get_qnas(
            project_name="str",
        )
        result = [r async for r in response]
        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_begin_update_qnas(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await (
            await client.begin_update_qnas(
                project_name="str",
                body=[
                    {
                        "op": "str",
                        "value": {
                            "id": 0,
                            "activeLearningSuggestions": [
                                {
                                    "clusterHead": "str",
                                    "suggestedQuestions": [
                                        {"autoSuggestedCount": 0, "question": "str", "userSuggestedCount": 0}
                                    ],
                                }
                            ],
                            "answer": "str",
                            "dialog": {
                                "isContextOnly": bool,
                                "prompts": [{"displayOrder": 0, "displayText": "str", "qna": ..., "qnaId": 0}],
                            },
                            "metadata": {"str": "str"},
                            "questions": ["str"],
                            "source": "str",
                        },
                    }
                ],
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_get_update_qnas_status(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await client.get_update_qnas_status(
            project_name="str",
            job_id="str",
        )

        # please add some check logic here by yourself
        # ...

    @QuestionAnsweringAuthoringPreparer()
    @recorded_by_proxy_async
    async def test_add_feedback(self, questionansweringauthoring_endpoint):
        client = self.create_async_client(endpoint=questionansweringauthoring_endpoint)
        response = await client.add_feedback(
            project_name="str",
            body={"records": [{"qnaId": 0, "userId": "str", "userQuestion": "str"}]},
        )

        # please add some check logic here by yourself
        # ...
