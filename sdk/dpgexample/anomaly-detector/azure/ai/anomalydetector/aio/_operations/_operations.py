# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ..._operations._operations import (
    build_batch_detect_anomaly_request,
    build_create_multivariate_model_request,
    build_delete_multivariate_model_request,
    build_get_batch_detection_result_request,
    build_get_multivariate_model_request,
    build_last_detect_anomaly_request,
    build_list_multivariate_model_request,
)
from .._vendor import MixinABC

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class AnomalyDetectorClientOperationsMixin(MixinABC):
    @distributed_trace_async
    async def get_batch_detection_result(self, result_id: str, **kwargs: Any) -> JSON:
        """Get Multivariate Anomaly Detection Result.

        For asynchronous inference, get multivariate anomaly detection result based on resultId
        returned by the BatchDetectAnomaly api.

        :param result_id: Result identifier. Required.
        :type result_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "resultId": "str",  # Result identifier, which is used to fetch the results
                      of an inference call. Required.
                    "results": [
                        {
                            "timestamp": "2020-02-20 00:00:00",  # The timestamp for this
                              anomaly. Required.
                            "errors": [
                                {
                                    "code": "str",  # The error code. Required.
                                    "message": "str"  # The message explaining
                                      the error reported by the service. Required.
                                }
                            ],
                            "value": {
                                "isAnomaly": bool,  # True if an anomaly is detected
                                  at the current timestamp. Required.
                                "score": 0.0,  # Raw anomaly score of severity, will
                                  help indicate the degree of abnormality as well. Required.
                                "severity": 0.0,  # Indicates the significance of the
                                  anomaly. The higher the severity, the more significant the anomaly
                                  is. Required.
                                "interpretation": [
                                    {
                                        "contributionScore": 0.0,  #
                                          Optional. This score shows the percentage contributing to the
                                          anomalous timestamp. A number between 0 and 1.
                                        "correlationChanges": {
                                            "changedVariables": [
                                                "str"  # Optional.
                                                  The correlated variables that have correlation
                                                  changes under an anomaly.
                                            ]
                                        },
                                        "variable": "str"  # Optional.
                                          Variable.
                                    }
                                ]
                            }
                        }
                    ],
                    "summary": {
                        "setupInfo": {
                            "dataSource": "str",  # Source link to the input data to
                              indicate an accessible Azure storage Uri, either pointed to an Azure blob
                              storage folder, or pointed to a CSV file in Azure blob storage based on
                              you data schema selection. The data schema should be exactly the same
                              with those used in the training phase. Required.
                            "endTime": "2020-02-20 00:00:00",  # A required field,
                              indicating the end time of data for detection, which should be date-time
                              of ISO 8601 format. Required.
                            "startTime": "2020-02-20 00:00:00",  # A required field,
                              indicating the start time of data for detection, which should be
                              date-time of ISO 8601 format. Required.
                            "topContributorCount": 0  # An optional field, which is used
                              to specify the number of top contributed variables for one anomalous
                              timestamp in the response. The default number is 10. Required.
                        },
                        "status": "str",  # Status of detection results. One of CREATED,
                          RUNNING, READY, and FAILED. Required. Known values are: "CREATED", "RUNNING",
                          "READY", and "FAILED".
                        "errors": [
                            {
                                "code": "str",  # The error code. Required.
                                "message": "str"  # The message explaining the error
                                  reported by the service. Required.
                            }
                        ],
                        "variableStates": [
                            {
                                "effectiveCount": 0,  # Optional. Number of effective
                                  data points before applying fillNAMethod.
                                "filledNARatio": 0.0,  # Optional. Proportion of
                                  missing values that need to be filled by fillNAMethod.
                                "firstTimestamp": "2020-02-20 00:00:00",  # Optional.
                                  First valid timestamp with value of input data.
                                "lastTimestamp": "2020-02-20 00:00:00",  # Optional.
                                  Last valid timestamp with value of input data.
                                "variable": "str"  # Optional. Variable name in
                                  variable states.
                            }
                        ]
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_get_batch_detection_result_request(
            result_id=result_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_multivariate_model(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Train a Multivariate Anomaly Detection Model.

        Create and train a multivariate anomaly detection model. The request must include a source
        parameter to indicate an externally accessible Azure blob storage URI.There are two types of
        data input: An URI pointed to an Azure blob storage folder which contains multiple CSV files,
        and each CSV file contains two columns, timestamp and variable. Another type of input is an URI
        pointed to a CSV file in Azure blob storage, which contains all the variables and a timestamp
        column.

        :param body: Training request. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "dataSource": "str",  # Source link to the input data to indicate an
                      accessible Azure storage Uri, either pointed to an Azure blob storage folder, or
                      pointed to a CSV file in Azure blob storage based on you data schema selection.
                      Required.
                    "endTime": "2020-02-20 00:00:00",  # A required field, indicating the end
                      time of training data, which should be date-time of ISO 8601 format. Required.
                    "startTime": "2020-02-20 00:00:00",  # A required field, indicating the start
                      time of training data, which should be date-time of ISO 8601 format. Required.
                    "alignPolicy": {
                        "alignMode": "str",  # Optional. An optional field, indicating how to
                          align different variables to the same time-range. Either Inner or Outer.
                          Known values are: "Inner" and "Outer".
                        "fillNAMethod": "str",  # Optional. An optional field, indicating how
                          missing values will be filled. One of Previous, Subsequent, Linear, Zero,
                          Fixed. Known values are: "Previous", "Subsequent", "Linear", "Zero", and
                          "Fixed".
                        "paddingValue": 0.0  # Optional. An optional field. Required when
                          fillNAMethod is Fixed.
                    },
                    "dataSchema": "str",  # Optional. Data schema of input data source: OneTable
                      or MultiTable. The default DataSchema is OneTable. Known values are: "OneTable"
                      and "MultiTable".
                    "diagnosticsInfo": {
                        "modelState": {
                            "epochIds": [
                                0  # Optional. This indicates the number of passes of
                                  the entire training dataset the algorithm has completed.
                            ],
                            "latenciesInSeconds": [
                                0.0  # Optional. Latency for each epoch.
                            ],
                            "trainLosses": [
                                0.0  # Optional. List of metrics used to assess how
                                  the model fits the training data for each epoch.
                            ],
                            "validationLosses": [
                                0.0  # Optional. List of metrics used to assess how
                                  the model fits the validation set for each epoch.
                            ]
                        },
                        "variableStates": [
                            {
                                "effectiveCount": 0,  # Optional. Number of effective
                                  data points before applying fillNAMethod.
                                "filledNARatio": 0.0,  # Optional. Proportion of
                                  missing values that need to be filled by fillNAMethod.
                                "firstTimestamp": "2020-02-20 00:00:00",  # Optional.
                                  First valid timestamp with value of input data.
                                "lastTimestamp": "2020-02-20 00:00:00",  # Optional.
                                  Last valid timestamp with value of input data.
                                "variable": "str"  # Optional. Variable name in
                                  variable states.
                            }
                        ]
                    },
                    "displayName": "str",  # Optional. An optional field. The display name of the
                      model whose maximum length is 24 characters.
                    "errors": [
                        {
                            "code": "str",  # The error code. Required.
                            "message": "str"  # The message explaining the error reported
                              by the service. Required.
                        }
                    ],
                    "slidingWindow": 0,  # Optional. An optional field, indicating how many
                      previous timestamps will be used to detect whether the timestamp is anomaly or
                      not.
                    "status": "str"  # Optional. Model status. One of CREATED, RUNNING, READY,
                      and FAILED. Known values are: "CREATED", "RUNNING", "READY", and "FAILED".
                }

                # response body for status code(s): 201
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Date and time (UTC) when the model
                      was created. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # Date and time (UTC) when the
                      model was last updated. Required.
                    "modelId": "str",  # Model identifier. Required.
                    "modelInfo": {
                        "dataSource": "str",  # Source link to the input data to indicate an
                          accessible Azure storage Uri, either pointed to an Azure blob storage folder,
                          or pointed to a CSV file in Azure blob storage based on you data schema
                          selection. Required.
                        "endTime": "2020-02-20 00:00:00",  # A required field, indicating the
                          end time of training data, which should be date-time of ISO 8601 format.
                          Required.
                        "startTime": "2020-02-20 00:00:00",  # A required field, indicating
                          the start time of training data, which should be date-time of ISO 8601
                          format. Required.
                        "alignPolicy": {
                            "alignMode": "str",  # Optional. An optional field,
                              indicating how to align different variables to the same time-range.
                              Either Inner or Outer. Known values are: "Inner" and "Outer".
                            "fillNAMethod": "str",  # Optional. An optional field,
                              indicating how missing values will be filled. One of Previous,
                              Subsequent, Linear, Zero, Fixed. Known values are: "Previous",
                              "Subsequent", "Linear", "Zero", and "Fixed".
                            "paddingValue": 0.0  # Optional. An optional field. Required
                              when fillNAMethod is Fixed.
                        },
                        "dataSchema": "str",  # Optional. Data schema of input data source:
                          OneTable or MultiTable. The default DataSchema is OneTable. Known values are:
                          "OneTable" and "MultiTable".
                        "diagnosticsInfo": {
                            "modelState": {
                                "epochIds": [
                                    0  # Optional. This indicates the number of
                                      passes of the entire training dataset the algorithm has
                                      completed.
                                ],
                                "latenciesInSeconds": [
                                    0.0  # Optional. Latency for each epoch.
                                ],
                                "trainLosses": [
                                    0.0  # Optional. List of metrics used to
                                      assess how the model fits the training data for each epoch.
                                ],
                                "validationLosses": [
                                    0.0  # Optional. List of metrics used to
                                      assess how the model fits the validation set for each epoch.
                                ]
                            },
                            "variableStates": [
                                {
                                    "effectiveCount": 0,  # Optional. Number of
                                      effective data points before applying fillNAMethod.
                                    "filledNARatio": 0.0,  # Optional. Proportion
                                      of missing values that need to be filled by fillNAMethod.
                                    "firstTimestamp": "2020-02-20 00:00:00",  #
                                      Optional. First valid timestamp with value of input data.
                                    "lastTimestamp": "2020-02-20 00:00:00",  #
                                      Optional. Last valid timestamp with value of input data.
                                    "variable": "str"  # Optional. Variable name
                                      in variable states.
                                }
                            ]
                        },
                        "displayName": "str",  # Optional. An optional field. The display
                          name of the model whose maximum length is 24 characters.
                        "errors": [
                            {
                                "code": "str",  # The error code. Required.
                                "message": "str"  # The message explaining the error
                                  reported by the service. Required.
                            }
                        ],
                        "slidingWindow": 0,  # Optional. An optional field, indicating how
                          many previous timestamps will be used to detect whether the timestamp is
                          anomaly or not.
                        "status": "str"  # Optional. Model status. One of CREATED, RUNNING,
                          READY, and FAILED. Known values are: "CREATED", "RUNNING", "READY", and
                          "FAILED".
                    }
                }
        """

    @overload
    async def create_multivariate_model(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Train a Multivariate Anomaly Detection Model.

        Create and train a multivariate anomaly detection model. The request must include a source
        parameter to indicate an externally accessible Azure blob storage URI.There are two types of
        data input: An URI pointed to an Azure blob storage folder which contains multiple CSV files,
        and each CSV file contains two columns, timestamp and variable. Another type of input is an URI
        pointed to a CSV file in Azure blob storage, which contains all the variables and a timestamp
        column.

        :param body: Training request. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Date and time (UTC) when the model
                      was created. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # Date and time (UTC) when the
                      model was last updated. Required.
                    "modelId": "str",  # Model identifier. Required.
                    "modelInfo": {
                        "dataSource": "str",  # Source link to the input data to indicate an
                          accessible Azure storage Uri, either pointed to an Azure blob storage folder,
                          or pointed to a CSV file in Azure blob storage based on you data schema
                          selection. Required.
                        "endTime": "2020-02-20 00:00:00",  # A required field, indicating the
                          end time of training data, which should be date-time of ISO 8601 format.
                          Required.
                        "startTime": "2020-02-20 00:00:00",  # A required field, indicating
                          the start time of training data, which should be date-time of ISO 8601
                          format. Required.
                        "alignPolicy": {
                            "alignMode": "str",  # Optional. An optional field,
                              indicating how to align different variables to the same time-range.
                              Either Inner or Outer. Known values are: "Inner" and "Outer".
                            "fillNAMethod": "str",  # Optional. An optional field,
                              indicating how missing values will be filled. One of Previous,
                              Subsequent, Linear, Zero, Fixed. Known values are: "Previous",
                              "Subsequent", "Linear", "Zero", and "Fixed".
                            "paddingValue": 0.0  # Optional. An optional field. Required
                              when fillNAMethod is Fixed.
                        },
                        "dataSchema": "str",  # Optional. Data schema of input data source:
                          OneTable or MultiTable. The default DataSchema is OneTable. Known values are:
                          "OneTable" and "MultiTable".
                        "diagnosticsInfo": {
                            "modelState": {
                                "epochIds": [
                                    0  # Optional. This indicates the number of
                                      passes of the entire training dataset the algorithm has
                                      completed.
                                ],
                                "latenciesInSeconds": [
                                    0.0  # Optional. Latency for each epoch.
                                ],
                                "trainLosses": [
                                    0.0  # Optional. List of metrics used to
                                      assess how the model fits the training data for each epoch.
                                ],
                                "validationLosses": [
                                    0.0  # Optional. List of metrics used to
                                      assess how the model fits the validation set for each epoch.
                                ]
                            },
                            "variableStates": [
                                {
                                    "effectiveCount": 0,  # Optional. Number of
                                      effective data points before applying fillNAMethod.
                                    "filledNARatio": 0.0,  # Optional. Proportion
                                      of missing values that need to be filled by fillNAMethod.
                                    "firstTimestamp": "2020-02-20 00:00:00",  #
                                      Optional. First valid timestamp with value of input data.
                                    "lastTimestamp": "2020-02-20 00:00:00",  #
                                      Optional. Last valid timestamp with value of input data.
                                    "variable": "str"  # Optional. Variable name
                                      in variable states.
                                }
                            ]
                        },
                        "displayName": "str",  # Optional. An optional field. The display
                          name of the model whose maximum length is 24 characters.
                        "errors": [
                            {
                                "code": "str",  # The error code. Required.
                                "message": "str"  # The message explaining the error
                                  reported by the service. Required.
                            }
                        ],
                        "slidingWindow": 0,  # Optional. An optional field, indicating how
                          many previous timestamps will be used to detect whether the timestamp is
                          anomaly or not.
                        "status": "str"  # Optional. Model status. One of CREATED, RUNNING,
                          READY, and FAILED. Known values are: "CREATED", "RUNNING", "READY", and
                          "FAILED".
                    }
                }
        """

    @distributed_trace_async
    async def create_multivariate_model(self, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Train a Multivariate Anomaly Detection Model.

        Create and train a multivariate anomaly detection model. The request must include a source
        parameter to indicate an externally accessible Azure blob storage URI.There are two types of
        data input: An URI pointed to an Azure blob storage folder which contains multiple CSV files,
        and each CSV file contains two columns, timestamp and variable. Another type of input is an URI
        pointed to a CSV file in Azure blob storage, which contains all the variables and a timestamp
        column.

        :param body: Training request. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Date and time (UTC) when the model
                      was created. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # Date and time (UTC) when the
                      model was last updated. Required.
                    "modelId": "str",  # Model identifier. Required.
                    "modelInfo": {
                        "dataSource": "str",  # Source link to the input data to indicate an
                          accessible Azure storage Uri, either pointed to an Azure blob storage folder,
                          or pointed to a CSV file in Azure blob storage based on you data schema
                          selection. Required.
                        "endTime": "2020-02-20 00:00:00",  # A required field, indicating the
                          end time of training data, which should be date-time of ISO 8601 format.
                          Required.
                        "startTime": "2020-02-20 00:00:00",  # A required field, indicating
                          the start time of training data, which should be date-time of ISO 8601
                          format. Required.
                        "alignPolicy": {
                            "alignMode": "str",  # Optional. An optional field,
                              indicating how to align different variables to the same time-range.
                              Either Inner or Outer. Known values are: "Inner" and "Outer".
                            "fillNAMethod": "str",  # Optional. An optional field,
                              indicating how missing values will be filled. One of Previous,
                              Subsequent, Linear, Zero, Fixed. Known values are: "Previous",
                              "Subsequent", "Linear", "Zero", and "Fixed".
                            "paddingValue": 0.0  # Optional. An optional field. Required
                              when fillNAMethod is Fixed.
                        },
                        "dataSchema": "str",  # Optional. Data schema of input data source:
                          OneTable or MultiTable. The default DataSchema is OneTable. Known values are:
                          "OneTable" and "MultiTable".
                        "diagnosticsInfo": {
                            "modelState": {
                                "epochIds": [
                                    0  # Optional. This indicates the number of
                                      passes of the entire training dataset the algorithm has
                                      completed.
                                ],
                                "latenciesInSeconds": [
                                    0.0  # Optional. Latency for each epoch.
                                ],
                                "trainLosses": [
                                    0.0  # Optional. List of metrics used to
                                      assess how the model fits the training data for each epoch.
                                ],
                                "validationLosses": [
                                    0.0  # Optional. List of metrics used to
                                      assess how the model fits the validation set for each epoch.
                                ]
                            },
                            "variableStates": [
                                {
                                    "effectiveCount": 0,  # Optional. Number of
                                      effective data points before applying fillNAMethod.
                                    "filledNARatio": 0.0,  # Optional. Proportion
                                      of missing values that need to be filled by fillNAMethod.
                                    "firstTimestamp": "2020-02-20 00:00:00",  #
                                      Optional. First valid timestamp with value of input data.
                                    "lastTimestamp": "2020-02-20 00:00:00",  #
                                      Optional. Last valid timestamp with value of input data.
                                    "variable": "str"  # Optional. Variable name
                                      in variable states.
                                }
                            ]
                        },
                        "displayName": "str",  # Optional. An optional field. The display
                          name of the model whose maximum length is 24 characters.
                        "errors": [
                            {
                                "code": "str",  # The error code. Required.
                                "message": "str"  # The message explaining the error
                                  reported by the service. Required.
                            }
                        ],
                        "slidingWindow": 0,  # Optional. An optional field, indicating how
                          many previous timestamps will be used to detect whether the timestamp is
                          anomaly or not.
                        "status": "str"  # Optional. Model status. One of CREATED, RUNNING,
                          READY, and FAILED. Known values are: "CREATED", "RUNNING", "READY", and
                          "FAILED".
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_multivariate_model_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)

    @distributed_trace
    def list_multivariate_model(
        self, *, skip: int = 0, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """List Multivariate Models.

        List models of a resource.

        :keyword skip: Skip indicates how many models will be skipped. Default value is 0.
        :paramtype skip: int
        :keyword top: Top indicates how many models will be fetched. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Date and time (UTC) when the model
                      was created. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # Date and time (UTC) when the
                      model was last updated. Required.
                    "modelId": "str",  # Model identifier. Required.
                    "modelInfo": {
                        "dataSource": "str",  # Source link to the input data to indicate an
                          accessible Azure storage Uri, either pointed to an Azure blob storage folder,
                          or pointed to a CSV file in Azure blob storage based on you data schema
                          selection. Required.
                        "endTime": "2020-02-20 00:00:00",  # A required field, indicating the
                          end time of training data, which should be date-time of ISO 8601 format.
                          Required.
                        "startTime": "2020-02-20 00:00:00",  # A required field, indicating
                          the start time of training data, which should be date-time of ISO 8601
                          format. Required.
                        "alignPolicy": {
                            "alignMode": "str",  # Optional. An optional field,
                              indicating how to align different variables to the same time-range.
                              Either Inner or Outer. Known values are: "Inner" and "Outer".
                            "fillNAMethod": "str",  # Optional. An optional field,
                              indicating how missing values will be filled. One of Previous,
                              Subsequent, Linear, Zero, Fixed. Known values are: "Previous",
                              "Subsequent", "Linear", "Zero", and "Fixed".
                            "paddingValue": 0.0  # Optional. An optional field. Required
                              when fillNAMethod is Fixed.
                        },
                        "dataSchema": "str",  # Optional. Data schema of input data source:
                          OneTable or MultiTable. The default DataSchema is OneTable. Known values are:
                          "OneTable" and "MultiTable".
                        "diagnosticsInfo": {
                            "modelState": {
                                "epochIds": [
                                    0  # Optional. This indicates the number of
                                      passes of the entire training dataset the algorithm has
                                      completed.
                                ],
                                "latenciesInSeconds": [
                                    0.0  # Optional. Latency for each epoch.
                                ],
                                "trainLosses": [
                                    0.0  # Optional. List of metrics used to
                                      assess how the model fits the training data for each epoch.
                                ],
                                "validationLosses": [
                                    0.0  # Optional. List of metrics used to
                                      assess how the model fits the validation set for each epoch.
                                ]
                            },
                            "variableStates": [
                                {
                                    "effectiveCount": 0,  # Optional. Number of
                                      effective data points before applying fillNAMethod.
                                    "filledNARatio": 0.0,  # Optional. Proportion
                                      of missing values that need to be filled by fillNAMethod.
                                    "firstTimestamp": "2020-02-20 00:00:00",  #
                                      Optional. First valid timestamp with value of input data.
                                    "lastTimestamp": "2020-02-20 00:00:00",  #
                                      Optional. Last valid timestamp with value of input data.
                                    "variable": "str"  # Optional. Variable name
                                      in variable states.
                                }
                            ]
                        },
                        "displayName": "str",  # Optional. An optional field. The display
                          name of the model whose maximum length is 24 characters.
                        "errors": [
                            {
                                "code": "str",  # The error code. Required.
                                "message": "str"  # The message explaining the error
                                  reported by the service. Required.
                            }
                        ],
                        "slidingWindow": 0,  # Optional. An optional field, indicating how
                          many previous timestamps will be used to detect whether the timestamp is
                          anomaly or not.
                        "status": "str"  # Optional. Model status. One of CREATED, RUNNING,
                          READY, and FAILED. Known values are: "CREATED", "RUNNING", "READY", and
                          "FAILED".
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_list_multivariate_model_request(
                    skip=skip,
                    top=top,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                request = HttpRequest("GET", next_link)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["models"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete_multivariate_model(  # pylint: disable=inconsistent-return-statements
        self, model_id: str, **kwargs: Any
    ) -> None:
        """Delete Multivariate Model.

        Delete an existing multivariate model according to the modelId.

        :param model_id: Model identifier. Required.
        :type model_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_delete_multivariate_model_request(
            model_id=model_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_multivariate_model(self, model_id: str, **kwargs: Any) -> JSON:
        """Get Multivariate Model.

        Get detailed information of multivariate model, including the training status and variables
        used in the model.

        :param model_id: Model identifier. Required.
        :type model_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Date and time (UTC) when the model
                      was created. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # Date and time (UTC) when the
                      model was last updated. Required.
                    "modelId": "str",  # Model identifier. Required.
                    "modelInfo": {
                        "dataSource": "str",  # Source link to the input data to indicate an
                          accessible Azure storage Uri, either pointed to an Azure blob storage folder,
                          or pointed to a CSV file in Azure blob storage based on you data schema
                          selection. Required.
                        "endTime": "2020-02-20 00:00:00",  # A required field, indicating the
                          end time of training data, which should be date-time of ISO 8601 format.
                          Required.
                        "startTime": "2020-02-20 00:00:00",  # A required field, indicating
                          the start time of training data, which should be date-time of ISO 8601
                          format. Required.
                        "alignPolicy": {
                            "alignMode": "str",  # Optional. An optional field,
                              indicating how to align different variables to the same time-range.
                              Either Inner or Outer. Known values are: "Inner" and "Outer".
                            "fillNAMethod": "str",  # Optional. An optional field,
                              indicating how missing values will be filled. One of Previous,
                              Subsequent, Linear, Zero, Fixed. Known values are: "Previous",
                              "Subsequent", "Linear", "Zero", and "Fixed".
                            "paddingValue": 0.0  # Optional. An optional field. Required
                              when fillNAMethod is Fixed.
                        },
                        "dataSchema": "str",  # Optional. Data schema of input data source:
                          OneTable or MultiTable. The default DataSchema is OneTable. Known values are:
                          "OneTable" and "MultiTable".
                        "diagnosticsInfo": {
                            "modelState": {
                                "epochIds": [
                                    0  # Optional. This indicates the number of
                                      passes of the entire training dataset the algorithm has
                                      completed.
                                ],
                                "latenciesInSeconds": [
                                    0.0  # Optional. Latency for each epoch.
                                ],
                                "trainLosses": [
                                    0.0  # Optional. List of metrics used to
                                      assess how the model fits the training data for each epoch.
                                ],
                                "validationLosses": [
                                    0.0  # Optional. List of metrics used to
                                      assess how the model fits the validation set for each epoch.
                                ]
                            },
                            "variableStates": [
                                {
                                    "effectiveCount": 0,  # Optional. Number of
                                      effective data points before applying fillNAMethod.
                                    "filledNARatio": 0.0,  # Optional. Proportion
                                      of missing values that need to be filled by fillNAMethod.
                                    "firstTimestamp": "2020-02-20 00:00:00",  #
                                      Optional. First valid timestamp with value of input data.
                                    "lastTimestamp": "2020-02-20 00:00:00",  #
                                      Optional. Last valid timestamp with value of input data.
                                    "variable": "str"  # Optional. Variable name
                                      in variable states.
                                }
                            ]
                        },
                        "displayName": "str",  # Optional. An optional field. The display
                          name of the model whose maximum length is 24 characters.
                        "errors": [
                            {
                                "code": "str",  # The error code. Required.
                                "message": "str"  # The message explaining the error
                                  reported by the service. Required.
                            }
                        ],
                        "slidingWindow": 0,  # Optional. An optional field, indicating how
                          many previous timestamps will be used to detect whether the timestamp is
                          anomaly or not.
                        "status": "str"  # Optional. Model status. One of CREATED, RUNNING,
                          READY, and FAILED. Known values are: "CREATED", "RUNNING", "READY", and
                          "FAILED".
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_get_multivariate_model_request(
            model_id=model_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def batch_detect_anomaly(
        self, model_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Detect Multivariate Anomaly.

        Submit multivariate anomaly detection task with the modelId of trained model and inference
        data, the input schema should be the same with the training request. The request will complete
        asynchronously and return a resultId to query the detection result.The request should be a
        source link to indicate an externally accessible Azure storage Uri, either pointed to an Azure
        blob storage folder, or pointed to a CSV file in Azure blob storage.

        :param model_id: Model identifier. Required.
        :type model_id: str
        :param body: Detect anomaly request. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "dataSource": "str",  # Source link to the input data to indicate an
                      accessible Azure storage Uri, either pointed to an Azure blob storage folder, or
                      pointed to a CSV file in Azure blob storage based on you data schema selection.
                      The data schema should be exactly the same with those used in the training phase.
                      Required.
                    "endTime": "2020-02-20 00:00:00",  # A required field, indicating the end
                      time of data for detection, which should be date-time of ISO 8601 format.
                      Required.
                    "startTime": "2020-02-20 00:00:00",  # A required field, indicating the start
                      time of data for detection, which should be date-time of ISO 8601 format.
                      Required.
                    "topContributorCount": 0  # An optional field, which is used to specify the
                      number of top contributed variables for one anomalous timestamp in the response.
                      The default number is 10. Required.
                }

                # response body for status code(s): 202
                response == {
                    "resultId": "str",  # Result identifier, which is used to fetch the results
                      of an inference call. Required.
                    "results": [
                        {
                            "timestamp": "2020-02-20 00:00:00",  # The timestamp for this
                              anomaly. Required.
                            "errors": [
                                {
                                    "code": "str",  # The error code. Required.
                                    "message": "str"  # The message explaining
                                      the error reported by the service. Required.
                                }
                            ],
                            "value": {
                                "isAnomaly": bool,  # True if an anomaly is detected
                                  at the current timestamp. Required.
                                "score": 0.0,  # Raw anomaly score of severity, will
                                  help indicate the degree of abnormality as well. Required.
                                "severity": 0.0,  # Indicates the significance of the
                                  anomaly. The higher the severity, the more significant the anomaly
                                  is. Required.
                                "interpretation": [
                                    {
                                        "contributionScore": 0.0,  #
                                          Optional. This score shows the percentage contributing to the
                                          anomalous timestamp. A number between 0 and 1.
                                        "correlationChanges": {
                                            "changedVariables": [
                                                "str"  # Optional.
                                                  The correlated variables that have correlation
                                                  changes under an anomaly.
                                            ]
                                        },
                                        "variable": "str"  # Optional.
                                          Variable.
                                    }
                                ]
                            }
                        }
                    ],
                    "summary": {
                        "setupInfo": {
                            "dataSource": "str",  # Source link to the input data to
                              indicate an accessible Azure storage Uri, either pointed to an Azure blob
                              storage folder, or pointed to a CSV file in Azure blob storage based on
                              you data schema selection. The data schema should be exactly the same
                              with those used in the training phase. Required.
                            "endTime": "2020-02-20 00:00:00",  # A required field,
                              indicating the end time of data for detection, which should be date-time
                              of ISO 8601 format. Required.
                            "startTime": "2020-02-20 00:00:00",  # A required field,
                              indicating the start time of data for detection, which should be
                              date-time of ISO 8601 format. Required.
                            "topContributorCount": 0  # An optional field, which is used
                              to specify the number of top contributed variables for one anomalous
                              timestamp in the response. The default number is 10. Required.
                        },
                        "status": "str",  # Status of detection results. One of CREATED,
                          RUNNING, READY, and FAILED. Required. Known values are: "CREATED", "RUNNING",
                          "READY", and "FAILED".
                        "errors": [
                            {
                                "code": "str",  # The error code. Required.
                                "message": "str"  # The message explaining the error
                                  reported by the service. Required.
                            }
                        ],
                        "variableStates": [
                            {
                                "effectiveCount": 0,  # Optional. Number of effective
                                  data points before applying fillNAMethod.
                                "filledNARatio": 0.0,  # Optional. Proportion of
                                  missing values that need to be filled by fillNAMethod.
                                "firstTimestamp": "2020-02-20 00:00:00",  # Optional.
                                  First valid timestamp with value of input data.
                                "lastTimestamp": "2020-02-20 00:00:00",  # Optional.
                                  Last valid timestamp with value of input data.
                                "variable": "str"  # Optional. Variable name in
                                  variable states.
                            }
                        ]
                    }
                }
        """

    @overload
    async def batch_detect_anomaly(
        self, model_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Detect Multivariate Anomaly.

        Submit multivariate anomaly detection task with the modelId of trained model and inference
        data, the input schema should be the same with the training request. The request will complete
        asynchronously and return a resultId to query the detection result.The request should be a
        source link to indicate an externally accessible Azure storage Uri, either pointed to an Azure
        blob storage folder, or pointed to a CSV file in Azure blob storage.

        :param model_id: Model identifier. Required.
        :type model_id: str
        :param body: Detect anomaly request. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "resultId": "str",  # Result identifier, which is used to fetch the results
                      of an inference call. Required.
                    "results": [
                        {
                            "timestamp": "2020-02-20 00:00:00",  # The timestamp for this
                              anomaly. Required.
                            "errors": [
                                {
                                    "code": "str",  # The error code. Required.
                                    "message": "str"  # The message explaining
                                      the error reported by the service. Required.
                                }
                            ],
                            "value": {
                                "isAnomaly": bool,  # True if an anomaly is detected
                                  at the current timestamp. Required.
                                "score": 0.0,  # Raw anomaly score of severity, will
                                  help indicate the degree of abnormality as well. Required.
                                "severity": 0.0,  # Indicates the significance of the
                                  anomaly. The higher the severity, the more significant the anomaly
                                  is. Required.
                                "interpretation": [
                                    {
                                        "contributionScore": 0.0,  #
                                          Optional. This score shows the percentage contributing to the
                                          anomalous timestamp. A number between 0 and 1.
                                        "correlationChanges": {
                                            "changedVariables": [
                                                "str"  # Optional.
                                                  The correlated variables that have correlation
                                                  changes under an anomaly.
                                            ]
                                        },
                                        "variable": "str"  # Optional.
                                          Variable.
                                    }
                                ]
                            }
                        }
                    ],
                    "summary": {
                        "setupInfo": {
                            "dataSource": "str",  # Source link to the input data to
                              indicate an accessible Azure storage Uri, either pointed to an Azure blob
                              storage folder, or pointed to a CSV file in Azure blob storage based on
                              you data schema selection. The data schema should be exactly the same
                              with those used in the training phase. Required.
                            "endTime": "2020-02-20 00:00:00",  # A required field,
                              indicating the end time of data for detection, which should be date-time
                              of ISO 8601 format. Required.
                            "startTime": "2020-02-20 00:00:00",  # A required field,
                              indicating the start time of data for detection, which should be
                              date-time of ISO 8601 format. Required.
                            "topContributorCount": 0  # An optional field, which is used
                              to specify the number of top contributed variables for one anomalous
                              timestamp in the response. The default number is 10. Required.
                        },
                        "status": "str",  # Status of detection results. One of CREATED,
                          RUNNING, READY, and FAILED. Required. Known values are: "CREATED", "RUNNING",
                          "READY", and "FAILED".
                        "errors": [
                            {
                                "code": "str",  # The error code. Required.
                                "message": "str"  # The message explaining the error
                                  reported by the service. Required.
                            }
                        ],
                        "variableStates": [
                            {
                                "effectiveCount": 0,  # Optional. Number of effective
                                  data points before applying fillNAMethod.
                                "filledNARatio": 0.0,  # Optional. Proportion of
                                  missing values that need to be filled by fillNAMethod.
                                "firstTimestamp": "2020-02-20 00:00:00",  # Optional.
                                  First valid timestamp with value of input data.
                                "lastTimestamp": "2020-02-20 00:00:00",  # Optional.
                                  Last valid timestamp with value of input data.
                                "variable": "str"  # Optional. Variable name in
                                  variable states.
                            }
                        ]
                    }
                }
        """

    @distributed_trace_async
    async def batch_detect_anomaly(self, model_id: str, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Detect Multivariate Anomaly.

        Submit multivariate anomaly detection task with the modelId of trained model and inference
        data, the input schema should be the same with the training request. The request will complete
        asynchronously and return a resultId to query the detection result.The request should be a
        source link to indicate an externally accessible Azure storage Uri, either pointed to an Azure
        blob storage folder, or pointed to a CSV file in Azure blob storage.

        :param model_id: Model identifier. Required.
        :type model_id: str
        :param body: Detect anomaly request. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "resultId": "str",  # Result identifier, which is used to fetch the results
                      of an inference call. Required.
                    "results": [
                        {
                            "timestamp": "2020-02-20 00:00:00",  # The timestamp for this
                              anomaly. Required.
                            "errors": [
                                {
                                    "code": "str",  # The error code. Required.
                                    "message": "str"  # The message explaining
                                      the error reported by the service. Required.
                                }
                            ],
                            "value": {
                                "isAnomaly": bool,  # True if an anomaly is detected
                                  at the current timestamp. Required.
                                "score": 0.0,  # Raw anomaly score of severity, will
                                  help indicate the degree of abnormality as well. Required.
                                "severity": 0.0,  # Indicates the significance of the
                                  anomaly. The higher the severity, the more significant the anomaly
                                  is. Required.
                                "interpretation": [
                                    {
                                        "contributionScore": 0.0,  #
                                          Optional. This score shows the percentage contributing to the
                                          anomalous timestamp. A number between 0 and 1.
                                        "correlationChanges": {
                                            "changedVariables": [
                                                "str"  # Optional.
                                                  The correlated variables that have correlation
                                                  changes under an anomaly.
                                            ]
                                        },
                                        "variable": "str"  # Optional.
                                          Variable.
                                    }
                                ]
                            }
                        }
                    ],
                    "summary": {
                        "setupInfo": {
                            "dataSource": "str",  # Source link to the input data to
                              indicate an accessible Azure storage Uri, either pointed to an Azure blob
                              storage folder, or pointed to a CSV file in Azure blob storage based on
                              you data schema selection. The data schema should be exactly the same
                              with those used in the training phase. Required.
                            "endTime": "2020-02-20 00:00:00",  # A required field,
                              indicating the end time of data for detection, which should be date-time
                              of ISO 8601 format. Required.
                            "startTime": "2020-02-20 00:00:00",  # A required field,
                              indicating the start time of data for detection, which should be
                              date-time of ISO 8601 format. Required.
                            "topContributorCount": 0  # An optional field, which is used
                              to specify the number of top contributed variables for one anomalous
                              timestamp in the response. The default number is 10. Required.
                        },
                        "status": "str",  # Status of detection results. One of CREATED,
                          RUNNING, READY, and FAILED. Required. Known values are: "CREATED", "RUNNING",
                          "READY", and "FAILED".
                        "errors": [
                            {
                                "code": "str",  # The error code. Required.
                                "message": "str"  # The message explaining the error
                                  reported by the service. Required.
                            }
                        ],
                        "variableStates": [
                            {
                                "effectiveCount": 0,  # Optional. Number of effective
                                  data points before applying fillNAMethod.
                                "filledNARatio": 0.0,  # Optional. Proportion of
                                  missing values that need to be filled by fillNAMethod.
                                "firstTimestamp": "2020-02-20 00:00:00",  # Optional.
                                  First valid timestamp with value of input data.
                                "lastTimestamp": "2020-02-20 00:00:00",  # Optional.
                                  Last valid timestamp with value of input data.
                                "variable": "str"  # Optional. Variable name in
                                  variable states.
                            }
                        ]
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_batch_detect_anomaly_request(
            model_id=model_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))
        response_headers["Operation-Id"] = self._deserialize("str", response.headers.get("Operation-Id"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)

    @overload
    async def last_detect_anomaly(
        self, model_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Detect anomalies in the last point of the request body.

        Submit multivariate anomaly detection task with the modelId of trained model and inference
        data, and the inference data should be put into request body in a JSON format. The request will
        complete synchronously and return the detection immediately in the response body.

        :param model_id: Model identifier. Required.
        :type model_id: str
        :param body: Request for last detection. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "topContributorCount": 0,  # An optional field, which is used to specify the
                      number of top contributed variables for one anomalous timestamp in the response.
                      The default number is 10. Required.
                    "variables": [
                        {
                            "timestamps": [
                                "str"  # Timestamps of last detection request.
                                  Required.
                            ],
                            "values": [
                                0.0  # Values of variables. Required.
                            ],
                            "variable": "str"  # Variable name of last detection request.
                              Required.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "results": [
                        {
                            "timestamp": "2020-02-20 00:00:00",  # The timestamp for this
                              anomaly. Required.
                            "errors": [
                                {
                                    "code": "str",  # The error code. Required.
                                    "message": "str"  # The message explaining
                                      the error reported by the service. Required.
                                }
                            ],
                            "value": {
                                "isAnomaly": bool,  # True if an anomaly is detected
                                  at the current timestamp. Required.
                                "score": 0.0,  # Raw anomaly score of severity, will
                                  help indicate the degree of abnormality as well. Required.
                                "severity": 0.0,  # Indicates the significance of the
                                  anomaly. The higher the severity, the more significant the anomaly
                                  is. Required.
                                "interpretation": [
                                    {
                                        "contributionScore": 0.0,  #
                                          Optional. This score shows the percentage contributing to the
                                          anomalous timestamp. A number between 0 and 1.
                                        "correlationChanges": {
                                            "changedVariables": [
                                                "str"  # Optional.
                                                  The correlated variables that have correlation
                                                  changes under an anomaly.
                                            ]
                                        },
                                        "variable": "str"  # Optional.
                                          Variable.
                                    }
                                ]
                            }
                        }
                    ],
                    "variableStates": [
                        {
                            "effectiveCount": 0,  # Optional. Number of effective data
                              points before applying fillNAMethod.
                            "filledNARatio": 0.0,  # Optional. Proportion of missing
                              values that need to be filled by fillNAMethod.
                            "firstTimestamp": "2020-02-20 00:00:00",  # Optional. First
                              valid timestamp with value of input data.
                            "lastTimestamp": "2020-02-20 00:00:00",  # Optional. Last
                              valid timestamp with value of input data.
                            "variable": "str"  # Optional. Variable name in variable
                              states.
                        }
                    ]
                }
        """

    @overload
    async def last_detect_anomaly(
        self, model_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Detect anomalies in the last point of the request body.

        Submit multivariate anomaly detection task with the modelId of trained model and inference
        data, and the inference data should be put into request body in a JSON format. The request will
        complete synchronously and return the detection immediately in the response body.

        :param model_id: Model identifier. Required.
        :type model_id: str
        :param body: Request for last detection. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "results": [
                        {
                            "timestamp": "2020-02-20 00:00:00",  # The timestamp for this
                              anomaly. Required.
                            "errors": [
                                {
                                    "code": "str",  # The error code. Required.
                                    "message": "str"  # The message explaining
                                      the error reported by the service. Required.
                                }
                            ],
                            "value": {
                                "isAnomaly": bool,  # True if an anomaly is detected
                                  at the current timestamp. Required.
                                "score": 0.0,  # Raw anomaly score of severity, will
                                  help indicate the degree of abnormality as well. Required.
                                "severity": 0.0,  # Indicates the significance of the
                                  anomaly. The higher the severity, the more significant the anomaly
                                  is. Required.
                                "interpretation": [
                                    {
                                        "contributionScore": 0.0,  #
                                          Optional. This score shows the percentage contributing to the
                                          anomalous timestamp. A number between 0 and 1.
                                        "correlationChanges": {
                                            "changedVariables": [
                                                "str"  # Optional.
                                                  The correlated variables that have correlation
                                                  changes under an anomaly.
                                            ]
                                        },
                                        "variable": "str"  # Optional.
                                          Variable.
                                    }
                                ]
                            }
                        }
                    ],
                    "variableStates": [
                        {
                            "effectiveCount": 0,  # Optional. Number of effective data
                              points before applying fillNAMethod.
                            "filledNARatio": 0.0,  # Optional. Proportion of missing
                              values that need to be filled by fillNAMethod.
                            "firstTimestamp": "2020-02-20 00:00:00",  # Optional. First
                              valid timestamp with value of input data.
                            "lastTimestamp": "2020-02-20 00:00:00",  # Optional. Last
                              valid timestamp with value of input data.
                            "variable": "str"  # Optional. Variable name in variable
                              states.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def last_detect_anomaly(self, model_id: str, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Detect anomalies in the last point of the request body.

        Submit multivariate anomaly detection task with the modelId of trained model and inference
        data, and the inference data should be put into request body in a JSON format. The request will
        complete synchronously and return the detection immediately in the response body.

        :param model_id: Model identifier. Required.
        :type model_id: str
        :param body: Request for last detection. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "results": [
                        {
                            "timestamp": "2020-02-20 00:00:00",  # The timestamp for this
                              anomaly. Required.
                            "errors": [
                                {
                                    "code": "str",  # The error code. Required.
                                    "message": "str"  # The message explaining
                                      the error reported by the service. Required.
                                }
                            ],
                            "value": {
                                "isAnomaly": bool,  # True if an anomaly is detected
                                  at the current timestamp. Required.
                                "score": 0.0,  # Raw anomaly score of severity, will
                                  help indicate the degree of abnormality as well. Required.
                                "severity": 0.0,  # Indicates the significance of the
                                  anomaly. The higher the severity, the more significant the anomaly
                                  is. Required.
                                "interpretation": [
                                    {
                                        "contributionScore": 0.0,  #
                                          Optional. This score shows the percentage contributing to the
                                          anomalous timestamp. A number between 0 and 1.
                                        "correlationChanges": {
                                            "changedVariables": [
                                                "str"  # Optional.
                                                  The correlated variables that have correlation
                                                  changes under an anomaly.
                                            ]
                                        },
                                        "variable": "str"  # Optional.
                                          Variable.
                                    }
                                ]
                            }
                        }
                    ],
                    "variableStates": [
                        {
                            "effectiveCount": 0,  # Optional. Number of effective data
                              points before applying fillNAMethod.
                            "filledNARatio": 0.0,  # Optional. Proportion of missing
                              values that need to be filled by fillNAMethod.
                            "firstTimestamp": "2020-02-20 00:00:00",  # Optional. First
                              valid timestamp with value of input data.
                            "lastTimestamp": "2020-02-20 00:00:00",  # Optional. Last
                              valid timestamp with value of input data.
                            "variable": "str"  # Optional. Variable name in variable
                              states.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_last_detect_anomaly_request(
            model_id=model_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)
