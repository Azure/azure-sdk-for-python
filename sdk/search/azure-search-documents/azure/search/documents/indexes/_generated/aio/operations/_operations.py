# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, AsyncIterable, Callable, Dict, IO, List, Optional, Type, TypeVar, Union, overload
import urllib.parse

from azure.core import MatchConditions
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceModifiedError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import SdkJSONEncoder, _deserialize
from ...operations._operations import (
    build_data_sources_operations_create_or_update_request,
    build_data_sources_operations_create_request,
    build_data_sources_operations_delete_request,
    build_data_sources_operations_get_request,
    build_data_sources_operations_list_request,
    build_indexers_operations_create_or_update_request,
    build_indexers_operations_create_request,
    build_indexers_operations_delete_request,
    build_indexers_operations_get_request,
    build_indexers_operations_get_status_request,
    build_indexers_operations_list_request,
    build_indexers_operations_reset_request,
    build_indexers_operations_run_request,
    build_indexes_operations_analyze_request,
    build_indexes_operations_create_or_update_request,
    build_indexes_operations_create_request,
    build_indexes_operations_delete_request,
    build_indexes_operations_get_request,
    build_indexes_operations_get_statistics_request,
    build_indexes_operations_list_request,
    build_search_get_service_statistics_request,
    build_skillsets_operations_create_or_update_request,
    build_skillsets_operations_create_request,
    build_skillsets_operations_delete_request,
    build_skillsets_operations_get_request,
    build_skillsets_operations_list_request,
    build_synonym_maps_operations_create_or_update_request,
    build_synonym_maps_operations_create_request,
    build_synonym_maps_operations_delete_request,
    build_synonym_maps_operations_get_request,
    build_synonym_maps_operations_list_request,
)
from .._vendor import SearchClientMixinABC

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class DataSourcesOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`data_sources_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_or_update(
        self,
        data_source_name: str,
        data_source: _models.SearchIndexerDataSource,
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource to create or update. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Required.
        :type data_source: ~azure.search.documents.models.SearchIndexerDataSource
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        data_source_name: str,
        data_source: JSON,
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource to create or update. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Required.
        :type data_source: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        data_source_name: str,
        data_source: IO[bytes],
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource to create or update. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Required.
        :type data_source: IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        data_source_name: str,
        data_source: Union[_models.SearchIndexerDataSource, JSON, IO[bytes]],
        *,
        prefer: Union[str, _models.Enum0],
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource to create or update. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Is one of the
         following types: SearchIndexerDataSource, JSON, IO[bytes] Required.
        :type data_source: ~azure.search.documents.models.SearchIndexerDataSource or JSON or IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexerDataSource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(data_source, (IOBase, bytes)):
            _content = data_source
        else:
            _content = json.dumps(data_source, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_data_sources_operations_create_or_update_request(
            data_source_name=data_source_name,
            prefer=prefer,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerDataSource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        data_source_name: str,
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a datasource.

        :param data_source_name: The name of the datasource to delete. Required.
        :type data_source_name: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_data_sources_operations_delete_request(
            data_source_name=data_source_name,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get(self, data_source_name: str, **kwargs: Any) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Retrieves a datasource definition.

        :param data_source_name: The name of the datasource to retrieve. Required.
        :type data_source_name: str
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchIndexerDataSource] = kwargs.pop("cls", None)

        _request = build_data_sources_operations_get_request(
            data_source_name=data_source_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerDataSource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list(self, *, _select: Optional[str] = None, **kwargs: Any) -> _models.ListDataSourcesResult:
        # pylint: disable=line-too-long
        """Lists all datasources available for a search service.

        :keyword _select: Selects which top-level properties of the data sources to retrieve. Specified
         as a comma-separated list of JSON property names, or '*' for all properties.
         The default is all properties. Default value is None.
        :paramtype _select: str
        :return: ListDataSourcesResult. The ListDataSourcesResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.ListDataSourcesResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "container": {
                                "name": "str",  # The name of the table or view (for
                                  Azure SQL data source) or collection (for CosmosDB data source) that
                                  will be indexed. Required.
                                "query": "str"  # Optional. A query that is applied
                                  to this data container. The syntax and meaning of this parameter is
                                  datasource-specific. Not supported by Azure SQL datasources.
                            },
                            "credentials": {
                                "connectionString": "str"  # Optional. The connection
                                  string for the datasource. Set to ``<unchanged>`` (with brackets) if
                                  you don't want the connection string updated. Set to ``<redacted>``
                                  if you want to remove the connection string value from the
                                  datasource.
                            },
                            "name": "str",  # The name of the datasource. Required.
                            "type": "str",  # The type of the datasource. Required. Known
                              values are: "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql",
                              and "adlsgen2".
                            "@odata.etag": "str",  # Optional. The ETag of the data
                              source.
                            "dataChangeDetectionPolicy": data_change_detection_policy,
                            "dataDeletionDetectionPolicy":
                              data_deletion_detection_policy,
                            "description": "str",  # Optional. The description of the
                              datasource.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  ``https://my-keyvault-name.vault.azure.net``. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                }
                            }
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListDataSourcesResult] = kwargs.pop("cls", None)

        _request = build_data_sources_operations_list_request(
            _select=_select,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListDataSourcesResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self, data_source: _models.SearchIndexerDataSource, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource.

        :param data_source: The definition of the datasource to create. Required.
        :type data_source: ~azure.search.documents.models.SearchIndexerDataSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create(
        self, data_source: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource.

        :param data_source: The definition of the datasource to create. Required.
        :type data_source: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create(
        self, data_source: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource.

        :param data_source: The definition of the datasource to create. Required.
        :type data_source: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @distributed_trace_async
    async def create(
        self, data_source: Union[_models.SearchIndexerDataSource, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource.

        :param data_source: The definition of the datasource to create. Is one of the following types:
         SearchIndexerDataSource, JSON, IO[bytes] Required.
        :type data_source: ~azure.search.documents.models.SearchIndexerDataSource or JSON or IO[bytes]
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexerDataSource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(data_source, (IOBase, bytes)):
            _content = data_source
        else:
            _content = json.dumps(data_source, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_data_sources_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerDataSource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class IndexersOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`indexers_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def reset(self, indexer_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Resets the change tracking state associated with an indexer.

        :param indexer_name: The name of the indexer to reset. Required.
        :type indexer_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_indexers_operations_reset_request(
            indexer_name=indexer_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def run(self, indexer_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Runs an indexer on-demand.

        :param indexer_name: The name of the indexer to run. Required.
        :type indexer_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_indexers_operations_run_request(
            indexer_name=indexer_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_or_update(
        self,
        indexer_name: str,
        indexer: _models.SearchIndexer,
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer or updates an indexer if it already exists.

        :param indexer_name: The name of the indexer to create or update. Required.
        :type indexer_name: str
        :param indexer: The definition of the indexer to create or update. Required.
        :type indexer: ~azure.search.documents.models.SearchIndexer
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                indexer = {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @overload
    async def create_or_update(
        self,
        indexer_name: str,
        indexer: JSON,
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer or updates an indexer if it already exists.

        :param indexer_name: The name of the indexer to create or update. Required.
        :type indexer_name: str
        :param indexer: The definition of the indexer to create or update. Required.
        :type indexer: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @overload
    async def create_or_update(
        self,
        indexer_name: str,
        indexer: IO[bytes],
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer or updates an indexer if it already exists.

        :param indexer_name: The name of the indexer to create or update. Required.
        :type indexer_name: str
        :param indexer: The definition of the indexer to create or update. Required.
        :type indexer: IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        indexer_name: str,
        indexer: Union[_models.SearchIndexer, JSON, IO[bytes]],
        *,
        prefer: Union[str, _models.Enum0],
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer or updates an indexer if it already exists.

        :param indexer_name: The name of the indexer to create or update. Required.
        :type indexer_name: str
        :param indexer: The definition of the indexer to create or update. Is one of the following
         types: SearchIndexer, JSON, IO[bytes] Required.
        :type indexer: ~azure.search.documents.models.SearchIndexer or JSON or IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                indexer = {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexer] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(indexer, (IOBase, bytes)):
            _content = indexer
        else:
            _content = json.dumps(indexer, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_indexers_operations_create_or_update_request(
            indexer_name=indexer_name,
            prefer=prefer,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        indexer_name: str,
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes an indexer.

        :param indexer_name: The name of the indexer to delete. Required.
        :type indexer_name: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_indexers_operations_delete_request(
            indexer_name=indexer_name,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get(self, indexer_name: str, **kwargs: Any) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Retrieves an indexer definition.

        :param indexer_name: The name of the indexer to retrieve. Required.
        :type indexer_name: str
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchIndexer] = kwargs.pop("cls", None)

        _request = build_indexers_operations_get_request(
            indexer_name=indexer_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list(self, *, _select: Optional[str] = None, **kwargs: Any) -> _models.ListIndexersResult:
        # pylint: disable=line-too-long
        """Lists all indexers available for a search service.

        :keyword _select: Selects which top-level properties of the indexers to retrieve. Specified as
         a
         comma-separated list of JSON property names, or '*' for all properties. The
         default is all properties. Default value is None.
        :paramtype _select: str
        :return: ListIndexersResult. The ListIndexersResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.ListIndexersResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "dataSourceName": "str",  # The name of the datasource from
                              which this indexer reads data. Required.
                            "name": "str",  # The name of the indexer. Required.
                            "targetIndexName": "str",  # The name of the index to which
                              this indexer writes data. Required.
                            "@odata.etag": "str",  # Optional. The ETag of the indexer.
                            "description": "str",  # Optional. The description of the
                              indexer.
                            "disabled": bool,  # Optional. A value indicating whether the
                              indexer is disabled. Default is false.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  ``https://my-keyvault-name.vault.azure.net``. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                }
                            },
                            "fieldMappings": [
                                {
                                    "sourceFieldName": "str",  # The name of the
                                      field in the data source. Required.
                                    "mappingFunction": {
                                        "name": "str",  # The name of the
                                          field mapping function. Required.
                                        "parameters": {
                                            "str": {}  # Optional. A
                                              dictionary of parameter name/value pairs to pass to the
                                              function. Each value must be of a primitive type.
                                        }
                                    },
                                    "targetFieldName": "str"  # Optional. The
                                      name of the target field in the index. Same as the source field
                                      name by default.
                                }
                            ],
                            "outputFieldMappings": [
                                {
                                    "sourceFieldName": "str",  # The name of the
                                      field in the data source. Required.
                                    "mappingFunction": {
                                        "name": "str",  # The name of the
                                          field mapping function. Required.
                                        "parameters": {
                                            "str": {}  # Optional. A
                                              dictionary of parameter name/value pairs to pass to the
                                              function. Each value must be of a primitive type.
                                        }
                                    },
                                    "targetFieldName": "str"  # Optional. The
                                      name of the target field in the index. Same as the source field
                                      name by default.
                                }
                            ],
                            "parameters": {
                                "batchSize": 0,  # Optional. The number of items that
                                  are read from the data source and indexed as a single batch in order
                                  to improve performance. The default depends on the data source type.
                                "configuration": {
                                    "allowSkillsetToReadFileData": bool,  #
                                      Optional. If true, will create a path //document//file_data that
                                      is an object representing the original file data downloaded from
                                      your blob data source. This allows you to pass the original file
                                      data to a custom skill for processing within the enrichment
                                      pipeline, or to the Document Extraction skill.
                                    "dataToExtract": "str",  # Optional.
                                      Specifies the data to extract from Azure blob storage and tells
                                      the indexer which data to extract from image content when
                                      "imageAction" is set to a value other than "none".  This applies
                                      to embedded image content in a .PDF or other application, or
                                      image files such as .jpg and .png, in Azure blobs. Known values
                                      are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                                    "delimitedTextDelimiter": "str",  # Optional.
                                      For CSV blobs, specifies the end-of-line single-character
                                      delimiter for CSV files where each line starts a new document
                                      (for example, "|").
                                    "delimitedTextHeaders": "str",  # Optional.
                                      For CSV blobs, specifies a comma-delimited list of column
                                      headers, useful for mapping source fields to destination fields
                                      in an index.
                                    "documentRoot": "str",  # Optional. For JSON
                                      arrays, given a structured or semi-structured document, you can
                                      specify a path to the array using this property.
                                    "excludedFileNameExtensions": "str",  #
                                      Optional. Comma-delimited list of filename extensions to ignore
                                      when processing from Azure blob storage.  For example, you could
                                      exclude ".png, .mp4" to skip over those files during indexing.
                                    "executionEnvironment": "str",  # Optional.
                                      Specifies the environment in which the indexer should execute.
                                      Known values are: "standard" and "private".
                                    "failOnUnprocessableDocument": bool,  #
                                      Optional. For Azure blobs, set to false if you want to continue
                                      indexing if a document fails indexing.
                                    "failOnUnsupportedContentType": bool,  #
                                      Optional. For Azure blobs, set to false if you want to continue
                                      indexing when an unsupported content type is encountered, and you
                                      don't know all the content types (file extensions) in advance.
                                    "firstLineContainsHeaders": bool,  #
                                      Optional. For CSV blobs, indicates that the first (non-blank)
                                      line of each blob contains headers.
                                    "imageAction": "str",  # Optional. Determines
                                      how to process embedded images and image files in Azure blob
                                      storage.  Setting the "imageAction" configuration to any value
                                      other than "none" requires that a skillset also be attached to
                                      that indexer. Known values are: "none",
                                      "generateNormalizedImages", and "generateNormalizedImagePerPage".
                "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                                      Optional. For Azure blobs, set this property to true to still
                                      index storage metadata for blob content that is too large to
                                      process. Oversized blobs are treated as errors by default. For
                                      limits on blob size, see
                                      https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                                    "indexedFileNameExtensions": "str",  #
                                      Optional. Comma-delimited list of filename extensions to select
                                      when processing from Azure blob storage.  For example, you could
                                      focus indexing on specific application files ".docx, .pptx, .msg"
                                      to specifically include those file types.
                                    "parsingMode": "str",  # Optional. Represents
                                      the parsing mode for indexing from an Azure blob data source.
                                      Known values are: "default", "text", "delimitedText", "json",
                                      "jsonArray", and "jsonLines".
                                    "pdfTextRotationAlgorithm": "str",  #
                                      Optional. Determines algorithm for text extraction from PDF files
                                      in Azure blob storage. Known values are: "none" and
                                      "detectAngles".
                                    "queryTimeout": "str"  # Optional. Increases
                                      the timeout beyond the 5-minute default for Azure SQL database
                                      data sources, specified in the format "hh:mm:ss".
                                },
                                "maxFailedItems": 0,  # Optional. The maximum number
                                  of items that can fail indexing for indexer execution to still be
                                  considered successful. -1 means no limit. Default is 0.
                                "maxFailedItemsPerBatch": 0  # Optional. The maximum
                                  number of items in a single batch that can fail indexing for the
                                  batch to still be considered successful. -1 means no limit. Default
                                  is 0.
                            },
                            "schedule": {
                                "interval": "1 day, 0:00:00",  # The interval of time
                                  between indexer executions. Required.
                                "startTime": "2020-02-20 00:00:00"  # Optional. The
                                  time when an indexer should start running.
                            },
                            "skillsetName": "str"  # Optional. The name of the skillset
                              executing with this indexer.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListIndexersResult] = kwargs.pop("cls", None)

        _request = build_indexers_operations_list_request(
            _select=_select,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListIndexersResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self, indexer: _models.SearchIndexer, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer.

        :param indexer: The definition of the indexer to create. Required.
        :type indexer: ~azure.search.documents.models.SearchIndexer
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                indexer = {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @overload
    async def create(
        self, indexer: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer.

        :param indexer: The definition of the indexer to create. Required.
        :type indexer: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @overload
    async def create(
        self, indexer: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer.

        :param indexer: The definition of the indexer to create. Required.
        :type indexer: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @distributed_trace_async
    async def create(
        self, indexer: Union[_models.SearchIndexer, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer.

        :param indexer: The definition of the indexer to create. Is one of the following types:
         SearchIndexer, JSON, IO[bytes] Required.
        :type indexer: ~azure.search.documents.models.SearchIndexer or JSON or IO[bytes]
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                indexer = {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexer] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(indexer, (IOBase, bytes)):
            _content = indexer
        else:
            _content = json.dumps(indexer, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_indexers_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_status(self, indexer_name: str, **kwargs: Any) -> _models.SearchIndexerStatus:
        # pylint: disable=line-too-long
        """Returns the current status and execution history of an indexer.

        :param indexer_name: The name of the indexer for which to retrieve status. Required.
        :type indexer_name: str
        :return: SearchIndexerStatus. The SearchIndexerStatus is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerStatus
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "executionHistory": [
                        {
                            "errors": [
                                {
                                    "errorMessage": "str",  # The message
                                      describing the error that occurred while processing the item.
                                      Required.
                                    "statusCode": 0,  # The status code
                                      indicating why the indexing operation failed. Possible values
                                      include: 400 for a malformed input document, 404 for document not
                                      found, 409 for a version conflict, 422 when the index is
                                      temporarily unavailable, or 503 for when the service is too busy.
                                      Required.
                                    "details": "str",  # Optional. Additional,
                                      verbose details about the error to assist in debugging the
                                      indexer. This may not be always available.
                                    "documentationLink": "str",  # Optional. A
                                      link to a troubleshooting guide for these classes of errors. This
                                      may not be always available.
                                    "key": "str",  # Optional. The key of the
                                      item for which indexing failed.
                                    "name": "str"  # Optional. The name of the
                                      source at which the error originated. For example, this could
                                      refer to a particular skill in the attached skillset. This may
                                      not be always available.
                                }
                            ],
                            "itemsFailed": 0,  # The number of items that failed to be
                              indexed during this indexer execution. Required.
                            "itemsProcessed": 0,  # The number of items that were
                              processed during this indexer execution. This includes both successfully
                              processed items and items where indexing was attempted but failed.
                              Required.
                            "status": "str",  # The outcome of this indexer execution.
                              Required. Known values are: "transientFailure", "success", "inProgress",
                              and "reset".
                            "warnings": [
                                {
                                    "message": "str",  # The message describing
                                      the warning that occurred while processing the item. Required.
                                    "details": "str",  # Optional. Additional,
                                      verbose details about the warning to assist in debugging the
                                      indexer. This may not be always available.
                                    "documentationLink": "str",  # Optional. A
                                      link to a troubleshooting guide for these classes of warnings.
                                      This may not be always available.
                                    "key": "str",  # Optional. The key of the
                                      item which generated a warning.
                                    "name": "str"  # Optional. The name of the
                                      source at which the warning originated. For example, this could
                                      refer to a particular skill in the attached skillset. This may
                                      not be always available.
                                }
                            ],
                            "endTime": "2020-02-20 00:00:00",  # Optional. The end time
                              of this indexer execution, if the execution has already completed.
                            "errorMessage": "str",  # Optional. The error message
                              indicating the top-level error, if any.
                            "finalTrackingState": "str",  # Optional. Change tracking
                              state with which an indexer execution finished.
                            "initialTrackingState": "str",  # Optional. Change tracking
                              state with which an indexer execution started.
                            "startTime": "2020-02-20 00:00:00"  # Optional. The start
                              time of this indexer execution.
                        }
                    ],
                    "limits": {
                        "maxDocumentContentCharactersToExtract": 0,  # Optional. The maximum
                          number of characters that will be extracted from a document picked up for
                          indexing.
                        "maxDocumentExtractionSize": 0,  # Optional. The maximum size of a
                          document, in bytes, which will be considered valid for indexing.
                        "maxRunTime": "1 day, 0:00:00"  # Optional. The maximum duration that
                          the indexer is permitted to run for one execution.
                    },
                    "status": "str",  # Overall indexer status. Required. Known values are:
                      "unknown", "error", and "running".
                    "lastResult": {
                        "errors": [
                            {
                                "errorMessage": "str",  # The message describing the
                                  error that occurred while processing the item. Required.
                                "statusCode": 0,  # The status code indicating why
                                  the indexing operation failed. Possible values include: 400 for a
                                  malformed input document, 404 for document not found, 409 for a
                                  version conflict, 422 when the index is temporarily unavailable, or
                                  503 for when the service is too busy. Required.
                                "details": "str",  # Optional. Additional, verbose
                                  details about the error to assist in debugging the indexer. This may
                                  not be always available.
                                "documentationLink": "str",  # Optional. A link to a
                                  troubleshooting guide for these classes of errors. This may not be
                                  always available.
                                "key": "str",  # Optional. The key of the item for
                                  which indexing failed.
                                "name": "str"  # Optional. The name of the source at
                                  which the error originated. For example, this could refer to a
                                  particular skill in the attached skillset. This may not be always
                                  available.
                            }
                        ],
                        "itemsFailed": 0,  # The number of items that failed to be indexed
                          during this indexer execution. Required.
                        "itemsProcessed": 0,  # The number of items that were processed
                          during this indexer execution. This includes both successfully processed
                          items and items where indexing was attempted but failed. Required.
                        "status": "str",  # The outcome of this indexer execution. Required.
                          Known values are: "transientFailure", "success", "inProgress", and "reset".
                        "warnings": [
                            {
                                "message": "str",  # The message describing the
                                  warning that occurred while processing the item. Required.
                                "details": "str",  # Optional. Additional, verbose
                                  details about the warning to assist in debugging the indexer. This
                                  may not be always available.
                                "documentationLink": "str",  # Optional. A link to a
                                  troubleshooting guide for these classes of warnings. This may not be
                                  always available.
                                "key": "str",  # Optional. The key of the item which
                                  generated a warning.
                                "name": "str"  # Optional. The name of the source at
                                  which the warning originated. For example, this could refer to a
                                  particular skill in the attached skillset. This may not be always
                                  available.
                            }
                        ],
                        "endTime": "2020-02-20 00:00:00",  # Optional. The end time of this
                          indexer execution, if the execution has already completed.
                        "errorMessage": "str",  # Optional. The error message indicating the
                          top-level error, if any.
                        "finalTrackingState": "str",  # Optional. Change tracking state with
                          which an indexer execution finished.
                        "initialTrackingState": "str",  # Optional. Change tracking state
                          with which an indexer execution started.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The start time of
                          this indexer execution.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchIndexerStatus] = kwargs.pop("cls", None)

        _request = build_indexers_operations_get_status_request(
            indexer_name=indexer_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SkillsetsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`skillsets_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_or_update(
        self,
        skillset_name: str,
        skillset: _models.SearchIndexerSkillset,
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service or updates the skillset if it
        already exists.

        :param skillset_name: The name of the skillset to create or update. Required.
        :type skillset_name: str
        :param skillset: The skillset containing one or more skills to create or update in a search
         service. Required.
        :type skillset: ~azure.search.documents.models.SearchIndexerSkillset
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template you can fill out and use as your body input.
                skillset = {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        skillset_name: str,
        skillset: JSON,
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service or updates the skillset if it
        already exists.

        :param skillset_name: The name of the skillset to create or update. Required.
        :type skillset_name: str
        :param skillset: The skillset containing one or more skills to create or update in a search
         service. Required.
        :type skillset: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        skillset_name: str,
        skillset: IO[bytes],
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service or updates the skillset if it
        already exists.

        :param skillset_name: The name of the skillset to create or update. Required.
        :type skillset_name: str
        :param skillset: The skillset containing one or more skills to create or update in a search
         service. Required.
        :type skillset: IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        skillset_name: str,
        skillset: Union[_models.SearchIndexerSkillset, JSON, IO[bytes]],
        *,
        prefer: Union[str, _models.Enum0],
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service or updates the skillset if it
        already exists.

        :param skillset_name: The name of the skillset to create or update. Required.
        :type skillset_name: str
        :param skillset: The skillset containing one or more skills to create or update in a search
         service. Is one of the following types: SearchIndexerSkillset, JSON, IO[bytes] Required.
        :type skillset: ~azure.search.documents.models.SearchIndexerSkillset or JSON or IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template you can fill out and use as your body input.
                skillset = {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexerSkillset] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(skillset, (IOBase, bytes)):
            _content = skillset
        else:
            _content = json.dumps(skillset, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_skillsets_operations_create_or_update_request(
            skillset_name=skillset_name,
            prefer=prefer,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerSkillset, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        skillset_name: str,
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a skillset in a search service.

        :param skillset_name: The name of the skillset to delete. Required.
        :type skillset_name: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_skillsets_operations_delete_request(
            skillset_name=skillset_name,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get(self, skillset_name: str, **kwargs: Any) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Retrieves a skillset in a search service.

        :param skillset_name: The name of the skillset to retrieve. Required.
        :type skillset_name: str
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchIndexerSkillset] = kwargs.pop("cls", None)

        _request = build_skillsets_operations_get_request(
            skillset_name=skillset_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerSkillset, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list(self, *, _select: Optional[str] = None, **kwargs: Any) -> _models.ListSkillsetsResult:
        # pylint: disable=line-too-long
        """List all skillsets in a search service.

        :keyword _select: Selects which top-level properties of the skillsets to retrieve. Specified as
         a
         comma-separated list of JSON property names, or '*' for all properties. The
         default is all properties. Default value is None.
        :paramtype _select: str
        :return: ListSkillsetsResult. The ListSkillsetsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.ListSkillsetsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "name": "str",  # The name of the skillset. Required.
                            "skills": [
                                search_indexer_skill
                            ],
                            "@odata.etag": "str",  # Optional. The ETag of the skillset.
                            "cognitiveServices": cognitive_services_account,
                            "description": "str",  # Optional. The description of the
                              skillset.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  ``https://my-keyvault-name.vault.azure.net``. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                }
                            },
                            "indexProjections": {
                                "selectors": [
                                    {
                                        "mappings": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "parentKeyFieldName": "str",  # Name
                                          of the field in the search index to map the parent document's
                                          key value to. Must be a string field that is filterable and
                                          not the key field. Required.
                                        "sourceContext": "str",  # Source
                                          context for the projections. Represents the cardinality at
                                          which the document will be split into multiple sub documents.
                                          Required.
                                        "targetIndexName": "str"  # Name of
                                          the search index to project to. Must have a key field with
                                          the 'keyword' analyzer set. Required.
                                    }
                                ],
                                "parameters": {
                                    "projectionMode": "str"  # Optional. Defines
                                      behavior of the index projections in relation to the rest of the
                                      indexer. Known values are: "skipIndexingParentDocuments" and
                                      "includeIndexingParentDocuments".
                                }
                            },
                            "knowledgeStore": {
                                "projections": [
                                    {
                                        "files": [
                                            {
                                                "storageContainer":
                                                  "str",  # Blob container to store projections in.
                                                  Required.
                                                "generatedKeyName":
                                                  "str",  # Optional. Name of generated key to store
                                                  projection under.
                                                "inputs": [
                                                    {
                "name": "str",  # The name of the input.
                                                          Required.
                "inputs": [
                ...
                                                        ],
                "source": "str",  # Optional. The source of
                                                          the input.
                "sourceContext": "str"  # Optional. The
                                                          source context used for selecting recursive
                                                          inputs.
                                                    }
                                                ],
                                                "referenceKeyName":
                                                  "str",  # Optional. Name of reference key to
                                                  different projection.
                                                "source": "str",  #
                                                  Optional. Source data to project.
                                                "sourceContext":
                                                  "str"  # Optional. Source context for complex
                                                  projections.
                                            }
                                        ],
                                        "objects": [
                                            {
                                                "storageContainer":
                                                  "str",  # Blob container to store projections in.
                                                  Required.
                                                "generatedKeyName":
                                                  "str",  # Optional. Name of generated key to store
                                                  projection under.
                                                "inputs": [
                                                    {
                "name": "str",  # The name of the input.
                                                          Required.
                "inputs": [
                ...
                                                        ],
                "source": "str",  # Optional. The source of
                                                          the input.
                "sourceContext": "str"  # Optional. The
                                                          source context used for selecting recursive
                                                          inputs.
                                                    }
                                                ],
                                                "referenceKeyName":
                                                  "str",  # Optional. Name of reference key to
                                                  different projection.
                                                "source": "str",  #
                                                  Optional. Source data to project.
                                                "sourceContext":
                                                  "str"  # Optional. Source context for complex
                                                  projections.
                                            }
                                        ],
                                        "tables": [
                                            {
                                                "tableName": "str",
                                                  # Name of the Azure table to store projected data in.
                                                  Required.
                                                "generatedKeyName":
                                                  "str",  # Optional. Name of generated key to store
                                                  projection under.
                                                "inputs": [
                                                    {
                "name": "str",  # The name of the input.
                                                          Required.
                "inputs": [
                ...
                                                        ],
                "source": "str",  # Optional. The source of
                                                          the input.
                "sourceContext": "str"  # Optional. The
                                                          source context used for selecting recursive
                                                          inputs.
                                                    }
                                                ],
                                                "referenceKeyName":
                                                  "str",  # Optional. Name of reference key to
                                                  different projection.
                                                "source": "str",  #
                                                  Optional. Source data to project.
                                                "sourceContext":
                                                  "str"  # Optional. Source context for complex
                                                  projections.
                                            }
                                        ]
                                    }
                                ],
                                "storageConnectionString": "str"  # The connection
                                  string to the storage account projections will be stored in.
                                  Required.
                            }
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListSkillsetsResult] = kwargs.pop("cls", None)

        _request = build_skillsets_operations_list_request(
            _select=_select,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListSkillsetsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self, skillset: _models.SearchIndexerSkillset, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service.

        :param skillset: The skillset containing one or more skills to create in a search service.
         Required.
        :type skillset: ~azure.search.documents.models.SearchIndexerSkillset
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template you can fill out and use as your body input.
                skillset = {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @overload
    async def create(
        self, skillset: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service.

        :param skillset: The skillset containing one or more skills to create in a search service.
         Required.
        :type skillset: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @overload
    async def create(
        self, skillset: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service.

        :param skillset: The skillset containing one or more skills to create in a search service.
         Required.
        :type skillset: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @distributed_trace_async
    async def create(
        self, skillset: Union[_models.SearchIndexerSkillset, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service.

        :param skillset: The skillset containing one or more skills to create in a search service. Is
         one of the following types: SearchIndexerSkillset, JSON, IO[bytes] Required.
        :type skillset: ~azure.search.documents.models.SearchIndexerSkillset or JSON or IO[bytes]
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template you can fill out and use as your body input.
                skillset = {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexerSkillset] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(skillset, (IOBase, bytes)):
            _content = skillset
        else:
            _content = json.dumps(skillset, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_skillsets_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerSkillset, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SynonymMapsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`synonym_maps_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_or_update(
        self,
        synonym_map_name: str,
        synonym_map: _models.SynonymMap,
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map or updates a synonym map if it already exists.

        :param synonym_map_name: The name of the synonym map to create or update. Required.
        :type synonym_map_name: str
        :param synonym_map: The definition of the synonym map to create or update. Required.
        :type synonym_map: ~azure.search.documents.models.SynonymMap
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                synonym_map = {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        synonym_map_name: str,
        synonym_map: JSON,
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map or updates a synonym map if it already exists.

        :param synonym_map_name: The name of the synonym map to create or update. Required.
        :type synonym_map_name: str
        :param synonym_map: The definition of the synonym map to create or update. Required.
        :type synonym_map: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        synonym_map_name: str,
        synonym_map: IO[bytes],
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map or updates a synonym map if it already exists.

        :param synonym_map_name: The name of the synonym map to create or update. Required.
        :type synonym_map_name: str
        :param synonym_map: The definition of the synonym map to create or update. Required.
        :type synonym_map: IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        synonym_map_name: str,
        synonym_map: Union[_models.SynonymMap, JSON, IO[bytes]],
        *,
        prefer: Union[str, _models.Enum0],
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map or updates a synonym map if it already exists.

        :param synonym_map_name: The name of the synonym map to create or update. Required.
        :type synonym_map_name: str
        :param synonym_map: The definition of the synonym map to create or update. Is one of the
         following types: SynonymMap, JSON, IO[bytes] Required.
        :type synonym_map: ~azure.search.documents.models.SynonymMap or JSON or IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                synonym_map = {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SynonymMap] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(synonym_map, (IOBase, bytes)):
            _content = synonym_map
        else:
            _content = json.dumps(synonym_map, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_synonym_maps_operations_create_or_update_request(
            synonym_map_name=synonym_map_name,
            prefer=prefer,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SynonymMap, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        synonym_map_name: str,
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a synonym map.

        :param synonym_map_name: The name of the synonym map to delete. Required.
        :type synonym_map_name: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_synonym_maps_operations_delete_request(
            synonym_map_name=synonym_map_name,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get(self, synonym_map_name: str, **kwargs: Any) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Retrieves a synonym map definition.

        :param synonym_map_name: The name of the synonym map to retrieve. Required.
        :type synonym_map_name: str
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SynonymMap] = kwargs.pop("cls", None)

        _request = build_synonym_maps_operations_get_request(
            synonym_map_name=synonym_map_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SynonymMap, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list(self, *, _select: Optional[str] = None, **kwargs: Any) -> _models.ListSynonymMapsResult:
        # pylint: disable=line-too-long
        """Lists all synonym maps available for a search service.

        :keyword _select: Selects which top-level properties of the synonym maps to retrieve. Specified
         as a comma-separated list of JSON property names, or '*' for all properties.
         The default is all properties. Default value is None.
        :paramtype _select: str
        :return: ListSynonymMapsResult. The ListSynonymMapsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.ListSynonymMapsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "format": "solr",  # Default value is "solr". The format of
                              the synonym map. Only the 'solr' format is currently supported. Required.
                            "name": "str",  # The name of the synonym map. Required.
                            "synonyms": "str",  # A series of synonym rules in the
                              specified synonym map format. The rules must be separated by newlines.
                              Required.
                            "@odata.etag": "str",  # Optional. The ETag of the synonym
                              map.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  ``https://my-keyvault-name.vault.azure.net``. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                }
                            }
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListSynonymMapsResult] = kwargs.pop("cls", None)

        _request = build_synonym_maps_operations_list_request(
            _select=_select,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListSynonymMapsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self, synonym_map: _models.SynonymMap, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map.

        :param synonym_map: The definition of the synonym map to create. Required.
        :type synonym_map: ~azure.search.documents.models.SynonymMap
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                synonym_map = {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create(
        self, synonym_map: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map.

        :param synonym_map: The definition of the synonym map to create. Required.
        :type synonym_map: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create(
        self, synonym_map: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map.

        :param synonym_map: The definition of the synonym map to create. Required.
        :type synonym_map: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @distributed_trace_async
    async def create(
        self, synonym_map: Union[_models.SynonymMap, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map.

        :param synonym_map: The definition of the synonym map to create. Is one of the following types:
         SynonymMap, JSON, IO[bytes] Required.
        :type synonym_map: ~azure.search.documents.models.SynonymMap or JSON or IO[bytes]
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                synonym_map = {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SynonymMap] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(synonym_map, (IOBase, bytes)):
            _content = synonym_map
        else:
            _content = json.dumps(synonym_map, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_synonym_maps_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SynonymMap, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class IndexesOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`indexes_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self, index: _models.SearchIndex, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index.

        :param index: The definition of the index to create. Required.
        :type index: ~azure.search.documents.models.SearchIndex
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # JSON input template you can fill out and use as your body input.
                index = {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @overload
    async def create(
        self, index: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index.

        :param index: The definition of the index to create. Required.
        :type index: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @overload
    async def create(
        self, index: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index.

        :param index: The definition of the index to create. Required.
        :type index: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @distributed_trace_async
    async def create(self, index: Union[_models.SearchIndex, JSON, IO[bytes]], **kwargs: Any) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index.

        :param index: The definition of the index to create. Is one of the following types:
         SearchIndex, JSON, IO[bytes] Required.
        :type index: ~azure.search.documents.models.SearchIndex or JSON or IO[bytes]
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # JSON input template you can fill out and use as your body input.
                index = {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndex] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(index, (IOBase, bytes)):
            _content = index
        else:
            _content = json.dumps(index, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_indexes_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndex, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(self, *, _select: Optional[str] = None, **kwargs: Any) -> AsyncIterable["_models.SearchIndex"]:
        # pylint: disable=line-too-long
        """Lists all indexes available for a search service.

        :keyword _select: Selects which top-level properties of the index definitions to retrieve.
         Specified as a comma-separated list of JSON property names, or '*' for all
         properties. The default is all properties. Default value is None.
        :paramtype _select: str
        :return: An iterator like instance of SearchIndex
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.search.documents.models.SearchIndex]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SearchIndex]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_indexes_operations_list_request(
                    _select=_select,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SearchIndex], deserialized["indexes"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def create_or_update(
        self,
        index_name: str,
        index: _models.SearchIndex,
        *,
        prefer: Union[str, _models.Enum0],
        allow_index_downtime: Optional[bool] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index or updates an index if it already exists.

        :param index_name: The definition of the index to create or update. Required.
        :type index_name: str
        :param index: The definition of the index to create or update. Required.
        :type index: ~azure.search.documents.models.SearchIndex
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword allow_index_downtime: Allows new analyzers, tokenizers, token filters, or char filters
         to be added to
         an index by taking the index offline for at least a few seconds. This
         temporarily causes indexing and query requests to fail. Performance and write
         availability of the index can be impaired for several minutes after the index
         is updated, or longer for very large indexes. Default value is None.
        :paramtype allow_index_downtime: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # JSON input template you can fill out and use as your body input.
                index = {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        index_name: str,
        index: JSON,
        *,
        prefer: Union[str, _models.Enum0],
        allow_index_downtime: Optional[bool] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index or updates an index if it already exists.

        :param index_name: The definition of the index to create or update. Required.
        :type index_name: str
        :param index: The definition of the index to create or update. Required.
        :type index: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword allow_index_downtime: Allows new analyzers, tokenizers, token filters, or char filters
         to be added to
         an index by taking the index offline for at least a few seconds. This
         temporarily causes indexing and query requests to fail. Performance and write
         availability of the index can be impaired for several minutes after the index
         is updated, or longer for very large indexes. Default value is None.
        :paramtype allow_index_downtime: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        index_name: str,
        index: IO[bytes],
        *,
        prefer: Union[str, _models.Enum0],
        allow_index_downtime: Optional[bool] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index or updates an index if it already exists.

        :param index_name: The definition of the index to create or update. Required.
        :type index_name: str
        :param index: The definition of the index to create or update. Required.
        :type index: IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword allow_index_downtime: Allows new analyzers, tokenizers, token filters, or char filters
         to be added to
         an index by taking the index offline for at least a few seconds. This
         temporarily causes indexing and query requests to fail. Performance and write
         availability of the index can be impaired for several minutes after the index
         is updated, or longer for very large indexes. Default value is None.
        :paramtype allow_index_downtime: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        index_name: str,
        index: Union[_models.SearchIndex, JSON, IO[bytes]],
        *,
        prefer: Union[str, _models.Enum0],
        allow_index_downtime: Optional[bool] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index or updates an index if it already exists.

        :param index_name: The definition of the index to create or update. Required.
        :type index_name: str
        :param index: The definition of the index to create or update. Is one of the following types:
         SearchIndex, JSON, IO[bytes] Required.
        :type index: ~azure.search.documents.models.SearchIndex or JSON or IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword allow_index_downtime: Allows new analyzers, tokenizers, token filters, or char filters
         to be added to
         an index by taking the index offline for at least a few seconds. This
         temporarily causes indexing and query requests to fail. Performance and write
         availability of the index can be impaired for several minutes after the index
         is updated, or longer for very large indexes. Default value is None.
        :paramtype allow_index_downtime: bool
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # JSON input template you can fill out and use as your body input.
                index = {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndex] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(index, (IOBase, bytes)):
            _content = index
        else:
            _content = json.dumps(index, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_indexes_operations_create_or_update_request(
            index_name=index_name,
            prefer=prefer,
            allow_index_downtime=allow_index_downtime,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndex, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        index_name: str,
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a search index and all the documents it contains. This operation is
        permanent, with no recovery option. Make sure you have a master copy of your
        index definition, data ingestion code, and a backup of the primary data source
        in case you need to re-build the index.

        :param index_name: The name of the index to delete. Required.
        :type index_name: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_indexes_operations_delete_request(
            index_name=index_name,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get(self, index_name: str, **kwargs: Any) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Retrieves an index definition.

        :param index_name: The name of the index to retrieve. Required.
        :type index_name: str
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchIndex] = kwargs.pop("cls", None)

        _request = build_indexes_operations_get_request(
            index_name=index_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndex, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_statistics(self, index_name: str, **kwargs: Any) -> _models.GetIndexStatisticsResult:
        """Returns statistics for the given index, including a document count and storage
        usage.

        :param index_name: The name of the index for which to retrieve statistics. Required.
        :type index_name: str
        :return: GetIndexStatisticsResult. The GetIndexStatisticsResult is compatible with
         MutableMapping
        :rtype: ~azure.search.documents.models.GetIndexStatisticsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "documentCount": 0,  # The number of documents in the index. Required.
                    "storageSize": 0,  # The amount of storage in bytes consumed by the index.
                      Required.
                    "vectorIndexSize": 0  # The amount of memory in bytes consumed by vectors in
                      the index. Required.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GetIndexStatisticsResult] = kwargs.pop("cls", None)

        _request = build_indexes_operations_get_statistics_request(
            index_name=index_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GetIndexStatisticsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def analyze(
        self, index_name: str, request: _models.AnalyzeRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AnalyzeResult:
        # pylint: disable=line-too-long
        """Shows how an analyzer breaks text into tokens.

        :param index_name: The name of the index for which to test an analyzer. Required.
        :type index_name: str
        :param request: The text and analyzer or analysis components to test. Required.
        :type request: ~azure.search.documents.models.AnalyzeRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AnalyzeResult. The AnalyzeResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AnalyzeResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request = {
                    "text": "str",  # The text to break into tokens. Required.
                    "analyzer": "str",  # Optional. The name of the analyzer to use to break the
                      given text. If this parameter is not specified, you must specify a tokenizer
                      instead. The tokenizer and analyzer parameters are mutually exclusive. Known
                      values are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                      "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                      "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft", "zh-Hant.lucene",
                      "hr.microsoft", "cs.microsoft", "cs.lucene", "da.microsoft", "da.lucene",
                      "nl.microsoft", "nl.lucene", "en.microsoft", "en.lucene", "et.microsoft",
                      "fi.microsoft", "fi.lucene", "fr.microsoft", "fr.lucene", "gl.lucene",
                      "de.microsoft", "de.lucene", "el.microsoft", "el.lucene", "gu.microsoft",
                      "he.microsoft", "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene",
                      "is.microsoft", "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft",
                      "it.lucene", "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft",
                      "ko.lucene", "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                      "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                      "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                      "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft", "ro.lucene",
                      "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft", "sr-latin.microsoft",
                      "sk.microsoft", "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft",
                      "sv.lucene", "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                      "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft", "vi.microsoft",
                      "standard.lucene", "standardasciifolding.lucene", "keyword", "pattern", "simple",
                      "stop", and "whitespace".
                    "charFilters": [
                        "str"  # Optional. An optional list of character filters to use when
                          breaking the given text. This parameter can only be set when using the
                          tokenizer parameter.
                    ],
                    "tokenFilters": [
                        "str"  # Optional. An optional list of token filters to use when
                          breaking the given text. This parameter can only be set when using the
                          tokenizer parameter.
                    ],
                    "tokenizer": "str"  # Optional. The name of the tokenizer to use to break the
                      given text. If this parameter is not specified, you must specify an analyzer
                      instead. The tokenizer and analyzer parameters are mutually exclusive. Known
                      values are: "classic", "edgeNGram", "keyword_v2", "letter", "lowercase",
                      "microsoft_language_tokenizer", "microsoft_language_stemming_tokenizer", "nGram",
                      "path_hierarchy_v2", "pattern", "standard_v2", "uax_url_email", and "whitespace".
                }

                # response body for status code(s): 200
                response == {
                    "tokens": [
                        {
                            "endOffset": 0,  # The index of the last character of the
                              token in the input text. Required.
                            "position": 0,  # The position of the token in the input text
                              relative to other tokens. The first token in the input text has position
                              0, the next has position 1, and so on. Depending on the analyzer used,
                              some tokens might have the same position, for example if they are
                              synonyms of each other. Required.
                            "startOffset": 0,  # The index of the first character of the
                              token in the input text. Required.
                            "token": "str"  # The token returned by the analyzer.
                              Required.
                        }
                    ]
                }
        """

    @overload
    async def analyze(
        self, index_name: str, request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AnalyzeResult:
        # pylint: disable=line-too-long
        """Shows how an analyzer breaks text into tokens.

        :param index_name: The name of the index for which to test an analyzer. Required.
        :type index_name: str
        :param request: The text and analyzer or analysis components to test. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AnalyzeResult. The AnalyzeResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AnalyzeResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tokens": [
                        {
                            "endOffset": 0,  # The index of the last character of the
                              token in the input text. Required.
                            "position": 0,  # The position of the token in the input text
                              relative to other tokens. The first token in the input text has position
                              0, the next has position 1, and so on. Depending on the analyzer used,
                              some tokens might have the same position, for example if they are
                              synonyms of each other. Required.
                            "startOffset": 0,  # The index of the first character of the
                              token in the input text. Required.
                            "token": "str"  # The token returned by the analyzer.
                              Required.
                        }
                    ]
                }
        """

    @overload
    async def analyze(
        self, index_name: str, request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AnalyzeResult:
        # pylint: disable=line-too-long
        """Shows how an analyzer breaks text into tokens.

        :param index_name: The name of the index for which to test an analyzer. Required.
        :type index_name: str
        :param request: The text and analyzer or analysis components to test. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AnalyzeResult. The AnalyzeResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AnalyzeResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tokens": [
                        {
                            "endOffset": 0,  # The index of the last character of the
                              token in the input text. Required.
                            "position": 0,  # The position of the token in the input text
                              relative to other tokens. The first token in the input text has position
                              0, the next has position 1, and so on. Depending on the analyzer used,
                              some tokens might have the same position, for example if they are
                              synonyms of each other. Required.
                            "startOffset": 0,  # The index of the first character of the
                              token in the input text. Required.
                            "token": "str"  # The token returned by the analyzer.
                              Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def analyze(
        self, index_name: str, request: Union[_models.AnalyzeRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AnalyzeResult:
        # pylint: disable=line-too-long
        """Shows how an analyzer breaks text into tokens.

        :param index_name: The name of the index for which to test an analyzer. Required.
        :type index_name: str
        :param request: The text and analyzer or analysis components to test. Is one of the following
         types: AnalyzeRequest, JSON, IO[bytes] Required.
        :type request: ~azure.search.documents.models.AnalyzeRequest or JSON or IO[bytes]
        :return: AnalyzeResult. The AnalyzeResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AnalyzeResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request = {
                    "text": "str",  # The text to break into tokens. Required.
                    "analyzer": "str",  # Optional. The name of the analyzer to use to break the
                      given text. If this parameter is not specified, you must specify a tokenizer
                      instead. The tokenizer and analyzer parameters are mutually exclusive. Known
                      values are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                      "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                      "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft", "zh-Hant.lucene",
                      "hr.microsoft", "cs.microsoft", "cs.lucene", "da.microsoft", "da.lucene",
                      "nl.microsoft", "nl.lucene", "en.microsoft", "en.lucene", "et.microsoft",
                      "fi.microsoft", "fi.lucene", "fr.microsoft", "fr.lucene", "gl.lucene",
                      "de.microsoft", "de.lucene", "el.microsoft", "el.lucene", "gu.microsoft",
                      "he.microsoft", "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene",
                      "is.microsoft", "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft",
                      "it.lucene", "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft",
                      "ko.lucene", "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                      "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                      "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                      "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft", "ro.lucene",
                      "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft", "sr-latin.microsoft",
                      "sk.microsoft", "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft",
                      "sv.lucene", "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                      "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft", "vi.microsoft",
                      "standard.lucene", "standardasciifolding.lucene", "keyword", "pattern", "simple",
                      "stop", and "whitespace".
                    "charFilters": [
                        "str"  # Optional. An optional list of character filters to use when
                          breaking the given text. This parameter can only be set when using the
                          tokenizer parameter.
                    ],
                    "tokenFilters": [
                        "str"  # Optional. An optional list of token filters to use when
                          breaking the given text. This parameter can only be set when using the
                          tokenizer parameter.
                    ],
                    "tokenizer": "str"  # Optional. The name of the tokenizer to use to break the
                      given text. If this parameter is not specified, you must specify an analyzer
                      instead. The tokenizer and analyzer parameters are mutually exclusive. Known
                      values are: "classic", "edgeNGram", "keyword_v2", "letter", "lowercase",
                      "microsoft_language_tokenizer", "microsoft_language_stemming_tokenizer", "nGram",
                      "path_hierarchy_v2", "pattern", "standard_v2", "uax_url_email", and "whitespace".
                }

                # response body for status code(s): 200
                response == {
                    "tokens": [
                        {
                            "endOffset": 0,  # The index of the last character of the
                              token in the input text. Required.
                            "position": 0,  # The position of the token in the input text
                              relative to other tokens. The first token in the input text has position
                              0, the next has position 1, and so on. Depending on the analyzer used,
                              some tokens might have the same position, for example if they are
                              synonyms of each other. Required.
                            "startOffset": 0,  # The index of the first character of the
                              token in the input text. Required.
                            "token": "str"  # The token returned by the analyzer.
                              Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AnalyzeResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_indexes_operations_analyze_request(
            index_name=index_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AnalyzeResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SearchClientOperationsMixin(SearchClientMixinABC):

    @distributed_trace_async
    async def get_service_statistics(self, **kwargs: Any) -> _models.SearchServiceStatistics:
        # pylint: disable=line-too-long
        """Gets service level statistics for a search service.

        :return: SearchServiceStatistics. The SearchServiceStatistics is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchServiceStatistics
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "counters": {
                        "dataSourcesCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "documentCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "indexersCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "indexesCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "skillsetCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "storageSize": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "synonymMaps": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "vectorIndexSize": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        }
                    },
                    "limits": {
                        "maxComplexCollectionFieldsPerIndex": 0,  # Optional. The maximum
                          number of fields of type Collection(Edm.ComplexType) allowed in an index.
                        "maxComplexObjectsInCollectionsPerDocument": 0,  # Optional. The
                          maximum number of objects in complex collections allowed per document.
                        "maxFieldNestingDepthPerIndex": 0,  # Optional. The maximum depth
                          which you can nest sub-fields in an index, including the top-level complex
                          field. For example, a/b/c has a nesting depth of 3.
                        "maxFieldsPerIndex": 0,  # Optional. The maximum allowed fields per
                          index.
                        "maxStoragePerIndex": 0  # Optional. The maximum amount of storage in
                          bytes allowed per index.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchServiceStatistics] = kwargs.pop("cls", None)

        _request = build_search_get_service_statistics_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchServiceStatistics, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
