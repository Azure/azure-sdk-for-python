# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, List, Optional, Type, TypeVar, Union, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import SdkJSONEncoder, _deserialize
from ...operations._operations import (
    build_documents_operations_autocomplete_get_request,
    build_documents_operations_autocomplete_post_request,
    build_documents_operations_count_request,
    build_documents_operations_get_request,
    build_documents_operations_index_request,
    build_documents_operations_search_get_request,
    build_documents_operations_search_post_request,
    build_documents_operations_suggest_get_request,
    build_documents_operations_suggest_post_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class DocumentsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`documents_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def count(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Queries the number of documents in the index.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_documents_operations_count_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def search_get(
        self,
        *,
        search_text: Optional[str] = None,
        include_total_result_count: Optional[bool] = None,
        facets: Optional[List[str]] = None,
        _filter: Optional[str] = None,
        highlight_fields: Optional[List[str]] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        order_by: Optional[List[str]] = None,
        query_type: Optional[Union[str, _models.QueryType]] = None,
        scoring_parameters: Optional[List[str]] = None,
        scoring_profile: Optional[str] = None,
        search_fields: Optional[List[str]] = None,
        search_mode: Optional[Union[str, _models.SearchMode]] = None,
        scoring_statistics: Optional[Union[str, _models.ScoringStatistics]] = None,
        session_id: Optional[str] = None,
        _select: Optional[List[str]] = None,
        _skip: Optional[int] = None,
        _top: Optional[int] = None,
        semantic_configuration: Optional[str] = None,
        semantic_error_handling: Optional[Union[str, _models.SemanticErrorMode]] = None,
        semantic_max_wait_in_milliseconds: Optional[int] = None,
        answers: Optional[Union[str, _models.QueryAnswerType]] = None,
        captions: Optional[Union[str, _models.QueryCaptionType]] = None,
        semantic_query: Optional[str] = None,
        **kwargs: Any
    ) -> _models.SearchDocumentsResult:
        # pylint: disable=line-too-long
        """Searches for documents in the index.

        :keyword search_text: A full-text search query expression; Use "*" or omit this parameter to
         match
         all documents. Default value is None.
        :paramtype search_text: str
        :keyword include_total_result_count: A value that specifies whether to fetch the total count of
         results. Default is
         false. Setting this value to true may have a performance impact. Note that the
         count returned is an approximation. Default value is None.
        :paramtype include_total_result_count: bool
        :keyword facets: The list of facet expressions to apply to the search query. Each facet
         expression contains a field name, optionally followed by a comma-separated list
         of name:value pairs. Default value is None.
        :paramtype facets: list[str]
        :keyword _filter: The OData $filter expression to apply to the search query. Default value is
         None.
        :paramtype _filter: str
        :keyword highlight_fields: The list of field names to use for hit highlights. Only searchable
         fields can
         be used for hit highlighting. Default value is None.
        :paramtype highlight_fields: list[str]
        :keyword highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
         highlightPreTag. Default is &lt;/em&gt;. Default value is None.
        :paramtype highlight_post_tag: str
        :keyword highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
         highlightPostTag. Default is &lt;em&gt;. Default value is None.
        :paramtype highlight_pre_tag: str
        :keyword minimum_coverage: A number between 0 and 100 indicating the percentage of the index
         that must be
         covered by a search query in order for the query to be reported as a success.
         This parameter can be useful for ensuring search availability even for services
         with only one replica. The default is 100. Default value is None.
        :paramtype minimum_coverage: float
        :keyword order_by: The list of OData $orderby expressions by which to sort the results. Each
         expression can be either a field name or a call to either the geo.distance() or
         the search.score() functions. Each expression can be followed by asc to
         indicate ascending, and desc to indicate descending. The default is ascending
         order. Ties will be broken by the match scores of documents. If no OrderBy is
         specified, the default sort order is descending by document match score. There
         can be at most 32 $orderby clauses. Default value is None.
        :paramtype order_by: list[str]
        :keyword query_type: A value that specifies the syntax of the search query. The default is
         'simple'.
         Use 'full' if your query uses the Lucene query syntax. Known values are: "simple", "full", and
         "semantic". Default value is None.
        :paramtype query_type: str or ~azure.search.documents.models.QueryType
        :keyword scoring_parameters: The list of parameter values to be used in scoring functions (for
         example,
         referencePointParameter) using the format name-values. For example, if the
         scoring profile defines a function with a parameter called 'mylocation' the
         parameter string would be "mylocation--122.2,44.8" (without the quotes). Default value is
         None.
        :paramtype scoring_parameters: list[str]
        :keyword scoring_profile: The name of a scoring profile to evaluate match scores for matching
         documents
         in order to sort the results. Default value is None.
        :paramtype scoring_profile: str
        :keyword search_fields: The list of field names to which to scope the full-text search. When
         using
         fielded search (fieldName:searchExpression) in a full Lucene query, the field
         names of each fielded search expression take precedence over any field names
         listed in this parameter. Default value is None.
        :paramtype search_fields: list[str]
        :keyword search_mode: A value that specifies whether any or all of the search terms must be
         matched
         in order to count the document as a match. Known values are: "any" and "all". Default value is
         None.
        :paramtype search_mode: str or ~azure.search.documents.models.SearchMode
        :keyword scoring_statistics: A value that specifies whether we want to calculate scoring
         statistics (such as
         document frequency) globally for more consistent scoring, or locally, for lower
         latency. Known values are: "local" and "global". Default value is None.
        :paramtype scoring_statistics: str or ~azure.search.documents.models.ScoringStatistics
        :keyword session_id: A value to be used to create a sticky session, which can help to get more
         consistent results. As long as the same sessionId is used, a best-effort
         attempt will be made to target the same replica set. Be wary that reusing the
         same sessionID values repeatedly can interfere with the load balancing of the
         requests across replicas and adversely affect the performance of the search
         service. The value used as sessionId cannot start with a '_' character. Default value is None.
        :paramtype session_id: str
        :keyword _select: The list of fields to retrieve. If unspecified, all fields marked as
         retrievable in the schema are included. Default value is None.
        :paramtype _select: list[str]
        :keyword _skip: The number of search results to skip. This value cannot be greater than
         100,000. If you need to scan documents in sequence, but cannot use $skip due to
         this limitation, consider using $orderby on a totally-ordered key and $filter
         with a range query instead. Default value is None.
        :paramtype _skip: int
        :keyword _top: The number of search results to retrieve. This can be used in conjunction with
         $skip to implement client-side paging of search results. If results are
         truncated due to server-side paging, the response will include a continuation
         token that can be used to issue another Search request for the next page of
         results. Default value is None.
        :paramtype _top: int
        :keyword semantic_configuration: The name of the semantic configuration that lists which fields
         should be used
         for semantic ranking, captions, highlights, and answers. Default value is None.
        :paramtype semantic_configuration: str
        :keyword semantic_error_handling: Allows the user to choose whether a semantic call should fail
         completely, or to
         return partial results (default). Known values are: "partial" and "fail". Default value is
         None.
        :paramtype semantic_error_handling: str or ~azure.search.documents.models.SemanticErrorMode
        :keyword semantic_max_wait_in_milliseconds: Allows the user to set an upper bound on the amount
         of time it takes for
         semantic enrichment to finish processing before the request fails. Default value is None.
        :paramtype semantic_max_wait_in_milliseconds: int
        :keyword answers: This parameter is only valid if the query type is ``semantic``. If set, the
         query
         returns answers extracted from key passages in the highest ranked documents.
         The number of answers returned can be configured by appending the pipe
         character ``|`` followed by the ``count-<number of answers>`` option after the
         answers parameter value, such as ``extractive|count-3``. Default count is 1. The
         confidence threshold can be configured by appending the pipe character ``|``
         followed by the ``threshold-<confidence threshold>`` option after the answers
         parameter value, such as ``extractive|threshold-0.9``. Default threshold is 0.7. Known values
         are: "none" and "extractive". Default value is None.
        :paramtype answers: str or ~azure.search.documents.models.QueryAnswerType
        :keyword captions: This parameter is only valid if the query type is ``semantic``. If set, the
         query
         returns captions extracted from key passages in the highest ranked documents.
         When Captions is set to ``extractive``\\ , highlighting is enabled by default, and
         can be configured by appending the pipe character ``|`` followed by the
         ``highlight-<true/false>`` option, such as ``extractive|highlight-true``. Defaults
         to ``None``. Known values are: "none" and "extractive". Default value is None.
        :paramtype captions: str or ~azure.search.documents.models.QueryCaptionType
        :keyword semantic_query: Allows setting a separate search query that will be solely used for
         semantic
         reranking, semantic captions and semantic answers. Is useful for scenarios
         where there is a need to use different queries between the base retrieval and
         ranking phase, and the L2 semantic phase. Default value is None.
        :paramtype semantic_query: str
        :return: SearchDocumentsResult. The SearchDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if the query can't return all the
                      requested documents in a single response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when the
                      query can't return all the requested results in a single response. You can use
                      this URL to formulate another GET or POST Search request to get the next part of
                      the search response. Make sure to use the same verb (GET or POST) as the request
                      that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticErrorHandling": "str",  # Optional. Allows the user to
                          choose whether a semantic call should fail completely (default / current
                          behavior), or to return partial results. Known values are: "partial" and
                          "fail".
                        "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to
                          set an upper bound on the amount of time it takes for semantic enrichment to
                          finish processing before the request fails.
                        "semanticQuery": "str",  # Optional. Allows setting a separate search
                          query that will be solely used for semantic reranking, semantic captions and
                          semantic answers. Is useful for scenarios where there is a need to use
                          different queries between the base retrieval and ranking phase, and the L2
                          semantic phase.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "top": 0,  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                        "vectorFilterMode": "str",  # Optional. Determines whether or not
                          filters are applied before or after the vector search is performed. Default
                          is 'preFilter' for new indexes. Known values are: "postFilter" and
                          "preFilter".
                        "vectorQueries": [
                            vector_query
                        ]
                    },
                    "@search.semanticPartialResponseReason": "str",  # Optional. Reason that a
                      partial response was returned for a semantic ranking request. Known values are:
                      "maxWaitExceeded", "capacityOverloaded", and "transient".
                    "@search.semanticPartialResponseType": "str"  # Optional. Type of partial
                      response that was returned for a semantic ranking request. Known values are:
                      "baseResults" and "rerankedResults".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchDocumentsResult] = kwargs.pop("cls", None)

        _request = build_documents_operations_search_get_request(
            search_text=search_text,
            include_total_result_count=include_total_result_count,
            facets=facets,
            _filter=_filter,
            highlight_fields=highlight_fields,
            highlight_post_tag=highlight_post_tag,
            highlight_pre_tag=highlight_pre_tag,
            minimum_coverage=minimum_coverage,
            order_by=order_by,
            query_type=query_type,
            scoring_parameters=scoring_parameters,
            scoring_profile=scoring_profile,
            search_fields=search_fields,
            search_mode=search_mode,
            scoring_statistics=scoring_statistics,
            session_id=session_id,
            _select=_select,
            _skip=_skip,
            _top=_top,
            semantic_configuration=semantic_configuration,
            semantic_error_handling=semantic_error_handling,
            semantic_max_wait_in_milliseconds=semantic_max_wait_in_milliseconds,
            answers=answers,
            captions=captions,
            semantic_query=semantic_query,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchDocumentsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def search_post(
        self, search_request: _models.SearchRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchDocumentsResult:
        # pylint: disable=line-too-long
        """Searches for documents in the index.

        :param search_request: The definition of the Search request. Required.
        :type search_request: ~azure.search.documents.models.SearchRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchDocumentsResult. The SearchDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                search_request = {
                    "answers": "str",  # Optional. A value that specifies whether answers should
                      be returned as part of the search response. Known values are: "none" and
                      "extractive".
                    "captions": "str",  # Optional. A value that specifies whether captions
                      should be returned as part of the search response. Known values are: "none" and
                      "extractive".
                    "count": bool,  # Optional. A value that specifies whether to fetch the total
                      count of results. Default is false. Setting this value to true may have a
                      performance impact. Note that the count returned is an approximation.
                    "facets": [
                        "str"  # Optional. The list of facet expressions to apply to the
                          search query. Each facet expression contains a field name, optionally
                          followed by a comma-separated list of name:value pairs.
                    ],
                    "filter": "str",  # Optional. The OData $filter expression to apply to the
                      search query.
                    "highlight": "str",  # Optional. The comma-separated list of field names to
                      use for hit highlights. Only searchable fields can be used for hit highlighting.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by a search query in order for
                      the query to be reported as a success. This parameter can be useful for ensuring
                      search availability even for services with only one replica. The default is 100.
                    "orderby": "str",  # Optional. The comma-separated list of OData $orderby
                      expressions by which to sort the results. Each expression can be either a field
                      name or a call to either the geo.distance() or the search.score() functions. Each
                      expression can be followed by asc to indicate ascending, or desc to indicate
                      descending. The default is ascending order. Ties will be broken by the match
                      scores of documents. If no $orderby is specified, the default sort order is
                      descending by document match score. There can be at most 32 $orderby clauses.
                    "queryType": "str",  # Optional. A value that specifies the syntax of the
                      search query. The default is 'simple'. Use 'full' if your query uses the Lucene
                      query syntax. Known values are: "simple", "full", and "semantic".
                    "scoringParameters": [
                        "str"  # Optional. The list of parameter values to be used in scoring
                          functions (for example, referencePointParameter) using the format
                          name-values. For example, if the scoring profile defines a function with a
                          parameter called 'mylocation' the parameter string would be
                          "mylocation--122.2,44.8" (without the quotes).
                    ],
                    "scoringProfile": "str",  # Optional. The name of a scoring profile to
                      evaluate match scores for matching documents in order to sort the results.
                    "scoringStatistics": "str",  # Optional. A value that specifies whether we
                      want to calculate scoring statistics (such as document frequency) globally for
                      more consistent scoring, or locally, for lower latency. The default is 'local'.
                      Use 'global' to aggregate scoring statistics globally before scoring. Using
                      global scoring statistics can increase latency of search queries. Known values
                      are: "local" and "global".
                    "search": "str",  # Optional. A full-text search query expression; Use "*" or
                      omit this parameter to match all documents.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to which to scope the full-text search. When using fielded search
                      (fieldName:searchExpression) in a full Lucene query, the field names of each
                      fielded search expression take precedence over any field names listed in this
                      parameter.
                    "searchMode": "str",  # Optional. A value that specifies whether any or all
                      of the search terms must be matched in order to count the document as a match.
                      Known values are: "any" and "all".
                    "select": "str",  # Optional. The comma-separated list of fields to retrieve.
                      If unspecified, all fields marked as retrievable in the schema are included.
                    "semanticConfiguration": "str",  # Optional. The name of a semantic
                      configuration that will be used when processing documents for queries of type
                      semantic.
                    "semanticErrorHandling": "str",  # Optional. Allows the user to choose
                      whether a semantic call should fail completely (default / current behavior), or
                      to return partial results. Known values are: "partial" and "fail".
                    "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to set an
                      upper bound on the amount of time it takes for semantic enrichment to finish
                      processing before the request fails.
                    "semanticQuery": "str",  # Optional. Allows setting a separate search query
                      that will be solely used for semantic reranking, semantic captions and semantic
                      answers. Is useful for scenarios where there is a need to use different queries
                      between the base retrieval and ranking phase, and the L2 semantic phase.
                    "sessionId": "str",  # Optional. A value to be used to create a sticky
                      session, which can help getting more consistent results. As long as the same
                      sessionId is used, a best-effort attempt will be made to target the same replica
                      set. Be wary that reusing the same sessionID values repeatedly can interfere with
                      the load balancing of the requests across replicas and adversely affect the
                      performance of the search service. The value used as sessionId cannot start with
                      a '_' character.
                    "skip": 0,  # Optional. The number of search results to skip. This value
                      cannot be greater than 100,000. If you need to scan documents in sequence, but
                      cannot use skip due to this limitation, consider using orderby on a
                      totally-ordered key and filter with a range query instead.
                    "top": 0,  # Optional. The number of search results to retrieve. This can be
                      used in conjunction with $skip to implement client-side paging of search results.
                      If results are truncated due to server-side paging, the response will include a
                      continuation token that can be used to issue another Search request for the next
                      page of results.
                    "vectorFilterMode": "str",  # Optional. Determines whether or not filters are
                      applied before or after the vector search is performed. Default is 'preFilter'
                      for new indexes. Known values are: "postFilter" and "preFilter".
                    "vectorQueries": [
                        vector_query
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if the query can't return all the
                      requested documents in a single response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when the
                      query can't return all the requested results in a single response. You can use
                      this URL to formulate another GET or POST Search request to get the next part of
                      the search response. Make sure to use the same verb (GET or POST) as the request
                      that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticErrorHandling": "str",  # Optional. Allows the user to
                          choose whether a semantic call should fail completely (default / current
                          behavior), or to return partial results. Known values are: "partial" and
                          "fail".
                        "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to
                          set an upper bound on the amount of time it takes for semantic enrichment to
                          finish processing before the request fails.
                        "semanticQuery": "str",  # Optional. Allows setting a separate search
                          query that will be solely used for semantic reranking, semantic captions and
                          semantic answers. Is useful for scenarios where there is a need to use
                          different queries between the base retrieval and ranking phase, and the L2
                          semantic phase.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "top": 0,  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                        "vectorFilterMode": "str",  # Optional. Determines whether or not
                          filters are applied before or after the vector search is performed. Default
                          is 'preFilter' for new indexes. Known values are: "postFilter" and
                          "preFilter".
                        "vectorQueries": [
                            vector_query
                        ]
                    },
                    "@search.semanticPartialResponseReason": "str",  # Optional. Reason that a
                      partial response was returned for a semantic ranking request. Known values are:
                      "maxWaitExceeded", "capacityOverloaded", and "transient".
                    "@search.semanticPartialResponseType": "str"  # Optional. Type of partial
                      response that was returned for a semantic ranking request. Known values are:
                      "baseResults" and "rerankedResults".
                }
        """

    @overload
    async def search_post(
        self, search_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchDocumentsResult:
        # pylint: disable=line-too-long
        """Searches for documents in the index.

        :param search_request: The definition of the Search request. Required.
        :type search_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchDocumentsResult. The SearchDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if the query can't return all the
                      requested documents in a single response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when the
                      query can't return all the requested results in a single response. You can use
                      this URL to formulate another GET or POST Search request to get the next part of
                      the search response. Make sure to use the same verb (GET or POST) as the request
                      that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticErrorHandling": "str",  # Optional. Allows the user to
                          choose whether a semantic call should fail completely (default / current
                          behavior), or to return partial results. Known values are: "partial" and
                          "fail".
                        "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to
                          set an upper bound on the amount of time it takes for semantic enrichment to
                          finish processing before the request fails.
                        "semanticQuery": "str",  # Optional. Allows setting a separate search
                          query that will be solely used for semantic reranking, semantic captions and
                          semantic answers. Is useful for scenarios where there is a need to use
                          different queries between the base retrieval and ranking phase, and the L2
                          semantic phase.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "top": 0,  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                        "vectorFilterMode": "str",  # Optional. Determines whether or not
                          filters are applied before or after the vector search is performed. Default
                          is 'preFilter' for new indexes. Known values are: "postFilter" and
                          "preFilter".
                        "vectorQueries": [
                            vector_query
                        ]
                    },
                    "@search.semanticPartialResponseReason": "str",  # Optional. Reason that a
                      partial response was returned for a semantic ranking request. Known values are:
                      "maxWaitExceeded", "capacityOverloaded", and "transient".
                    "@search.semanticPartialResponseType": "str"  # Optional. Type of partial
                      response that was returned for a semantic ranking request. Known values are:
                      "baseResults" and "rerankedResults".
                }
        """

    @overload
    async def search_post(
        self, search_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchDocumentsResult:
        # pylint: disable=line-too-long
        """Searches for documents in the index.

        :param search_request: The definition of the Search request. Required.
        :type search_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchDocumentsResult. The SearchDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if the query can't return all the
                      requested documents in a single response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when the
                      query can't return all the requested results in a single response. You can use
                      this URL to formulate another GET or POST Search request to get the next part of
                      the search response. Make sure to use the same verb (GET or POST) as the request
                      that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticErrorHandling": "str",  # Optional. Allows the user to
                          choose whether a semantic call should fail completely (default / current
                          behavior), or to return partial results. Known values are: "partial" and
                          "fail".
                        "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to
                          set an upper bound on the amount of time it takes for semantic enrichment to
                          finish processing before the request fails.
                        "semanticQuery": "str",  # Optional. Allows setting a separate search
                          query that will be solely used for semantic reranking, semantic captions and
                          semantic answers. Is useful for scenarios where there is a need to use
                          different queries between the base retrieval and ranking phase, and the L2
                          semantic phase.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "top": 0,  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                        "vectorFilterMode": "str",  # Optional. Determines whether or not
                          filters are applied before or after the vector search is performed. Default
                          is 'preFilter' for new indexes. Known values are: "postFilter" and
                          "preFilter".
                        "vectorQueries": [
                            vector_query
                        ]
                    },
                    "@search.semanticPartialResponseReason": "str",  # Optional. Reason that a
                      partial response was returned for a semantic ranking request. Known values are:
                      "maxWaitExceeded", "capacityOverloaded", and "transient".
                    "@search.semanticPartialResponseType": "str"  # Optional. Type of partial
                      response that was returned for a semantic ranking request. Known values are:
                      "baseResults" and "rerankedResults".
                }
        """

    @distributed_trace_async
    async def search_post(
        self, search_request: Union[_models.SearchRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SearchDocumentsResult:
        # pylint: disable=line-too-long
        """Searches for documents in the index.

        :param search_request: The definition of the Search request. Is one of the following types:
         SearchRequest, JSON, IO[bytes] Required.
        :type search_request: ~azure.search.documents.models.SearchRequest or JSON or IO[bytes]
        :return: SearchDocumentsResult. The SearchDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                search_request = {
                    "answers": "str",  # Optional. A value that specifies whether answers should
                      be returned as part of the search response. Known values are: "none" and
                      "extractive".
                    "captions": "str",  # Optional. A value that specifies whether captions
                      should be returned as part of the search response. Known values are: "none" and
                      "extractive".
                    "count": bool,  # Optional. A value that specifies whether to fetch the total
                      count of results. Default is false. Setting this value to true may have a
                      performance impact. Note that the count returned is an approximation.
                    "facets": [
                        "str"  # Optional. The list of facet expressions to apply to the
                          search query. Each facet expression contains a field name, optionally
                          followed by a comma-separated list of name:value pairs.
                    ],
                    "filter": "str",  # Optional. The OData $filter expression to apply to the
                      search query.
                    "highlight": "str",  # Optional. The comma-separated list of field names to
                      use for hit highlights. Only searchable fields can be used for hit highlighting.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by a search query in order for
                      the query to be reported as a success. This parameter can be useful for ensuring
                      search availability even for services with only one replica. The default is 100.
                    "orderby": "str",  # Optional. The comma-separated list of OData $orderby
                      expressions by which to sort the results. Each expression can be either a field
                      name or a call to either the geo.distance() or the search.score() functions. Each
                      expression can be followed by asc to indicate ascending, or desc to indicate
                      descending. The default is ascending order. Ties will be broken by the match
                      scores of documents. If no $orderby is specified, the default sort order is
                      descending by document match score. There can be at most 32 $orderby clauses.
                    "queryType": "str",  # Optional. A value that specifies the syntax of the
                      search query. The default is 'simple'. Use 'full' if your query uses the Lucene
                      query syntax. Known values are: "simple", "full", and "semantic".
                    "scoringParameters": [
                        "str"  # Optional. The list of parameter values to be used in scoring
                          functions (for example, referencePointParameter) using the format
                          name-values. For example, if the scoring profile defines a function with a
                          parameter called 'mylocation' the parameter string would be
                          "mylocation--122.2,44.8" (without the quotes).
                    ],
                    "scoringProfile": "str",  # Optional. The name of a scoring profile to
                      evaluate match scores for matching documents in order to sort the results.
                    "scoringStatistics": "str",  # Optional. A value that specifies whether we
                      want to calculate scoring statistics (such as document frequency) globally for
                      more consistent scoring, or locally, for lower latency. The default is 'local'.
                      Use 'global' to aggregate scoring statistics globally before scoring. Using
                      global scoring statistics can increase latency of search queries. Known values
                      are: "local" and "global".
                    "search": "str",  # Optional. A full-text search query expression; Use "*" or
                      omit this parameter to match all documents.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to which to scope the full-text search. When using fielded search
                      (fieldName:searchExpression) in a full Lucene query, the field names of each
                      fielded search expression take precedence over any field names listed in this
                      parameter.
                    "searchMode": "str",  # Optional. A value that specifies whether any or all
                      of the search terms must be matched in order to count the document as a match.
                      Known values are: "any" and "all".
                    "select": "str",  # Optional. The comma-separated list of fields to retrieve.
                      If unspecified, all fields marked as retrievable in the schema are included.
                    "semanticConfiguration": "str",  # Optional. The name of a semantic
                      configuration that will be used when processing documents for queries of type
                      semantic.
                    "semanticErrorHandling": "str",  # Optional. Allows the user to choose
                      whether a semantic call should fail completely (default / current behavior), or
                      to return partial results. Known values are: "partial" and "fail".
                    "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to set an
                      upper bound on the amount of time it takes for semantic enrichment to finish
                      processing before the request fails.
                    "semanticQuery": "str",  # Optional. Allows setting a separate search query
                      that will be solely used for semantic reranking, semantic captions and semantic
                      answers. Is useful for scenarios where there is a need to use different queries
                      between the base retrieval and ranking phase, and the L2 semantic phase.
                    "sessionId": "str",  # Optional. A value to be used to create a sticky
                      session, which can help getting more consistent results. As long as the same
                      sessionId is used, a best-effort attempt will be made to target the same replica
                      set. Be wary that reusing the same sessionID values repeatedly can interfere with
                      the load balancing of the requests across replicas and adversely affect the
                      performance of the search service. The value used as sessionId cannot start with
                      a '_' character.
                    "skip": 0,  # Optional. The number of search results to skip. This value
                      cannot be greater than 100,000. If you need to scan documents in sequence, but
                      cannot use skip due to this limitation, consider using orderby on a
                      totally-ordered key and filter with a range query instead.
                    "top": 0,  # Optional. The number of search results to retrieve. This can be
                      used in conjunction with $skip to implement client-side paging of search results.
                      If results are truncated due to server-side paging, the response will include a
                      continuation token that can be used to issue another Search request for the next
                      page of results.
                    "vectorFilterMode": "str",  # Optional. Determines whether or not filters are
                      applied before or after the vector search is performed. Default is 'preFilter'
                      for new indexes. Known values are: "postFilter" and "preFilter".
                    "vectorQueries": [
                        vector_query
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if the query can't return all the
                      requested documents in a single response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when the
                      query can't return all the requested results in a single response. You can use
                      this URL to formulate another GET or POST Search request to get the next part of
                      the search response. Make sure to use the same verb (GET or POST) as the request
                      that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticErrorHandling": "str",  # Optional. Allows the user to
                          choose whether a semantic call should fail completely (default / current
                          behavior), or to return partial results. Known values are: "partial" and
                          "fail".
                        "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to
                          set an upper bound on the amount of time it takes for semantic enrichment to
                          finish processing before the request fails.
                        "semanticQuery": "str",  # Optional. Allows setting a separate search
                          query that will be solely used for semantic reranking, semantic captions and
                          semantic answers. Is useful for scenarios where there is a need to use
                          different queries between the base retrieval and ranking phase, and the L2
                          semantic phase.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "top": 0,  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                        "vectorFilterMode": "str",  # Optional. Determines whether or not
                          filters are applied before or after the vector search is performed. Default
                          is 'preFilter' for new indexes. Known values are: "postFilter" and
                          "preFilter".
                        "vectorQueries": [
                            vector_query
                        ]
                    },
                    "@search.semanticPartialResponseReason": "str",  # Optional. Reason that a
                      partial response was returned for a semantic ranking request. Known values are:
                      "maxWaitExceeded", "capacityOverloaded", and "transient".
                    "@search.semanticPartialResponseType": "str"  # Optional. Type of partial
                      response that was returned for a semantic ranking request. Known values are:
                      "baseResults" and "rerankedResults".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchDocumentsResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(search_request, (IOBase, bytes)):
            _content = search_request
        else:
            _content = json.dumps(search_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_documents_operations_search_post_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchDocumentsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get(  # pylint: disable=inconsistent-return-statements
        self, key: str, *, selected_fields: Optional[List[str]] = None, **kwargs: Any
    ) -> None:
        """Retrieves a document from the index.

        :param key: The key of the document to retrieve. Required.
        :type key: str
        :keyword selected_fields: List of field names to retrieve for the document; Any field not
         retrieved will
         be missing from the returned document. Default value is None.
        :paramtype selected_fields: list[str]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_documents_operations_get_request(
            key=key,
            selected_fields=selected_fields,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def suggest_get(
        self,
        *,
        search_text: str,
        suggester_name: str,
        _filter: Optional[str] = None,
        use_fuzzy_matching: Optional[bool] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        order_by: Optional[List[str]] = None,
        search_fields: Optional[List[str]] = None,
        _select: Optional[List[str]] = None,
        _top: Optional[int] = None,
        **kwargs: Any
    ) -> _models.SuggestDocumentsResult:
        # pylint: disable=line-too-long
        """Suggests documents in the index that match the given partial query text.

        :keyword search_text: The search text to use to suggest documents. Must be at least 1
         character, and
         no more than 100 characters. Required.
        :paramtype search_text: str
        :keyword suggester_name: The name of the suggester as specified in the suggesters collection
         that's part
         of the index definition. Required.
        :paramtype suggester_name: str
        :keyword _filter: An OData expression that filters the documents considered for suggestions.
         Default value is None.
        :paramtype _filter: str
        :keyword use_fuzzy_matching: A value indicating whether to use fuzzy matching for the
         suggestions query.
         Default is false. When set to true, the query will find terms even if there's a
         substituted or missing character in the search text. While this provides a
         better experience in some scenarios, it comes at a performance cost as fuzzy
         suggestions queries are slower and consume more resources. Default value is None.
        :paramtype use_fuzzy_matching: bool
        :keyword highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
         highlightPreTag. If omitted, hit highlighting of suggestions is disabled. Default value is
         None.
        :paramtype highlight_post_tag: str
        :keyword highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
         highlightPostTag. If omitted, hit highlighting of suggestions is disabled. Default value is
         None.
        :paramtype highlight_pre_tag: str
        :keyword minimum_coverage: A number between 0 and 100 indicating the percentage of the index
         that must be
         covered by a suggestions query in order for the query to be reported as a
         success. This parameter can be useful for ensuring search availability even for
         services with only one replica. The default is 80. Default value is None.
        :paramtype minimum_coverage: float
        :keyword order_by: The list of OData $orderby expressions by which to sort the results. Each
         expression can be either a field name or a call to either the geo.distance() or
         the search.score() functions. Each expression can be followed by asc to
         indicate ascending, or desc to indicate descending. The default is ascending
         order. Ties will be broken by the match scores of documents. If no $orderby is
         specified, the default sort order is descending by document match score. There
         can be at most 32 $orderby clauses. Default value is None.
        :paramtype order_by: list[str]
        :keyword search_fields: The list of field names to search for the specified search text. Target
         fields
         must be included in the specified suggester. Default value is None.
        :paramtype search_fields: list[str]
        :keyword _select: The list of fields to retrieve. If unspecified, only the key field will be
         included in the results. Default value is None.
        :paramtype _select: list[str]
        :keyword _top: The number of suggestions to retrieve. The value must be a number between 1 and


         #. The default is 5. Default value is None.
        :paramtype _top: int
        :return: SuggestDocumentsResult. The SuggestDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SuggestDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SuggestDocumentsResult] = kwargs.pop("cls", None)

        _request = build_documents_operations_suggest_get_request(
            search_text=search_text,
            suggester_name=suggester_name,
            _filter=_filter,
            use_fuzzy_matching=use_fuzzy_matching,
            highlight_post_tag=highlight_post_tag,
            highlight_pre_tag=highlight_pre_tag,
            minimum_coverage=minimum_coverage,
            order_by=order_by,
            search_fields=search_fields,
            _select=_select,
            _top=_top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SuggestDocumentsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def suggest_post(
        self, suggest_request: _models.SuggestRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SuggestDocumentsResult:
        # pylint: disable=line-too-long
        """Suggests documents in the index that match the given partial query text.

        :param suggest_request: The Suggest request. Required.
        :type suggest_request: ~azure.search.documents.models.SuggestRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SuggestDocumentsResult. The SuggestDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SuggestDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                suggest_request = {
                    "search": "str",  # The search text to use to suggest documents. Must be at
                      least 1 character, and no more than 100 characters. Required.
                    "suggesterName": "str",  # The name of the suggester as specified in the
                      suggesters collection that's part of the index definition. Required.
                    "filter": "str",  # Optional. An OData expression that filters the documents
                      considered for suggestions.
                    "fuzzy": bool,  # Optional. A value indicating whether to use fuzzy matching
                      for the suggestion query. Default is false. When set to true, the query will find
                      suggestions even if there's a substituted or missing character in the search
                      text. While this provides a better experience in some scenarios, it comes at a
                      performance cost as fuzzy suggestion searches are slower and consume more
                      resources.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. If omitted, hit highlighting of
                      suggestions is disabled.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. If omitted, hit highlighting of
                      suggestions is disabled.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by a suggestion query in order
                      for the query to be reported as a success. This parameter can be useful for
                      ensuring search availability even for services with only one replica. The default
                      is 80.
                    "orderby": "str",  # Optional. The comma-separated list of OData $orderby
                      expressions by which to sort the results. Each expression can be either a field
                      name or a call to either the geo.distance() or the search.score() functions. Each
                      expression can be followed by asc to indicate ascending, or desc to indicate
                      descending. The default is ascending order. Ties will be broken by the match
                      scores of documents. If no $orderby is specified, the default sort order is
                      descending by document match score. There can be at most 32 $orderby clauses.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to search for the specified search text. Target fields must be included in the
                      specified suggester.
                    "select": "str",  # Optional. The comma-separated list of fields to retrieve.
                      If unspecified, only the key field will be included in the results.
                    "top": 0  # Optional. The number of suggestions to retrieve. This must be a
                      value between 1 and 100. The default is 5.
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """

    @overload
    async def suggest_post(
        self, suggest_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SuggestDocumentsResult:
        # pylint: disable=line-too-long
        """Suggests documents in the index that match the given partial query text.

        :param suggest_request: The Suggest request. Required.
        :type suggest_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SuggestDocumentsResult. The SuggestDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SuggestDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """

    @overload
    async def suggest_post(
        self, suggest_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SuggestDocumentsResult:
        # pylint: disable=line-too-long
        """Suggests documents in the index that match the given partial query text.

        :param suggest_request: The Suggest request. Required.
        :type suggest_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SuggestDocumentsResult. The SuggestDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SuggestDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """

    @distributed_trace_async
    async def suggest_post(
        self, suggest_request: Union[_models.SuggestRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SuggestDocumentsResult:
        # pylint: disable=line-too-long
        """Suggests documents in the index that match the given partial query text.

        :param suggest_request: The Suggest request. Is one of the following types: SuggestRequest,
         JSON, IO[bytes] Required.
        :type suggest_request: ~azure.search.documents.models.SuggestRequest or JSON or IO[bytes]
        :return: SuggestDocumentsResult. The SuggestDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SuggestDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                suggest_request = {
                    "search": "str",  # The search text to use to suggest documents. Must be at
                      least 1 character, and no more than 100 characters. Required.
                    "suggesterName": "str",  # The name of the suggester as specified in the
                      suggesters collection that's part of the index definition. Required.
                    "filter": "str",  # Optional. An OData expression that filters the documents
                      considered for suggestions.
                    "fuzzy": bool,  # Optional. A value indicating whether to use fuzzy matching
                      for the suggestion query. Default is false. When set to true, the query will find
                      suggestions even if there's a substituted or missing character in the search
                      text. While this provides a better experience in some scenarios, it comes at a
                      performance cost as fuzzy suggestion searches are slower and consume more
                      resources.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. If omitted, hit highlighting of
                      suggestions is disabled.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. If omitted, hit highlighting of
                      suggestions is disabled.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by a suggestion query in order
                      for the query to be reported as a success. This parameter can be useful for
                      ensuring search availability even for services with only one replica. The default
                      is 80.
                    "orderby": "str",  # Optional. The comma-separated list of OData $orderby
                      expressions by which to sort the results. Each expression can be either a field
                      name or a call to either the geo.distance() or the search.score() functions. Each
                      expression can be followed by asc to indicate ascending, or desc to indicate
                      descending. The default is ascending order. Ties will be broken by the match
                      scores of documents. If no $orderby is specified, the default sort order is
                      descending by document match score. There can be at most 32 $orderby clauses.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to search for the specified search text. Target fields must be included in the
                      specified suggester.
                    "select": "str",  # Optional. The comma-separated list of fields to retrieve.
                      If unspecified, only the key field will be included in the results.
                    "top": 0  # Optional. The number of suggestions to retrieve. This must be a
                      value between 1 and 100. The default is 5.
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SuggestDocumentsResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(suggest_request, (IOBase, bytes)):
            _content = suggest_request
        else:
            _content = json.dumps(suggest_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_documents_operations_suggest_post_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SuggestDocumentsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def index(
        self, batch: _models.IndexBatch, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IndexDocumentsResult:
        # pylint: disable=line-too-long
        """Sends a batch of document write actions to the index.

        :param batch: The batch of index actions. Required.
        :type batch: ~azure.search.documents.models.IndexBatch
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IndexDocumentsResult. The IndexDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.IndexDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                batch = {
                    "value": [
                        {
                            "@search.action": "str"  # Optional. The operation to perform
                              on a document in an indexing batch. Known values are: "upload", "merge",
                              "mergeOrUpload", and "delete".
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "key": "str",  # The key of a document that was in the
                              indexing request. Required.
                            "status": bool,  # A value indicating whether the indexing
                              operation succeeded for the document identified by the key. Required.
                            "statusCode": 0,  # The status code of the indexing
                              operation. Possible values include: 200 for a successful update or
                              delete, 201 for successful document creation, 400 for a malformed input
                              document, 404 for document not found, 409 for a version conflict, 422
                              when the index is temporarily unavailable, or 503 for when the service is
                              too busy. Required.
                            "errorMessage": "str"  # Optional. The error message
                              explaining why the indexing operation failed for the document identified
                              by the key; null if indexing succeeded.
                        }
                    ]
                }
        """

    @overload
    async def index(
        self, batch: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IndexDocumentsResult:
        # pylint: disable=line-too-long
        """Sends a batch of document write actions to the index.

        :param batch: The batch of index actions. Required.
        :type batch: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IndexDocumentsResult. The IndexDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.IndexDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "key": "str",  # The key of a document that was in the
                              indexing request. Required.
                            "status": bool,  # A value indicating whether the indexing
                              operation succeeded for the document identified by the key. Required.
                            "statusCode": 0,  # The status code of the indexing
                              operation. Possible values include: 200 for a successful update or
                              delete, 201 for successful document creation, 400 for a malformed input
                              document, 404 for document not found, 409 for a version conflict, 422
                              when the index is temporarily unavailable, or 503 for when the service is
                              too busy. Required.
                            "errorMessage": "str"  # Optional. The error message
                              explaining why the indexing operation failed for the document identified
                              by the key; null if indexing succeeded.
                        }
                    ]
                }
        """

    @overload
    async def index(
        self, batch: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IndexDocumentsResult:
        # pylint: disable=line-too-long
        """Sends a batch of document write actions to the index.

        :param batch: The batch of index actions. Required.
        :type batch: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IndexDocumentsResult. The IndexDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.IndexDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "key": "str",  # The key of a document that was in the
                              indexing request. Required.
                            "status": bool,  # A value indicating whether the indexing
                              operation succeeded for the document identified by the key. Required.
                            "statusCode": 0,  # The status code of the indexing
                              operation. Possible values include: 200 for a successful update or
                              delete, 201 for successful document creation, 400 for a malformed input
                              document, 404 for document not found, 409 for a version conflict, 422
                              when the index is temporarily unavailable, or 503 for when the service is
                              too busy. Required.
                            "errorMessage": "str"  # Optional. The error message
                              explaining why the indexing operation failed for the document identified
                              by the key; null if indexing succeeded.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def index(
        self, batch: Union[_models.IndexBatch, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.IndexDocumentsResult:
        # pylint: disable=line-too-long
        """Sends a batch of document write actions to the index.

        :param batch: The batch of index actions. Is one of the following types: IndexBatch, JSON,
         IO[bytes] Required.
        :type batch: ~azure.search.documents.models.IndexBatch or JSON or IO[bytes]
        :return: IndexDocumentsResult. The IndexDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.IndexDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                batch = {
                    "value": [
                        {
                            "@search.action": "str"  # Optional. The operation to perform
                              on a document in an indexing batch. Known values are: "upload", "merge",
                              "mergeOrUpload", and "delete".
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "key": "str",  # The key of a document that was in the
                              indexing request. Required.
                            "status": bool,  # A value indicating whether the indexing
                              operation succeeded for the document identified by the key. Required.
                            "statusCode": 0,  # The status code of the indexing
                              operation. Possible values include: 200 for a successful update or
                              delete, 201 for successful document creation, 400 for a malformed input
                              document, 404 for document not found, 409 for a version conflict, 422
                              when the index is temporarily unavailable, or 503 for when the service is
                              too busy. Required.
                            "errorMessage": "str"  # Optional. The error message
                              explaining why the indexing operation failed for the document identified
                              by the key; null if indexing succeeded.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IndexDocumentsResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(batch, (IOBase, bytes)):
            _content = batch
        else:
            _content = json.dumps(batch, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_documents_operations_index_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IndexDocumentsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def autocomplete_get(
        self,
        *,
        search_text: str,
        suggester_name: str,
        autocomplete_mode: Optional[Union[str, _models.AutocompleteMode]] = None,
        _filter: Optional[str] = None,
        use_fuzzy_matching: Optional[bool] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        search_fields: Optional[List[str]] = None,
        _top: Optional[int] = None,
        **kwargs: Any
    ) -> _models.AutocompleteResult:
        # pylint: disable=line-too-long
        """Autocompletes incomplete query terms based on input text and matching terms in
        the index.

        :keyword search_text: The incomplete term which should be auto-completed. Required.
        :paramtype search_text: str
        :keyword suggester_name: The name of the suggester as specified in the suggesters collection
         that's part
         of the index definition. Required.
        :paramtype suggester_name: str
        :keyword autocomplete_mode: Specifies the mode for Autocomplete. The default is 'oneTerm'. Use
         'twoTerms'
         to get shingles and 'oneTermWithContext' to use the current context while
         producing auto-completed terms. Known values are: "oneTerm", "twoTerms", and
         "oneTermWithContext". Default value is None.
        :paramtype autocomplete_mode: str or ~azure.search.documents.models.AutocompleteMode
        :keyword _filter: An OData expression that filters the documents used to produce completed
         terms
         for the Autocomplete result. Default value is None.
        :paramtype _filter: str
        :keyword use_fuzzy_matching: A value indicating whether to use fuzzy matching for the
         autocomplete query.
         Default is false. When set to true, the query will find terms even if there's a
         substituted or missing character in the search text. While this provides a
         better experience in some scenarios, it comes at a performance cost as fuzzy
         autocomplete queries are slower and consume more resources. Default value is None.
        :paramtype use_fuzzy_matching: bool
        :keyword highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
         highlightPreTag. If omitted, hit highlighting is disabled. Default value is None.
        :paramtype highlight_post_tag: str
        :keyword highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
         highlightPostTag. If omitted, hit highlighting is disabled. Default value is None.
        :paramtype highlight_pre_tag: str
        :keyword minimum_coverage: A number between 0 and 100 indicating the percentage of the index
         that must be
         covered by an autocomplete query in order for the query to be reported as a
         success. This parameter can be useful for ensuring search availability even for
         services with only one replica. The default is 80. Default value is None.
        :paramtype minimum_coverage: float
        :keyword search_fields: The list of field names to consider when querying for auto-completed
         terms.
         Target fields must be included in the specified suggester. Default value is None.
        :paramtype search_fields: list[str]
        :keyword _top: The number of auto-completed terms to retrieve. This must be a value between 1
         and 100. The default is 5. Default value is None.
        :paramtype _top: int
        :return: AutocompleteResult. The AutocompleteResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AutocompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AutocompleteResult] = kwargs.pop("cls", None)

        _request = build_documents_operations_autocomplete_get_request(
            search_text=search_text,
            suggester_name=suggester_name,
            autocomplete_mode=autocomplete_mode,
            _filter=_filter,
            use_fuzzy_matching=use_fuzzy_matching,
            highlight_post_tag=highlight_post_tag,
            highlight_pre_tag=highlight_pre_tag,
            minimum_coverage=minimum_coverage,
            search_fields=search_fields,
            _top=_top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AutocompleteResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def autocomplete_post(
        self,
        autocomplete_request: _models.AutocompleteRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AutocompleteResult:
        # pylint: disable=line-too-long
        """Autocompletes incomplete query terms based on input text and matching terms in
        the index.

        :param autocomplete_request: The definition of the Autocomplete request. Required.
        :type autocomplete_request: ~azure.search.documents.models.AutocompleteRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AutocompleteResult. The AutocompleteResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AutocompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                autocomplete_request = {
                    "search": "str",  # The search text on which to base autocomplete results.
                      Required.
                    "suggesterName": "str",  # The name of the suggester as specified in the
                      suggesters collection that's part of the index definition. Required.
                    "autocompleteMode": "str",  # Optional. Specifies the mode for Autocomplete.
                      The default is 'oneTerm'. Use 'twoTerms' to get shingles and 'oneTermWithContext'
                      to use the current context while producing auto-completed terms. Known values
                      are: "oneTerm", "twoTerms", and "oneTermWithContext".
                    "filter": "str",  # Optional. An OData expression that filters the documents
                      used to produce completed terms for the Autocomplete result.
                    "fuzzy": bool,  # Optional. A value indicating whether to use fuzzy matching
                      for the autocomplete query. Default is false. When set to true, the query will
                      autocomplete terms even if there's a substituted or missing character in the
                      search text. While this provides a better experience in some scenarios, it comes
                      at a performance cost as fuzzy autocomplete queries are slower and consume more
                      resources.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. If omitted, hit highlighting is
                      disabled.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. If omitted, hit highlighting is
                      disabled.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by an autocomplete query in
                      order for the query to be reported as a success. This parameter can be useful for
                      ensuring search availability even for services with only one replica. The default
                      is 80.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to consider when querying for auto-completed terms. Target fields must be
                      included in the specified suggester.
                    "top": 0  # Optional. The number of auto-completed terms to retrieve. This
                      must be a value between 1 and 100. The default is 5.
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """

    @overload
    async def autocomplete_post(
        self, autocomplete_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AutocompleteResult:
        # pylint: disable=line-too-long
        """Autocompletes incomplete query terms based on input text and matching terms in
        the index.

        :param autocomplete_request: The definition of the Autocomplete request. Required.
        :type autocomplete_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AutocompleteResult. The AutocompleteResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AutocompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """

    @overload
    async def autocomplete_post(
        self, autocomplete_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AutocompleteResult:
        # pylint: disable=line-too-long
        """Autocompletes incomplete query terms based on input text and matching terms in
        the index.

        :param autocomplete_request: The definition of the Autocomplete request. Required.
        :type autocomplete_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AutocompleteResult. The AutocompleteResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AutocompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """

    @distributed_trace_async
    async def autocomplete_post(
        self, autocomplete_request: Union[_models.AutocompleteRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AutocompleteResult:
        # pylint: disable=line-too-long
        """Autocompletes incomplete query terms based on input text and matching terms in
        the index.

        :param autocomplete_request: The definition of the Autocomplete request. Is one of the
         following types: AutocompleteRequest, JSON, IO[bytes] Required.
        :type autocomplete_request: ~azure.search.documents.models.AutocompleteRequest or JSON or
         IO[bytes]
        :return: AutocompleteResult. The AutocompleteResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AutocompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                autocomplete_request = {
                    "search": "str",  # The search text on which to base autocomplete results.
                      Required.
                    "suggesterName": "str",  # The name of the suggester as specified in the
                      suggesters collection that's part of the index definition. Required.
                    "autocompleteMode": "str",  # Optional. Specifies the mode for Autocomplete.
                      The default is 'oneTerm'. Use 'twoTerms' to get shingles and 'oneTermWithContext'
                      to use the current context while producing auto-completed terms. Known values
                      are: "oneTerm", "twoTerms", and "oneTermWithContext".
                    "filter": "str",  # Optional. An OData expression that filters the documents
                      used to produce completed terms for the Autocomplete result.
                    "fuzzy": bool,  # Optional. A value indicating whether to use fuzzy matching
                      for the autocomplete query. Default is false. When set to true, the query will
                      autocomplete terms even if there's a substituted or missing character in the
                      search text. While this provides a better experience in some scenarios, it comes
                      at a performance cost as fuzzy autocomplete queries are slower and consume more
                      resources.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. If omitted, hit highlighting is
                      disabled.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. If omitted, hit highlighting is
                      disabled.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by an autocomplete query in
                      order for the query to be reported as a success. This parameter can be useful for
                      ensuring search availability even for services with only one replica. The default
                      is 80.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to consider when querying for auto-completed terms. Target fields must be
                      included in the specified suggester.
                    "top": 0  # Optional. The number of auto-completed terms to retrieve. This
                      must be a value between 1 and 100. The default is 5.
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AutocompleteResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(autocomplete_request, (IOBase, bytes)):
            _content = autocomplete_request
        else:
            _content = json.dumps(autocomplete_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_documents_operations_autocomplete_post_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AutocompleteResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
