# pylint: disable=line-too-long,useless-suppression,too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
# pylint: disable=useless-super-delegation

import datetime
from typing import Any, Dict, List, Literal, Mapping, Optional, TYPE_CHECKING, Union, overload

from .. import _model_base
from .._model_base import rest_discriminator, rest_field
from ._enums import (
    VectorQueryKind,
    VectorSearchAlgorithmKind,
    VectorSearchCompressionKind,
    VectorSearchVectorizerKind,
    VectorThresholdKind,
)

if TYPE_CHECKING:
    from .. import models as _models


class CognitiveServicesAccount(_model_base.Model):
    """Base type for describing any Azure AI service resource attached to a skillset.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AIServicesAccountIdentity, AIServicesAccountKey, CognitiveServicesAccountKey,
    DefaultCognitiveServicesAccount


    :ivar odata_type: The discriminator for derived types. Required. Default value is None.
    :vartype odata_type: str
    :ivar description: Description of the Azure AI service resource attached to a skillset.
    :vartype description: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    odata_type: str = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])
    """The discriminator for derived types. Required. Default value is None."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Description of the Azure AI service resource attached to a skillset."""

    @overload
    def __init__(
        self,
        *,
        odata_type: str,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AIServicesAccountIdentity(CognitiveServicesAccount, discriminator="#Microsoft.Azure.Search.AIServicesByIdentity"):
    """The multi-region account of an Azure AI service resource that's attached to a
    skillset.


    :ivar description: Description of the Azure AI service resource attached to a skillset.
    :vartype description: str
    :ivar identity: The user-assigned managed identity used for connections to AI Service. If not
     specified, the system-assigned managed identity is used. On updates to the
     skillset, if the identity is unspecified, the value remains unchanged. If set
     to "none", the value of this property is cleared. Required.
    :vartype identity: ~azure.search.documents.models.SearchIndexerDataIdentity
    :ivar subdomain_url: The subdomain url for the corresponding AI Service. Required.
    :vartype subdomain_url: str
    :ivar odata_type: A URI fragment specifying the type of Azure AI service resource attached to a
     skillset. Required. Default value is "#Microsoft.Azure.Search.AIServicesByIdentity".
    :vartype odata_type: str
    """

    identity: "_models.SearchIndexerDataIdentity" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The user-assigned managed identity used for connections to AI Service. If not
     specified, the system-assigned managed identity is used. On updates to the
     skillset, if the identity is unspecified, the value remains unchanged. If set
     to \"none\", the value of this property is cleared. Required."""
    subdomain_url: str = rest_field(name="subdomainUrl", visibility=["read", "create", "update", "delete", "query"])
    """The subdomain url for the corresponding AI Service. Required."""
    odata_type: Literal["#Microsoft.Azure.Search.AIServicesByIdentity"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of Azure AI service resource attached to a
     skillset. Required. Default value is \"#Microsoft.Azure.Search.AIServicesByIdentity\"."""

    @overload
    def __init__(
        self,
        *,
        identity: "_models.SearchIndexerDataIdentity",
        subdomain_url: str,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.AIServicesByIdentity", **kwargs)


class AIServicesAccountKey(CognitiveServicesAccount, discriminator="#Microsoft.Azure.Search.AIServicesByKey"):
    """The account key of an Azure AI service resource that's attached to a skillset,
    to be used with the resource's subdomain.


    :ivar description: Description of the Azure AI service resource attached to a skillset.
    :vartype description: str
    :ivar key: The key used to provision the Azure AI service resource attached to a skillset.
     Required.
    :vartype key: str
    :ivar subdomain_url: The subdomain url for the corresponding AI Service. Required.
    :vartype subdomain_url: str
    :ivar odata_type: A URI fragment specifying the type of Azure AI service resource attached to a
     skillset. Required. Default value is "#Microsoft.Azure.Search.AIServicesByKey".
    :vartype odata_type: str
    """

    key: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The key used to provision the Azure AI service resource attached to a skillset. Required."""
    subdomain_url: str = rest_field(name="subdomainUrl", visibility=["read", "create", "update", "delete", "query"])
    """The subdomain url for the corresponding AI Service. Required."""
    odata_type: Literal["#Microsoft.Azure.Search.AIServicesByKey"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of Azure AI service resource attached to a
     skillset. Required. Default value is \"#Microsoft.Azure.Search.AIServicesByKey\"."""

    @overload
    def __init__(
        self,
        *,
        key: str,
        subdomain_url: str,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.AIServicesByKey", **kwargs)


class AIServicesVisionParameters(_model_base.Model):
    """Specifies the AI Services Vision parameters for vectorizing a query image or
    text.


    :ivar model_version: The version of the model to use when calling the AI Services Vision
     service. It
     will default to the latest available when not specified. Required.
    :vartype model_version: str
    :ivar resource_uri: The resource URI of the AI Services resource. Required.
    :vartype resource_uri: str
    :ivar api_key: API key of the designated AI Services resource.
    :vartype api_key: str
    :ivar auth_identity: The user-assigned managed identity used for outbound connections. If an
     authResourceId is provided and it's not specified, the system-assigned managed
     identity is used. On updates to the index, if the identity is unspecified, the
     value remains unchanged. If set to "none", the value of this property is
     cleared.
    :vartype auth_identity: ~azure.search.documents.models.SearchIndexerDataIdentity
    """

    model_version: str = rest_field(name="modelVersion", visibility=["read", "create", "update", "delete", "query"])
    """The version of the model to use when calling the AI Services Vision service. It
     will default to the latest available when not specified. Required."""
    resource_uri: str = rest_field(name="resourceUri", visibility=["read", "create", "update", "delete", "query"])
    """The resource URI of the AI Services resource. Required."""
    api_key: Optional[str] = rest_field(name="apiKey", visibility=["read", "create", "update", "delete", "query"])
    """API key of the designated AI Services resource."""
    auth_identity: Optional["_models.SearchIndexerDataIdentity"] = rest_field(
        name="authIdentity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The user-assigned managed identity used for outbound connections. If an
     authResourceId is provided and it's not specified, the system-assigned managed
     identity is used. On updates to the index, if the identity is unspecified, the
     value remains unchanged. If set to \"none\", the value of this property is
     cleared."""

    @overload
    def __init__(
        self,
        *,
        model_version: str,
        resource_uri: str,
        api_key: Optional[str] = None,
        auth_identity: Optional["_models.SearchIndexerDataIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorSearchVectorizer(_model_base.Model):
    """Specifies the vectorization method to be used during query time.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AIServicesVisionVectorizer, AzureMachineLearningVectorizer, AzureOpenAIVectorizer,
    WebApiVectorizer


    :ivar vectorizer_name: The name to associate with this particular vectorization method.
     Required.
    :vartype vectorizer_name: str
    :ivar kind: Type of VectorSearchVectorizer. Required. Known values are: "azureOpenAI",
     "customWebApi", "aiServicesVision", and "aml".
    :vartype kind: str or ~azure.search.documents.models.VectorSearchVectorizerKind
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    vectorizer_name: str = rest_field(name="name", visibility=["read", "create", "update", "delete", "query"])
    """The name to associate with this particular vectorization method. Required."""
    kind: str = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])
    """Type of VectorSearchVectorizer. Required. Known values are: \"azureOpenAI\", \"customWebApi\",
     \"aiServicesVision\", and \"aml\"."""

    @overload
    def __init__(
        self,
        *,
        vectorizer_name: str,
        kind: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AIServicesVisionVectorizer(VectorSearchVectorizer, discriminator="aiServicesVision"):
    """Clears the identity property of a datasource.


    :ivar vectorizer_name: The name to associate with this particular vectorization method.
     Required.
    :vartype vectorizer_name: str
    :ivar ai_services_vision_parameters: Contains the parameters specific to AI Services Vision
     embedding vectorization.
    :vartype ai_services_vision_parameters:
     ~azure.search.documents.models.AIServicesVisionParameters
    :ivar kind: The name of the kind of vectorization method being configured for use with
     vector search. Required. Generate embeddings for an image or text input at query time using the
     Azure AI
     Services Vision Vectorize API.
    :vartype kind: str or ~azure.search.documents.models.AI_SERVICES_VISION
    """

    ai_services_vision_parameters: Optional["_models.AIServicesVisionParameters"] = rest_field(
        name="AIServicesVisionParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains the parameters specific to AI Services Vision embedding vectorization."""
    kind: Literal[VectorSearchVectorizerKind.AI_SERVICES_VISION] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The name of the kind of vectorization method being configured for use with
     vector search. Required. Generate embeddings for an image or text input at query time using the
     Azure AI
     Services Vision Vectorize API."""

    @overload
    def __init__(
        self,
        *,
        vectorizer_name: str,
        ai_services_vision_parameters: Optional["_models.AIServicesVisionParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorSearchVectorizerKind.AI_SERVICES_VISION, **kwargs)


class AnalyzedTokenInfo(_model_base.Model):
    """Information about a token returned by an analyzer.


    :ivar token: The token returned by the analyzer. Required.
    :vartype token: str
    :ivar start_offset: The index of the first character of the token in the input text. Required.
    :vartype start_offset: int
    :ivar end_offset: The index of the last character of the token in the input text. Required.
    :vartype end_offset: int
    :ivar position: The position of the token in the input text relative to other tokens. The first
     token in the input text has position 0, the next has position 1, and so on.
     Depending on the analyzer used, some tokens might have the same position, for
     example if they are synonyms of each other. Required.
    :vartype position: int
    """

    token: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The token returned by the analyzer. Required."""
    start_offset: int = rest_field(name="startOffset", visibility=["read", "create", "update", "delete", "query"])
    """The index of the first character of the token in the input text. Required."""
    end_offset: int = rest_field(name="endOffset", visibility=["read", "create", "update", "delete", "query"])
    """The index of the last character of the token in the input text. Required."""
    position: int = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The position of the token in the input text relative to other tokens. The first
     token in the input text has position 0, the next has position 1, and so on.
     Depending on the analyzer used, some tokens might have the same position, for
     example if they are synonyms of each other. Required."""

    @overload
    def __init__(
        self,
        *,
        token: str,
        start_offset: int,
        end_offset: int,
        position: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AnalyzeRequest(_model_base.Model):
    """Specifies some text and analysis components used to break that text into tokens.

    All required parameters must be populated in order to send to server.

    :ivar text: The text to break into tokens. Required.
    :vartype text: str
    :ivar analyzer: The name of the analyzer to use to break the given text. If this parameter is
     not specified, you must specify a tokenizer instead. The tokenizer and analyzer
     parameters are mutually exclusive. Known values are: "ar.microsoft", "ar.lucene", "hy.lucene",
     "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
     "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft",
     "cs.microsoft", "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
     "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
     "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft", "el.lucene",
     "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene",
     "is.microsoft", "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
     "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft",
     "lv.lucene", "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft", "nb.microsoft",
     "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
     "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft",
     "ru.lucene", "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft", "sl.microsoft",
     "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
     "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
     "vi.microsoft", "standard.lucene", "standardasciifolding.lucene", "keyword", "pattern",
     "simple", "stop", and "whitespace".
    :vartype analyzer: str or ~azure.search.documents.models.LexicalAnalyzerName
    :ivar tokenizer: The name of the tokenizer to use to break the given text. If this parameter is
     not specified, you must specify an analyzer instead. The tokenizer and analyzer
     parameters are mutually exclusive. Known values are: "classic", "edgeNGram", "keyword_v2",
     "letter", "lowercase", "microsoft_language_tokenizer", "microsoft_language_stemming_tokenizer",
     "nGram", "path_hierarchy_v2", "pattern", "standard_v2", "uax_url_email", and "whitespace".
    :vartype tokenizer: str or ~azure.search.documents.models.LexicalTokenizerName
    :ivar normalizer: The name of the normalizer to use to normalize the given text. Known values
     are: "asciifolding", "elision", "lowercase", "standard", and "uppercase".
    :vartype normalizer: str or ~azure.search.documents.models.LexicalNormalizerName
    :ivar token_filters: An optional list of token filters to use when breaking the given text.
     This
     parameter can only be set when using the tokenizer parameter.
    :vartype token_filters: list[str or ~azure.search.documents.models.TokenFilterName]
    :ivar char_filters: An optional list of character filters to use when breaking the given text.
     This
     parameter can only be set when using the tokenizer parameter.
    :vartype char_filters: list[str or ~azure.search.documents.models.CharFilterName]
    """

    text: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The text to break into tokens. Required."""
    analyzer: Optional[Union[str, "_models.LexicalAnalyzerName"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the analyzer to use to break the given text. If this parameter is
     not specified, you must specify a tokenizer instead. The tokenizer and analyzer
     parameters are mutually exclusive. Known values are: \"ar.microsoft\", \"ar.lucene\",
     \"hy.lucene\", \"bn.microsoft\", \"eu.lucene\", \"bg.microsoft\", \"bg.lucene\",
     \"ca.microsoft\", \"ca.lucene\", \"zh-Hans.microsoft\", \"zh-Hans.lucene\",
     \"zh-Hant.microsoft\", \"zh-Hant.lucene\", \"hr.microsoft\", \"cs.microsoft\", \"cs.lucene\",
     \"da.microsoft\", \"da.lucene\", \"nl.microsoft\", \"nl.lucene\", \"en.microsoft\",
     \"en.lucene\", \"et.microsoft\", \"fi.microsoft\", \"fi.lucene\", \"fr.microsoft\",
     \"fr.lucene\", \"gl.lucene\", \"de.microsoft\", \"de.lucene\", \"el.microsoft\", \"el.lucene\",
     \"gu.microsoft\", \"he.microsoft\", \"hi.microsoft\", \"hi.lucene\", \"hu.microsoft\",
     \"hu.lucene\", \"is.microsoft\", \"id.microsoft\", \"id.lucene\", \"ga.lucene\",
     \"it.microsoft\", \"it.lucene\", \"ja.microsoft\", \"ja.lucene\", \"kn.microsoft\",
     \"ko.microsoft\", \"ko.lucene\", \"lv.microsoft\", \"lv.lucene\", \"lt.microsoft\",
     \"ml.microsoft\", \"ms.microsoft\", \"mr.microsoft\", \"nb.microsoft\", \"no.lucene\",
     \"fa.lucene\", \"pl.microsoft\", \"pl.lucene\", \"pt-BR.microsoft\", \"pt-BR.lucene\",
     \"pt-PT.microsoft\", \"pt-PT.lucene\", \"pa.microsoft\", \"ro.microsoft\", \"ro.lucene\",
     \"ru.microsoft\", \"ru.lucene\", \"sr-cyrillic.microsoft\", \"sr-latin.microsoft\",
     \"sk.microsoft\", \"sl.microsoft\", \"es.microsoft\", \"es.lucene\", \"sv.microsoft\",
     \"sv.lucene\", \"ta.microsoft\", \"te.microsoft\", \"th.microsoft\", \"th.lucene\",
     \"tr.microsoft\", \"tr.lucene\", \"uk.microsoft\", \"ur.microsoft\", \"vi.microsoft\",
     \"standard.lucene\", \"standardasciifolding.lucene\", \"keyword\", \"pattern\", \"simple\",
     \"stop\", and \"whitespace\"."""
    tokenizer: Optional[Union[str, "_models.LexicalTokenizerName"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the tokenizer to use to break the given text. If this parameter is
     not specified, you must specify an analyzer instead. The tokenizer and analyzer
     parameters are mutually exclusive. Known values are: \"classic\", \"edgeNGram\",
     \"keyword_v2\", \"letter\", \"lowercase\", \"microsoft_language_tokenizer\",
     \"microsoft_language_stemming_tokenizer\", \"nGram\", \"path_hierarchy_v2\", \"pattern\",
     \"standard_v2\", \"uax_url_email\", and \"whitespace\"."""
    normalizer: Optional[Union[str, "_models.LexicalNormalizerName"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the normalizer to use to normalize the given text. Known values are:
     \"asciifolding\", \"elision\", \"lowercase\", \"standard\", and \"uppercase\"."""
    token_filters: Optional[List[Union[str, "_models.TokenFilterName"]]] = rest_field(
        name="tokenFilters", visibility=["read", "create", "update", "delete", "query"]
    )
    """An optional list of token filters to use when breaking the given text. This
     parameter can only be set when using the tokenizer parameter."""
    char_filters: Optional[List[Union[str, "_models.CharFilterName"]]] = rest_field(
        name="charFilters", visibility=["read", "create", "update", "delete", "query"]
    )
    """An optional list of character filters to use when breaking the given text. This
     parameter can only be set when using the tokenizer parameter."""

    @overload
    def __init__(
        self,
        *,
        text: str,
        analyzer: Optional[Union[str, "_models.LexicalAnalyzerName"]] = None,
        tokenizer: Optional[Union[str, "_models.LexicalTokenizerName"]] = None,
        normalizer: Optional[Union[str, "_models.LexicalNormalizerName"]] = None,
        token_filters: Optional[List[Union[str, "_models.TokenFilterName"]]] = None,
        char_filters: Optional[List[Union[str, "_models.CharFilterName"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AnalyzeResult(_model_base.Model):
    """The result of testing an analyzer on text.


    :ivar tokens: The list of tokens returned by the analyzer specified in the request. Required.
    :vartype tokens: list[~azure.search.documents.models.AnalyzedTokenInfo]
    """

    tokens: List["_models.AnalyzedTokenInfo"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The list of tokens returned by the analyzer specified in the request. Required."""

    @overload
    def __init__(
        self,
        *,
        tokens: List["_models.AnalyzedTokenInfo"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TokenFilter(_model_base.Model):
    """Base type for token filters.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AsciiFoldingTokenFilter, CjkBigramTokenFilter, CommonGramTokenFilter,
    DictionaryDecompounderTokenFilter, EdgeNGramTokenFilterV2, ElisionTokenFilter, KeepTokenFilter,
    KeywordMarkerTokenFilter, LengthTokenFilter, LimitTokenFilter, NGramTokenFilterV2,
    PatternCaptureTokenFilter, PatternReplaceTokenFilter, PhoneticTokenFilter, ShingleTokenFilter,
    SnowballTokenFilter, StemmerOverrideTokenFilter, StemmerTokenFilter, StopwordsTokenFilter,
    SynonymTokenFilter, TruncateTokenFilter, UniqueTokenFilter, WordDelimiterTokenFilter


    :ivar odata_type: The discriminator for derived types. Required. Default value is None.
    :vartype odata_type: str
    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    odata_type: str = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])
    """The discriminator for derived types. Required. Default value is None."""
    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required."""

    @overload
    def __init__(
        self,
        *,
        odata_type: str,
        name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsciiFoldingTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.AsciiFoldingTokenFilter"):
    """Converts alphabetic, numeric, and symbolic Unicode characters which are not in
    the first 127 ASCII characters (the "Basic Latin" Unicode block) into their
    ASCII equivalents, if such equivalents exist. This token filter is implemented
    using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar preserve_original: A value indicating whether the original token will be kept. Default is
     false.
    :vartype preserve_original: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.AsciiFoldingTokenFilter".
    :vartype odata_type: str
    """

    preserve_original: Optional[bool] = rest_field(
        name="preserveOriginal", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether the original token will be kept. Default is false."""
    odata_type: Literal["#Microsoft.Azure.Search.AsciiFoldingTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.AsciiFoldingTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        preserve_original: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.AsciiFoldingTokenFilter", **kwargs)


class AutocompleteItem(_model_base.Model):
    """The result of Autocomplete requests.


    :ivar text: The completed term. Required.
    :vartype text: str
    :ivar query_plus_text: The query along with the completed term. Required.
    :vartype query_plus_text: str
    """

    text: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The completed term. Required."""
    query_plus_text: str = rest_field(name="queryPlusText", visibility=["read", "create", "update", "delete", "query"])
    """The query along with the completed term. Required."""

    @overload
    def __init__(
        self,
        *,
        text: str,
        query_plus_text: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AutocompleteRequest(_model_base.Model):
    """Parameters for fuzzy matching, and other autocomplete query behaviors.

    All required parameters must be populated in order to send to server.

    :ivar search_text: The search text on which to base autocomplete results. Required.
    :vartype search_text: str
    :ivar autocomplete_mode: Specifies the mode for Autocomplete. The default is 'oneTerm'. Use
     'twoTerms'
     to get shingles and 'oneTermWithContext' to use the current context while
     producing auto-completed terms. Known values are: "oneTerm", "twoTerms", and
     "oneTermWithContext".
    :vartype autocomplete_mode: str or ~azure.search.documents.models.AutocompleteMode
    :ivar filter: An OData expression that filters the documents used to produce completed terms
     for the Autocomplete result.
    :vartype filter: str
    :ivar use_fuzzy_matching: A value indicating whether to use fuzzy matching for the autocomplete
     query.
     Default is false. When set to true, the query will autocomplete terms even if
     there's a substituted or missing character in the search text. While this
     provides a better experience in some scenarios, it comes at a performance cost
     as fuzzy autocomplete queries are slower and consume more resources.
    :vartype use_fuzzy_matching: bool
    :ivar highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. If omitted, hit highlighting is disabled.
    :vartype highlight_post_tag: str
    :ivar highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. If omitted, hit highlighting is disabled.
    :vartype highlight_pre_tag: str
    :ivar minimum_coverage: A number between 0 and 100 indicating the percentage of the index that
     must be
     covered by an autocomplete query in order for the query to be reported as a
     success. This parameter can be useful for ensuring search availability even for
     services with only one replica. The default is 80.
    :vartype minimum_coverage: float
    :ivar search_fields: The comma-separated list of field names to consider when querying for
     auto-completed terms. Target fields must be included in the specified
     suggester.
    :vartype search_fields: str
    :ivar suggester_name: The name of the suggester as specified in the suggesters collection
     that's part
     of the index definition. Required.
    :vartype suggester_name: str
    :ivar top: The number of auto-completed terms to retrieve. This must be a value between 1
     and 100. The default is 5.
    :vartype top: int
    """

    search_text: str = rest_field(name="search", visibility=["read", "create", "update", "delete", "query"])
    """The search text on which to base autocomplete results. Required."""
    autocomplete_mode: Optional[Union[str, "_models.AutocompleteMode"]] = rest_field(
        name="autocompleteMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'
     to get shingles and 'oneTermWithContext' to use the current context while
     producing auto-completed terms. Known values are: \"oneTerm\", \"twoTerms\", and
     \"oneTermWithContext\"."""
    filter: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """An OData expression that filters the documents used to produce completed terms
     for the Autocomplete result."""
    use_fuzzy_matching: Optional[bool] = rest_field(
        name="fuzzy", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to use fuzzy matching for the autocomplete query.
     Default is false. When set to true, the query will autocomplete terms even if
     there's a substituted or missing character in the search text. While this
     provides a better experience in some scenarios, it comes at a performance cost
     as fuzzy autocomplete queries are slower and consume more resources."""
    highlight_post_tag: Optional[str] = rest_field(
        name="highlightPostTag", visibility=["read", "create", "update", "delete", "query"]
    )
    """A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. If omitted, hit highlighting is disabled."""
    highlight_pre_tag: Optional[str] = rest_field(
        name="highlightPreTag", visibility=["read", "create", "update", "delete", "query"]
    )
    """A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. If omitted, hit highlighting is disabled."""
    minimum_coverage: Optional[float] = rest_field(
        name="minimumCoverage", visibility=["read", "create", "update", "delete", "query"]
    )
    """A number between 0 and 100 indicating the percentage of the index that must be
     covered by an autocomplete query in order for the query to be reported as a
     success. This parameter can be useful for ensuring search availability even for
     services with only one replica. The default is 80."""
    search_fields: Optional[str] = rest_field(
        name="searchFields", visibility=["read", "create", "update", "delete", "query"]
    )
    """The comma-separated list of field names to consider when querying for
     auto-completed terms. Target fields must be included in the specified
     suggester."""
    suggester_name: str = rest_field(name="suggesterName", visibility=["read", "create", "update", "delete", "query"])
    """The name of the suggester as specified in the suggesters collection that's part
     of the index definition. Required."""
    top: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The number of auto-completed terms to retrieve. This must be a value between 1
     and 100. The default is 5."""

    @overload
    def __init__(
        self,
        *,
        search_text: str,
        suggester_name: str,
        autocomplete_mode: Optional[Union[str, "_models.AutocompleteMode"]] = None,
        filter: Optional[str] = None,  # pylint: disable=redefined-builtin
        use_fuzzy_matching: Optional[bool] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        search_fields: Optional[str] = None,
        top: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AutocompleteResult(_model_base.Model):
    """The result of Autocomplete query.


    :ivar coverage: A value indicating the percentage of the index that was considered by the
     autocomplete request, or null if minimumCoverage was not specified in the
     request.
    :vartype coverage: float
    :ivar results: The list of returned Autocompleted items. Required.
    :vartype results: list[~azure.search.documents.models.AutocompleteItem]
    """

    coverage: Optional[float] = rest_field(
        name="@search.coverage", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating the percentage of the index that was considered by the
     autocomplete request, or null if minimumCoverage was not specified in the
     request."""
    results: List["_models.AutocompleteItem"] = rest_field(
        name="value", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of returned Autocompleted items. Required."""

    @overload
    def __init__(
        self,
        *,
        results: List["_models.AutocompleteItem"],
        coverage: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AzureActiveDirectoryApplicationCredentials(_model_base.Model):  # pylint: disable=name-too-long
    """Credentials of a registered application created for your search service, used
    for authenticated access to the encryption keys stored in Azure Key Vault.


    :ivar application_id: An AAD Application ID that was granted the required access permissions to
     the
     Azure Key Vault that is to be used when encrypting your data at rest. The
     Application ID should not be confused with the Object ID for your AAD
     Application. Required.
    :vartype application_id: str
    :ivar application_secret: The authentication key of the specified AAD application.
    :vartype application_secret: str
    """

    application_id: str = rest_field(name="applicationId", visibility=["read", "create", "update", "delete", "query"])
    """An AAD Application ID that was granted the required access permissions to the
     Azure Key Vault that is to be used when encrypting your data at rest. The
     Application ID should not be confused with the Object ID for your AAD
     Application. Required."""
    application_secret: Optional[str] = rest_field(
        name="applicationSecret", visibility=["read", "create", "update", "delete", "query"]
    )
    """The authentication key of the specified AAD application."""

    @overload
    def __init__(
        self,
        *,
        application_id: str,
        application_secret: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AzureMachineLearningParameters(_model_base.Model):
    """Specifies the properties for connecting to an AML vectorizer.


    :ivar scoring_uri: (Required for no authentication or key authentication) The scoring URI of
     the
     AML service to which the JSON payload will be sent. Only the https URI scheme
     is allowed. Required.
    :vartype scoring_uri: str
    :ivar authentication_key: (Required for key authentication) The key for the AML service.
    :vartype authentication_key: str
    :ivar resource_id: (Required for token authentication). The Azure Resource Manager resource ID
     of
     the AML service. It should be in the format
     subscriptions/{guid}/resourceGroups/{resource-group-name}/Microsoft.MachineLearningServices/workspaces/{workspace-name}/services/{service_name}.
    :vartype resource_id: str
    :ivar timeout: (Optional) When specified, indicates the timeout for the http client making the
     API call.
    :vartype timeout: ~datetime.timedelta
    :ivar region: (Optional for token authentication). The region the AML service is deployed in.
    :vartype region: str
    :ivar model_name: The name of the embedding model from the Azure AI Studio Catalog that is
     deployed at the provided endpoint. Known values are:
     "OpenAI-CLIP-Image-Text-Embeddings-vit-base-patch32",
     "OpenAI-CLIP-Image-Text-Embeddings-ViT-Large-Patch14-336",
     "Facebook-DinoV2-Image-Embeddings-ViT-Base", "Facebook-DinoV2-Image-Embeddings-ViT-Giant",
     "Cohere-embed-v3-english", and "Cohere-embed-v3-multilingual".
    :vartype model_name: str or ~azure.search.documents.models.AIFoundryModelCatalogName
    """

    scoring_uri: str = rest_field(name="uri", visibility=["read", "create", "update", "delete", "query"])
    """(Required for no authentication or key authentication) The scoring URI of the
     AML service to which the JSON payload will be sent. Only the https URI scheme
     is allowed. Required."""
    authentication_key: Optional[str] = rest_field(
        name="key", visibility=["read", "create", "update", "delete", "query"]
    )
    """(Required for key authentication) The key for the AML service."""
    resource_id: Optional[str] = rest_field(
        name="resourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """(Required for token authentication). The Azure Resource Manager resource ID of
     the AML service. It should be in the format
     subscriptions/{guid}/resourceGroups/{resource-group-name}/Microsoft.MachineLearningServices/workspaces/{workspace-name}/services/{service_name}."""
    timeout: Optional[datetime.timedelta] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """(Optional) When specified, indicates the timeout for the http client making the
     API call."""
    region: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """(Optional for token authentication). The region the AML service is deployed in."""
    model_name: Optional[Union[str, "_models.AIFoundryModelCatalogName"]] = rest_field(
        name="modelName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the embedding model from the Azure AI Studio Catalog that is
     deployed at the provided endpoint. Known values are:
     \"OpenAI-CLIP-Image-Text-Embeddings-vit-base-patch32\",
     \"OpenAI-CLIP-Image-Text-Embeddings-ViT-Large-Patch14-336\",
     \"Facebook-DinoV2-Image-Embeddings-ViT-Base\", \"Facebook-DinoV2-Image-Embeddings-ViT-Giant\",
     \"Cohere-embed-v3-english\", and \"Cohere-embed-v3-multilingual\"."""

    @overload
    def __init__(
        self,
        *,
        scoring_uri: str,
        authentication_key: Optional[str] = None,
        resource_id: Optional[str] = None,
        timeout: Optional[datetime.timedelta] = None,
        region: Optional[str] = None,
        model_name: Optional[Union[str, "_models.AIFoundryModelCatalogName"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerSkill(_model_base.Model):
    """Base type for skills.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AzureMachineLearningSkill, WebApiSkill, AzureOpenAIEmbeddingSkill, CustomEntityLookupSkill,
    EntityRecognitionSkill, KeyPhraseExtractionSkill, LanguageDetectionSkill, MergeSkill,
    PIIDetectionSkill, SentimentSkill, SplitSkill, TextTranslationSkill, EntityLinkingSkill,
    EntityRecognitionSkillV3, SentimentSkillV3, ConditionalSkill, DocumentExtractionSkill,
    DocumentIntelligenceLayoutSkill, ShaperSkill, ImageAnalysisSkill, OcrSkill,
    VisionVectorizeSkill


    :ivar odata_type: The discriminator for derived types. Required. Default value is None.
    :vartype odata_type: str
    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    odata_type: str = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])
    """The discriminator for derived types. Required. Default value is None."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The description of the skill which describes the inputs, outputs, and usage of
     the skill."""
    context: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document."""
    inputs: List["_models.InputFieldMappingEntry"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required."""
    outputs: List["_models.OutputFieldMappingEntry"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required."""

    @overload
    def __init__(
        self,
        *,
        odata_type: str,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AzureMachineLearningSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Custom.AmlSkill"):
    """The AML skill allows you to extend AI enrichment with a custom Azure Machine
    Learning (AML) model. Once an AML model is trained and deployed, an AML skill
    integrates it into AI enrichment.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar scoring_uri: (Required for no authentication or key authentication) The scoring URI of
     the
     AML service to which the JSON payload will be sent. Only the https URI scheme
     is allowed.
    :vartype scoring_uri: str
    :ivar authentication_key: (Required for key authentication) The key for the AML service.
    :vartype authentication_key: str
    :ivar resource_id: (Required for token authentication). The Azure Resource Manager resource ID
     of
     the AML service. It should be in the format
     subscriptions/{guid}/resourceGroups/{resource-group-name}/Microsoft.MachineLearningServices/workspaces/{workspace-name}/services/{service_name}.
    :vartype resource_id: str
    :ivar timeout: (Optional) When specified, indicates the timeout for the http client making the
     API call.
    :vartype timeout: ~datetime.timedelta
    :ivar region: (Optional for token authentication). The region the AML service is deployed in.
    :vartype region: str
    :ivar degree_of_parallelism: (Optional) When specified, indicates the number of calls the
     indexer will make
     in parallel to the endpoint you have provided. You can decrease this value if
     your endpoint is failing under too high of a request load, or raise it if your
     endpoint is able to accept more requests and you would like an increase in the
     performance of the indexer. If not set, a default value of 5 is used. The
     degreeOfParallelism can be set to a maximum of 10 and a minimum of 1.
    :vartype degree_of_parallelism: int
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Custom.AmlSkill".
    :vartype odata_type: str
    """

    scoring_uri: Optional[str] = rest_field(name="uri", visibility=["read", "create", "update", "delete", "query"])
    """(Required for no authentication or key authentication) The scoring URI of the
     AML service to which the JSON payload will be sent. Only the https URI scheme
     is allowed."""
    authentication_key: Optional[str] = rest_field(
        name="key", visibility=["read", "create", "update", "delete", "query"]
    )
    """(Required for key authentication) The key for the AML service."""
    resource_id: Optional[str] = rest_field(
        name="resourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """(Required for token authentication). The Azure Resource Manager resource ID of
     the AML service. It should be in the format
     subscriptions/{guid}/resourceGroups/{resource-group-name}/Microsoft.MachineLearningServices/workspaces/{workspace-name}/services/{service_name}."""
    timeout: Optional[datetime.timedelta] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """(Optional) When specified, indicates the timeout for the http client making the
     API call."""
    region: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """(Optional for token authentication). The region the AML service is deployed in."""
    degree_of_parallelism: Optional[int] = rest_field(
        name="degreeOfParallelism", visibility=["read", "create", "update", "delete", "query"]
    )
    """(Optional) When specified, indicates the number of calls the indexer will make
     in parallel to the endpoint you have provided. You can decrease this value if
     your endpoint is failing under too high of a request load, or raise it if your
     endpoint is able to accept more requests and you would like an increase in the
     performance of the indexer. If not set, a default value of 5 is used. The
     degreeOfParallelism can be set to a maximum of 10 and a minimum of 1."""
    odata_type: Literal["#Microsoft.Skills.Custom.AmlSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Custom.AmlSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        scoring_uri: Optional[str] = None,
        authentication_key: Optional[str] = None,
        resource_id: Optional[str] = None,
        timeout: Optional[datetime.timedelta] = None,
        region: Optional[str] = None,
        degree_of_parallelism: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Custom.AmlSkill", **kwargs)


class AzureMachineLearningVectorizer(VectorSearchVectorizer, discriminator="aml"):
    """Specifies an Azure Machine Learning endpoint deployed via the Azure AI Studio
    Model Catalog for generating the vector embedding of a query string.


    :ivar vectorizer_name: The name to associate with this particular vectorization method.
     Required.
    :vartype vectorizer_name: str
    :ivar aml_parameters: Specifies the properties of the AML vectorizer.
    :vartype aml_parameters: ~azure.search.documents.models.AzureMachineLearningParameters
    :ivar kind: The name of the kind of vectorization method being configured for use with
     vector search. Required. Generate embeddings using an Azure Machine Learning endpoint deployed
     via the
     Azure AI Studio Model Catalog at query time.
    :vartype kind: str or ~azure.search.documents.models.AML
    """

    aml_parameters: Optional["_models.AzureMachineLearningParameters"] = rest_field(
        name="amlParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the properties of the AML vectorizer."""
    kind: Literal[VectorSearchVectorizerKind.AML] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The name of the kind of vectorization method being configured for use with
     vector search. Required. Generate embeddings using an Azure Machine Learning endpoint deployed
     via the
     Azure AI Studio Model Catalog at query time."""

    @overload
    def __init__(
        self,
        *,
        vectorizer_name: str,
        aml_parameters: Optional["_models.AzureMachineLearningParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorSearchVectorizerKind.AML, **kwargs)


class AzureOpenAIEmbeddingSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill"):
    """Allows you to generate a vector embedding for a given text input using the
    Azure OpenAI resource.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar resource_url: The resource URI of the Azure OpenAI resource.
    :vartype resource_url: str
    :ivar deployment_name: ID of the Azure OpenAI model deployment on the designated resource.
    :vartype deployment_name: str
    :ivar api_key: API key of the designated Azure OpenAI resource.
    :vartype api_key: str
    :ivar auth_identity: The user-assigned managed identity used for outbound connections.
    :vartype auth_identity: ~azure.search.documents.models.SearchIndexerDataIdentity
    :ivar model_name: The name of the embedding model that is deployed at the provided deploymentId
     path. Known values are: "text-embedding-ada-002", "text-embedding-3-large", and
     "text-embedding-3-small".
    :vartype model_name: str or ~azure.search.documents.models.AzureOpenAIModelName
    :ivar dimensions: The number of dimensions the resulting output embeddings should have. Only
     supported in text-embedding-3 and later models.
    :vartype dimensions: int
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill".
    :vartype odata_type: str
    """

    resource_url: Optional[str] = rest_field(
        name="resourceUri", visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource URI of the Azure OpenAI resource."""
    deployment_name: Optional[str] = rest_field(
        name="deploymentId", visibility=["read", "create", "update", "delete", "query"]
    )
    """ID of the Azure OpenAI model deployment on the designated resource."""
    api_key: Optional[str] = rest_field(name="apiKey", visibility=["read", "create", "update", "delete", "query"])
    """API key of the designated Azure OpenAI resource."""
    auth_identity: Optional["_models.SearchIndexerDataIdentity"] = rest_field(
        name="authIdentity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The user-assigned managed identity used for outbound connections."""
    model_name: Optional[Union[str, "_models.AzureOpenAIModelName"]] = rest_field(
        name="modelName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the embedding model that is deployed at the provided deploymentId
     path. Known values are: \"text-embedding-ada-002\", \"text-embedding-3-large\", and
     \"text-embedding-3-small\"."""
    dimensions: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The number of dimensions the resulting output embeddings should have. Only
     supported in text-embedding-3 and later models."""
    odata_type: Literal["#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        resource_url: Optional[str] = None,
        deployment_name: Optional[str] = None,
        api_key: Optional[str] = None,
        auth_identity: Optional["_models.SearchIndexerDataIdentity"] = None,
        model_name: Optional[Union[str, "_models.AzureOpenAIModelName"]] = None,
        dimensions: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill", **kwargs)


class AzureOpenAITokenizerParameters(_model_base.Model):
    """Azure OpenAI Tokenizer parameters.

    :ivar encoder_model_name: Only applies if the unit is set to azureOpenAITokens. Options include
     'R50k_base', 'P50k_base', 'P50k_edit' and 'CL100k_base'. The default value is 'CL100k_base'.
     Known values are: "r50k_base", "p50k_base", "p50k_edit", and "cl100k_base".
    :vartype encoder_model_name: str or ~azure.search.documents.models.SplitSkillEncoderModelName
    :ivar allowed_special_tokens: (Optional) Only applies if the unit is set to azureOpenAITokens.
     This parameter
     defines a collection of special tokens that are permitted within the
     tokenization process.
    :vartype allowed_special_tokens: list[str]
    """

    encoder_model_name: Optional[Union[str, "_models.SplitSkillEncoderModelName"]] = rest_field(
        name="encoderModelName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Only applies if the unit is set to azureOpenAITokens. Options include
     'R50k_base', 'P50k_base', 'P50k_edit' and 'CL100k_base'. The default value is 'CL100k_base'.
     Known values are: \"r50k_base\", \"p50k_base\", \"p50k_edit\", and \"cl100k_base\"."""
    allowed_special_tokens: Optional[List[str]] = rest_field(
        name="allowedSpecialTokens", visibility=["read", "create", "update", "delete", "query"]
    )
    """(Optional) Only applies if the unit is set to azureOpenAITokens. This parameter
     defines a collection of special tokens that are permitted within the
     tokenization process."""

    @overload
    def __init__(
        self,
        *,
        encoder_model_name: Optional[Union[str, "_models.SplitSkillEncoderModelName"]] = None,
        allowed_special_tokens: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AzureOpenAIVectorizer(VectorSearchVectorizer, discriminator="azureOpenAI"):
    """Specifies the Azure OpenAI resource used to vectorize a query string.


    :ivar vectorizer_name: The name to associate with this particular vectorization method.
     Required.
    :vartype vectorizer_name: str
    :ivar parameters: Contains the parameters specific to Azure OpenAI embedding vectorization.
    :vartype parameters: ~azure.search.documents.models.AzureOpenAIVectorizerParameters
    :ivar kind: The name of the kind of vectorization method being configured for use with
     vector search. Required. Generate embeddings using an Azure OpenAI resource at query time.
    :vartype kind: str or ~azure.search.documents.models.AZURE_OPEN_AI
    """

    parameters: Optional["_models.AzureOpenAIVectorizerParameters"] = rest_field(
        name="azureOpenAIParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains the parameters specific to Azure OpenAI embedding vectorization."""
    kind: Literal[VectorSearchVectorizerKind.AZURE_OPEN_AI] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The name of the kind of vectorization method being configured for use with
     vector search. Required. Generate embeddings using an Azure OpenAI resource at query time."""

    @overload
    def __init__(
        self,
        *,
        vectorizer_name: str,
        parameters: Optional["_models.AzureOpenAIVectorizerParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorSearchVectorizerKind.AZURE_OPEN_AI, **kwargs)


class AzureOpenAIVectorizerParameters(_model_base.Model):
    """Specifies the parameters for connecting to the Azure OpenAI resource.

    :ivar resource_url: The resource URI of the Azure OpenAI resource.
    :vartype resource_url: str
    :ivar deployment_name: ID of the Azure OpenAI model deployment on the designated resource.
    :vartype deployment_name: str
    :ivar api_key: API key of the designated Azure OpenAI resource.
    :vartype api_key: str
    :ivar auth_identity: The user-assigned managed identity used for outbound connections.
    :vartype auth_identity: ~azure.search.documents.models.SearchIndexerDataIdentity
    :ivar model_name: The name of the embedding model that is deployed at the provided deploymentId
     path. Known values are: "text-embedding-ada-002", "text-embedding-3-large", and
     "text-embedding-3-small".
    :vartype model_name: str or ~azure.search.documents.models.AzureOpenAIModelName
    """

    resource_url: Optional[str] = rest_field(
        name="resourceUri", visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource URI of the Azure OpenAI resource."""
    deployment_name: Optional[str] = rest_field(
        name="deploymentId", visibility=["read", "create", "update", "delete", "query"]
    )
    """ID of the Azure OpenAI model deployment on the designated resource."""
    api_key: Optional[str] = rest_field(name="apiKey", visibility=["read", "create", "update", "delete", "query"])
    """API key of the designated Azure OpenAI resource."""
    auth_identity: Optional["_models.SearchIndexerDataIdentity"] = rest_field(
        name="authIdentity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The user-assigned managed identity used for outbound connections."""
    model_name: Optional[Union[str, "_models.AzureOpenAIModelName"]] = rest_field(
        name="modelName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the embedding model that is deployed at the provided deploymentId
     path. Known values are: \"text-embedding-ada-002\", \"text-embedding-3-large\", and
     \"text-embedding-3-small\"."""

    @overload
    def __init__(
        self,
        *,
        resource_url: Optional[str] = None,
        deployment_name: Optional[str] = None,
        api_key: Optional[str] = None,
        auth_identity: Optional["_models.SearchIndexerDataIdentity"] = None,
        model_name: Optional[Union[str, "_models.AzureOpenAIModelName"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorSearchCompression(_model_base.Model):
    """Contains configuration options specific to the compression method used during
    indexing or querying.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    BinaryQuantizationCompression, ScalarQuantizationCompression


    :ivar compression_name: The name to associate with this particular configuration. Required.
    :vartype compression_name: str
    :ivar rerank_with_original_vectors: If set to true, once the ordered set of results calculated
     using compressed
     vectors are obtained, they will be reranked again by recalculating the
     full-precision similarity scores. This will improve recall at the expense of
     latency.
    :vartype rerank_with_original_vectors: bool
    :ivar default_oversampling: Default oversampling factor. Oversampling will internally request
     more
     documents (specified by this multiplier) in the initial search. This increases
     the set of results that will be reranked using recomputed similarity scores
     from full-precision vectors. Minimum value is 1, meaning no oversampling (1x).
     This parameter can only be set when rerankWithOriginalVectors is true. Higher
     values improve recall at the expense of latency.
    :vartype default_oversampling: float
    :ivar rescoring_options: Contains the options for rescoring.
    :vartype rescoring_options: ~azure.search.documents.models.RescoringOptions
    :ivar truncation_dimension: The number of dimensions to truncate the vectors to. Truncating the
     vectors
     reduces the size of the vectors and the amount of data that needs to be
     transferred during search. This can save storage cost and improve search
     performance at the expense of recall. It should be only used for embeddings
     trained with Matryoshka Representation Learning (MRL) such as OpenAI
     text-embedding-3-large (small). The default value is null, which means no
     truncation.
    :vartype truncation_dimension: int
    :ivar kind: Type of VectorSearchCompression. Required. Known values are: "scalarQuantization"
     and "binaryQuantization".
    :vartype kind: str or ~azure.search.documents.models.VectorSearchCompressionKind
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    compression_name: str = rest_field(name="name", visibility=["read", "create", "update", "delete", "query"])
    """The name to associate with this particular configuration. Required."""
    rerank_with_original_vectors: Optional[bool] = rest_field(
        name="rerankWithOriginalVectors", visibility=["read", "create", "update", "delete", "query"]
    )
    """If set to true, once the ordered set of results calculated using compressed
     vectors are obtained, they will be reranked again by recalculating the
     full-precision similarity scores. This will improve recall at the expense of
     latency."""
    default_oversampling: Optional[float] = rest_field(
        name="defaultOversampling", visibility=["read", "create", "update", "delete", "query"]
    )
    """Default oversampling factor. Oversampling will internally request more
     documents (specified by this multiplier) in the initial search. This increases
     the set of results that will be reranked using recomputed similarity scores
     from full-precision vectors. Minimum value is 1, meaning no oversampling (1x).
     This parameter can only be set when rerankWithOriginalVectors is true. Higher
     values improve recall at the expense of latency."""
    rescoring_options: Optional["_models.RescoringOptions"] = rest_field(
        name="rescoringOptions", visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains the options for rescoring."""
    truncation_dimension: Optional[int] = rest_field(
        name="truncationDimension", visibility=["read", "create", "update", "delete", "query"]
    )
    """The number of dimensions to truncate the vectors to. Truncating the vectors
     reduces the size of the vectors and the amount of data that needs to be
     transferred during search. This can save storage cost and improve search
     performance at the expense of recall. It should be only used for embeddings
     trained with Matryoshka Representation Learning (MRL) such as OpenAI
     text-embedding-3-large (small). The default value is null, which means no
     truncation."""
    kind: str = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])
    """Type of VectorSearchCompression. Required. Known values are: \"scalarQuantization\" and
     \"binaryQuantization\"."""

    @overload
    def __init__(
        self,
        *,
        compression_name: str,
        kind: str,
        rerank_with_original_vectors: Optional[bool] = None,
        default_oversampling: Optional[float] = None,
        rescoring_options: Optional["_models.RescoringOptions"] = None,
        truncation_dimension: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BinaryQuantizationCompression(VectorSearchCompression, discriminator="binaryQuantization"):
    """Contains configuration options specific to the binary quantization compression
    method used during indexing and querying.


    :ivar compression_name: The name to associate with this particular configuration. Required.
    :vartype compression_name: str
    :ivar rerank_with_original_vectors: If set to true, once the ordered set of results calculated
     using compressed
     vectors are obtained, they will be reranked again by recalculating the
     full-precision similarity scores. This will improve recall at the expense of
     latency.
    :vartype rerank_with_original_vectors: bool
    :ivar default_oversampling: Default oversampling factor. Oversampling will internally request
     more
     documents (specified by this multiplier) in the initial search. This increases
     the set of results that will be reranked using recomputed similarity scores
     from full-precision vectors. Minimum value is 1, meaning no oversampling (1x).
     This parameter can only be set when rerankWithOriginalVectors is true. Higher
     values improve recall at the expense of latency.
    :vartype default_oversampling: float
    :ivar rescoring_options: Contains the options for rescoring.
    :vartype rescoring_options: ~azure.search.documents.models.RescoringOptions
    :ivar truncation_dimension: The number of dimensions to truncate the vectors to. Truncating the
     vectors
     reduces the size of the vectors and the amount of data that needs to be
     transferred during search. This can save storage cost and improve search
     performance at the expense of recall. It should be only used for embeddings
     trained with Matryoshka Representation Learning (MRL) such as OpenAI
     text-embedding-3-large (small). The default value is null, which means no
     truncation.
    :vartype truncation_dimension: int
    :ivar kind: The name of the kind of compression method being configured for use with vector
     search. Required. Binary Quantization, a type of compression method. In binary quantization,
     the
     original vectors values are compressed to the narrower binary type by discretizing
     and representing each component of a vector using binary values,
     thereby reducing the overall data size.
    :vartype kind: str or ~azure.search.documents.models.BINARY_QUANTIZATION
    """

    kind: Literal[VectorSearchCompressionKind.BINARY_QUANTIZATION] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The name of the kind of compression method being configured for use with vector
     search. Required. Binary Quantization, a type of compression method. In binary quantization,
     the
     original vectors values are compressed to the narrower binary type by discretizing
     and representing each component of a vector using binary values,
     thereby reducing the overall data size."""

    @overload
    def __init__(
        self,
        *,
        compression_name: str,
        rerank_with_original_vectors: Optional[bool] = None,
        default_oversampling: Optional[float] = None,
        rescoring_options: Optional["_models.RescoringOptions"] = None,
        truncation_dimension: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorSearchCompressionKind.BINARY_QUANTIZATION, **kwargs)


class SimilarityAlgorithm(_model_base.Model):
    """Base type for similarity algorithms. Similarity algorithms are used to
    calculate scores that tie queries to documents. The higher the score, the more
    relevant the document is to that specific query. Those scores are used to rank
    the search results.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    BM25SimilarityAlgorithm, ClassicSimilarityAlgorithm


    :ivar odata_type: The discriminator for derived types. Required. Default value is None.
    :vartype odata_type: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    odata_type: str = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])
    """The discriminator for derived types. Required. Default value is None."""

    @overload
    def __init__(
        self,
        *,
        odata_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BM25SimilarityAlgorithm(SimilarityAlgorithm, discriminator="#Microsoft.Azure.Search.BM25Similarity"):
    """Ranking function based on the Okapi BM25 similarity algorithm. BM25 is a
    TF-IDF-like algorithm that includes length normalization (controlled by the 'b'
    parameter) as well as term frequency saturation (controlled by the 'k1'
    parameter).


    :ivar k1: This property controls the scaling function between the term frequency of each
     matching terms and the final relevance score of a document-query pair. By
     default, a value of 1.2 is used. A value of 0.0 means the score does not scale
     with an increase in term frequency.
    :vartype k1: float
    :ivar b: This property controls how the length of a document affects the relevance
     score. By default, a value of 0.75 is used. A value of 0.0 means no length
     normalization is applied, while a value of 1.0 means the score is fully
     normalized by the length of the document.
    :vartype b: float
    :ivar odata_type: The discriminator for derived types. Required. Default value is
     "#Microsoft.Azure.Search.BM25Similarity".
    :vartype odata_type: str
    """

    k1: Optional[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """This property controls the scaling function between the term frequency of each
     matching terms and the final relevance score of a document-query pair. By
     default, a value of 1.2 is used. A value of 0.0 means the score does not scale
     with an increase in term frequency."""
    b: Optional[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """This property controls how the length of a document affects the relevance
     score. By default, a value of 0.75 is used. A value of 0.0 means no length
     normalization is applied, while a value of 1.0 means the score is fully
     normalized by the length of the document."""
    odata_type: Literal["#Microsoft.Azure.Search.BM25Similarity"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The discriminator for derived types. Required. Default value is
     \"#Microsoft.Azure.Search.BM25Similarity\"."""

    @overload
    def __init__(
        self,
        *,
        k1: Optional[float] = None,
        b: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.BM25Similarity", **kwargs)


class CharFilter(_model_base.Model):
    """Base type for character filters.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    MappingCharFilter, PatternReplaceCharFilter


    :ivar odata_type: The discriminator for derived types. Required. Default value is None.
    :vartype odata_type: str
    :ivar name: The name of the char filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    odata_type: str = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])
    """The discriminator for derived types. Required. Default value is None."""
    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the char filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required."""

    @overload
    def __init__(
        self,
        *,
        odata_type: str,
        name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CjkBigramTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.CjkBigramTokenFilter"):
    """Forms bigrams of CJK terms that are generated from the standard tokenizer. This
    token filter is implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar ignore_scripts: The scripts to ignore.
    :vartype ignore_scripts: list[str or
     ~azure.search.documents.models.CjkBigramTokenFilterScripts]
    :ivar output_unigrams: A value indicating whether to output both unigrams and bigrams (if
     true), or
     just bigrams (if false). Default is false.
    :vartype output_unigrams: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.CjkBigramTokenFilter".
    :vartype odata_type: str
    """

    ignore_scripts: Optional[List[Union[str, "_models.CjkBigramTokenFilterScripts"]]] = rest_field(
        name="ignoreScripts", visibility=["read", "create", "update", "delete", "query"]
    )
    """The scripts to ignore."""
    output_unigrams: Optional[bool] = rest_field(
        name="outputUnigrams", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to output both unigrams and bigrams (if true), or
     just bigrams (if false). Default is false."""
    odata_type: Literal["#Microsoft.Azure.Search.CjkBigramTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.CjkBigramTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        ignore_scripts: Optional[List[Union[str, "_models.CjkBigramTokenFilterScripts"]]] = None,
        output_unigrams: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.CjkBigramTokenFilter", **kwargs)


class ClassicSimilarityAlgorithm(SimilarityAlgorithm, discriminator="#Microsoft.Azure.Search.ClassicSimilarity"):
    """Legacy similarity algorithm which uses the Lucene TFIDFSimilarity
    implementation of TF-IDF. This variation of TF-IDF introduces static document
    length normalization as well as coordinating factors that penalize documents
    that only partially match the searched queries.


    :ivar odata_type: The discriminator for derived types. Required. Default value is
     "#Microsoft.Azure.Search.ClassicSimilarity".
    :vartype odata_type: str
    """

    odata_type: Literal["#Microsoft.Azure.Search.ClassicSimilarity"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The discriminator for derived types. Required. Default value is
     \"#Microsoft.Azure.Search.ClassicSimilarity\"."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.ClassicSimilarity", **kwargs)


class LexicalTokenizer(_model_base.Model):
    """Base type for tokenizers.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    ClassicTokenizer, EdgeNGramTokenizer, KeywordTokenizerV2, MicrosoftLanguageStemmingTokenizer,
    MicrosoftLanguageTokenizer, NGramTokenizer, PathHierarchyTokenizerV2, PatternTokenizer,
    LuceneStandardTokenizerV2, UaxUrlEmailTokenizer


    :ivar odata_type: The discriminator for derived types. Required. Default value is None.
    :vartype odata_type: str
    :ivar name: The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    odata_type: str = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])
    """The discriminator for derived types. Required. Default value is None."""
    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required."""

    @overload
    def __init__(
        self,
        *,
        odata_type: str,
        name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClassicTokenizer(LexicalTokenizer, discriminator="#Microsoft.Azure.Search.ClassicTokenizer"):
    """Grammar-based tokenizer that is suitable for processing most European-language
    documents. This tokenizer is implemented using Apache Lucene.


    :ivar name: The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar max_token_length: The maximum token length. Default is 255. Tokens longer than the
     maximum length
     are split. The maximum token length that can be used is 300 characters.
    :vartype max_token_length: int
    :ivar odata_type: A URI fragment specifying the type of tokenizer. Required. Default value is
     "#Microsoft.Azure.Search.ClassicTokenizer".
    :vartype odata_type: str
    """

    max_token_length: Optional[int] = rest_field(
        name="maxTokenLength", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum token length. Default is 255. Tokens longer than the maximum length
     are split. The maximum token length that can be used is 300 characters."""
    odata_type: Literal["#Microsoft.Azure.Search.ClassicTokenizer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of tokenizer. Required. Default value is
     \"#Microsoft.Azure.Search.ClassicTokenizer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        max_token_length: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.ClassicTokenizer", **kwargs)


class CognitiveServicesAccountKey(
    CognitiveServicesAccount, discriminator="#Microsoft.Azure.Search.CognitiveServicesByKey"
):
    """The multi-region account key of an Azure AI service resource that's attached to
    a skillset.


    :ivar description: Description of the Azure AI service resource attached to a skillset.
    :vartype description: str
    :ivar key: The key used to provision the Azure AI service resource attached to a skillset.
     Required.
    :vartype key: str
    :ivar odata_type: A URI fragment specifying the type of Azure AI service resource attached to a
     skillset. Required. Default value is "#Microsoft.Azure.Search.CognitiveServicesByKey".
    :vartype odata_type: str
    """

    key: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The key used to provision the Azure AI service resource attached to a skillset. Required."""
    odata_type: Literal["#Microsoft.Azure.Search.CognitiveServicesByKey"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of Azure AI service resource attached to a
     skillset. Required. Default value is \"#Microsoft.Azure.Search.CognitiveServicesByKey\"."""

    @overload
    def __init__(
        self,
        *,
        key: str,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.CognitiveServicesByKey", **kwargs)


class CommonGramTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.CommonGramTokenFilter"):
    """Construct bigrams for frequently occurring terms while indexing. Single terms
    are still indexed too, with bigrams overlaid. This token filter is implemented
    using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar common_words: The set of common words. Required.
    :vartype common_words: list[str]
    :ivar ignore_case: A value indicating whether common words matching will be case insensitive.
     Default is false.
    :vartype ignore_case: bool
    :ivar use_query_mode: A value that indicates whether the token filter is in query mode. When in
     query
     mode, the token filter generates bigrams and then removes common words and
     single terms followed by a common word. Default is false.
    :vartype use_query_mode: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.CommonGramTokenFilter".
    :vartype odata_type: str
    """

    common_words: List[str] = rest_field(name="commonWords", visibility=["read", "create", "update", "delete", "query"])
    """The set of common words. Required."""
    ignore_case: Optional[bool] = rest_field(
        name="ignoreCase", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether common words matching will be case insensitive.
     Default is false."""
    use_query_mode: Optional[bool] = rest_field(
        name="queryMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value that indicates whether the token filter is in query mode. When in query
     mode, the token filter generates bigrams and then removes common words and
     single terms followed by a common word. Default is false."""
    odata_type: Literal["#Microsoft.Azure.Search.CommonGramTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.CommonGramTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        common_words: List[str],
        ignore_case: Optional[bool] = None,
        use_query_mode: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.CommonGramTokenFilter", **kwargs)


class ConditionalSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Util.ConditionalSkill"):
    """A skill that enables scenarios that require a Boolean operation to determine
    the data to assign to an output.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Util.ConditionalSkill".
    :vartype odata_type: str
    """

    odata_type: Literal["#Microsoft.Skills.Util.ConditionalSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Util.ConditionalSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Util.ConditionalSkill", **kwargs)


class CorsOptions(_model_base.Model):
    """Defines options to control Cross-Origin Resource Sharing (CORS) for an index.


    :ivar allowed_origins: The list of origins from which JavaScript code will be granted access to
     your
     index. Can contain a list of hosts of the form
     {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to allow
     all origins (not recommended). Required.
    :vartype allowed_origins: list[str]
    :ivar max_age_in_seconds: The duration for which browsers should cache CORS preflight
     responses. Defaults
     to 5 minutes.
    :vartype max_age_in_seconds: int
    """

    allowed_origins: List[str] = rest_field(
        name="allowedOrigins", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of origins from which JavaScript code will be granted access to your
     index. Can contain a list of hosts of the form
     {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to allow
     all origins (not recommended). Required."""
    max_age_in_seconds: Optional[int] = rest_field(
        name="maxAgeInSeconds", visibility=["read", "create", "update", "delete", "query"]
    )
    """The duration for which browsers should cache CORS preflight responses. Defaults
     to 5 minutes."""

    @overload
    def __init__(
        self,
        *,
        allowed_origins: List[str],
        max_age_in_seconds: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LexicalAnalyzer(_model_base.Model):
    """Base type for analyzers.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CustomAnalyzer, PatternAnalyzer, LuceneStandardAnalyzer, StopAnalyzer


    :ivar odata_type: The discriminator for derived types. Required. Default value is None.
    :vartype odata_type: str
    :ivar name: The name of the analyzer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    odata_type: str = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])
    """The discriminator for derived types. Required. Default value is None."""
    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the analyzer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required."""

    @overload
    def __init__(
        self,
        *,
        odata_type: str,
        name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CustomAnalyzer(LexicalAnalyzer, discriminator="#Microsoft.Azure.Search.CustomAnalyzer"):
    """Allows you to take control over the process of converting text into
    indexable/searchable tokens. It's a user-defined configuration consisting of a
    single predefined tokenizer and one or more filters. The tokenizer is
    responsible for breaking text into tokens, and the filters for modifying tokens
    emitted by the tokenizer.


    :ivar name: The name of the analyzer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar tokenizer: The name of the tokenizer to use to divide continuous text into a sequence of
     tokens, such as breaking a sentence into words. Required. Known values are: "classic",
     "edgeNGram", "keyword_v2", "letter", "lowercase", "microsoft_language_tokenizer",
     "microsoft_language_stemming_tokenizer", "nGram", "path_hierarchy_v2", "pattern",
     "standard_v2", "uax_url_email", and "whitespace".
    :vartype tokenizer: str or ~azure.search.documents.models.LexicalTokenizerName
    :ivar token_filters: A list of token filters used to filter out or modify the tokens generated
     by a
     tokenizer. For example, you can specify a lowercase filter that converts all
     characters to lowercase. The filters are run in the order in which they are
     listed.
    :vartype token_filters: list[str or ~azure.search.documents.models.TokenFilterName]
    :ivar char_filters: A list of character filters used to prepare input text before it is
     processed
     by the tokenizer. For instance, they can replace certain characters or symbols.
     The filters are run in the order in which they are listed.
    :vartype char_filters: list[str or ~azure.search.documents.models.CharFilterName]
    :ivar odata_type: A URI fragment specifying the type of analyzer. Required. Default value is
     "#Microsoft.Azure.Search.CustomAnalyzer".
    :vartype odata_type: str
    """

    tokenizer: Union[str, "_models.LexicalTokenizerName"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the tokenizer to use to divide continuous text into a sequence of
     tokens, such as breaking a sentence into words. Required. Known values are: \"classic\",
     \"edgeNGram\", \"keyword_v2\", \"letter\", \"lowercase\", \"microsoft_language_tokenizer\",
     \"microsoft_language_stemming_tokenizer\", \"nGram\", \"path_hierarchy_v2\", \"pattern\",
     \"standard_v2\", \"uax_url_email\", and \"whitespace\"."""
    token_filters: Optional[List[Union[str, "_models.TokenFilterName"]]] = rest_field(
        name="tokenFilters", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of token filters used to filter out or modify the tokens generated by a
     tokenizer. For example, you can specify a lowercase filter that converts all
     characters to lowercase. The filters are run in the order in which they are
     listed."""
    char_filters: Optional[List[Union[str, "_models.CharFilterName"]]] = rest_field(
        name="charFilters", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of character filters used to prepare input text before it is processed
     by the tokenizer. For instance, they can replace certain characters or symbols.
     The filters are run in the order in which they are listed."""
    odata_type: Literal["#Microsoft.Azure.Search.CustomAnalyzer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of analyzer. Required. Default value is
     \"#Microsoft.Azure.Search.CustomAnalyzer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        tokenizer: Union[str, "_models.LexicalTokenizerName"],
        token_filters: Optional[List[Union[str, "_models.TokenFilterName"]]] = None,
        char_filters: Optional[List[Union[str, "_models.CharFilterName"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.CustomAnalyzer", **kwargs)


class CustomEntity(_model_base.Model):
    """An object that contains information about the matches that were found, and
    related metadata.


    :ivar name: The top-level entity descriptor. Matches in the skill output will be grouped by
     this name, and it should represent the "normalized" form of the text being
     found. Required.
    :vartype name: str
    :ivar description: This field can be used as a passthrough for custom metadata about the
     matched
     text(s). The value of this field will appear with every match of its entity in
     the skill output.
    :vartype description: str
    :ivar type: This field can be used as a passthrough for custom metadata about the matched
     text(s). The value of this field will appear with every match of its entity in
     the skill output.
    :vartype type: str
    :ivar subtype: This field can be used as a passthrough for custom metadata about the matched
     text(s). The value of this field will appear with every match of its entity in
     the skill output.
    :vartype subtype: str
    :ivar id: This field can be used as a passthrough for custom metadata about the matched
     text(s). The value of this field will appear with every match of its entity in
     the skill output.
    :vartype id: str
    :ivar case_sensitive: Defaults to false. Boolean value denoting whether comparisons with the
     entity
     name should be sensitive to character casing. Sample case insensitive matches
     of "Microsoft" could be: microsoft, microSoft, MICROSOFT.
    :vartype case_sensitive: bool
    :ivar accent_sensitive: Defaults to false. Boolean value denoting whether comparisons with the
     entity
     name should be sensitive to accent.
    :vartype accent_sensitive: bool
    :ivar fuzzy_edit_distance: Defaults to 0. Maximum value of 5. Denotes the acceptable number of
     divergent
     characters that would still constitute a match with the entity name. The
     smallest possible fuzziness for any given match is returned. For instance, if
     the edit distance is set to 3, "Windows10" would still match "Windows",
     "Windows10" and "Windows 7". When case sensitivity is set to false, case
     differences do NOT count towards fuzziness tolerance, but otherwise do.
    :vartype fuzzy_edit_distance: int
    :ivar default_case_sensitive: Changes the default case sensitivity value for this entity. It be
     used to
     change the default value of all aliases caseSensitive values.
    :vartype default_case_sensitive: bool
    :ivar default_accent_sensitive: Changes the default accent sensitivity value for this entity.
     It be used to
     change the default value of all aliases accentSensitive values.
    :vartype default_accent_sensitive: bool
    :ivar default_fuzzy_edit_distance: Changes the default fuzzy edit distance value for this
     entity. It can be used
     to change the default value of all aliases fuzzyEditDistance values.
    :vartype default_fuzzy_edit_distance: int
    :ivar aliases: An array of complex objects that can be used to specify alternative spellings
     or synonyms to the root entity name.
    :vartype aliases: list[~azure.search.documents.models.CustomEntityAlias]
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The top-level entity descriptor. Matches in the skill output will be grouped by
     this name, and it should represent the \"normalized\" form of the text being
     found. Required."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """This field can be used as a passthrough for custom metadata about the matched
     text(s). The value of this field will appear with every match of its entity in
     the skill output."""
    type: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """This field can be used as a passthrough for custom metadata about the matched
     text(s). The value of this field will appear with every match of its entity in
     the skill output."""
    subtype: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """This field can be used as a passthrough for custom metadata about the matched
     text(s). The value of this field will appear with every match of its entity in
     the skill output."""
    id: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """This field can be used as a passthrough for custom metadata about the matched
     text(s). The value of this field will appear with every match of its entity in
     the skill output."""
    case_sensitive: Optional[bool] = rest_field(
        name="caseSensitive", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defaults to false. Boolean value denoting whether comparisons with the entity
     name should be sensitive to character casing. Sample case insensitive matches
     of \"Microsoft\" could be: microsoft, microSoft, MICROSOFT."""
    accent_sensitive: Optional[bool] = rest_field(
        name="accentSensitive", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defaults to false. Boolean value denoting whether comparisons with the entity
     name should be sensitive to accent."""
    fuzzy_edit_distance: Optional[int] = rest_field(
        name="fuzzyEditDistance", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defaults to 0. Maximum value of 5. Denotes the acceptable number of divergent
     characters that would still constitute a match with the entity name. The
     smallest possible fuzziness for any given match is returned. For instance, if
     the edit distance is set to 3, \"Windows10\" would still match \"Windows\",
     \"Windows10\" and \"Windows 7\". When case sensitivity is set to false, case
     differences do NOT count towards fuzziness tolerance, but otherwise do."""
    default_case_sensitive: Optional[bool] = rest_field(
        name="defaultCaseSensitive", visibility=["read", "create", "update", "delete", "query"]
    )
    """Changes the default case sensitivity value for this entity. It be used to
     change the default value of all aliases caseSensitive values."""
    default_accent_sensitive: Optional[bool] = rest_field(
        name="defaultAccentSensitive", visibility=["read", "create", "update", "delete", "query"]
    )
    """Changes the default accent sensitivity value for this entity. It be used to
     change the default value of all aliases accentSensitive values."""
    default_fuzzy_edit_distance: Optional[int] = rest_field(
        name="defaultFuzzyEditDistance", visibility=["read", "create", "update", "delete", "query"]
    )
    """Changes the default fuzzy edit distance value for this entity. It can be used
     to change the default value of all aliases fuzzyEditDistance values."""
    aliases: Optional[List["_models.CustomEntityAlias"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """An array of complex objects that can be used to specify alternative spellings
     or synonyms to the root entity name."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        description: Optional[str] = None,
        type: Optional[str] = None,
        subtype: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        case_sensitive: Optional[bool] = None,
        accent_sensitive: Optional[bool] = None,
        fuzzy_edit_distance: Optional[int] = None,
        default_case_sensitive: Optional[bool] = None,
        default_accent_sensitive: Optional[bool] = None,
        default_fuzzy_edit_distance: Optional[int] = None,
        aliases: Optional[List["_models.CustomEntityAlias"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CustomEntityAlias(_model_base.Model):
    """A complex object that can be used to specify alternative spellings or synonyms
    to the root entity name.


    :ivar text: The text of the alias. Required.
    :vartype text: str
    :ivar case_sensitive: Determine if the alias is case sensitive.
    :vartype case_sensitive: bool
    :ivar accent_sensitive: Determine if the alias is accent sensitive.
    :vartype accent_sensitive: bool
    :ivar fuzzy_edit_distance: Determine the fuzzy edit distance of the alias.
    :vartype fuzzy_edit_distance: int
    """

    text: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The text of the alias. Required."""
    case_sensitive: Optional[bool] = rest_field(
        name="caseSensitive", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determine if the alias is case sensitive."""
    accent_sensitive: Optional[bool] = rest_field(
        name="accentSensitive", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determine if the alias is accent sensitive."""
    fuzzy_edit_distance: Optional[int] = rest_field(
        name="fuzzyEditDistance", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determine the fuzzy edit distance of the alias."""

    @overload
    def __init__(
        self,
        *,
        text: str,
        case_sensitive: Optional[bool] = None,
        accent_sensitive: Optional[bool] = None,
        fuzzy_edit_distance: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CustomEntityLookupSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.CustomEntityLookupSkill"):
    """A skill looks for text from a custom, user-defined list of words and phrases.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar default_language_code: A value indicating which language code to use. Default is ``en``.
     Known values are: "da", "de", "en", "es", "fi", "fr", "it", "ko", and "pt".
    :vartype default_language_code: str or
     ~azure.search.documents.models.CustomEntityLookupSkillLanguage
    :ivar entities_definition_uri: Path to a JSON or CSV file containing all the target text to
     match against.
     This entity definition is read at the beginning of an indexer run. Any updates
     to this file during an indexer run will not take effect until subsequent runs.
     This config must be accessible over HTTPS.
    :vartype entities_definition_uri: str
    :ivar inline_entities_definition: The inline CustomEntity definition.
    :vartype inline_entities_definition: list[~azure.search.documents.models.CustomEntity]
    :ivar global_default_case_sensitive: A global flag for CaseSensitive. If CaseSensitive is not
     set in CustomEntity,
     this value will be the default value.
    :vartype global_default_case_sensitive: bool
    :ivar global_default_accent_sensitive: A global flag for AccentSensitive. If AccentSensitive is
     not set in
     CustomEntity, this value will be the default value.
    :vartype global_default_accent_sensitive: bool
    :ivar global_default_fuzzy_edit_distance: A global flag for FuzzyEditDistance. If
     FuzzyEditDistance is not set in
     CustomEntity, this value will be the default value.
    :vartype global_default_fuzzy_edit_distance: int
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.CustomEntityLookupSkill".
    :vartype odata_type: str
    """

    default_language_code: Optional[Union[str, "_models.CustomEntityLookupSkillLanguage"]] = rest_field(
        name="defaultLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which language code to use. Default is ``en``. Known values are: \"da\",
     \"de\", \"en\", \"es\", \"fi\", \"fr\", \"it\", \"ko\", and \"pt\"."""
    entities_definition_uri: Optional[str] = rest_field(
        name="entitiesDefinitionUri", visibility=["read", "create", "update", "delete", "query"]
    )
    """Path to a JSON or CSV file containing all the target text to match against.
     This entity definition is read at the beginning of an indexer run. Any updates
     to this file during an indexer run will not take effect until subsequent runs.
     This config must be accessible over HTTPS."""
    inline_entities_definition: Optional[List["_models.CustomEntity"]] = rest_field(
        name="inlineEntitiesDefinition", visibility=["read", "create", "update", "delete", "query"]
    )
    """The inline CustomEntity definition."""
    global_default_case_sensitive: Optional[bool] = rest_field(
        name="globalDefaultCaseSensitive", visibility=["read", "create", "update", "delete", "query"]
    )
    """A global flag for CaseSensitive. If CaseSensitive is not set in CustomEntity,
     this value will be the default value."""
    global_default_accent_sensitive: Optional[bool] = rest_field(
        name="globalDefaultAccentSensitive", visibility=["read", "create", "update", "delete", "query"]
    )
    """A global flag for AccentSensitive. If AccentSensitive is not set in
     CustomEntity, this value will be the default value."""
    global_default_fuzzy_edit_distance: Optional[int] = rest_field(
        name="globalDefaultFuzzyEditDistance", visibility=["read", "create", "update", "delete", "query"]
    )
    """A global flag for FuzzyEditDistance. If FuzzyEditDistance is not set in
     CustomEntity, this value will be the default value."""
    odata_type: Literal["#Microsoft.Skills.Text.CustomEntityLookupSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.CustomEntityLookupSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        default_language_code: Optional[Union[str, "_models.CustomEntityLookupSkillLanguage"]] = None,
        entities_definition_uri: Optional[str] = None,
        inline_entities_definition: Optional[List["_models.CustomEntity"]] = None,
        global_default_case_sensitive: Optional[bool] = None,
        global_default_accent_sensitive: Optional[bool] = None,
        global_default_fuzzy_edit_distance: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.CustomEntityLookupSkill", **kwargs)


class LexicalNormalizer(_model_base.Model):
    """Base type for normalizers.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CustomNormalizer


    :ivar odata_type: The discriminator for derived types. Required. Default value is None.
    :vartype odata_type: str
    :ivar name: The name of the char filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    odata_type: str = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])
    """The discriminator for derived types. Required. Default value is None."""
    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the char filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required."""

    @overload
    def __init__(
        self,
        *,
        odata_type: str,
        name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CustomNormalizer(LexicalNormalizer, discriminator="#Microsoft.Azure.Search.CustomNormalizer"):
    """Allows you to configure normalization for filterable, sortable, and facetable
    fields, which by default operate with strict matching. This is a user-defined
    configuration consisting of at least one or more filters, which modify the
    token that is stored.


    :ivar name: The name of the char filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar token_filters: A list of token filters used to filter out or modify the input token. For
     example, you can specify a lowercase filter that converts all characters to
     lowercase. The filters are run in the order in which they are listed.
    :vartype token_filters: list[str or ~azure.search.documents.models.TokenFilterName]
    :ivar char_filters: A list of character filters used to prepare input text before it is
     processed.
     For instance, they can replace certain characters or symbols. The filters are
     run in the order in which they are listed.
    :vartype char_filters: list[str or ~azure.search.documents.models.CharFilterName]
    :ivar odata_type: A URI fragment specifying the type of normalizer. Required. Default value is
     "#Microsoft.Azure.Search.CustomNormalizer".
    :vartype odata_type: str
    """

    token_filters: Optional[List[Union[str, "_models.TokenFilterName"]]] = rest_field(
        name="tokenFilters", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of token filters used to filter out or modify the input token. For
     example, you can specify a lowercase filter that converts all characters to
     lowercase. The filters are run in the order in which they are listed."""
    char_filters: Optional[List[Union[str, "_models.CharFilterName"]]] = rest_field(
        name="charFilters", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of character filters used to prepare input text before it is processed.
     For instance, they can replace certain characters or symbols. The filters are
     run in the order in which they are listed."""
    odata_type: Literal["#Microsoft.Azure.Search.CustomNormalizer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of normalizer. Required. Default value is
     \"#Microsoft.Azure.Search.CustomNormalizer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        token_filters: Optional[List[Union[str, "_models.TokenFilterName"]]] = None,
        char_filters: Optional[List[Union[str, "_models.CharFilterName"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.CustomNormalizer", **kwargs)


class DataChangeDetectionPolicy(_model_base.Model):
    """Base type for data change detection policies.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    HighWaterMarkChangeDetectionPolicy, SqlIntegratedChangeTrackingPolicy


    :ivar odata_type: The discriminator for derived types. Required. Default value is None.
    :vartype odata_type: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    odata_type: str = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])
    """The discriminator for derived types. Required. Default value is None."""

    @overload
    def __init__(
        self,
        *,
        odata_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataDeletionDetectionPolicy(_model_base.Model):
    """Base type for data deletion detection policies.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    NativeBlobSoftDeleteDeletionDetectionPolicy, SoftDeleteColumnDeletionDetectionPolicy


    :ivar odata_type: The discriminator for derived types. Required. Default value is None.
    :vartype odata_type: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    odata_type: str = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])
    """The discriminator for derived types. Required. Default value is None."""

    @overload
    def __init__(
        self,
        *,
        odata_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataSourceCredentials(_model_base.Model):
    """Represents credentials that can be used to connect to a datasource.

    :ivar connection_string: The connection string for the datasource. Set to ``<unchanged>`` (with
     brackets)
     if you don't want the connection string updated. Set to ``<redacted>`` if you
     want to remove the connection string value from the datasource.
    :vartype connection_string: str
    """

    connection_string: Optional[str] = rest_field(
        name="connectionString", visibility=["read", "create", "update", "delete", "query"]
    )
    """The connection string for the datasource. Set to ``<unchanged>`` (with brackets)
     if you don't want the connection string updated. Set to ``<redacted>`` if you
     want to remove the connection string value from the datasource."""

    @overload
    def __init__(
        self,
        *,
        connection_string: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DebugInfo(_model_base.Model):
    """Contains debugging information that can be used to further explore your search
    results.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar query_rewrites: Contains debugging information specific to query rewrites.
    :vartype query_rewrites: ~azure.search.documents.models.QueryRewritesDebugInfo
    """

    query_rewrites: Optional["_models.QueryRewritesDebugInfo"] = rest_field(name="queryRewrites", visibility=["read"])
    """Contains debugging information specific to query rewrites."""


class DefaultCognitiveServicesAccount(
    CognitiveServicesAccount, discriminator="#Microsoft.Azure.Search.DefaultCognitiveServices"
):
    """An empty object that represents the default Azure AI service resource for a
    skillset.


    :ivar description: Description of the Azure AI service resource attached to a skillset.
    :vartype description: str
    :ivar odata_type: A URI fragment specifying the type of Azure AI service resource attached to a
     skillset. Required. Default value is "#Microsoft.Azure.Search.DefaultCognitiveServices".
    :vartype odata_type: str
    """

    odata_type: Literal["#Microsoft.Azure.Search.DefaultCognitiveServices"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of Azure AI service resource attached to a
     skillset. Required. Default value is \"#Microsoft.Azure.Search.DefaultCognitiveServices\"."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.DefaultCognitiveServices", **kwargs)


class DictionaryDecompounderTokenFilter(
    TokenFilter, discriminator="#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter"
):
    """Decomposes compound words found in many Germanic languages. This token filter
    is implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar word_list: The list of words to match against. Required.
    :vartype word_list: list[str]
    :ivar min_word_size: The minimum word size. Only words longer than this get processed. Default
     is 5.
     Maximum is 300.
    :vartype min_word_size: int
    :ivar min_subword_size: The minimum subword size. Only subwords longer than this are outputted.
     Default
     is 2. Maximum is 300.
    :vartype min_subword_size: int
    :ivar max_subword_size: The maximum subword size. Only subwords shorter than this are
     outputted.
     Default is 15. Maximum is 300.
    :vartype max_subword_size: int
    :ivar only_longest_match: A value indicating whether to add only the longest matching subword
     to the
     output. Default is false.
    :vartype only_longest_match: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter".
    :vartype odata_type: str
    """

    word_list: List[str] = rest_field(name="wordList", visibility=["read", "create", "update", "delete", "query"])
    """The list of words to match against. Required."""
    min_word_size: Optional[int] = rest_field(
        name="minWordSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The minimum word size. Only words longer than this get processed. Default is 5.
     Maximum is 300."""
    min_subword_size: Optional[int] = rest_field(
        name="minSubwordSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The minimum subword size. Only subwords longer than this are outputted. Default
     is 2. Maximum is 300."""
    max_subword_size: Optional[int] = rest_field(
        name="maxSubwordSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum subword size. Only subwords shorter than this are outputted.
     Default is 15. Maximum is 300."""
    only_longest_match: Optional[bool] = rest_field(
        name="onlyLongestMatch", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to add only the longest matching subword to the
     output. Default is false."""
    odata_type: Literal["#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        word_list: List[str],
        min_word_size: Optional[int] = None,
        min_subword_size: Optional[int] = None,
        max_subword_size: Optional[int] = None,
        only_longest_match: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter", **kwargs)


class ScoringFunction(_model_base.Model):
    """Base type for functions that can modify document scores during ranking.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    DistanceScoringFunction, FreshnessScoringFunction, MagnitudeScoringFunction, TagScoringFunction


    :ivar field_name: The name of the field used as input to the scoring function. Required.
    :vartype field_name: str
    :ivar boost: A multiplier for the raw score. Must be a positive number not equal to 1.0.
     Required.
    :vartype boost: float
    :ivar interpolation: A value indicating how boosting will be interpolated across document
     scores;
     defaults to "Linear". Known values are: "linear", "constant", "quadratic", and "logarithmic".
    :vartype interpolation: str or ~azure.search.documents.models.ScoringFunctionInterpolation
    :ivar type: Type of ScoringFunction. Required. Default value is None.
    :vartype type: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    field_name: str = rest_field(name="fieldName", visibility=["read", "create", "update", "delete", "query"])
    """The name of the field used as input to the scoring function. Required."""
    boost: float = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A multiplier for the raw score. Must be a positive number not equal to 1.0. Required."""
    interpolation: Optional[Union[str, "_models.ScoringFunctionInterpolation"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating how boosting will be interpolated across document scores;
     defaults to \"Linear\". Known values are: \"linear\", \"constant\", \"quadratic\", and
     \"logarithmic\"."""
    type: str = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])
    """Type of ScoringFunction. Required. Default value is None."""

    @overload
    def __init__(
        self,
        *,
        field_name: str,
        boost: float,
        type: str,
        interpolation: Optional[Union[str, "_models.ScoringFunctionInterpolation"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DistanceScoringFunction(ScoringFunction, discriminator="distance"):
    """Defines a function that boosts scores based on distance from a geographic
    location.


    :ivar field_name: The name of the field used as input to the scoring function. Required.
    :vartype field_name: str
    :ivar boost: A multiplier for the raw score. Must be a positive number not equal to 1.0.
     Required.
    :vartype boost: float
    :ivar interpolation: A value indicating how boosting will be interpolated across document
     scores;
     defaults to "Linear". Known values are: "linear", "constant", "quadratic", and "logarithmic".
    :vartype interpolation: str or ~azure.search.documents.models.ScoringFunctionInterpolation
    :ivar parameters: Parameter values for the distance scoring function. Required.
    :vartype parameters: ~azure.search.documents.models.DistanceScoringParameters
    :ivar type: Indicates the type of function to use. Valid values include magnitude,
     freshness, distance, and tag. The function type must be lower case. Required. Default value is
     "distance".
    :vartype type: str
    """

    parameters: "_models.DistanceScoringParameters" = rest_field(
        name="distance", visibility=["read", "create", "update", "delete", "query"]
    )
    """Parameter values for the distance scoring function. Required."""
    type: Literal["distance"] = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Indicates the type of function to use. Valid values include magnitude,
     freshness, distance, and tag. The function type must be lower case. Required. Default value is
     \"distance\"."""

    @overload
    def __init__(
        self,
        *,
        field_name: str,
        boost: float,
        parameters: "_models.DistanceScoringParameters",
        interpolation: Optional[Union[str, "_models.ScoringFunctionInterpolation"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="distance", **kwargs)


class DistanceScoringParameters(_model_base.Model):
    """Provides parameter values to a distance scoring function.


    :ivar reference_point_parameter: The name of the parameter passed in search queries to specify
     the reference
     location. Required.
    :vartype reference_point_parameter: str
    :ivar boosting_distance: The distance in kilometers from the reference location where the
     boosting range
     ends. Required.
    :vartype boosting_distance: float
    """

    reference_point_parameter: str = rest_field(
        name="referencePointParameter", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the parameter passed in search queries to specify the reference
     location. Required."""
    boosting_distance: float = rest_field(
        name="boostingDistance", visibility=["read", "create", "update", "delete", "query"]
    )
    """The distance in kilometers from the reference location where the boosting range
     ends. Required."""

    @overload
    def __init__(
        self,
        *,
        reference_point_parameter: str,
        boosting_distance: float,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DocumentDebugInfo(_model_base.Model):
    """Contains debugging information that can be used to further explore your search
    results.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar semantic: Contains debugging information specific to semantic ranking requests.
    :vartype semantic: ~azure.search.documents.models.SemanticDebugInfo
    :ivar vectors: Contains debugging information specific to vector and hybrid search.
    :vartype vectors: ~azure.search.documents.models.VectorsDebugInfo
    """

    semantic: Optional["_models.SemanticDebugInfo"] = rest_field(visibility=["read"])
    """Contains debugging information specific to semantic ranking requests."""
    vectors: Optional["_models.VectorsDebugInfo"] = rest_field(visibility=["read"])
    """Contains debugging information specific to vector and hybrid search."""


class DocumentExtractionSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Util.DocumentExtractionSkill"):
    """A skill that extracts content from a file within the enrichment pipeline.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar parsing_mode: The parsingMode for the skill. Will be set to 'default' if not defined.
    :vartype parsing_mode: str
    :ivar data_to_extract: The type of data to be extracted for the skill. Will be set to
     'contentAndMetadata' if not defined.
    :vartype data_to_extract: str
    :ivar configuration: A dictionary of configurations for the skill.
    :vartype configuration: dict[str, any]
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Util.DocumentExtractionSkill".
    :vartype odata_type: str
    """

    parsing_mode: Optional[str] = rest_field(
        name="parsingMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The parsingMode for the skill. Will be set to 'default' if not defined."""
    data_to_extract: Optional[str] = rest_field(
        name="dataToExtract", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of data to be extracted for the skill. Will be set to 'contentAndMetadata' if not
     defined."""
    configuration: Optional[Dict[str, Any]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A dictionary of configurations for the skill."""
    odata_type: Literal["#Microsoft.Skills.Util.DocumentExtractionSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Util.DocumentExtractionSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        parsing_mode: Optional[str] = None,
        data_to_extract: Optional[str] = None,
        configuration: Optional[Dict[str, Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Util.DocumentExtractionSkill", **kwargs)


class DocumentIntelligenceLayoutSkill(
    SearchIndexerSkill, discriminator="#Microsoft.Skills.Util.DocumentIntelligenceLayoutSkill"
):
    """A skill that extracts content and layout information (as markdown), via Azure
    AI Services, from files within the enrichment pipeline.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar output_mode: Controls the cardinality of the output produced by the skill. Default is
     'oneToMany'. "oneToMany"
    :vartype output_mode: str or
     ~azure.search.documents.models.DocumentIntelligenceLayoutSkillOutputMode
    :ivar markdown_header_depth: The depth of headers in the markdown output. Default is h6. Known
     values are: "h1", "h2", "h3", "h4", "h5", and "h6".
    :vartype markdown_header_depth: str or
     ~azure.search.documents.models.DocumentIntelligenceLayoutSkillMarkdownHeaderDepth
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Util.DocumentIntelligenceLayoutSkill".
    :vartype odata_type: str
    """

    output_mode: Optional[Union[str, "_models.DocumentIntelligenceLayoutSkillOutputMode"]] = rest_field(
        name="outputMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Controls the cardinality of the output produced by the skill. Default is 'oneToMany'.
     \"oneToMany\""""
    markdown_header_depth: Optional[Union[str, "_models.DocumentIntelligenceLayoutSkillMarkdownHeaderDepth"]] = (
        rest_field(name="markdownHeaderDepth", visibility=["read", "create", "update", "delete", "query"])
    )
    """The depth of headers in the markdown output. Default is h6. Known values are: \"h1\", \"h2\",
     \"h3\", \"h4\", \"h5\", and \"h6\"."""
    odata_type: Literal["#Microsoft.Skills.Util.DocumentIntelligenceLayoutSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Util.DocumentIntelligenceLayoutSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        output_mode: Optional[Union[str, "_models.DocumentIntelligenceLayoutSkillOutputMode"]] = None,
        markdown_header_depth: Optional[
            Union[str, "_models.DocumentIntelligenceLayoutSkillMarkdownHeaderDepth"]
        ] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Util.DocumentIntelligenceLayoutSkill", **kwargs)


class DocumentKeysOrIds(_model_base.Model):
    """The type of the keysOrIds.

    :ivar document_keys: document keys to be reset.
    :vartype document_keys: list[str]
    :ivar datasource_document_ids: datasource document identifiers to be reset.
    :vartype datasource_document_ids: list[str]
    """

    document_keys: Optional[List[str]] = rest_field(
        name="documentKeys", visibility=["read", "create", "update", "delete", "query"]
    )
    """document keys to be reset."""
    datasource_document_ids: Optional[List[str]] = rest_field(
        name="datasourceDocumentIds", visibility=["read", "create", "update", "delete", "query"]
    )
    """datasource document identifiers to be reset."""

    @overload
    def __init__(
        self,
        *,
        document_keys: Optional[List[str]] = None,
        datasource_document_ids: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EdgeNGramTokenFilterV2(TokenFilter, discriminator="#Microsoft.Azure.Search.EdgeNGramTokenFilterV2"):
    """Generates n-grams of the given size(s) starting from the front or the back of
    an input token. This token filter is implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar min_gram: The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the
     value of maxGram.
    :vartype min_gram: int
    :ivar max_gram: The maximum n-gram length. Default is 2. Maximum is 300.
    :vartype max_gram: int
    :ivar side: Specifies which side of the input the n-gram should be generated from. Default
     is "front". Known values are: "front" and "back".
    :vartype side: str or ~azure.search.documents.models.EdgeNGramTokenFilterSide
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2".
    :vartype odata_type: str
    """

    min_gram: Optional[int] = rest_field(name="minGram", visibility=["read", "create", "update", "delete", "query"])
    """The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the
     value of maxGram."""
    max_gram: Optional[int] = rest_field(name="maxGram", visibility=["read", "create", "update", "delete", "query"])
    """The maximum n-gram length. Default is 2. Maximum is 300."""
    side: Optional[Union[str, "_models.EdgeNGramTokenFilterSide"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies which side of the input the n-gram should be generated from. Default
     is \"front\". Known values are: \"front\" and \"back\"."""
    odata_type: Literal["#Microsoft.Azure.Search.EdgeNGramTokenFilterV2"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.EdgeNGramTokenFilterV2\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        min_gram: Optional[int] = None,
        max_gram: Optional[int] = None,
        side: Optional[Union[str, "_models.EdgeNGramTokenFilterSide"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.EdgeNGramTokenFilterV2", **kwargs)


class EdgeNGramTokenizer(LexicalTokenizer, discriminator="#Microsoft.Azure.Search.EdgeNGramTokenizer"):
    """Tokenizes the input from an edge into n-grams of the given size(s). This
    tokenizer is implemented using Apache Lucene.


    :ivar name: The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar min_gram: The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the
     value of maxGram.
    :vartype min_gram: int
    :ivar max_gram: The maximum n-gram length. Default is 2. Maximum is 300.
    :vartype max_gram: int
    :ivar token_chars: Character classes to keep in the tokens.
    :vartype token_chars: list[str or ~azure.search.documents.models.TokenCharacterKind]
    :ivar odata_type: A URI fragment specifying the type of tokenizer. Required. Default value is
     "#Microsoft.Azure.Search.EdgeNGramTokenizer".
    :vartype odata_type: str
    """

    min_gram: Optional[int] = rest_field(name="minGram", visibility=["read", "create", "update", "delete", "query"])
    """The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the
     value of maxGram."""
    max_gram: Optional[int] = rest_field(name="maxGram", visibility=["read", "create", "update", "delete", "query"])
    """The maximum n-gram length. Default is 2. Maximum is 300."""
    token_chars: Optional[List[Union[str, "_models.TokenCharacterKind"]]] = rest_field(
        name="tokenChars", visibility=["read", "create", "update", "delete", "query"]
    )
    """Character classes to keep in the tokens."""
    odata_type: Literal["#Microsoft.Azure.Search.EdgeNGramTokenizer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of tokenizer. Required. Default value is
     \"#Microsoft.Azure.Search.EdgeNGramTokenizer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        min_gram: Optional[int] = None,
        max_gram: Optional[int] = None,
        token_chars: Optional[List[Union[str, "_models.TokenCharacterKind"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.EdgeNGramTokenizer", **kwargs)


class ElisionTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.ElisionTokenFilter"):
    """Removes elisions. For example, "l'avion" (the plane) will be converted to
    "avion" (plane). This token filter is implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar articles: The set of articles to remove.
    :vartype articles: list[str]
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.ElisionTokenFilter".
    :vartype odata_type: str
    """

    articles: Optional[List[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The set of articles to remove."""
    odata_type: Literal["#Microsoft.Azure.Search.ElisionTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.ElisionTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        articles: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.ElisionTokenFilter", **kwargs)


class EntityLinkingSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.V3.EntityLinkingSkill"):
    """Using the Text Analytics API, extracts linked entities from text.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar default_language_code: A value indicating which language code to use. Default is ``en``.
    :vartype default_language_code: str
    :ivar minimum_precision: A value between 0 and 1 that be used to only include entities whose
     confidence
     score is greater than the value specified. If not set (default), or if
     explicitly set to null, all entities will be included.
    :vartype minimum_precision: float
    :ivar model_version: The version of the model to use when calling the Text Analytics service.
     It
     will default to the latest available when not specified. We recommend you do
     not specify this value unless absolutely necessary.
    :vartype model_version: str
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.V3.EntityLinkingSkill".
    :vartype odata_type: str
    """

    default_language_code: Optional[str] = rest_field(
        name="defaultLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which language code to use. Default is ``en``."""
    minimum_precision: Optional[float] = rest_field(
        name="minimumPrecision", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value between 0 and 1 that be used to only include entities whose confidence
     score is greater than the value specified. If not set (default), or if
     explicitly set to null, all entities will be included."""
    model_version: Optional[str] = rest_field(
        name="modelVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The version of the model to use when calling the Text Analytics service. It
     will default to the latest available when not specified. We recommend you do
     not specify this value unless absolutely necessary."""
    odata_type: Literal["#Microsoft.Skills.Text.V3.EntityLinkingSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.V3.EntityLinkingSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        default_language_code: Optional[str] = None,
        minimum_precision: Optional[float] = None,
        model_version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.V3.EntityLinkingSkill", **kwargs)


class EntityRecognitionSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.EntityRecognitionSkill"):
    """This skill is deprecated. Use the V3.EntityRecognitionSkill instead.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar categories: A list of entity categories that should be extracted.
    :vartype categories: list[str or ~azure.search.documents.models.EntityCategory]
    :ivar default_language_code: A value indicating which language code to use. Default is ``en``.
     Known values are: "ar", "cs", "zh-Hans", "zh-Hant", "da", "nl", "en", "fi", "fr", "de", "el",
     "hu", "it", "ja", "ko", "no", "pl", "pt-PT", "pt-BR", "ru", "es", "sv", and "tr".
    :vartype default_language_code: str or
     ~azure.search.documents.models.EntityRecognitionSkillLanguage
    :ivar include_typeless_entities: Determines whether or not to include entities which are well
     known but don't
     conform to a pre-defined type. If this configuration is not set (default), set
     to null or set to false, entities which don't conform to one of the pre-defined
     types will not be surfaced.
    :vartype include_typeless_entities: bool
    :ivar minimum_precision: A value between 0 and 1 that be used to only include entities whose
     confidence
     score is greater than the value specified. If not set (default), or if
     explicitly set to null, all entities will be included.
    :vartype minimum_precision: float
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.EntityRecognitionSkill".
    :vartype odata_type: str
    """

    categories: Optional[List[Union[str, "_models.EntityCategory"]]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of entity categories that should be extracted."""
    default_language_code: Optional[Union[str, "_models.EntityRecognitionSkillLanguage"]] = rest_field(
        name="defaultLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which language code to use. Default is ``en``. Known values are: \"ar\",
     \"cs\", \"zh-Hans\", \"zh-Hant\", \"da\", \"nl\", \"en\", \"fi\", \"fr\", \"de\", \"el\",
     \"hu\", \"it\", \"ja\", \"ko\", \"no\", \"pl\", \"pt-PT\", \"pt-BR\", \"ru\", \"es\", \"sv\",
     and \"tr\"."""
    include_typeless_entities: Optional[bool] = rest_field(
        name="includeTypelessEntities", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines whether or not to include entities which are well known but don't
     conform to a pre-defined type. If this configuration is not set (default), set
     to null or set to false, entities which don't conform to one of the pre-defined
     types will not be surfaced."""
    minimum_precision: Optional[float] = rest_field(
        name="minimumPrecision", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value between 0 and 1 that be used to only include entities whose confidence
     score is greater than the value specified. If not set (default), or if
     explicitly set to null, all entities will be included."""
    odata_type: Literal["#Microsoft.Skills.Text.EntityRecognitionSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.EntityRecognitionSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        categories: Optional[List[Union[str, "_models.EntityCategory"]]] = None,
        default_language_code: Optional[Union[str, "_models.EntityRecognitionSkillLanguage"]] = None,
        include_typeless_entities: Optional[bool] = None,
        minimum_precision: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.EntityRecognitionSkill", **kwargs)


class EntityRecognitionSkillV3(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.V3.EntityRecognitionSkill"):
    """Using the Text Analytics API, extracts entities of different types from text.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar categories: A list of entity categories that should be extracted.
    :vartype categories: list[str]
    :ivar default_language_code: A value indicating which language code to use. Default is ``en``.
    :vartype default_language_code: str
    :ivar minimum_precision: A value between 0 and 1 that be used to only include entities whose
     confidence
     score is greater than the value specified. If not set (default), or if
     explicitly set to null, all entities will be included.
    :vartype minimum_precision: float
    :ivar model_version: The version of the model to use when calling the Text Analytics API. It
     will
     default to the latest available when not specified. We recommend you do not
     specify this value unless absolutely necessary.
    :vartype model_version: str
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.V3.EntityRecognitionSkill".
    :vartype odata_type: str
    """

    categories: Optional[List[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A list of entity categories that should be extracted."""
    default_language_code: Optional[str] = rest_field(
        name="defaultLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which language code to use. Default is ``en``."""
    minimum_precision: Optional[float] = rest_field(
        name="minimumPrecision", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value between 0 and 1 that be used to only include entities whose confidence
     score is greater than the value specified. If not set (default), or if
     explicitly set to null, all entities will be included."""
    model_version: Optional[str] = rest_field(
        name="modelVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The version of the model to use when calling the Text Analytics API. It will
     default to the latest available when not specified. We recommend you do not
     specify this value unless absolutely necessary."""
    odata_type: Literal["#Microsoft.Skills.Text.V3.EntityRecognitionSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.V3.EntityRecognitionSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        categories: Optional[List[str]] = None,
        default_language_code: Optional[str] = None,
        minimum_precision: Optional[float] = None,
        model_version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.V3.EntityRecognitionSkill", **kwargs)


class ErrorAdditionalInfo(_model_base.Model):
    """The resource management error additional info.

    :ivar type: The additional info type.
    :vartype type: str
    :ivar info: The additional info.
    :vartype info: dict[str, str]
    """

    type: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The additional info type."""
    info: Optional[Dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The additional info."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[str] = None,
        info: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ErrorDetail(_model_base.Model):
    """The error detail.

    :ivar code: The error code.
    :vartype code: str
    :ivar message: The error message.
    :vartype message: str
    :ivar target: The error target.
    :vartype target: str
    :ivar details: The error details.
    :vartype details: list[~azure.search.documents.models.ErrorDetail]
    :ivar additional_info: The error additional info.
    :vartype additional_info: list[~azure.search.documents.models.ErrorAdditionalInfo]
    """

    code: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The error code."""
    message: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The error message."""
    target: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The error target."""
    details: Optional[List["_models.ErrorDetail"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The error details."""
    additional_info: Optional[List["_models.ErrorAdditionalInfo"]] = rest_field(
        name="additionalInfo", visibility=["read", "create", "update", "delete", "query"]
    )
    """The error additional info."""

    @overload
    def __init__(
        self,
        *,
        code: Optional[str] = None,
        message: Optional[str] = None,
        target: Optional[str] = None,
        details: Optional[List["_models.ErrorDetail"]] = None,
        additional_info: Optional[List["_models.ErrorAdditionalInfo"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ErrorResponse(_model_base.Model):
    """Common error response for all Azure Resource Manager APIs to return error
    details for failed operations. (This also follows the OData error response
    format.).

    :ivar error: The error object.
    :vartype error: ~azure.search.documents.models.ErrorDetail
    """

    error: Optional["_models.ErrorDetail"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The error object."""

    @overload
    def __init__(
        self,
        *,
        error: Optional["_models.ErrorDetail"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorSearchAlgorithmConfiguration(_model_base.Model):
    """Contains configuration options specific to the algorithm used during indexing
    or querying.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    ExhaustiveKnnAlgorithmConfiguration, HnswAlgorithmConfiguration


    :ivar name: The name to associate with this particular configuration. Required.
    :vartype name: str
    :ivar kind: Type of VectorSearchAlgorithmConfiguration. Required. Known values are: "hnsw" and
     "exhaustiveKnn".
    :vartype kind: str or ~azure.search.documents.models.VectorSearchAlgorithmKind
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name to associate with this particular configuration. Required."""
    kind: str = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])
    """Type of VectorSearchAlgorithmConfiguration. Required. Known values are: \"hnsw\" and
     \"exhaustiveKnn\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        kind: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExhaustiveKnnAlgorithmConfiguration(VectorSearchAlgorithmConfiguration, discriminator="exhaustiveKnn"):
    """Contains configuration options specific to the exhaustive KNN algorithm used
    during querying, which will perform brute-force search across the entire vector
    index.


    :ivar name: The name to associate with this particular configuration. Required.
    :vartype name: str
    :ivar parameters: Contains the parameters specific to exhaustive KNN algorithm.
    :vartype parameters: ~azure.search.documents.models.ExhaustiveKnnParameters
    :ivar kind: The name of the kind of algorithm being configured for use with vector search.
     Required. Exhaustive KNN algorithm which will perform brute-force search.
    :vartype kind: str or ~azure.search.documents.models.EXHAUSTIVE_KNN
    """

    parameters: Optional["_models.ExhaustiveKnnParameters"] = rest_field(
        name="exhaustiveKnnParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains the parameters specific to exhaustive KNN algorithm."""
    kind: Literal[VectorSearchAlgorithmKind.EXHAUSTIVE_KNN] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The name of the kind of algorithm being configured for use with vector search. Required.
     Exhaustive KNN algorithm which will perform brute-force search."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        parameters: Optional["_models.ExhaustiveKnnParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorSearchAlgorithmKind.EXHAUSTIVE_KNN, **kwargs)


class ExhaustiveKnnParameters(_model_base.Model):
    """Contains the parameters specific to exhaustive KNN algorithm.

    :ivar metric: The similarity metric to use for vector comparisons. Known values are: "cosine",
     "euclidean", "dotProduct", and "hamming".
    :vartype metric: str or ~azure.search.documents.models.VectorSearchAlgorithmMetric
    """

    metric: Optional[Union[str, "_models.VectorSearchAlgorithmMetric"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The similarity metric to use for vector comparisons. Known values are: \"cosine\",
     \"euclidean\", \"dotProduct\", and \"hamming\"."""

    @overload
    def __init__(
        self,
        *,
        metric: Optional[Union[str, "_models.VectorSearchAlgorithmMetric"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FacetResult(_model_base.Model):
    """A single bucket of a facet query result. Reports the number of documents with a
    field value falling within a particular range or having a particular value or
    interval.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar count: The approximate count of documents falling within the bucket described by this
     facet.
    :vartype count: int
    :ivar facets: The nested facet query results for the search operation, organized as a
     collection of buckets for each faceted field; null if the query did not contain
     any nested facets.
    :vartype facets: dict[str, list[~azure.search.documents.models.FacetResult]]
    """

    count: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The approximate count of documents falling within the bucket described by this
     facet."""
    facets: Optional[Dict[str, List["_models.FacetResult"]]] = rest_field(name="@search.facets", visibility=["read"])
    """The nested facet query results for the search operation, organized as a
     collection of buckets for each faceted field; null if the query did not contain
     any nested facets."""

    @overload
    def __init__(
        self,
        *,
        count: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldMapping(_model_base.Model):
    """Defines a mapping between a field in a data source and a target field in an
    index.


    :ivar source_field_name: The name of the field in the data source. Required.
    :vartype source_field_name: str
    :ivar target_field_name: The name of the target field in the index. Same as the source field
     name by
     default.
    :vartype target_field_name: str
    :ivar mapping_function: A function to apply to each source field value before indexing.
    :vartype mapping_function: ~azure.search.documents.models.FieldMappingFunction
    """

    source_field_name: str = rest_field(
        name="sourceFieldName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the field in the data source. Required."""
    target_field_name: Optional[str] = rest_field(
        name="targetFieldName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the target field in the index. Same as the source field name by
     default."""
    mapping_function: Optional["_models.FieldMappingFunction"] = rest_field(
        name="mappingFunction", visibility=["read", "create", "update", "delete", "query"]
    )
    """A function to apply to each source field value before indexing."""

    @overload
    def __init__(
        self,
        *,
        source_field_name: str,
        target_field_name: Optional[str] = None,
        mapping_function: Optional["_models.FieldMappingFunction"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldMappingFunction(_model_base.Model):
    """Represents a function that transforms a value from a data source before
    indexing.


    :ivar name: The name of the field mapping function. Required.
    :vartype name: str
    :ivar parameters: A dictionary of parameter name/value pairs to pass to the function. Each
     value
     must be of a primitive type.
    :vartype parameters: dict[str, any]
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the field mapping function. Required."""
    parameters: Optional[Dict[str, Any]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A dictionary of parameter name/value pairs to pass to the function. Each value
     must be of a primitive type."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        parameters: Optional[Dict[str, Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FreshnessScoringFunction(ScoringFunction, discriminator="freshness"):
    """Defines a function that boosts scores based on the value of a date-time field.


    :ivar field_name: The name of the field used as input to the scoring function. Required.
    :vartype field_name: str
    :ivar boost: A multiplier for the raw score. Must be a positive number not equal to 1.0.
     Required.
    :vartype boost: float
    :ivar interpolation: A value indicating how boosting will be interpolated across document
     scores;
     defaults to "Linear". Known values are: "linear", "constant", "quadratic", and "logarithmic".
    :vartype interpolation: str or ~azure.search.documents.models.ScoringFunctionInterpolation
    :ivar parameters: Parameter values for the freshness scoring function. Required.
    :vartype parameters: ~azure.search.documents.models.FreshnessScoringParameters
    :ivar type: Indicates the type of function to use. Valid values include magnitude,
     freshness, distance, and tag. The function type must be lower case. Required. Default value is
     "freshness".
    :vartype type: str
    """

    parameters: "_models.FreshnessScoringParameters" = rest_field(
        name="freshness", visibility=["read", "create", "update", "delete", "query"]
    )
    """Parameter values for the freshness scoring function. Required."""
    type: Literal["freshness"] = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Indicates the type of function to use. Valid values include magnitude,
     freshness, distance, and tag. The function type must be lower case. Required. Default value is
     \"freshness\"."""

    @overload
    def __init__(
        self,
        *,
        field_name: str,
        boost: float,
        parameters: "_models.FreshnessScoringParameters",
        interpolation: Optional[Union[str, "_models.ScoringFunctionInterpolation"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="freshness", **kwargs)


class FreshnessScoringParameters(_model_base.Model):
    """Provides parameter values to a freshness scoring function.


    :ivar boosting_duration: The expiration period after which boosting will stop for a particular
     document. Required.
    :vartype boosting_duration: ~datetime.timedelta
    """

    boosting_duration: datetime.timedelta = rest_field(
        name="boostingDuration", visibility=["read", "create", "update", "delete", "query"]
    )
    """The expiration period after which boosting will stop for a particular document. Required."""

    @overload
    def __init__(
        self,
        *,
        boosting_duration: datetime.timedelta,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GetIndexStatisticsResult(_model_base.Model):
    """Statistics for a given index. Statistics are collected periodically and are not
    guaranteed to always be up-to-date.


    :ivar document_count: The number of documents in the index. Required.
    :vartype document_count: int
    :ivar storage_size: The amount of storage in bytes consumed by the index. Required.
    :vartype storage_size: int
    :ivar vector_index_size: The amount of memory in bytes consumed by vectors in the index.
     Required.
    :vartype vector_index_size: int
    """

    document_count: int = rest_field(name="documentCount", visibility=["read", "create", "update", "delete", "query"])
    """The number of documents in the index. Required."""
    storage_size: int = rest_field(name="storageSize", visibility=["read", "create", "update", "delete", "query"])
    """The amount of storage in bytes consumed by the index. Required."""
    vector_index_size: int = rest_field(
        name="vectorIndexSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The amount of memory in bytes consumed by vectors in the index. Required."""

    @overload
    def __init__(
        self,
        *,
        document_count: int,
        storage_size: int,
        vector_index_size: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class HighWaterMarkChangeDetectionPolicy(
    DataChangeDetectionPolicy, discriminator="#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
):
    """Defines a data change detection policy that captures changes based on the value
    of a high water mark column.


    :ivar high_water_mark_column_name: The name of the high water mark column. Required.
    :vartype high_water_mark_column_name: str
    :ivar odata_type: A URI fragment specifying the type of data change detection policy. Required.
     Default value is "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy".
    :vartype odata_type: str
    """

    high_water_mark_column_name: str = rest_field(
        name="highWaterMarkColumnName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the high water mark column. Required."""
    odata_type: Literal["#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of data change detection policy. Required. Default value is
     \"#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy\"."""

    @overload
    def __init__(
        self,
        *,
        high_water_mark_column_name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy", **kwargs)


class HnswAlgorithmConfiguration(VectorSearchAlgorithmConfiguration, discriminator="hnsw"):
    """Contains configuration options specific to the HNSW approximate nearest
    neighbors algorithm used during indexing and querying. The HNSW algorithm
    offers a tunable trade-off between search speed and accuracy.


    :ivar name: The name to associate with this particular configuration. Required.
    :vartype name: str
    :ivar parameters: Contains the parameters specific to HNSW algorithm.
    :vartype parameters: ~azure.search.documents.models.HnswParameters
    :ivar kind: The name of the kind of algorithm being configured for use with vector search.
     Required. HNSW (Hierarchical Navigable Small World), a type of approximate nearest
     neighbors algorithm.
    :vartype kind: str or ~azure.search.documents.models.HNSW
    """

    parameters: Optional["_models.HnswParameters"] = rest_field(
        name="hnswParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains the parameters specific to HNSW algorithm."""
    kind: Literal[VectorSearchAlgorithmKind.HNSW] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The name of the kind of algorithm being configured for use with vector search. Required. HNSW
     (Hierarchical Navigable Small World), a type of approximate nearest
     neighbors algorithm."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        parameters: Optional["_models.HnswParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorSearchAlgorithmKind.HNSW, **kwargs)


class HnswParameters(_model_base.Model):
    """Contains the parameters specific to the HNSW algorithm.

    :ivar m: The number of bi-directional links created for every new element during
     construction. Increasing this parameter value may improve recall and reduce
     retrieval times for datasets with high intrinsic dimensionality at the expense
     of increased memory consumption and longer indexing time.
    :vartype m: int
    :ivar ef_construction: The size of the dynamic list containing the nearest neighbors, which is
     used
     during index time. Increasing this parameter may improve index quality, at the
     expense of increased indexing time. At a certain point, increasing this
     parameter leads to diminishing returns.
    :vartype ef_construction: int
    :ivar ef_search: The size of the dynamic list containing the nearest neighbors, which is used
     during search time. Increasing this parameter may improve search results, at
     the expense of slower search. At a certain point, increasing this parameter
     leads to diminishing returns.
    :vartype ef_search: int
    :ivar metric: The similarity metric to use for vector comparisons. Known values are: "cosine",
     "euclidean", "dotProduct", and "hamming".
    :vartype metric: str or ~azure.search.documents.models.VectorSearchAlgorithmMetric
    """

    m: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The number of bi-directional links created for every new element during
     construction. Increasing this parameter value may improve recall and reduce
     retrieval times for datasets with high intrinsic dimensionality at the expense
     of increased memory consumption and longer indexing time."""
    ef_construction: Optional[int] = rest_field(
        name="efConstruction", visibility=["read", "create", "update", "delete", "query"]
    )
    """The size of the dynamic list containing the nearest neighbors, which is used
     during index time. Increasing this parameter may improve index quality, at the
     expense of increased indexing time. At a certain point, increasing this
     parameter leads to diminishing returns."""
    ef_search: Optional[int] = rest_field(name="efSearch", visibility=["read", "create", "update", "delete", "query"])
    """The size of the dynamic list containing the nearest neighbors, which is used
     during search time. Increasing this parameter may improve search results, at
     the expense of slower search. At a certain point, increasing this parameter
     leads to diminishing returns."""
    metric: Optional[Union[str, "_models.VectorSearchAlgorithmMetric"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The similarity metric to use for vector comparisons. Known values are: \"cosine\",
     \"euclidean\", \"dotProduct\", and \"hamming\"."""

    @overload
    def __init__(
        self,
        *,
        m: Optional[int] = None,
        ef_construction: Optional[int] = None,
        ef_search: Optional[int] = None,
        metric: Optional[Union[str, "_models.VectorSearchAlgorithmMetric"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class HybridSearch(_model_base.Model):
    """TThe query parameters to configure hybrid search behaviors.

    :ivar max_text_recall_size: Determines the maximum number of documents to be retrieved by the
     text query
     portion of a hybrid search request. Those documents will be combined with the
     documents matching the vector queries to produce a single final list of
     results. Choosing a larger maxTextRecallSize value will allow retrieving and
     paging through more documents (using the top and skip parameters), at the cost
     of higher resource utilization and higher latency. The value needs to be
     between 1 and 10,000. Default is 1000.
    :vartype max_text_recall_size: int
    :ivar count_and_facet_mode: Determines whether the count and facets should includes all
     documents that
     matched the search query, or only the documents that are retrieved within the
     'maxTextRecallSize' window. Known values are: "countRetrievableResults" and "countAllResults".
    :vartype count_and_facet_mode: str or ~azure.search.documents.models.HybridCountAndFacetMode
    """

    max_text_recall_size: Optional[int] = rest_field(
        name="maxTextRecallSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines the maximum number of documents to be retrieved by the text query
     portion of a hybrid search request. Those documents will be combined with the
     documents matching the vector queries to produce a single final list of
     results. Choosing a larger maxTextRecallSize value will allow retrieving and
     paging through more documents (using the top and skip parameters), at the cost
     of higher resource utilization and higher latency. The value needs to be
     between 1 and 10,000. Default is 1000."""
    count_and_facet_mode: Optional[Union[str, "_models.HybridCountAndFacetMode"]] = rest_field(
        name="countAndFacetMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines whether the count and facets should includes all documents that
     matched the search query, or only the documents that are retrieved within the
     'maxTextRecallSize' window. Known values are: \"countRetrievableResults\" and
     \"countAllResults\"."""

    @overload
    def __init__(
        self,
        *,
        max_text_recall_size: Optional[int] = None,
        count_and_facet_mode: Optional[Union[str, "_models.HybridCountAndFacetMode"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageAnalysisSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Vision.ImageAnalysisSkill"):
    """A skill that analyzes image files. It extracts a rich set of visual features
    based on the image content.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar default_language_code: A value indicating which language code to use. Default is ``en``.
     Known values are: "ar", "az", "bg", "bs", "ca", "cs", "cy", "da", "de", "el", "en", "es", "et",
     "eu", "fi", "fr", "ga", "gl", "he", "hi", "hr", "hu", "id", "it", "ja", "kk", "ko", "lt", "lv",
     "mk", "ms", "nb", "nl", "pl", "prs", "pt-BR", "pt", "pt-PT", "ro", "ru", "sk", "sl", "sr-Cyrl",
     "sr-Latn", "sv", "th", "tr", "uk", "vi", "zh", "zh-Hans", and "zh-Hant".
    :vartype default_language_code: str or
     ~azure.search.documents.models.ImageAnalysisSkillLanguage
    :ivar visual_features: A list of visual features.
    :vartype visual_features: list[str or ~azure.search.documents.models.VisualFeature]
    :ivar details: A string indicating which domain-specific details to return.
    :vartype details: list[str or ~azure.search.documents.models.ImageDetail]
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Vision.ImageAnalysisSkill".
    :vartype odata_type: str
    """

    default_language_code: Optional[Union[str, "_models.ImageAnalysisSkillLanguage"]] = rest_field(
        name="defaultLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which language code to use. Default is ``en``. Known values are: \"ar\",
     \"az\", \"bg\", \"bs\", \"ca\", \"cs\", \"cy\", \"da\", \"de\", \"el\", \"en\", \"es\", \"et\",
     \"eu\", \"fi\", \"fr\", \"ga\", \"gl\", \"he\", \"hi\", \"hr\", \"hu\", \"id\", \"it\", \"ja\",
     \"kk\", \"ko\", \"lt\", \"lv\", \"mk\", \"ms\", \"nb\", \"nl\", \"pl\", \"prs\", \"pt-BR\",
     \"pt\", \"pt-PT\", \"ro\", \"ru\", \"sk\", \"sl\", \"sr-Cyrl\", \"sr-Latn\", \"sv\", \"th\",
     \"tr\", \"uk\", \"vi\", \"zh\", \"zh-Hans\", and \"zh-Hant\"."""
    visual_features: Optional[List[Union[str, "_models.VisualFeature"]]] = rest_field(
        name="visualFeatures", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of visual features."""
    details: Optional[List[Union[str, "_models.ImageDetail"]]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A string indicating which domain-specific details to return."""
    odata_type: Literal["#Microsoft.Skills.Vision.ImageAnalysisSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Vision.ImageAnalysisSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        default_language_code: Optional[Union[str, "_models.ImageAnalysisSkillLanguage"]] = None,
        visual_features: Optional[List[Union[str, "_models.VisualFeature"]]] = None,
        details: Optional[List[Union[str, "_models.ImageDetail"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Vision.ImageAnalysisSkill", **kwargs)


class IndexAction(_model_base.Model):
    """Represents an index action that operates on a document.

    :ivar action_type: The operation to perform on a document in an indexing batch. Known values
     are: "upload", "merge", "mergeOrUpload", and "delete".
    :vartype action_type: str or ~azure.search.documents.models.IndexActionType
    """

    action_type: Optional[Union[str, "_models.IndexActionType"]] = rest_field(
        name="@search.action", visibility=["read", "create", "update", "delete", "query"]
    )
    """The operation to perform on a document in an indexing batch. Known values are: \"upload\",
     \"merge\", \"mergeOrUpload\", and \"delete\"."""

    @overload
    def __init__(
        self,
        *,
        action_type: Optional[Union[str, "_models.IndexActionType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndexBatch(_model_base.Model):
    """Contains a batch of document write actions to send to the index.

    All required parameters must be populated in order to send to server.

    :ivar actions: The actions in the batch. Required.
    :vartype actions: list[~azure.search.documents.models.IndexAction]
    """

    actions: List["_models.IndexAction"] = rest_field(
        name="value", visibility=["read", "create", "update", "delete", "query"]
    )
    """The actions in the batch. Required."""

    @overload
    def __init__(
        self,
        *,
        actions: List["_models.IndexAction"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndexDocumentsResult(_model_base.Model):
    """Response containing the status of operations for all documents in the indexing
    request.


    :ivar results: The list of status information for each document in the indexing request.
     Required.
    :vartype results: list[~azure.search.documents.models.IndexingResult]
    """

    results: List["_models.IndexingResult"] = rest_field(
        name="value", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of status information for each document in the indexing request. Required."""

    @overload
    def __init__(
        self,
        *,
        results: List["_models.IndexingResult"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndexerCurrentState(_model_base.Model):
    """Represents all of the state that defines and dictates the indexer's current
    execution.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar mode: The mode the indexer is running in. Known values are: "indexingAllDocs" and
     "indexingResetDocs".
    :vartype mode: str or ~azure.search.documents.models.IndexingMode
    :ivar all_docs_initial_change_tracking_state: Change tracking state used when indexing starts
     on all documents in the
     datasource.
    :vartype all_docs_initial_change_tracking_state: str
    :ivar all_docs_final_change_tracking_state: Change tracking state value when indexing finishes
     on all documents in the
     datasource.
    :vartype all_docs_final_change_tracking_state: str
    :ivar reset_docs_initial_change_tracking_state: Change tracking state used when indexing starts
     on select, reset documents in
     the datasource.
    :vartype reset_docs_initial_change_tracking_state: str
    :ivar reset_docs_final_change_tracking_state: Change tracking state value when indexing
     finishes on select, reset documents
     in the datasource.
    :vartype reset_docs_final_change_tracking_state: str
    :ivar reset_document_keys: The list of document keys that have been reset. The document key is
     the
     document's unique identifier for the data in the search index. The indexer will
     prioritize selectively re-ingesting these keys.
    :vartype reset_document_keys: list[str]
    :ivar reset_datasource_document_ids: The list of datasource document ids that have been reset.
     The datasource
     document id is the unique identifier for the data in the datasource. The
     indexer will prioritize selectively re-ingesting these ids.
    :vartype reset_datasource_document_ids: list[str]
    """

    mode: Optional[Union[str, "_models.IndexingMode"]] = rest_field(visibility=["read"])
    """The mode the indexer is running in. Known values are: \"indexingAllDocs\" and
     \"indexingResetDocs\"."""
    all_docs_initial_change_tracking_state: Optional[str] = rest_field(
        name="allDocsInitialChangeTrackingState", visibility=["read"]
    )
    """Change tracking state used when indexing starts on all documents in the
     datasource."""
    all_docs_final_change_tracking_state: Optional[str] = rest_field(
        name="allDocsFinalChangeTrackingState", visibility=["read"]
    )
    """Change tracking state value when indexing finishes on all documents in the
     datasource."""
    reset_docs_initial_change_tracking_state: Optional[str] = rest_field(
        name="resetDocsInitialChangeTrackingState", visibility=["read"]
    )
    """Change tracking state used when indexing starts on select, reset documents in
     the datasource."""
    reset_docs_final_change_tracking_state: Optional[str] = rest_field(
        name="resetDocsFinalChangeTrackingState", visibility=["read"]
    )
    """Change tracking state value when indexing finishes on select, reset documents
     in the datasource."""
    reset_document_keys: Optional[List[str]] = rest_field(name="resetDocumentKeys", visibility=["read"])
    """The list of document keys that have been reset. The document key is the
     document's unique identifier for the data in the search index. The indexer will
     prioritize selectively re-ingesting these keys."""
    reset_datasource_document_ids: Optional[List[str]] = rest_field(
        name="resetDatasourceDocumentIds", visibility=["read"]
    )
    """The list of datasource document ids that have been reset. The datasource
     document id is the unique identifier for the data in the datasource. The
     indexer will prioritize selectively re-ingesting these ids."""


class IndexerExecutionResult(_model_base.Model):
    """Represents the result of an individual indexer execution.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar status: The outcome of this indexer execution. Required. Known values are:
     "transientFailure", "success", "inProgress", and "reset".
    :vartype status: str or ~azure.search.documents.models.IndexerExecutionStatus
    :ivar status_detail: The outcome of this indexer execution. "resetDocs"
    :vartype status_detail: str or ~azure.search.documents.models.IndexerExecutionStatusDetail
    :ivar current_state: All of the state that defines and dictates the indexer's current
     execution.
    :vartype current_state: ~azure.search.documents.models.IndexerCurrentState
    :ivar error_message: The error message indicating the top-level error, if any.
    :vartype error_message: str
    :ivar start_time: The start time of this indexer execution.
    :vartype start_time: ~datetime.datetime
    :ivar end_time: The end time of this indexer execution, if the execution has already completed.
    :vartype end_time: ~datetime.datetime
    :ivar errors: The item-level indexing errors. Required.
    :vartype errors: list[~azure.search.documents.models.SearchIndexerError]
    :ivar warnings: The item-level indexing warnings. Required.
    :vartype warnings: list[~azure.search.documents.models.SearchIndexerWarning]
    :ivar item_count: The number of items that were processed during this indexer execution. This
     includes both successfully processed items and items where indexing was
     attempted but failed. Required.
    :vartype item_count: int
    :ivar failed_item_count: The number of items that failed to be indexed during this indexer
     execution. Required.
    :vartype failed_item_count: int
    :ivar initial_tracking_state: Change tracking state with which an indexer execution started.
    :vartype initial_tracking_state: str
    :ivar final_tracking_state: Change tracking state with which an indexer execution finished.
    :vartype final_tracking_state: str
    """

    status: Union[str, "_models.IndexerExecutionStatus"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The outcome of this indexer execution. Required. Known values are: \"transientFailure\",
     \"success\", \"inProgress\", and \"reset\"."""
    status_detail: Optional[Union[str, "_models.IndexerExecutionStatusDetail"]] = rest_field(
        name="statusDetail", visibility=["read"]
    )
    """The outcome of this indexer execution. \"resetDocs\""""
    current_state: Optional["_models.IndexerCurrentState"] = rest_field(name="currentState", visibility=["read"])
    """All of the state that defines and dictates the indexer's current execution."""
    error_message: Optional[str] = rest_field(
        name="errorMessage", visibility=["read", "create", "update", "delete", "query"]
    )
    """The error message indicating the top-level error, if any."""
    start_time: Optional[datetime.datetime] = rest_field(
        name="startTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start time of this indexer execution."""
    end_time: Optional[datetime.datetime] = rest_field(
        name="endTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The end time of this indexer execution, if the execution has already completed."""
    errors: List["_models.SearchIndexerError"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The item-level indexing errors. Required."""
    warnings: List["_models.SearchIndexerWarning"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The item-level indexing warnings. Required."""
    item_count: int = rest_field(name="itemsProcessed", visibility=["read", "create", "update", "delete", "query"])
    """The number of items that were processed during this indexer execution. This
     includes both successfully processed items and items where indexing was
     attempted but failed. Required."""
    failed_item_count: int = rest_field(name="itemsFailed", visibility=["read", "create", "update", "delete", "query"])
    """The number of items that failed to be indexed during this indexer execution. Required."""
    initial_tracking_state: Optional[str] = rest_field(
        name="initialTrackingState", visibility=["read", "create", "update", "delete", "query"]
    )
    """Change tracking state with which an indexer execution started."""
    final_tracking_state: Optional[str] = rest_field(
        name="finalTrackingState", visibility=["read", "create", "update", "delete", "query"]
    )
    """Change tracking state with which an indexer execution finished."""

    @overload
    def __init__(
        self,
        *,
        status: Union[str, "_models.IndexerExecutionStatus"],
        errors: List["_models.SearchIndexerError"],
        warnings: List["_models.SearchIndexerWarning"],
        item_count: int,
        failed_item_count: int,
        error_message: Optional[str] = None,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        initial_tracking_state: Optional[str] = None,
        final_tracking_state: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndexingParameters(_model_base.Model):
    """Represents parameters for indexer execution.

    :ivar batch_size: The number of items that are read from the data source and indexed as a
     single
     batch in order to improve performance. The default depends on the data source
     type.
    :vartype batch_size: int
    :ivar max_failed_items: The maximum number of items that can fail indexing for indexer
     execution to
     still be considered successful. -1 means no limit. Default is 0.
    :vartype max_failed_items: int
    :ivar max_failed_items_per_batch: The maximum number of items in a single batch that can fail
     indexing for the
     batch to still be considered successful. -1 means no limit. Default is 0.
    :vartype max_failed_items_per_batch: int
    :ivar configuration: A dictionary of indexer-specific configuration properties. Each name is
     the
     name of a specific property. Each value must be of a primitive type.
    :vartype configuration: ~azure.search.documents.models.IndexingParametersConfiguration
    """

    batch_size: Optional[int] = rest_field(name="batchSize", visibility=["read", "create", "update", "delete", "query"])
    """The number of items that are read from the data source and indexed as a single
     batch in order to improve performance. The default depends on the data source
     type."""
    max_failed_items: Optional[int] = rest_field(
        name="maxFailedItems", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of items that can fail indexing for indexer execution to
     still be considered successful. -1 means no limit. Default is 0."""
    max_failed_items_per_batch: Optional[int] = rest_field(
        name="maxFailedItemsPerBatch", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of items in a single batch that can fail indexing for the
     batch to still be considered successful. -1 means no limit. Default is 0."""
    configuration: Optional["_models.IndexingParametersConfiguration"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A dictionary of indexer-specific configuration properties. Each name is the
     name of a specific property. Each value must be of a primitive type."""

    @overload
    def __init__(
        self,
        *,
        batch_size: Optional[int] = None,
        max_failed_items: Optional[int] = None,
        max_failed_items_per_batch: Optional[int] = None,
        configuration: Optional["_models.IndexingParametersConfiguration"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndexingParametersConfiguration(_model_base.Model):
    """A dictionary of indexer-specific configuration properties. Each name is the
    name of a specific property. Each value must be of a primitive type.

    :ivar parsing_mode: Represents the parsing mode for indexing from an Azure blob data source.
     Known values are: "default", "text", "delimitedText", "json", "jsonArray", "jsonLines", and
     "markdown".
    :vartype parsing_mode: str or ~azure.search.documents.models.BlobIndexerParsingMode
    :ivar excluded_file_name_extensions: Comma-delimited list of filename extensions to ignore when
     processing from
     Azure blob storage.  For example, you could exclude ".png, .mp4" to skip over
     those files during indexing.
    :vartype excluded_file_name_extensions: str
    :ivar indexed_file_name_extensions: Comma-delimited list of filename extensions to select when
     processing from
     Azure blob storage.  For example, you could focus indexing on specific
     application files ".docx, .pptx, .msg" to specifically include those file
     types.
    :vartype indexed_file_name_extensions: str
    :ivar fail_on_unsupported_content_type: For Azure blobs, set to false if you want to continue
     indexing when an
     unsupported content type is encountered, and you don't know all the content
     types (file extensions) in advance.
    :vartype fail_on_unsupported_content_type: bool
    :ivar fail_on_unprocessable_document: For Azure blobs, set to false if you want to continue
     indexing if a document
     fails indexing.
    :vartype fail_on_unprocessable_document: bool
    :ivar index_storage_metadata_only_for_oversized_documents: For Azure blobs, set this property
     to true to still index storage metadata for
     blob content that is too large to process. Oversized blobs are treated as
     errors by default. For limits on blob size, see
     https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
    :vartype index_storage_metadata_only_for_oversized_documents: bool
    :ivar delimited_text_headers: For CSV blobs, specifies a comma-delimited list of column
     headers, useful for
     mapping source fields to destination fields in an index.
    :vartype delimited_text_headers: str
    :ivar delimited_text_delimiter: For CSV blobs, specifies the end-of-line single-character
     delimiter for CSV
     files where each line starts a new document (for example, "|").
    :vartype delimited_text_delimiter: str
    :ivar first_line_contains_headers: For CSV blobs, indicates that the first (non-blank) line of
     each blob contains
     headers.
    :vartype first_line_contains_headers: bool
    :ivar markdown_parsing_submode: Specifies the submode that will determine whether a markdown
     file will be
     parsed into exactly one search document or multiple search documents. Default
     is ``oneToMany``. Known values are: "oneToMany" and "oneToOne".
    :vartype markdown_parsing_submode: str or ~azure.search.documents.models.MarkdownParsingSubmode
    :ivar markdown_header_depth: Specifies the max header depth that will be considered while
     grouping markdown
     content. Default is ``h6``. Known values are: "h1", "h2", "h3", "h4", "h5", and "h6".
    :vartype markdown_header_depth: str or ~azure.search.documents.models.MarkdownHeaderDepth
    :ivar document_root: For JSON arrays, given a structured or semi-structured document, you can
     specify a path to the array using this property.
    :vartype document_root: str
    :ivar data_to_extract: Specifies the data to extract from Azure blob storage and tells the
     indexer
     which data to extract from image content when "imageAction" is set to a value
     other than "none".  This applies to embedded image content in a .PDF or other
     application, or image files such as .jpg and .png, in Azure blobs. Known values are:
     "storageMetadata", "allMetadata", and "contentAndMetadata".
    :vartype data_to_extract: str or ~azure.search.documents.models.BlobIndexerDataToExtract
    :ivar image_action: Determines how to process embedded images and image files in Azure blob
     storage.  Setting the "imageAction" configuration to any value other than
     "none" requires that a skillset also be attached to that indexer. Known values are: "none",
     "generateNormalizedImages", and "generateNormalizedImagePerPage".
    :vartype image_action: str or ~azure.search.documents.models.BlobIndexerImageAction
    :ivar allow_skillset_to_read_file_data: If true, will create a path //document//file_data that
     is an object
     representing the original file data downloaded from your blob data source.
     This allows you to pass the original file data to a custom skill for processing
     within the enrichment pipeline, or to the Document Extraction skill.
    :vartype allow_skillset_to_read_file_data: bool
    :ivar pdf_text_rotation_algorithm: Determines algorithm for text extraction from PDF files in
     Azure blob storage. Known values are: "none" and "detectAngles".
    :vartype pdf_text_rotation_algorithm: str or
     ~azure.search.documents.models.BlobIndexerPDFTextRotationAlgorithm
    :ivar execution_environment: Specifies the environment in which the indexer should execute.
     Known values are: "standard" and "private".
    :vartype execution_environment: str or
     ~azure.search.documents.models.IndexerExecutionEnvironment
    :ivar query_timeout: Increases the timeout beyond the 5-minute default for Azure SQL database
     data
     sources, specified in the format "hh:mm:ss".
    :vartype query_timeout: str
    """

    parsing_mode: Optional[Union[str, "_models.BlobIndexerParsingMode"]] = rest_field(
        name="parsingMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Represents the parsing mode for indexing from an Azure blob data source. Known values are:
     \"default\", \"text\", \"delimitedText\", \"json\", \"jsonArray\", \"jsonLines\", and
     \"markdown\"."""
    excluded_file_name_extensions: Optional[str] = rest_field(
        name="excludedFileNameExtensions", visibility=["read", "create", "update", "delete", "query"]
    )
    """Comma-delimited list of filename extensions to ignore when processing from
     Azure blob storage.  For example, you could exclude \".png, .mp4\" to skip over
     those files during indexing."""
    indexed_file_name_extensions: Optional[str] = rest_field(
        name="indexedFileNameExtensions", visibility=["read", "create", "update", "delete", "query"]
    )
    """Comma-delimited list of filename extensions to select when processing from
     Azure blob storage.  For example, you could focus indexing on specific
     application files \".docx, .pptx, .msg\" to specifically include those file
     types."""
    fail_on_unsupported_content_type: Optional[bool] = rest_field(
        name="failOnUnsupportedContentType", visibility=["read", "create", "update", "delete", "query"]
    )
    """For Azure blobs, set to false if you want to continue indexing when an
     unsupported content type is encountered, and you don't know all the content
     types (file extensions) in advance."""
    fail_on_unprocessable_document: Optional[bool] = rest_field(
        name="failOnUnprocessableDocument", visibility=["read", "create", "update", "delete", "query"]
    )
    """For Azure blobs, set to false if you want to continue indexing if a document
     fails indexing."""
    index_storage_metadata_only_for_oversized_documents: Optional[bool] = rest_field(
        name="indexStorageMetadataOnlyForOversizedDocuments", visibility=["read", "create", "update", "delete", "query"]
    )
    """For Azure blobs, set this property to true to still index storage metadata for
     blob content that is too large to process. Oversized blobs are treated as
     errors by default. For limits on blob size, see
     https://learn.microsoft.com/azure/search/search-limits-quotas-capacity."""
    delimited_text_headers: Optional[str] = rest_field(
        name="delimitedTextHeaders", visibility=["read", "create", "update", "delete", "query"]
    )
    """For CSV blobs, specifies a comma-delimited list of column headers, useful for
     mapping source fields to destination fields in an index."""
    delimited_text_delimiter: Optional[str] = rest_field(
        name="delimitedTextDelimiter", visibility=["read", "create", "update", "delete", "query"]
    )
    """For CSV blobs, specifies the end-of-line single-character delimiter for CSV
     files where each line starts a new document (for example, \"|\")."""
    first_line_contains_headers: Optional[bool] = rest_field(
        name="firstLineContainsHeaders", visibility=["read", "create", "update", "delete", "query"]
    )
    """For CSV blobs, indicates that the first (non-blank) line of each blob contains
     headers."""
    markdown_parsing_submode: Optional[Union[str, "_models.MarkdownParsingSubmode"]] = rest_field(
        name="markdownParsingSubmode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the submode that will determine whether a markdown file will be
     parsed into exactly one search document or multiple search documents. Default
     is ``oneToMany``. Known values are: \"oneToMany\" and \"oneToOne\"."""
    markdown_header_depth: Optional[Union[str, "_models.MarkdownHeaderDepth"]] = rest_field(
        name="markdownHeaderDepth", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the max header depth that will be considered while grouping markdown
     content. Default is ``h6``. Known values are: \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", and
     \"h6\"."""
    document_root: Optional[str] = rest_field(
        name="documentRoot", visibility=["read", "create", "update", "delete", "query"]
    )
    """For JSON arrays, given a structured or semi-structured document, you can
     specify a path to the array using this property."""
    data_to_extract: Optional[Union[str, "_models.BlobIndexerDataToExtract"]] = rest_field(
        name="dataToExtract", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the data to extract from Azure blob storage and tells the indexer
     which data to extract from image content when \"imageAction\" is set to a value
     other than \"none\".  This applies to embedded image content in a .PDF or other
     application, or image files such as .jpg and .png, in Azure blobs. Known values are:
     \"storageMetadata\", \"allMetadata\", and \"contentAndMetadata\"."""
    image_action: Optional[Union[str, "_models.BlobIndexerImageAction"]] = rest_field(
        name="imageAction", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines how to process embedded images and image files in Azure blob
     storage.  Setting the \"imageAction\" configuration to any value other than
     \"none\" requires that a skillset also be attached to that indexer. Known values are: \"none\",
     \"generateNormalizedImages\", and \"generateNormalizedImagePerPage\"."""
    allow_skillset_to_read_file_data: Optional[bool] = rest_field(
        name="allowSkillsetToReadFileData", visibility=["read", "create", "update", "delete", "query"]
    )
    """If true, will create a path //document//file_data that is an object
     representing the original file data downloaded from your blob data source.
     This allows you to pass the original file data to a custom skill for processing
     within the enrichment pipeline, or to the Document Extraction skill."""
    pdf_text_rotation_algorithm: Optional[Union[str, "_models.BlobIndexerPDFTextRotationAlgorithm"]] = rest_field(
        name="pdfTextRotationAlgorithm", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines algorithm for text extraction from PDF files in Azure blob storage. Known values
     are: \"none\" and \"detectAngles\"."""
    execution_environment: Optional[Union[str, "_models.IndexerExecutionEnvironment"]] = rest_field(
        name="executionEnvironment", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the environment in which the indexer should execute. Known values are: \"standard\"
     and \"private\"."""
    query_timeout: Optional[str] = rest_field(
        name="queryTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """Increases the timeout beyond the 5-minute default for Azure SQL database data
     sources, specified in the format \"hh:mm:ss\"."""

    @overload
    def __init__(
        self,
        *,
        parsing_mode: Optional[Union[str, "_models.BlobIndexerParsingMode"]] = None,
        excluded_file_name_extensions: Optional[str] = None,
        indexed_file_name_extensions: Optional[str] = None,
        fail_on_unsupported_content_type: Optional[bool] = None,
        fail_on_unprocessable_document: Optional[bool] = None,
        index_storage_metadata_only_for_oversized_documents: Optional[bool] = None,
        delimited_text_headers: Optional[str] = None,
        delimited_text_delimiter: Optional[str] = None,
        first_line_contains_headers: Optional[bool] = None,
        markdown_parsing_submode: Optional[Union[str, "_models.MarkdownParsingSubmode"]] = None,
        markdown_header_depth: Optional[Union[str, "_models.MarkdownHeaderDepth"]] = None,
        document_root: Optional[str] = None,
        data_to_extract: Optional[Union[str, "_models.BlobIndexerDataToExtract"]] = None,
        image_action: Optional[Union[str, "_models.BlobIndexerImageAction"]] = None,
        allow_skillset_to_read_file_data: Optional[bool] = None,
        pdf_text_rotation_algorithm: Optional[Union[str, "_models.BlobIndexerPDFTextRotationAlgorithm"]] = None,
        execution_environment: Optional[Union[str, "_models.IndexerExecutionEnvironment"]] = None,
        query_timeout: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndexingResult(_model_base.Model):
    """Status of an indexing operation for a single document.


    :ivar key: The key of a document that was in the indexing request. Required.
    :vartype key: str
    :ivar error_message: The error message explaining why the indexing operation failed for the
     document
     identified by the key; null if indexing succeeded.
    :vartype error_message: str
    :ivar succeeded: A value indicating whether the indexing operation succeeded for the document
     identified by the key. Required.
    :vartype succeeded: bool
    :ivar status_code: The status code of the indexing operation. Possible values include: 200 for
     a
     successful update or delete, 201 for successful document creation, 400 for a
     malformed input document, 404 for document not found, 409 for a version
     conflict, 422 when the index is temporarily unavailable, or 503 for when the
     service is too busy. Required.
    :vartype status_code: int
    """

    key: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The key of a document that was in the indexing request. Required."""
    error_message: Optional[str] = rest_field(
        name="errorMessage", visibility=["read", "create", "update", "delete", "query"]
    )
    """The error message explaining why the indexing operation failed for the document
     identified by the key; null if indexing succeeded."""
    succeeded: bool = rest_field(name="status", visibility=["read", "create", "update", "delete", "query"])
    """A value indicating whether the indexing operation succeeded for the document
     identified by the key. Required."""
    status_code: int = rest_field(name="statusCode", visibility=["read", "create", "update", "delete", "query"])
    """The status code of the indexing operation. Possible values include: 200 for a
     successful update or delete, 201 for successful document creation, 400 for a
     malformed input document, 404 for document not found, 409 for a version
     conflict, 422 when the index is temporarily unavailable, or 503 for when the
     service is too busy. Required."""

    @overload
    def __init__(
        self,
        *,
        key: str,
        succeeded: bool,
        status_code: int,
        error_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndexingSchedule(_model_base.Model):
    """Represents a schedule for indexer execution.


    :ivar interval: The interval of time between indexer executions. Required.
    :vartype interval: ~datetime.timedelta
    :ivar start_time: The time when an indexer should start running.
    :vartype start_time: ~datetime.datetime
    """

    interval: datetime.timedelta = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The interval of time between indexer executions. Required."""
    start_time: Optional[datetime.datetime] = rest_field(
        name="startTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The time when an indexer should start running."""

    @overload
    def __init__(
        self,
        *,
        interval: datetime.timedelta,
        start_time: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndexStatisticsSummary(_model_base.Model):
    """Statistics for a given index. Statistics are collected periodically and are not guaranteed to
    always be up-to-date.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar name: The name of the index. Required.
    :vartype name: str
    :ivar document_count: The number of documents in the index. Required.
    :vartype document_count: int
    :ivar storage_size: The amount of storage in bytes consumed by the index. Required.
    :vartype storage_size: int
    :ivar vector_index_size: The amount of memory in bytes consumed by vectors in the index.
    :vartype vector_index_size: int
    """

    name: str = rest_field(visibility=["read"])
    """The name of the index. Required."""
    document_count: int = rest_field(name="documentCount", visibility=["read"])
    """The number of documents in the index. Required."""
    storage_size: int = rest_field(name="storageSize", visibility=["read"])
    """The amount of storage in bytes consumed by the index. Required."""
    vector_index_size: Optional[int] = rest_field(name="vectorIndexSize", visibility=["read"])
    """The amount of memory in bytes consumed by vectors in the index."""


class InputFieldMappingEntry(_model_base.Model):
    """Input field mapping for a skill.


    :ivar name: The name of the input. Required.
    :vartype name: str
    :ivar source: The source of the input.
    :vartype source: str
    :ivar source_context: The source context used for selecting recursive inputs.
    :vartype source_context: str
    :ivar inputs: The recursive inputs used when creating a complex type.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the input. Required."""
    source: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The source of the input."""
    source_context: Optional[str] = rest_field(
        name="sourceContext", visibility=["read", "create", "update", "delete", "query"]
    )
    """The source context used for selecting recursive inputs."""
    inputs: Optional[List["_models.InputFieldMappingEntry"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The recursive inputs used when creating a complex type."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        source: Optional[str] = None,
        source_context: Optional[str] = None,
        inputs: Optional[List["_models.InputFieldMappingEntry"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class KeepTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.KeepTokenFilter"):
    """A token filter that only keeps tokens with text contained in a specified list
    of words. This token filter is implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar keep_words: The list of words to keep. Required.
    :vartype keep_words: list[str]
    :ivar lower_case_keep_words: A value indicating whether to lower case all words first. Default
     is false.
    :vartype lower_case_keep_words: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.KeepTokenFilter".
    :vartype odata_type: str
    """

    keep_words: List[str] = rest_field(name="keepWords", visibility=["read", "create", "update", "delete", "query"])
    """The list of words to keep. Required."""
    lower_case_keep_words: Optional[bool] = rest_field(
        name="keepWordsCase", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to lower case all words first. Default is false."""
    odata_type: Literal["#Microsoft.Azure.Search.KeepTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.KeepTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        keep_words: List[str],
        lower_case_keep_words: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.KeepTokenFilter", **kwargs)


class KeyPhraseExtractionSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.KeyPhraseExtractionSkill"):
    """A skill that uses text analytics for key phrase extraction.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar default_language_code: A value indicating which language code to use. Default is ``en``.
     Known values are: "da", "nl", "en", "fi", "fr", "de", "it", "ja", "ko", "no", "pl", "pt-PT",
     "pt-BR", "ru", "es", and "sv".
    :vartype default_language_code: str or
     ~azure.search.documents.models.KeyPhraseExtractionSkillLanguage
    :ivar max_key_phrase_count: A number indicating how many key phrases to return. If absent, all
     identified
     key phrases will be returned.
    :vartype max_key_phrase_count: int
    :ivar model_version: The version of the model to use when calling the Text Analytics service.
     It
     will default to the latest available when not specified. We recommend you do
     not specify this value unless absolutely necessary.
    :vartype model_version: str
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.KeyPhraseExtractionSkill".
    :vartype odata_type: str
    """

    default_language_code: Optional[Union[str, "_models.KeyPhraseExtractionSkillLanguage"]] = rest_field(
        name="defaultLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which language code to use. Default is ``en``. Known values are: \"da\",
     \"nl\", \"en\", \"fi\", \"fr\", \"de\", \"it\", \"ja\", \"ko\", \"no\", \"pl\", \"pt-PT\",
     \"pt-BR\", \"ru\", \"es\", and \"sv\"."""
    max_key_phrase_count: Optional[int] = rest_field(
        name="maxKeyPhraseCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """A number indicating how many key phrases to return. If absent, all identified
     key phrases will be returned."""
    model_version: Optional[str] = rest_field(
        name="modelVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The version of the model to use when calling the Text Analytics service. It
     will default to the latest available when not specified. We recommend you do
     not specify this value unless absolutely necessary."""
    odata_type: Literal["#Microsoft.Skills.Text.KeyPhraseExtractionSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.KeyPhraseExtractionSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        default_language_code: Optional[Union[str, "_models.KeyPhraseExtractionSkillLanguage"]] = None,
        max_key_phrase_count: Optional[int] = None,
        model_version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.KeyPhraseExtractionSkill", **kwargs)


class KeywordMarkerTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.KeywordMarkerTokenFilter"):
    """Marks terms as keywords. This token filter is implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar keywords: A list of words to mark as keywords. Required.
    :vartype keywords: list[str]
    :ivar ignore_case: A value indicating whether to ignore case. If true, all words are converted
     to
     lower case first. Default is false.
    :vartype ignore_case: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.KeywordMarkerTokenFilter".
    :vartype odata_type: str
    """

    keywords: List[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A list of words to mark as keywords. Required."""
    ignore_case: Optional[bool] = rest_field(
        name="ignoreCase", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to ignore case. If true, all words are converted to
     lower case first. Default is false."""
    odata_type: Literal["#Microsoft.Azure.Search.KeywordMarkerTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.KeywordMarkerTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        keywords: List[str],
        ignore_case: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.KeywordMarkerTokenFilter", **kwargs)


class KeywordTokenizerV2(LexicalTokenizer, discriminator="#Microsoft.Azure.Search.KeywordTokenizerV2"):
    """Emits the entire input as a single token. This tokenizer is implemented using
    Apache Lucene.


    :ivar name: The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar max_token_length: The maximum token length. Default is 256. Tokens longer than the
     maximum length
     are split. The maximum token length that can be used is 300 characters.
    :vartype max_token_length: int
    :ivar odata_type: A URI fragment specifying the type of tokenizer. Required. Default value is
     "#Microsoft.Azure.Search.KeywordTokenizerV2".
    :vartype odata_type: str
    """

    max_token_length: Optional[int] = rest_field(
        name="maxTokenLength", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum token length. Default is 256. Tokens longer than the maximum length
     are split. The maximum token length that can be used is 300 characters."""
    odata_type: Literal["#Microsoft.Azure.Search.KeywordTokenizerV2"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of tokenizer. Required. Default value is
     \"#Microsoft.Azure.Search.KeywordTokenizerV2\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        max_token_length: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.KeywordTokenizerV2", **kwargs)


class LanguageDetectionSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.LanguageDetectionSkill"):
    """A skill that detects the language of input text and reports a single language
    code for every document submitted on the request. The language code is paired
    with a score indicating the confidence of the analysis.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar default_country_hint: A country code to use as a hint to the language detection model if
     it cannot
     disambiguate the language.
    :vartype default_country_hint: str
    :ivar model_version: The version of the model to use when calling the Text Analytics service.
     It
     will default to the latest available when not specified. We recommend you do
     not specify this value unless absolutely necessary.
    :vartype model_version: str
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.LanguageDetectionSkill".
    :vartype odata_type: str
    """

    default_country_hint: Optional[str] = rest_field(
        name="defaultCountryHint", visibility=["read", "create", "update", "delete", "query"]
    )
    """A country code to use as a hint to the language detection model if it cannot
     disambiguate the language."""
    model_version: Optional[str] = rest_field(
        name="modelVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The version of the model to use when calling the Text Analytics service. It
     will default to the latest available when not specified. We recommend you do
     not specify this value unless absolutely necessary."""
    odata_type: Literal["#Microsoft.Skills.Text.LanguageDetectionSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.LanguageDetectionSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        default_country_hint: Optional[str] = None,
        model_version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.LanguageDetectionSkill", **kwargs)


class LengthTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.LengthTokenFilter"):
    """Removes words that are too long or too short. This token filter is implemented
    using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar min_length: The minimum length in characters. Default is 0. Maximum is 300. Must be less
     than the value of max.
    :vartype min_length: int
    :ivar max_length: The maximum length in characters. Default and maximum is 300.
    :vartype max_length: int
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.LengthTokenFilter".
    :vartype odata_type: str
    """

    min_length: Optional[int] = rest_field(name="min", visibility=["read", "create", "update", "delete", "query"])
    """The minimum length in characters. Default is 0. Maximum is 300. Must be less
     than the value of max."""
    max_length: Optional[int] = rest_field(name="max", visibility=["read", "create", "update", "delete", "query"])
    """The maximum length in characters. Default and maximum is 300."""
    odata_type: Literal["#Microsoft.Azure.Search.LengthTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.LengthTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        min_length: Optional[int] = None,
        max_length: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.LengthTokenFilter", **kwargs)


class LimitTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.LimitTokenFilter"):
    """Limits the number of tokens while indexing. This token filter is implemented
    using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar max_token_count: The maximum number of tokens to produce. Default is 1.
    :vartype max_token_count: int
    :ivar consume_all_tokens: A value indicating whether all tokens from the input must be consumed
     even if
     maxTokenCount is reached. Default is false.
    :vartype consume_all_tokens: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.LimitTokenFilter".
    :vartype odata_type: str
    """

    max_token_count: Optional[int] = rest_field(
        name="maxTokenCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of tokens to produce. Default is 1."""
    consume_all_tokens: Optional[bool] = rest_field(
        name="consumeAllTokens", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether all tokens from the input must be consumed even if
     maxTokenCount is reached. Default is false."""
    odata_type: Literal["#Microsoft.Azure.Search.LimitTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.LimitTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        max_token_count: Optional[int] = None,
        consume_all_tokens: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.LimitTokenFilter", **kwargs)


class ListDataSourcesResult(_model_base.Model):
    """Response from a List Datasources request. If successful, it includes the full
    definitions of all datasources.


    :ivar data_sources: The datasources in the Search service. Required.
    :vartype data_sources: list[~azure.search.documents.models.SearchIndexerDataSource]
    """

    data_sources: List["_models.SearchIndexerDataSource"] = rest_field(
        name="value", visibility=["read", "create", "update", "delete", "query"]
    )
    """The datasources in the Search service. Required."""

    @overload
    def __init__(
        self,
        *,
        data_sources: List["_models.SearchIndexerDataSource"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ListIndexersResult(_model_base.Model):
    """Response from a List Indexers request. If successful, it includes the full
    definitions of all indexers.


    :ivar indexers: The indexers in the Search service. Required.
    :vartype indexers: list[~azure.search.documents.models.SearchIndexer]
    """

    indexers: List["_models.SearchIndexer"] = rest_field(
        name="value", visibility=["read", "create", "update", "delete", "query"]
    )
    """The indexers in the Search service. Required."""

    @overload
    def __init__(
        self,
        *,
        indexers: List["_models.SearchIndexer"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ListIndexStatsSummary(_model_base.Model):
    """Response from a request to retrieve stats summary of all indexes. If successful, it includes
    the stats of each index in the service.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar indexes_statistics: The Statistics summary of all indexes in the Search service.
     Required.
    :vartype indexes_statistics: list[~azure.search.documents.models.IndexStatisticsSummary]
    """

    indexes_statistics: List["_models.IndexStatisticsSummary"] = rest_field(name="value", visibility=["read"])
    """The Statistics summary of all indexes in the Search service. Required."""


class ListSkillsetsResult(_model_base.Model):
    """Response from a list skillset request. If successful, it includes the full
    definitions of all skillsets.


    :ivar skillsets: The skillsets defined in the Search service. Required.
    :vartype skillsets: list[~azure.search.documents.models.SearchIndexerSkillset]
    """

    skillsets: List["_models.SearchIndexerSkillset"] = rest_field(
        name="value", visibility=["read", "create", "update", "delete", "query"]
    )
    """The skillsets defined in the Search service. Required."""

    @overload
    def __init__(
        self,
        *,
        skillsets: List["_models.SearchIndexerSkillset"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ListSynonymMapsResult(_model_base.Model):
    """Response from a List SynonymMaps request. If successful, it includes the full
    definitions of all synonym maps.


    :ivar synonym_maps: The synonym maps in the Search service. Required.
    :vartype synonym_maps: list[~azure.search.documents.models.SynonymMap]
    """

    synonym_maps: List["_models.SynonymMap"] = rest_field(
        name="value", visibility=["read", "create", "update", "delete", "query"]
    )
    """The synonym maps in the Search service. Required."""

    @overload
    def __init__(
        self,
        *,
        synonym_maps: List["_models.SynonymMap"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LookupDocument(_model_base.Model):
    """A document retrieved via a document lookup operation."""


class LuceneStandardAnalyzer(LexicalAnalyzer, discriminator="#Microsoft.Azure.Search.StandardAnalyzer"):
    """Standard Apache Lucene analyzer; Composed of the standard tokenizer, lowercase
    filter and stop filter.


    :ivar name: The name of the analyzer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar max_token_length: The maximum token length. Default is 255. Tokens longer than the
     maximum length
     are split. The maximum token length that can be used is 300 characters.
    :vartype max_token_length: int
    :ivar stopwords: A list of stopwords.
    :vartype stopwords: list[str]
    :ivar odata_type: A URI fragment specifying the type of analyzer. Required. Default value is
     "#Microsoft.Azure.Search.StandardAnalyzer".
    :vartype odata_type: str
    """

    max_token_length: Optional[int] = rest_field(
        name="maxTokenLength", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum token length. Default is 255. Tokens longer than the maximum length
     are split. The maximum token length that can be used is 300 characters."""
    stopwords: Optional[List[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A list of stopwords."""
    odata_type: Literal["#Microsoft.Azure.Search.StandardAnalyzer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of analyzer. Required. Default value is
     \"#Microsoft.Azure.Search.StandardAnalyzer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        max_token_length: Optional[int] = None,
        stopwords: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.StandardAnalyzer", **kwargs)


class LuceneStandardTokenizerV2(LexicalTokenizer, discriminator="#Microsoft.Azure.Search.StandardTokenizerV2"):
    """Breaks text following the Unicode Text Segmentation rules. This tokenizer is
    implemented using Apache Lucene.


    :ivar name: The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar max_token_length: The maximum token length. Default is 255. Tokens longer than the
     maximum length
     are split. The maximum token length that can be used is 300 characters.
    :vartype max_token_length: int
    :ivar odata_type: A URI fragment specifying the type of tokenizer. Required. Default value is
     "#Microsoft.Azure.Search.StandardTokenizerV2".
    :vartype odata_type: str
    """

    max_token_length: Optional[int] = rest_field(
        name="maxTokenLength", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum token length. Default is 255. Tokens longer than the maximum length
     are split. The maximum token length that can be used is 300 characters."""
    odata_type: Literal["#Microsoft.Azure.Search.StandardTokenizerV2"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of tokenizer. Required. Default value is
     \"#Microsoft.Azure.Search.StandardTokenizerV2\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        max_token_length: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.StandardTokenizerV2", **kwargs)


class MagnitudeScoringFunction(ScoringFunction, discriminator="magnitude"):
    """Defines a function that boosts scores based on the magnitude of a numeric field.


    :ivar field_name: The name of the field used as input to the scoring function. Required.
    :vartype field_name: str
    :ivar boost: A multiplier for the raw score. Must be a positive number not equal to 1.0.
     Required.
    :vartype boost: float
    :ivar interpolation: A value indicating how boosting will be interpolated across document
     scores;
     defaults to "Linear". Known values are: "linear", "constant", "quadratic", and "logarithmic".
    :vartype interpolation: str or ~azure.search.documents.models.ScoringFunctionInterpolation
    :ivar parameters: Parameter values for the magnitude scoring function. Required.
    :vartype parameters: ~azure.search.documents.models.MagnitudeScoringParameters
    :ivar type: Indicates the type of function to use. Valid values include magnitude,
     freshness, distance, and tag. The function type must be lower case. Required. Default value is
     "magnitude".
    :vartype type: str
    """

    parameters: "_models.MagnitudeScoringParameters" = rest_field(
        name="magnitude", visibility=["read", "create", "update", "delete", "query"]
    )
    """Parameter values for the magnitude scoring function. Required."""
    type: Literal["magnitude"] = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Indicates the type of function to use. Valid values include magnitude,
     freshness, distance, and tag. The function type must be lower case. Required. Default value is
     \"magnitude\"."""

    @overload
    def __init__(
        self,
        *,
        field_name: str,
        boost: float,
        parameters: "_models.MagnitudeScoringParameters",
        interpolation: Optional[Union[str, "_models.ScoringFunctionInterpolation"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="magnitude", **kwargs)


class MagnitudeScoringParameters(_model_base.Model):
    """Provides parameter values to a magnitude scoring function.


    :ivar boosting_range_start: The field value at which boosting starts. Required.
    :vartype boosting_range_start: float
    :ivar boosting_range_end: The field value at which boosting ends. Required.
    :vartype boosting_range_end: float
    :ivar should_boost_beyond_range_by_constant: A value indicating whether to apply a constant
     boost for field values beyond
     the range end value; default is false.
    :vartype should_boost_beyond_range_by_constant: bool
    """

    boosting_range_start: float = rest_field(
        name="boostingRangeStart", visibility=["read", "create", "update", "delete", "query"]
    )
    """The field value at which boosting starts. Required."""
    boosting_range_end: float = rest_field(
        name="boostingRangeEnd", visibility=["read", "create", "update", "delete", "query"]
    )
    """The field value at which boosting ends. Required."""
    should_boost_beyond_range_by_constant: Optional[bool] = rest_field(
        name="constantBoostBeyondRange", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to apply a constant boost for field values beyond
     the range end value; default is false."""

    @overload
    def __init__(
        self,
        *,
        boosting_range_start: float,
        boosting_range_end: float,
        should_boost_beyond_range_by_constant: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MappingCharFilter(CharFilter, discriminator="#Microsoft.Azure.Search.MappingCharFilter"):
    """A character filter that applies mappings defined with the mappings option.
    Matching is greedy (longest pattern matching at a given point wins).
    Replacement is allowed to be the empty string. This character filter is
    implemented using Apache Lucene.


    :ivar name: The name of the char filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar mappings: A list of mappings of the following format: "a=>b" (all occurrences of the
     character "a" will be replaced with character "b"). Required.
    :vartype mappings: list[str]
    :ivar odata_type: A URI fragment specifying the type of char filter. Required. Default value is
     "#Microsoft.Azure.Search.MappingCharFilter".
    :vartype odata_type: str
    """

    mappings: List[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A list of mappings of the following format: \"a=>b\" (all occurrences of the
     character \"a\" will be replaced with character \"b\"). Required."""
    odata_type: Literal["#Microsoft.Azure.Search.MappingCharFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of char filter. Required. Default value is
     \"#Microsoft.Azure.Search.MappingCharFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        mappings: List[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.MappingCharFilter", **kwargs)


class MergeSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.MergeSkill"):
    """A skill for merging two or more strings into a single unified string, with an
    optional user-defined delimiter separating each component part.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar insert_pre_tag: The tag indicates the start of the merged text. By default, the tag is an
     empty
     space.
    :vartype insert_pre_tag: str
    :ivar insert_post_tag: The tag indicates the end of the merged text. By default, the tag is an
     empty
     space.
    :vartype insert_post_tag: str
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.MergeSkill".
    :vartype odata_type: str
    """

    insert_pre_tag: Optional[str] = rest_field(
        name="insertPreTag", visibility=["read", "create", "update", "delete", "query"]
    )
    """The tag indicates the start of the merged text. By default, the tag is an empty
     space."""
    insert_post_tag: Optional[str] = rest_field(
        name="insertPostTag", visibility=["read", "create", "update", "delete", "query"]
    )
    """The tag indicates the end of the merged text. By default, the tag is an empty
     space."""
    odata_type: Literal["#Microsoft.Skills.Text.MergeSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.MergeSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        insert_pre_tag: Optional[str] = None,
        insert_post_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.MergeSkill", **kwargs)


class MicrosoftLanguageStemmingTokenizer(
    LexicalTokenizer, discriminator="#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer"
):
    """Divides text using language-specific rules and reduces words to their base
    forms.


    :ivar name: The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar max_token_length: The maximum token length. Tokens longer than the maximum length are
     split.
     Maximum token length that can be used is 300 characters. Tokens longer than 300
     characters are first split into tokens of length 300 and then each of those
     tokens is split based on the max token length set. Default is 255.
    :vartype max_token_length: int
    :ivar is_search_tokenizer: A value indicating how the tokenizer is used. Set to true if used as
     the search
     tokenizer, set to false if used as the indexing tokenizer. Default is false.
    :vartype is_search_tokenizer: bool
    :ivar language: The language to use. The default is English. Known values are: "arabic",
     "bangla", "bulgarian", "catalan", "croatian", "czech", "danish", "dutch", "english",
     "estonian", "finnish", "french", "german", "greek", "gujarati", "hebrew", "hindi", "hungarian",
     "icelandic", "indonesian", "italian", "kannada", "latvian", "lithuanian", "malay", "malayalam",
     "marathi", "norwegianBokmaal", "polish", "portuguese", "portugueseBrazilian", "punjabi",
     "romanian", "russian", "serbianCyrillic", "serbianLatin", "slovak", "slovenian", "spanish",
     "swedish", "tamil", "telugu", "turkish", "ukrainian", and "urdu".
    :vartype language: str or ~azure.search.documents.models.MicrosoftStemmingTokenizerLanguage
    :ivar odata_type: A URI fragment specifying the type of tokenizer. Required. Default value is
     "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer".
    :vartype odata_type: str
    """

    max_token_length: Optional[int] = rest_field(
        name="maxTokenLength", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum token length. Tokens longer than the maximum length are split.
     Maximum token length that can be used is 300 characters. Tokens longer than 300
     characters are first split into tokens of length 300 and then each of those
     tokens is split based on the max token length set. Default is 255."""
    is_search_tokenizer: Optional[bool] = rest_field(
        name="isSearchTokenizer", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating how the tokenizer is used. Set to true if used as the search
     tokenizer, set to false if used as the indexing tokenizer. Default is false."""
    language: Optional[Union[str, "_models.MicrosoftStemmingTokenizerLanguage"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The language to use. The default is English. Known values are: \"arabic\", \"bangla\",
     \"bulgarian\", \"catalan\", \"croatian\", \"czech\", \"danish\", \"dutch\", \"english\",
     \"estonian\", \"finnish\", \"french\", \"german\", \"greek\", \"gujarati\", \"hebrew\",
     \"hindi\", \"hungarian\", \"icelandic\", \"indonesian\", \"italian\", \"kannada\", \"latvian\",
     \"lithuanian\", \"malay\", \"malayalam\", \"marathi\", \"norwegianBokmaal\", \"polish\",
     \"portuguese\", \"portugueseBrazilian\", \"punjabi\", \"romanian\", \"russian\",
     \"serbianCyrillic\", \"serbianLatin\", \"slovak\", \"slovenian\", \"spanish\", \"swedish\",
     \"tamil\", \"telugu\", \"turkish\", \"ukrainian\", and \"urdu\"."""
    odata_type: Literal["#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of tokenizer. Required. Default value is
     \"#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        max_token_length: Optional[int] = None,
        is_search_tokenizer: Optional[bool] = None,
        language: Optional[Union[str, "_models.MicrosoftStemmingTokenizerLanguage"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer", **kwargs)


class MicrosoftLanguageTokenizer(LexicalTokenizer, discriminator="#Microsoft.Azure.Search.MicrosoftLanguageTokenizer"):
    """Divides text using language-specific rules.


    :ivar name: The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar max_token_length: The maximum token length. Tokens longer than the maximum length are
     split.
     Maximum token length that can be used is 300 characters. Tokens longer than 300
     characters are first split into tokens of length 300 and then each of those
     tokens is split based on the max token length set. Default is 255.
    :vartype max_token_length: int
    :ivar is_search_tokenizer: A value indicating how the tokenizer is used. Set to true if used as
     the search
     tokenizer, set to false if used as the indexing tokenizer. Default is false.
    :vartype is_search_tokenizer: bool
    :ivar language: The language to use. The default is English. Known values are: "bangla",
     "bulgarian", "catalan", "chineseSimplified", "chineseTraditional", "croatian", "czech",
     "danish", "dutch", "english", "french", "german", "greek", "gujarati", "hindi", "icelandic",
     "indonesian", "italian", "japanese", "kannada", "korean", "malay", "malayalam", "marathi",
     "norwegianBokmaal", "polish", "portuguese", "portugueseBrazilian", "punjabi", "romanian",
     "russian", "serbianCyrillic", "serbianLatin", "slovenian", "spanish", "swedish", "tamil",
     "telugu", "thai", "ukrainian", "urdu", and "vietnamese".
    :vartype language: str or ~azure.search.documents.models.MicrosoftTokenizerLanguage
    :ivar odata_type: A URI fragment specifying the type of tokenizer. Required. Default value is
     "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer".
    :vartype odata_type: str
    """

    max_token_length: Optional[int] = rest_field(
        name="maxTokenLength", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum token length. Tokens longer than the maximum length are split.
     Maximum token length that can be used is 300 characters. Tokens longer than 300
     characters are first split into tokens of length 300 and then each of those
     tokens is split based on the max token length set. Default is 255."""
    is_search_tokenizer: Optional[bool] = rest_field(
        name="isSearchTokenizer", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating how the tokenizer is used. Set to true if used as the search
     tokenizer, set to false if used as the indexing tokenizer. Default is false."""
    language: Optional[Union[str, "_models.MicrosoftTokenizerLanguage"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The language to use. The default is English. Known values are: \"bangla\", \"bulgarian\",
     \"catalan\", \"chineseSimplified\", \"chineseTraditional\", \"croatian\", \"czech\",
     \"danish\", \"dutch\", \"english\", \"french\", \"german\", \"greek\", \"gujarati\", \"hindi\",
     \"icelandic\", \"indonesian\", \"italian\", \"japanese\", \"kannada\", \"korean\", \"malay\",
     \"malayalam\", \"marathi\", \"norwegianBokmaal\", \"polish\", \"portuguese\",
     \"portugueseBrazilian\", \"punjabi\", \"romanian\", \"russian\", \"serbianCyrillic\",
     \"serbianLatin\", \"slovenian\", \"spanish\", \"swedish\", \"tamil\", \"telugu\", \"thai\",
     \"ukrainian\", \"urdu\", and \"vietnamese\"."""
    odata_type: Literal["#Microsoft.Azure.Search.MicrosoftLanguageTokenizer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of tokenizer. Required. Default value is
     \"#Microsoft.Azure.Search.MicrosoftLanguageTokenizer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        max_token_length: Optional[int] = None,
        is_search_tokenizer: Optional[bool] = None,
        language: Optional[Union[str, "_models.MicrosoftTokenizerLanguage"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.MicrosoftLanguageTokenizer", **kwargs)


class NativeBlobSoftDeleteDeletionDetectionPolicy(
    DataDeletionDetectionPolicy, discriminator="#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy"
):  # pylint: disable=name-too-long
    """Defines a data deletion detection policy utilizing Azure Blob Storage's native
    soft delete feature for deletion detection.


    :ivar odata_type: A URI fragment specifying the type of data deletion detection policy.
     Required. Default value is
     "#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy".
    :vartype odata_type: str
    """

    odata_type: Literal["#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of data deletion detection policy. Required. Default value
     is \"#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy\"."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(
            *args, odata_type="#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy", **kwargs
        )


class NGramTokenFilterV2(TokenFilter, discriminator="#Microsoft.Azure.Search.NGramTokenFilterV2"):
    """Generates n-grams of the given size(s). This token filter is implemented using
    Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar min_gram: The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the
     value of maxGram.
    :vartype min_gram: int
    :ivar max_gram: The maximum n-gram length. Default is 2. Maximum is 300.
    :vartype max_gram: int
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.NGramTokenFilterV2".
    :vartype odata_type: str
    """

    min_gram: Optional[int] = rest_field(name="minGram", visibility=["read", "create", "update", "delete", "query"])
    """The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the
     value of maxGram."""
    max_gram: Optional[int] = rest_field(name="maxGram", visibility=["read", "create", "update", "delete", "query"])
    """The maximum n-gram length. Default is 2. Maximum is 300."""
    odata_type: Literal["#Microsoft.Azure.Search.NGramTokenFilterV2"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.NGramTokenFilterV2\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        min_gram: Optional[int] = None,
        max_gram: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.NGramTokenFilterV2", **kwargs)


class NGramTokenizer(LexicalTokenizer, discriminator="#Microsoft.Azure.Search.NGramTokenizer"):
    """Tokenizes the input into n-grams of the given size(s). This tokenizer is
    implemented using Apache Lucene.


    :ivar name: The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar min_gram: The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the
     value of maxGram.
    :vartype min_gram: int
    :ivar max_gram: The maximum n-gram length. Default is 2. Maximum is 300.
    :vartype max_gram: int
    :ivar token_chars: Character classes to keep in the tokens.
    :vartype token_chars: list[str or ~azure.search.documents.models.TokenCharacterKind]
    :ivar odata_type: A URI fragment specifying the type of tokenizer. Required. Default value is
     "#Microsoft.Azure.Search.NGramTokenizer".
    :vartype odata_type: str
    """

    min_gram: Optional[int] = rest_field(name="minGram", visibility=["read", "create", "update", "delete", "query"])
    """The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the
     value of maxGram."""
    max_gram: Optional[int] = rest_field(name="maxGram", visibility=["read", "create", "update", "delete", "query"])
    """The maximum n-gram length. Default is 2. Maximum is 300."""
    token_chars: Optional[List[Union[str, "_models.TokenCharacterKind"]]] = rest_field(
        name="tokenChars", visibility=["read", "create", "update", "delete", "query"]
    )
    """Character classes to keep in the tokens."""
    odata_type: Literal["#Microsoft.Azure.Search.NGramTokenizer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of tokenizer. Required. Default value is
     \"#Microsoft.Azure.Search.NGramTokenizer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        min_gram: Optional[int] = None,
        max_gram: Optional[int] = None,
        token_chars: Optional[List[Union[str, "_models.TokenCharacterKind"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.NGramTokenizer", **kwargs)


class OcrSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Vision.OcrSkill"):
    """A skill that extracts text from image files.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar default_language_code: A value indicating which language code to use. Default is ``en``.
     Known values are: "af", "sq", "anp", "ar", "ast", "awa", "az", "bfy", "eu", "be", "be-cyrl",
     "be-latn", "bho", "bi", "brx", "bs", "bra", "br", "bg", "bns", "bua", "ca", "ceb", "rab", "ch",
     "hne", "zh-Hans", "zh-Hant", "kw", "co", "crh", "hr", "cs", "da", "prs", "dhi", "doi", "nl",
     "en", "myv", "et", "fo", "fj", "fil", "fi", "fr", "fur", "gag", "gl", "de", "gil", "gon", "el",
     "kl", "gvr", "ht", "hlb", "hni", "bgc", "haw", "hi", "mww", "hoc", "hu", "is", "smn", "id",
     "ia", "iu", "ga", "it", "ja", "Jns", "jv", "kea", "kac", "xnr", "krc", "kaa-cyrl", "kaa",
     "csb", "kk-cyrl", "kk-latn", "klr", "kha", "quc", "ko", "kfq", "kpy", "kos", "kum", "ku-arab",
     "ku-latn", "kru", "ky", "lkt", "la", "lt", "dsb", "smj", "lb", "bfz", "ms", "mt", "kmj", "gv",
     "mi", "mr", "mn", "cnr-cyrl", "cnr-latn", "nap", "ne", "niu", "nog", "sme", "nb", "no", "oc",
     "os", "ps", "fa", "pl", "pt", "pa", "ksh", "ro", "rm", "ru", "sck", "sm", "sa", "sat", "sco",
     "gd", "sr", "sr-Cyrl", "sr-Latn", "xsr", "srx", "sms", "sk", "sl", "so", "sma", "es", "sw",
     "sv", "tg", "tt", "tet", "thf", "to", "tr", "tk", "tyv", "hsb", "ur", "ug", "uz-arab",
     "uz-cyrl", "uz", "vo", "wae", "cy", "fy", "yua", "za", "zu", and "unk".
    :vartype default_language_code: str or ~azure.search.documents.models.OcrSkillLanguage
    :ivar should_detect_orientation: A value indicating to turn orientation detection on or not.
     Default is false.
    :vartype should_detect_orientation: bool
    :ivar line_ending: Defines the sequence of characters to use between the lines of text
     recognized
     by the OCR skill. The default value is "space". Known values are: "space", "carriageReturn",
     "lineFeed", and "carriageReturnLineFeed".
    :vartype line_ending: str or ~azure.search.documents.models.OcrLineEnding
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Vision.OcrSkill".
    :vartype odata_type: str
    """

    default_language_code: Optional[Union[str, "_models.OcrSkillLanguage"]] = rest_field(
        name="defaultLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which language code to use. Default is ``en``. Known values are: \"af\",
     \"sq\", \"anp\", \"ar\", \"ast\", \"awa\", \"az\", \"bfy\", \"eu\", \"be\", \"be-cyrl\",
     \"be-latn\", \"bho\", \"bi\", \"brx\", \"bs\", \"bra\", \"br\", \"bg\", \"bns\", \"bua\",
     \"ca\", \"ceb\", \"rab\", \"ch\", \"hne\", \"zh-Hans\", \"zh-Hant\", \"kw\", \"co\", \"crh\",
     \"hr\", \"cs\", \"da\", \"prs\", \"dhi\", \"doi\", \"nl\", \"en\", \"myv\", \"et\", \"fo\",
     \"fj\", \"fil\", \"fi\", \"fr\", \"fur\", \"gag\", \"gl\", \"de\", \"gil\", \"gon\", \"el\",
     \"kl\", \"gvr\", \"ht\", \"hlb\", \"hni\", \"bgc\", \"haw\", \"hi\", \"mww\", \"hoc\", \"hu\",
     \"is\", \"smn\", \"id\", \"ia\", \"iu\", \"ga\", \"it\", \"ja\", \"Jns\", \"jv\", \"kea\",
     \"kac\", \"xnr\", \"krc\", \"kaa-cyrl\", \"kaa\", \"csb\", \"kk-cyrl\", \"kk-latn\", \"klr\",
     \"kha\", \"quc\", \"ko\", \"kfq\", \"kpy\", \"kos\", \"kum\", \"ku-arab\", \"ku-latn\",
     \"kru\", \"ky\", \"lkt\", \"la\", \"lt\", \"dsb\", \"smj\", \"lb\", \"bfz\", \"ms\", \"mt\",
     \"kmj\", \"gv\", \"mi\", \"mr\", \"mn\", \"cnr-cyrl\", \"cnr-latn\", \"nap\", \"ne\", \"niu\",
     \"nog\", \"sme\", \"nb\", \"no\", \"oc\", \"os\", \"ps\", \"fa\", \"pl\", \"pt\", \"pa\",
     \"ksh\", \"ro\", \"rm\", \"ru\", \"sck\", \"sm\", \"sa\", \"sat\", \"sco\", \"gd\", \"sr\",
     \"sr-Cyrl\", \"sr-Latn\", \"xsr\", \"srx\", \"sms\", \"sk\", \"sl\", \"so\", \"sma\", \"es\",
     \"sw\", \"sv\", \"tg\", \"tt\", \"tet\", \"thf\", \"to\", \"tr\", \"tk\", \"tyv\", \"hsb\",
     \"ur\", \"ug\", \"uz-arab\", \"uz-cyrl\", \"uz\", \"vo\", \"wae\", \"cy\", \"fy\", \"yua\",
     \"za\", \"zu\", and \"unk\"."""
    should_detect_orientation: Optional[bool] = rest_field(
        name="detectOrientation", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating to turn orientation detection on or not. Default is false."""
    line_ending: Optional[Union[str, "_models.OcrLineEnding"]] = rest_field(
        name="lineEnding", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines the sequence of characters to use between the lines of text recognized
     by the OCR skill. The default value is \"space\". Known values are: \"space\",
     \"carriageReturn\", \"lineFeed\", and \"carriageReturnLineFeed\"."""
    odata_type: Literal["#Microsoft.Skills.Vision.OcrSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Vision.OcrSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        default_language_code: Optional[Union[str, "_models.OcrSkillLanguage"]] = None,
        should_detect_orientation: Optional[bool] = None,
        line_ending: Optional[Union[str, "_models.OcrLineEnding"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Vision.OcrSkill", **kwargs)


class OutputFieldMappingEntry(_model_base.Model):
    """Output field mapping for a skill.


    :ivar name: The name of the output defined by the skill. Required.
    :vartype name: str
    :ivar target_name: The target name of the output. It is optional and default to name.
    :vartype target_name: str
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the output defined by the skill. Required."""
    target_name: Optional[str] = rest_field(
        name="targetName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The target name of the output. It is optional and default to name."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        target_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PathHierarchyTokenizerV2(LexicalTokenizer, discriminator="#Microsoft.Azure.Search.PathHierarchyTokenizerV2"):
    """Tokenizer for path-like hierarchies. This tokenizer is implemented using Apache
    Lucene.


    :ivar name: The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar delimiter: The delimiter character to use. Default is "/".
    :vartype delimiter: str
    :ivar replacement: A value that, if set, replaces the delimiter character. Default is "/".
    :vartype replacement: str
    :ivar max_token_length: The maximum token length. Default and maximum is 300.
    :vartype max_token_length: int
    :ivar reverse_token_order: A value indicating whether to generate tokens in reverse order.
     Default is
     false.
    :vartype reverse_token_order: bool
    :ivar number_of_tokens_to_skip: The number of initial tokens to skip. Default is 0.
    :vartype number_of_tokens_to_skip: int
    :ivar odata_type: A URI fragment specifying the type of tokenizer. Required. Default value is
     "#Microsoft.Azure.Search.PathHierarchyTokenizerV2".
    :vartype odata_type: str
    """

    delimiter: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The delimiter character to use. Default is \"/\"."""
    replacement: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A value that, if set, replaces the delimiter character. Default is \"/\"."""
    max_token_length: Optional[int] = rest_field(
        name="maxTokenLength", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum token length. Default and maximum is 300."""
    reverse_token_order: Optional[bool] = rest_field(
        name="reverse", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to generate tokens in reverse order. Default is
     false."""
    number_of_tokens_to_skip: Optional[int] = rest_field(
        name="skip", visibility=["read", "create", "update", "delete", "query"]
    )
    """The number of initial tokens to skip. Default is 0."""
    odata_type: Literal["#Microsoft.Azure.Search.PathHierarchyTokenizerV2"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of tokenizer. Required. Default value is
     \"#Microsoft.Azure.Search.PathHierarchyTokenizerV2\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        delimiter: Optional[str] = None,
        replacement: Optional[str] = None,
        max_token_length: Optional[int] = None,
        reverse_token_order: Optional[bool] = None,
        number_of_tokens_to_skip: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.PathHierarchyTokenizerV2", **kwargs)


class PatternAnalyzer(LexicalAnalyzer, discriminator="#Microsoft.Azure.Search.PatternAnalyzer"):
    """Flexibly separates text into terms via a regular expression pattern. This
    analyzer is implemented using Apache Lucene.


    :ivar name: The name of the analyzer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar lower_case_terms: A value indicating whether terms should be lower-cased. Default is
     true.
    :vartype lower_case_terms: bool
    :ivar pattern: A regular expression pattern to match token separators. Default is an
     expression that matches one or more non-word characters.
    :vartype pattern: str
    :ivar flags: Regular expression flags. Known values are: "CANON_EQ", "CASE_INSENSITIVE",
     "COMMENTS", "DOTALL", "LITERAL", "MULTILINE", "UNICODE_CASE", and "UNIX_LINES".
    :vartype flags: str or ~azure.search.documents.models.RegexFlags
    :ivar stopwords: A list of stopwords.
    :vartype stopwords: list[str]
    :ivar odata_type: A URI fragment specifying the type of analyzer. Required. Default value is
     "#Microsoft.Azure.Search.PatternAnalyzer".
    :vartype odata_type: str
    """

    lower_case_terms: Optional[bool] = rest_field(
        name="lowercase", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether terms should be lower-cased. Default is true."""
    pattern: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A regular expression pattern to match token separators. Default is an
     expression that matches one or more non-word characters."""
    flags: Optional[Union[str, "_models.RegexFlags"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Regular expression flags. Known values are: \"CANON_EQ\", \"CASE_INSENSITIVE\", \"COMMENTS\",
     \"DOTALL\", \"LITERAL\", \"MULTILINE\", \"UNICODE_CASE\", and \"UNIX_LINES\"."""
    stopwords: Optional[List[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A list of stopwords."""
    odata_type: Literal["#Microsoft.Azure.Search.PatternAnalyzer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of analyzer. Required. Default value is
     \"#Microsoft.Azure.Search.PatternAnalyzer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        lower_case_terms: Optional[bool] = None,
        pattern: Optional[str] = None,
        flags: Optional[Union[str, "_models.RegexFlags"]] = None,
        stopwords: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.PatternAnalyzer", **kwargs)


class PatternCaptureTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.PatternCaptureTokenFilter"):
    """Uses Java regexes to emit multiple tokens - one for each capture group in one
    or more patterns. This token filter is implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar patterns: A list of patterns to match against each token. Required.
    :vartype patterns: list[str]
    :ivar preserve_original: A value indicating whether to return the original token even if one of
     the
     patterns matches. Default is true.
    :vartype preserve_original: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.PatternCaptureTokenFilter".
    :vartype odata_type: str
    """

    patterns: List[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A list of patterns to match against each token. Required."""
    preserve_original: Optional[bool] = rest_field(
        name="preserveOriginal", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to return the original token even if one of the
     patterns matches. Default is true."""
    odata_type: Literal["#Microsoft.Azure.Search.PatternCaptureTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.PatternCaptureTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        patterns: List[str],
        preserve_original: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.PatternCaptureTokenFilter", **kwargs)


class PatternReplaceCharFilter(CharFilter, discriminator="#Microsoft.Azure.Search.PatternReplaceCharFilter"):
    """A character filter that replaces characters in the input string. It uses a
    regular expression to identify character sequences to preserve and a
    replacement pattern to identify characters to replace. For example, given the
    input text "aa bb aa bb", pattern "(aa)\\s+(bb)", and replacement "$1#$2", the
    result would be "aa#bb aa#bb". This character filter is implemented using
    Apache Lucene.


    :ivar name: The name of the char filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar pattern: A regular expression pattern. Required.
    :vartype pattern: str
    :ivar replacement: The replacement text. Required.
    :vartype replacement: str
    :ivar odata_type: A URI fragment specifying the type of char filter. Required. Default value is
     "#Microsoft.Azure.Search.PatternReplaceCharFilter".
    :vartype odata_type: str
    """

    pattern: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A regular expression pattern. Required."""
    replacement: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The replacement text. Required."""
    odata_type: Literal["#Microsoft.Azure.Search.PatternReplaceCharFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of char filter. Required. Default value is
     \"#Microsoft.Azure.Search.PatternReplaceCharFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        pattern: str,
        replacement: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.PatternReplaceCharFilter", **kwargs)


class PatternReplaceTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.PatternReplaceTokenFilter"):
    """A character filter that replaces characters in the input string. It uses a
    regular expression to identify character sequences to preserve and a
    replacement pattern to identify characters to replace. For example, given the
    input text "aa bb aa bb", pattern "(aa)\\s+(bb)", and replacement "$1#$2", the
    result would be "aa#bb aa#bb". This token filter is implemented using Apache
    Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar pattern: A regular expression pattern. Required.
    :vartype pattern: str
    :ivar replacement: The replacement text. Required.
    :vartype replacement: str
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.PatternReplaceTokenFilter".
    :vartype odata_type: str
    """

    pattern: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A regular expression pattern. Required."""
    replacement: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The replacement text. Required."""
    odata_type: Literal["#Microsoft.Azure.Search.PatternReplaceTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.PatternReplaceTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        pattern: str,
        replacement: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.PatternReplaceTokenFilter", **kwargs)


class PatternTokenizer(LexicalTokenizer, discriminator="#Microsoft.Azure.Search.PatternTokenizer"):
    """Tokenizer that uses regex pattern matching to construct distinct tokens. This
    tokenizer is implemented using Apache Lucene.


    :ivar name: The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar pattern: A regular expression pattern to match token separators. Default is an
     expression that matches one or more non-word characters.
    :vartype pattern: str
    :ivar flags: Regular expression flags. Known values are: "CANON_EQ", "CASE_INSENSITIVE",
     "COMMENTS", "DOTALL", "LITERAL", "MULTILINE", "UNICODE_CASE", and "UNIX_LINES".
    :vartype flags: str or ~azure.search.documents.models.RegexFlags
    :ivar group: The zero-based ordinal of the matching group in the regular expression pattern
     to extract into tokens. Use -1 if you want to use the entire pattern to split
     the input into tokens, irrespective of matching groups. Default is -1.
    :vartype group: int
    :ivar odata_type: A URI fragment specifying the type of tokenizer. Required. Default value is
     "#Microsoft.Azure.Search.PatternTokenizer".
    :vartype odata_type: str
    """

    pattern: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A regular expression pattern to match token separators. Default is an
     expression that matches one or more non-word characters."""
    flags: Optional[Union[str, "_models.RegexFlags"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Regular expression flags. Known values are: \"CANON_EQ\", \"CASE_INSENSITIVE\", \"COMMENTS\",
     \"DOTALL\", \"LITERAL\", \"MULTILINE\", \"UNICODE_CASE\", and \"UNIX_LINES\"."""
    group: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The zero-based ordinal of the matching group in the regular expression pattern
     to extract into tokens. Use -1 if you want to use the entire pattern to split
     the input into tokens, irrespective of matching groups. Default is -1."""
    odata_type: Literal["#Microsoft.Azure.Search.PatternTokenizer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of tokenizer. Required. Default value is
     \"#Microsoft.Azure.Search.PatternTokenizer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        pattern: Optional[str] = None,
        flags: Optional[Union[str, "_models.RegexFlags"]] = None,
        group: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.PatternTokenizer", **kwargs)


class PhoneticTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.PhoneticTokenFilter"):
    """Create tokens for phonetic matches. This token filter is implemented using
    Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar encoder: The phonetic encoder to use. Default is "metaphone". Known values are:
     "metaphone", "doubleMetaphone", "soundex", "refinedSoundex", "caverphone1", "caverphone2",
     "cologne", "nysiis", "koelnerPhonetik", "haasePhonetik", and "beiderMorse".
    :vartype encoder: str or ~azure.search.documents.models.PhoneticEncoder
    :ivar replace_original_tokens: A value indicating whether encoded tokens should replace
     original tokens. If
     false, encoded tokens are added as synonyms. Default is true.
    :vartype replace_original_tokens: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.PhoneticTokenFilter".
    :vartype odata_type: str
    """

    encoder: Optional[Union[str, "_models.PhoneticEncoder"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The phonetic encoder to use. Default is \"metaphone\". Known values are: \"metaphone\",
     \"doubleMetaphone\", \"soundex\", \"refinedSoundex\", \"caverphone1\", \"caverphone2\",
     \"cologne\", \"nysiis\", \"koelnerPhonetik\", \"haasePhonetik\", and \"beiderMorse\"."""
    replace_original_tokens: Optional[bool] = rest_field(
        name="replace", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether encoded tokens should replace original tokens. If
     false, encoded tokens are added as synonyms. Default is true."""
    odata_type: Literal["#Microsoft.Azure.Search.PhoneticTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.PhoneticTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        encoder: Optional[Union[str, "_models.PhoneticEncoder"]] = None,
        replace_original_tokens: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.PhoneticTokenFilter", **kwargs)


class PIIDetectionSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.PIIDetectionSkill"):
    """Using the Text Analytics API, extracts personal information from an input text
    and gives you the option of masking it.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar default_language_code: A value indicating which language code to use. Default is ``en``.
    :vartype default_language_code: str
    :ivar minimum_precision: A value between 0 and 1 that be used to only include entities whose
     confidence
     score is greater than the value specified. If not set (default), or if
     explicitly set to null, all entities will be included.
    :vartype minimum_precision: float
    :ivar masking_mode: A parameter that provides various ways to mask the personal information
     detected in the input text. Default is 'none'. Known values are: "none" and "replace".
    :vartype masking_mode: str or ~azure.search.documents.models.PIIDetectionSkillMaskingMode
    :ivar mask: The character used to mask the text if the maskingMode parameter is set to
     replace. Default is '*'.
    :vartype mask: str
    :ivar model_version: The version of the model to use when calling the Text Analytics service.
     It
     will default to the latest available when not specified. We recommend you do
     not specify this value unless absolutely necessary.
    :vartype model_version: str
    :ivar pii_categories: A list of PII entity categories that should be extracted and masked.
    :vartype pii_categories: list[str]
    :ivar domain: If specified, will set the PII domain to include only a subset of the entity
     categories. Possible values include: 'phi', 'none'. Default is 'none'.
    :vartype domain: str
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.PIIDetectionSkill".
    :vartype odata_type: str
    """

    default_language_code: Optional[str] = rest_field(
        name="defaultLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which language code to use. Default is ``en``."""
    minimum_precision: Optional[float] = rest_field(
        name="minimumPrecision", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value between 0 and 1 that be used to only include entities whose confidence
     score is greater than the value specified. If not set (default), or if
     explicitly set to null, all entities will be included."""
    masking_mode: Optional[Union[str, "_models.PIIDetectionSkillMaskingMode"]] = rest_field(
        name="maskingMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A parameter that provides various ways to mask the personal information
     detected in the input text. Default is 'none'. Known values are: \"none\" and \"replace\"."""
    mask: Optional[str] = rest_field(
        name="maskingCharacter", visibility=["read", "create", "update", "delete", "query"]
    )
    """The character used to mask the text if the maskingMode parameter is set to
     replace. Default is '*'."""
    model_version: Optional[str] = rest_field(
        name="modelVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The version of the model to use when calling the Text Analytics service. It
     will default to the latest available when not specified. We recommend you do
     not specify this value unless absolutely necessary."""
    pii_categories: Optional[List[str]] = rest_field(
        name="piiCategories", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of PII entity categories that should be extracted and masked."""
    domain: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """If specified, will set the PII domain to include only a subset of the entity
     categories. Possible values include: 'phi', 'none'. Default is 'none'."""
    odata_type: Literal["#Microsoft.Skills.Text.PIIDetectionSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.PIIDetectionSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        default_language_code: Optional[str] = None,
        minimum_precision: Optional[float] = None,
        masking_mode: Optional[Union[str, "_models.PIIDetectionSkillMaskingMode"]] = None,
        mask: Optional[str] = None,
        model_version: Optional[str] = None,
        pii_categories: Optional[List[str]] = None,
        domain: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.PIIDetectionSkill", **kwargs)


class QueryAnswerResult(_model_base.Model):
    """An answer is a text passage extracted from the contents of the most relevant
    documents that matched the query. Answers are extracted from the top search
    results. Answer candidates are scored and the top answers are selected.

    :ivar score: The score value represents how relevant the answer is to the query relative to
     other answers returned for the query.
    :vartype score: float
    :ivar key: The key of the document the answer was extracted from.
    :vartype key: str
    :ivar text: The text passage extracted from the document contents as the answer.
    :vartype text: str
    :ivar highlights: Same text passage as in the Text property with highlighted text phrases most
     relevant to the query.
    :vartype highlights: str
    """

    score: Optional[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The score value represents how relevant the answer is to the query relative to
     other answers returned for the query."""
    key: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The key of the document the answer was extracted from."""
    text: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The text passage extracted from the document contents as the answer."""
    highlights: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Same text passage as in the Text property with highlighted text phrases most
     relevant to the query."""

    @overload
    def __init__(
        self,
        *,
        score: Optional[float] = None,
        key: Optional[str] = None,
        text: Optional[str] = None,
        highlights: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryCaptionResult(_model_base.Model):
    """Captions are the most representative passages from the document relatively to
    the search query. They are often used as document summary. Captions are only
    returned for queries of type ``semantic``.

    :ivar text: A representative text passage extracted from the document most relevant to the
     search query.
    :vartype text: str
    :ivar highlights: Same text passage as in the Text property with highlighted phrases most
     relevant to the query.
    :vartype highlights: str
    """

    text: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A representative text passage extracted from the document most relevant to the
     search query."""
    highlights: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Same text passage as in the Text property with highlighted phrases most
     relevant to the query."""

    @overload
    def __init__(
        self,
        *,
        text: Optional[str] = None,
        highlights: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryResultDocumentRerankerInput(_model_base.Model):
    """The raw concatenated strings that were sent to the semantic enrichment process.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar title: The raw string for the title field that was used for semantic enrichment.
    :vartype title: str
    :ivar content: The raw concatenated strings for the content fields that were used for semantic
     enrichment.
    :vartype content: str
    :ivar keywords: The raw concatenated strings for the keyword fields that were used for semantic
     enrichment.
    :vartype keywords: str
    """

    title: Optional[str] = rest_field(visibility=["read"])
    """The raw string for the title field that was used for semantic enrichment."""
    content: Optional[str] = rest_field(visibility=["read"])
    """The raw concatenated strings for the content fields that were used for semantic
     enrichment."""
    keywords: Optional[str] = rest_field(visibility=["read"])
    """The raw concatenated strings for the keyword fields that were used for semantic
     enrichment."""


class QueryResultDocumentSemanticField(_model_base.Model):
    """Description of fields that were sent to the semantic enrichment process, as
    well as how they were used.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: The name of the field that was sent to the semantic enrichment process.
    :vartype name: str
    :ivar state: The way the field was used for the semantic enrichment process (fully used,
     partially used, or unused). Known values are: "used", "unused", and "partial".
    :vartype state: str or ~azure.search.documents.models.SemanticFieldState
    """

    name: Optional[str] = rest_field(visibility=["read"])
    """The name of the field that was sent to the semantic enrichment process."""
    state: Optional[Union[str, "_models.SemanticFieldState"]] = rest_field(visibility=["read"])
    """The way the field was used for the semantic enrichment process (fully used,
     partially used, or unused). Known values are: \"used\", \"unused\", and \"partial\"."""


class QueryResultDocumentSubscores(_model_base.Model):
    """The breakdown of subscores between the text and vector query components of the
    search query for this document. Each vector query is shown as a separate object
    in the same order they were received.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar text: The BM25 or Classic score for the text portion of the query.
    :vartype text: ~azure.search.documents.models.TextResult
    :ivar vectors: The vector similarity and @search.score values for each vector query.
    :vartype vectors: list[dict[str, ~azure.search.documents.models.SingleVectorFieldResult]]
    :ivar document_boost: The BM25 or Classic score for the text portion of the query.
    :vartype document_boost: float
    """

    text: Optional["_models.TextResult"] = rest_field(visibility=["read"])
    """The BM25 or Classic score for the text portion of the query."""
    vectors: Optional[List[Dict[str, "_models.SingleVectorFieldResult"]]] = rest_field(visibility=["read"])
    """The vector similarity and @search.score values for each vector query."""
    document_boost: Optional[float] = rest_field(name="documentBoost", visibility=["read"])
    """The BM25 or Classic score for the text portion of the query."""


class QueryRewritesDebugInfo(_model_base.Model):
    """Contains debugging information specific to query rewrites.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar text: List of query rewrites generated for the text query.
    :vartype text: ~azure.search.documents.models.QueryRewritesValuesDebugInfo
    :ivar vectors: List of query rewrites generated for the vectorizable text queries.
    :vartype vectors: list[~azure.search.documents.models.QueryRewritesValuesDebugInfo]
    """

    text: Optional["_models.QueryRewritesValuesDebugInfo"] = rest_field(visibility=["read"])
    """List of query rewrites generated for the text query."""
    vectors: Optional[List["_models.QueryRewritesValuesDebugInfo"]] = rest_field(visibility=["read"])
    """List of query rewrites generated for the vectorizable text queries."""


class QueryRewritesValuesDebugInfo(_model_base.Model):
    """Contains debugging information specific to query rewrites.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar input_query: The input text to the generative query rewriting model. There may be cases
     where the user query and the input to the generative model are not identical.
    :vartype input_query: str
    :ivar rewrites: List of query rewrites.
    :vartype rewrites: list[str]
    """

    input_query: Optional[str] = rest_field(name="inputQuery", visibility=["read"])
    """The input text to the generative query rewriting model. There may be cases
     where the user query and the input to the generative model are not identical."""
    rewrites: Optional[List[str]] = rest_field(visibility=["read"])
    """List of query rewrites."""


class RescoringOptions(_model_base.Model):
    """Contains the options for rescoring.

    :ivar enable_rescoring: If set to true, after the initial search on the compressed vectors, the
     similarity scores are recalculated using the full-precision vectors. This will
     improve recall at the expense of latency.
    :vartype enable_rescoring: bool
    :ivar default_oversampling: Default oversampling factor. Oversampling retrieves a greater set
     of potential
     documents to offset the resolution loss due to quantization. This increases the
     set of results that will be rescored on full-precision vectors. Minimum value
     is 1, meaning no oversampling (1x). This parameter can only be set when 'enableRescoring'
     is true. Higher values improve recall at the expense of latency.
    :vartype default_oversampling: float
    :ivar rescore_storage_method: Controls the storage method for original vectors. This setting is
     immutable. Known values are: "preserveOriginals" and "discardOriginals".
    :vartype rescore_storage_method: str or
     ~azure.search.documents.models.VectorSearchCompressionRescoreStorageMethod
    """

    enable_rescoring: Optional[bool] = rest_field(
        name="enableRescoring", visibility=["read", "create", "update", "delete", "query"]
    )
    """If set to true, after the initial search on the compressed vectors, the
     similarity scores are recalculated using the full-precision vectors. This will
     improve recall at the expense of latency."""
    default_oversampling: Optional[float] = rest_field(
        name="defaultOversampling", visibility=["read", "create", "update", "delete", "query"]
    )
    """Default oversampling factor. Oversampling retrieves a greater set of potential
     documents to offset the resolution loss due to quantization. This increases the
     set of results that will be rescored on full-precision vectors. Minimum value
     is 1, meaning no oversampling (1x). This parameter can only be set when 'enableRescoring'
     is true. Higher values improve recall at the expense of latency."""
    rescore_storage_method: Optional[Union[str, "_models.VectorSearchCompressionRescoreStorageMethod"]] = rest_field(
        name="rescoreStorageMethod", visibility=["read", "create", "update", "delete", "query"]
    )
    """Controls the storage method for original vectors. This setting is immutable. Known values are:
     \"preserveOriginals\" and \"discardOriginals\"."""

    @overload
    def __init__(
        self,
        *,
        enable_rescoring: Optional[bool] = None,
        default_oversampling: Optional[float] = None,
        rescore_storage_method: Optional[Union[str, "_models.VectorSearchCompressionRescoreStorageMethod"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ResourceCounter(_model_base.Model):
    """Represents a resource's usage and quota.


    :ivar usage: The resource usage amount. Required.
    :vartype usage: int
    :ivar quota: The resource amount quota.
    :vartype quota: int
    """

    usage: int = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The resource usage amount. Required."""
    quota: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The resource amount quota."""

    @overload
    def __init__(
        self,
        *,
        usage: int,
        quota: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScalarQuantizationCompression(VectorSearchCompression, discriminator="scalarQuantization"):
    """Contains configuration options specific to the scalar quantization compression
    method used during indexing and querying.


    :ivar compression_name: The name to associate with this particular configuration. Required.
    :vartype compression_name: str
    :ivar rerank_with_original_vectors: If set to true, once the ordered set of results calculated
     using compressed
     vectors are obtained, they will be reranked again by recalculating the
     full-precision similarity scores. This will improve recall at the expense of
     latency.
    :vartype rerank_with_original_vectors: bool
    :ivar default_oversampling: Default oversampling factor. Oversampling will internally request
     more
     documents (specified by this multiplier) in the initial search. This increases
     the set of results that will be reranked using recomputed similarity scores
     from full-precision vectors. Minimum value is 1, meaning no oversampling (1x).
     This parameter can only be set when rerankWithOriginalVectors is true. Higher
     values improve recall at the expense of latency.
    :vartype default_oversampling: float
    :ivar rescoring_options: Contains the options for rescoring.
    :vartype rescoring_options: ~azure.search.documents.models.RescoringOptions
    :ivar truncation_dimension: The number of dimensions to truncate the vectors to. Truncating the
     vectors
     reduces the size of the vectors and the amount of data that needs to be
     transferred during search. This can save storage cost and improve search
     performance at the expense of recall. It should be only used for embeddings
     trained with Matryoshka Representation Learning (MRL) such as OpenAI
     text-embedding-3-large (small). The default value is null, which means no
     truncation.
    :vartype truncation_dimension: int
    :ivar parameters: Contains the parameters specific to Scalar Quantization.
    :vartype parameters: ~azure.search.documents.models.ScalarQuantizationParameters
    :ivar kind: The name of the kind of compression method being configured for use with vector
     search. Required. Scalar Quantization, a type of compression method. In scalar quantization,
     the
     original vectors values are compressed to a narrower type by discretizing and
     representing each component of a vector using a reduced set of quantized
     values, thereby reducing the overall data size.
    :vartype kind: str or ~azure.search.documents.models.SCALAR_QUANTIZATION
    """

    parameters: Optional["_models.ScalarQuantizationParameters"] = rest_field(
        name="scalarQuantizationParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains the parameters specific to Scalar Quantization."""
    kind: Literal[VectorSearchCompressionKind.SCALAR_QUANTIZATION] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The name of the kind of compression method being configured for use with vector
     search. Required. Scalar Quantization, a type of compression method. In scalar quantization,
     the
     original vectors values are compressed to a narrower type by discretizing and
     representing each component of a vector using a reduced set of quantized
     values, thereby reducing the overall data size."""

    @overload
    def __init__(
        self,
        *,
        compression_name: str,
        rerank_with_original_vectors: Optional[bool] = None,
        default_oversampling: Optional[float] = None,
        rescoring_options: Optional["_models.RescoringOptions"] = None,
        truncation_dimension: Optional[int] = None,
        parameters: Optional["_models.ScalarQuantizationParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorSearchCompressionKind.SCALAR_QUANTIZATION, **kwargs)


class ScalarQuantizationParameters(_model_base.Model):
    """Contains the parameters specific to Scalar Quantization.

    :ivar quantized_data_type: The quantized data type of compressed vector values. "int8"
    :vartype quantized_data_type: str or
     ~azure.search.documents.models.VectorSearchCompressionTarget
    """

    quantized_data_type: Optional[Union[str, "_models.VectorSearchCompressionTarget"]] = rest_field(
        name="quantizedDataType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The quantized data type of compressed vector values. \"int8\""""

    @overload
    def __init__(
        self,
        *,
        quantized_data_type: Optional[Union[str, "_models.VectorSearchCompressionTarget"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScoringProfile(_model_base.Model):
    """Defines parameters for a search index that influence scoring in search queries.


    :ivar name: The name of the scoring profile. Required.
    :vartype name: str
    :ivar text_weights: Parameters that boost scoring based on text matches in certain index
     fields.
    :vartype text_weights: ~azure.search.documents.models.TextWeights
    :ivar functions: The collection of functions that influence the scoring of documents.
    :vartype functions: list[~azure.search.documents.models.ScoringFunction]
    :ivar function_aggregation: A value indicating how the results of individual scoring functions
     should be
     combined. Defaults to "Sum". Ignored if there are no scoring functions. Known values are:
     "sum", "average", "minimum", "maximum", and "firstMatching".
    :vartype function_aggregation: str or ~azure.search.documents.models.ScoringFunctionAggregation
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the scoring profile. Required."""
    text_weights: Optional["_models.TextWeights"] = rest_field(
        name="text", visibility=["read", "create", "update", "delete", "query"]
    )
    """Parameters that boost scoring based on text matches in certain index fields."""
    functions: Optional[List["_models.ScoringFunction"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The collection of functions that influence the scoring of documents."""
    function_aggregation: Optional[Union[str, "_models.ScoringFunctionAggregation"]] = rest_field(
        name="functionAggregation", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating how the results of individual scoring functions should be
     combined. Defaults to \"Sum\". Ignored if there are no scoring functions. Known values are:
     \"sum\", \"average\", \"minimum\", \"maximum\", and \"firstMatching\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        text_weights: Optional["_models.TextWeights"] = None,
        functions: Optional[List["_models.ScoringFunction"]] = None,
        function_aggregation: Optional[Union[str, "_models.ScoringFunctionAggregation"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchAlias(_model_base.Model):
    """Represents an index alias, which describes a mapping from the alias name to an
    index. The alias name can be used in place of the index name for supported
    operations.


    :ivar name: The name of the alias. Required.
    :vartype name: str
    :ivar indexes: The name of the index this alias maps to. Only one index name may be specified.
     Required.
    :vartype indexes: list[str]
    :ivar e_tag: The ETag of the alias.
    :vartype e_tag: str
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the alias. Required."""
    indexes: List[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the index this alias maps to. Only one index name may be specified. Required."""
    e_tag: Optional[str] = rest_field(name="@odata.etag", visibility=["read", "create", "update", "delete", "query"])
    """The ETag of the alias."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        indexes: List[str],
        e_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchDocumentsResult(_model_base.Model):
    """Response containing search results from an index.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar count: The total count of results found by the search operation, or null if the count
     was not requested. If present, the count may be greater than the number of
     results in this response. This can happen if you use the $top or $skip
     parameters, or if the query can't return all the requested documents in a
     single response.
    :vartype count: int
    :ivar coverage: A value indicating the percentage of the index that was included in the query,
     or null if minimumCoverage was not specified in the request.
    :vartype coverage: float
    :ivar facets: The facet query results for the search operation, organized as a collection of
     buckets for each faceted field; null if the query did not include any facet
     expressions.
    :vartype facets: dict[str, list[~azure.search.documents.models.FacetResult]]
    :ivar answers: The answers query results for the search operation; null if the answers query
     parameter was not specified or set to 'none'.
    :vartype answers: list[~azure.search.documents.models.QueryAnswerResult]
    :ivar debug_info: Debug information that applies to the search results as a whole.
    :vartype debug_info: ~azure.search.documents.models.DebugInfo
    :ivar next_page_parameters: Continuation JSON payload returned when the query can't return all
     the
     requested results in a single response. You can use this JSON along with.
    :vartype next_page_parameters: ~azure.search.documents.models.SearchRequest
    :ivar results: The sequence of results returned by the query. Required.
    :vartype results: list[~azure.search.documents.models.SearchResult]
    :ivar next_link: Continuation URL returned when the query can't return all the requested
     results
     in a single response. You can use this URL to formulate another GET or POST
     Search request to get the next part of the search response. Make sure to use
     the same verb (GET or POST) as the request that produced this response.
    :vartype next_link: str
    :ivar semantic_partial_response_reason: Reason that a partial response was returned for a
     semantic ranking request. Known values are: "maxWaitExceeded", "capacityOverloaded", and
     "transient".
    :vartype semantic_partial_response_reason: str or
     ~azure.search.documents.models.SemanticErrorReason
    :ivar semantic_partial_response_type: Type of partial response that was returned for a semantic
     ranking request. Known values are: "baseResults" and "rerankedResults".
    :vartype semantic_partial_response_type: str or
     ~azure.search.documents.models.SemanticSearchResultsType
    :ivar semantic_query_rewrites_result_type: Type of query rewrite that was used to retrieve
     documents. "originalQueryOnly"
    :vartype semantic_query_rewrites_result_type: str or
     ~azure.search.documents.models.SemanticQueryRewritesResultType
    """

    count: Optional[int] = rest_field(name="@odata.count", visibility=["read", "create", "update", "delete", "query"])
    """The total count of results found by the search operation, or null if the count
     was not requested. If present, the count may be greater than the number of
     results in this response. This can happen if you use the $top or $skip
     parameters, or if the query can't return all the requested documents in a
     single response."""
    coverage: Optional[float] = rest_field(
        name="@search.coverage", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating the percentage of the index that was included in the query,
     or null if minimumCoverage was not specified in the request."""
    facets: Optional[Dict[str, List["_models.FacetResult"]]] = rest_field(
        name="@search.facets", visibility=["read", "create", "update", "delete", "query"]
    )
    """The facet query results for the search operation, organized as a collection of
     buckets for each faceted field; null if the query did not include any facet
     expressions."""
    answers: Optional[List["_models.QueryAnswerResult"]] = rest_field(
        name="@search.answers", visibility=["read", "create", "update", "delete", "query"]
    )
    """The answers query results for the search operation; null if the answers query
     parameter was not specified or set to 'none'."""
    debug_info: Optional["_models.DebugInfo"] = rest_field(name="@search.debug", visibility=["read"])
    """Debug information that applies to the search results as a whole."""
    next_page_parameters: Optional["_models.SearchRequest"] = rest_field(
        name="@search.nextPageParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """Continuation JSON payload returned when the query can't return all the
     requested results in a single response. You can use this JSON along with."""
    results: List["_models.SearchResult"] = rest_field(
        name="value", visibility=["read", "create", "update", "delete", "query"]
    )
    """The sequence of results returned by the query. Required."""
    next_link: Optional[str] = rest_field(
        name="@odata.nextLink", visibility=["read", "create", "update", "delete", "query"]
    )
    """Continuation URL returned when the query can't return all the requested results
     in a single response. You can use this URL to formulate another GET or POST
     Search request to get the next part of the search response. Make sure to use
     the same verb (GET or POST) as the request that produced this response."""
    semantic_partial_response_reason: Optional[Union[str, "_models.SemanticErrorReason"]] = rest_field(
        name="@search.semanticPartialResponseReason", visibility=["read", "create", "update", "delete", "query"]
    )
    """Reason that a partial response was returned for a semantic ranking request. Known values are:
     \"maxWaitExceeded\", \"capacityOverloaded\", and \"transient\"."""
    semantic_partial_response_type: Optional[Union[str, "_models.SemanticSearchResultsType"]] = rest_field(
        name="@search.semanticPartialResponseType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of partial response that was returned for a semantic ranking request. Known values are:
     \"baseResults\" and \"rerankedResults\"."""
    semantic_query_rewrites_result_type: Optional[Union[str, "_models.SemanticQueryRewritesResultType"]] = rest_field(
        name="@search.semanticQueryRewritesResultType", visibility=["read"]
    )
    """Type of query rewrite that was used to retrieve documents. \"originalQueryOnly\""""

    @overload
    def __init__(
        self,
        *,
        results: List["_models.SearchResult"],
        count: Optional[int] = None,
        coverage: Optional[float] = None,
        facets: Optional[Dict[str, List["_models.FacetResult"]]] = None,
        answers: Optional[List["_models.QueryAnswerResult"]] = None,
        next_page_parameters: Optional["_models.SearchRequest"] = None,
        next_link: Optional[str] = None,
        semantic_partial_response_reason: Optional[Union[str, "_models.SemanticErrorReason"]] = None,
        semantic_partial_response_type: Optional[Union[str, "_models.SemanticSearchResultsType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchField(_model_base.Model):
    """Represents a field in an index definition, which describes the name, data type,
    and search behavior of a field.


    :ivar name: The name of the field, which must be unique within the fields collection of the
     index or parent field. Required.
    :vartype name: str
    :ivar type: The data type of the field. Required. Known values are: "Edm.String", "Edm.Int32",
     "Edm.Int64", "Edm.Double", "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
     "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte", and "Edm.Byte".
    :vartype type: str or ~azure.search.documents.models.SearchFieldDataType
    :ivar key: A value indicating whether the field uniquely identifies documents in the
     index. Exactly one top-level field in each index must be chosen as the key
     field and it must be of type Edm.String. Key fields can be used to look up
     documents directly and update or delete specific documents. Default is false
     for simple fields and null for complex fields.
    :vartype key: bool
    :ivar retrievable: A value indicating whether the field can be returned in a search result. You
     can disable this option if you want to use a field (for example, margin) as a
     filter, sorting, or scoring mechanism but do not want the field to be visible
     to the end user. This property must be true for key fields, and it must be null
     for complex fields. This property can be changed on existing fields. Enabling
     this property does not cause any increase in index storage requirements.
     Default is true for simple fields, false for vector fields, and null for
     complex fields.
    :vartype retrievable: bool
    :ivar stored: An immutable value indicating whether the field will be persisted separately on
     disk to be returned in a search result. You can disable this option if you
     don't plan to return the field contents in a search response to save on storage
     overhead. This can only be set during index creation and only for vector
     fields. This property cannot be changed for existing fields or set as false for
     new fields. If this property is set as false, the property 'retrievable' must
     also be set to false. This property must be true or unset for key fields, for
     new fields, and for non-vector fields, and it must be null for complex fields.
     Disabling this property will reduce index storage requirements. The default is
     true for vector fields.
    :vartype stored: bool
    :ivar searchable: A value indicating whether the field is full-text searchable. This means it
     will undergo analysis such as word-breaking during indexing. If you set a
     searchable field to a value like "sunny day", internally it will be split into
     the individual tokens "sunny" and "day". This enables full-text searches for
     these terms. Fields of type Edm.String or Collection(Edm.String) are searchable
     by default. This property must be false for simple fields of other non-string
     data types, and it must be null for complex fields. Note: searchable fields
     consume extra space in your index to accommodate additional tokenized versions
     of the field value for full-text searches. If you want to save space in your
     index and you don't need a field to be included in searches, set searchable to
     false.
    :vartype searchable: bool
    :ivar filterable: A value indicating whether to enable the field to be referenced in $filter
     queries. filterable differs from searchable in how strings are handled. Fields
     of type Edm.String or Collection(Edm.String) that are filterable do not undergo
     word-breaking, so comparisons are for exact matches only. For example, if you
     set such a field f to "sunny day", $filter=f eq 'sunny' will find no matches,
     but $filter=f eq 'sunny day' will. This property must be null for complex
     fields. Default is true for simple fields and null for complex fields.
    :vartype filterable: bool
    :ivar sortable: A value indicating whether to enable the field to be referenced in $orderby
     expressions. By default, the search engine sorts results by score, but in many
     experiences users will want to sort by fields in the documents. A simple field
     can be sortable only if it is single-valued (it has a single value in the scope
     of the parent document). Simple collection fields cannot be sortable, since
     they are multi-valued. Simple sub-fields of complex collections are also
     multi-valued, and therefore cannot be sortable. This is true whether it's an
     immediate parent field, or an ancestor field, that's the complex collection.
     Complex fields cannot be sortable and the sortable property must be null for
     such fields. The default for sortable is true for single-valued simple fields,
     false for multi-valued simple fields, and null for complex fields.
    :vartype sortable: bool
    :ivar facetable: A value indicating whether to enable the field to be referenced in facet
     queries. Typically used in a presentation of search results that includes hit
     count by category (for example, search for digital cameras and see hits by
     brand, by megapixels, by price, and so on). This property must be null for
     complex fields. Fields of type Edm.GeographyPoint or
     Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all
     other simple fields.
    :vartype facetable: bool
    :ivar analyzer: The name of the analyzer to use for the field. This option can be used only
     with searchable fields and it can't be set together with either searchAnalyzer
     or indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the
     field. Must be null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
     "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft",
     "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft", "zh-Hant.lucene",
     "hr.microsoft", "cs.microsoft", "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft",
     "nl.lucene", "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
     "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
     "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene", "hu.microsoft",
     "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft",
     "it.lucene", "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
     "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
     "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene", "pt-BR.microsoft",
     "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft", "ro.lucene",
     "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
     "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft",
     "te.microsoft", "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
     "ur.microsoft", "vi.microsoft", "standard.lucene", "standardasciifolding.lucene", "keyword",
     "pattern", "simple", "stop", and "whitespace".
    :vartype analyzer: str or ~azure.search.documents.models.LexicalAnalyzerName
    :ivar search_analyzer: The name of the analyzer used at search time for the field. This option
     can be
     used only with searchable fields. It must be set together with indexAnalyzer
     and it cannot be set together with the analyzer option. This property cannot be
     set to the name of a language analyzer; use the analyzer property instead if
     you need a language analyzer. This analyzer can be updated on an existing
     field. Must be null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
     "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft",
     "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft", "zh-Hant.lucene",
     "hr.microsoft", "cs.microsoft", "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft",
     "nl.lucene", "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
     "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
     "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene", "hu.microsoft",
     "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft",
     "it.lucene", "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
     "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
     "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene", "pt-BR.microsoft",
     "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft", "ro.lucene",
     "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
     "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft",
     "te.microsoft", "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
     "ur.microsoft", "vi.microsoft", "standard.lucene", "standardasciifolding.lucene", "keyword",
     "pattern", "simple", "stop", and "whitespace".
    :vartype search_analyzer: str or ~azure.search.documents.models.LexicalAnalyzerName
    :ivar index_analyzer: The name of the analyzer used at indexing time for the field. This option
     can
     be used only with searchable fields. It must be set together with
     searchAnalyzer and it cannot be set together with the analyzer option.  This
     property cannot be set to the name of a language analyzer; use the analyzer
     property instead if you need a language analyzer. Once the analyzer is chosen,
     it cannot be changed for the field. Must be null for complex fields. Known values are:
     "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft",
     "bg.lucene", "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
     "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
     "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft", "en.lucene",
     "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft", "fr.lucene", "gl.lucene",
     "de.microsoft", "de.lucene", "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
     "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft",
     "id.lucene", "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
     "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene", "lt.microsoft",
     "ml.microsoft", "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
     "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft",
     "pt-PT.lucene", "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
     "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
     "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft", "th.microsoft",
     "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft", "vi.microsoft",
     "standard.lucene", "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop", and
     "whitespace".
    :vartype index_analyzer: str or ~azure.search.documents.models.LexicalAnalyzerName
    :ivar normalizer: The name of the normalizer to use for the field. This option can be used only
     with fields with filterable, sortable, or facetable enabled. Once the
     normalizer is chosen, it cannot be changed for the field. Must be null for
     complex fields. Known values are: "asciifolding", "elision", "lowercase", "standard", and
     "uppercase".
    :vartype normalizer: str or ~azure.search.documents.models.LexicalNormalizerName
    :ivar vector_search_dimensions: The dimensionality of the vector field.
    :vartype vector_search_dimensions: int
    :ivar vector_search_profile_name: The name of the vector search profile that specifies the
     algorithm and
     vectorizer to use when searching the vector field.
    :vartype vector_search_profile_name: str
    :ivar vector_encoding_format: The encoding format to interpret the field contents. "packedBit"
    :vartype vector_encoding_format: str or ~azure.search.documents.models.VectorEncodingFormat
    :ivar synonym_maps: A list of the names of synonym maps to associate with this field. This
     option
     can be used only with searchable fields. Currently only one synonym map per
     field is supported. Assigning a synonym map to a field ensures that query terms
     targeting that field are expanded at query-time using the rules in the synonym
     map. This attribute can be changed on existing fields. Must be null or an empty
     collection for complex fields.
    :vartype synonym_maps: list[str]
    :ivar fields: A list of sub-fields if this is a field of type Edm.ComplexType or
     Collection(Edm.ComplexType). Must be null or empty for simple fields.
    :vartype fields: list[~azure.search.documents.models.SearchField]
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the field, which must be unique within the fields collection of the
     index or parent field. Required."""
    type: Union[str, "_models.SearchFieldDataType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The data type of the field. Required. Known values are: \"Edm.String\", \"Edm.Int32\",
     \"Edm.Int64\", \"Edm.Double\", \"Edm.Boolean\", \"Edm.DateTimeOffset\", \"Edm.GeographyPoint\",
     \"Edm.ComplexType\", \"Edm.Single\", \"Edm.Half\", \"Edm.Int16\", \"Edm.SByte\", and
     \"Edm.Byte\"."""
    key: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A value indicating whether the field uniquely identifies documents in the
     index. Exactly one top-level field in each index must be chosen as the key
     field and it must be of type Edm.String. Key fields can be used to look up
     documents directly and update or delete specific documents. Default is false
     for simple fields and null for complex fields."""
    retrievable: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A value indicating whether the field can be returned in a search result. You
     can disable this option if you want to use a field (for example, margin) as a
     filter, sorting, or scoring mechanism but do not want the field to be visible
     to the end user. This property must be true for key fields, and it must be null
     for complex fields. This property can be changed on existing fields. Enabling
     this property does not cause any increase in index storage requirements.
     Default is true for simple fields, false for vector fields, and null for
     complex fields."""
    stored: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """An immutable value indicating whether the field will be persisted separately on
     disk to be returned in a search result. You can disable this option if you
     don't plan to return the field contents in a search response to save on storage
     overhead. This can only be set during index creation and only for vector
     fields. This property cannot be changed for existing fields or set as false for
     new fields. If this property is set as false, the property 'retrievable' must
     also be set to false. This property must be true or unset for key fields, for
     new fields, and for non-vector fields, and it must be null for complex fields.
     Disabling this property will reduce index storage requirements. The default is
     true for vector fields."""
    searchable: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A value indicating whether the field is full-text searchable. This means it
     will undergo analysis such as word-breaking during indexing. If you set a
     searchable field to a value like \"sunny day\", internally it will be split into
     the individual tokens \"sunny\" and \"day\". This enables full-text searches for
     these terms. Fields of type Edm.String or Collection(Edm.String) are searchable
     by default. This property must be false for simple fields of other non-string
     data types, and it must be null for complex fields. Note: searchable fields
     consume extra space in your index to accommodate additional tokenized versions
     of the field value for full-text searches. If you want to save space in your
     index and you don't need a field to be included in searches, set searchable to
     false."""
    filterable: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A value indicating whether to enable the field to be referenced in $filter
     queries. filterable differs from searchable in how strings are handled. Fields
     of type Edm.String or Collection(Edm.String) that are filterable do not undergo
     word-breaking, so comparisons are for exact matches only. For example, if you
     set such a field f to \"sunny day\", $filter=f eq 'sunny' will find no matches,
     but $filter=f eq 'sunny day' will. This property must be null for complex
     fields. Default is true for simple fields and null for complex fields."""
    sortable: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A value indicating whether to enable the field to be referenced in $orderby
     expressions. By default, the search engine sorts results by score, but in many
     experiences users will want to sort by fields in the documents. A simple field
     can be sortable only if it is single-valued (it has a single value in the scope
     of the parent document). Simple collection fields cannot be sortable, since
     they are multi-valued. Simple sub-fields of complex collections are also
     multi-valued, and therefore cannot be sortable. This is true whether it's an
     immediate parent field, or an ancestor field, that's the complex collection.
     Complex fields cannot be sortable and the sortable property must be null for
     such fields. The default for sortable is true for single-valued simple fields,
     false for multi-valued simple fields, and null for complex fields."""
    facetable: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A value indicating whether to enable the field to be referenced in facet
     queries. Typically used in a presentation of search results that includes hit
     count by category (for example, search for digital cameras and see hits by
     brand, by megapixels, by price, and so on). This property must be null for
     complex fields. Fields of type Edm.GeographyPoint or
     Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all
     other simple fields."""
    analyzer: Optional[Union[str, "_models.LexicalAnalyzerName"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the analyzer to use for the field. This option can be used only
     with searchable fields and it can't be set together with either searchAnalyzer
     or indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the
     field. Must be null for complex fields. Known values are: \"ar.microsoft\", \"ar.lucene\",
     \"hy.lucene\", \"bn.microsoft\", \"eu.lucene\", \"bg.microsoft\", \"bg.lucene\",
     \"ca.microsoft\", \"ca.lucene\", \"zh-Hans.microsoft\", \"zh-Hans.lucene\",
     \"zh-Hant.microsoft\", \"zh-Hant.lucene\", \"hr.microsoft\", \"cs.microsoft\", \"cs.lucene\",
     \"da.microsoft\", \"da.lucene\", \"nl.microsoft\", \"nl.lucene\", \"en.microsoft\",
     \"en.lucene\", \"et.microsoft\", \"fi.microsoft\", \"fi.lucene\", \"fr.microsoft\",
     \"fr.lucene\", \"gl.lucene\", \"de.microsoft\", \"de.lucene\", \"el.microsoft\", \"el.lucene\",
     \"gu.microsoft\", \"he.microsoft\", \"hi.microsoft\", \"hi.lucene\", \"hu.microsoft\",
     \"hu.lucene\", \"is.microsoft\", \"id.microsoft\", \"id.lucene\", \"ga.lucene\",
     \"it.microsoft\", \"it.lucene\", \"ja.microsoft\", \"ja.lucene\", \"kn.microsoft\",
     \"ko.microsoft\", \"ko.lucene\", \"lv.microsoft\", \"lv.lucene\", \"lt.microsoft\",
     \"ml.microsoft\", \"ms.microsoft\", \"mr.microsoft\", \"nb.microsoft\", \"no.lucene\",
     \"fa.lucene\", \"pl.microsoft\", \"pl.lucene\", \"pt-BR.microsoft\", \"pt-BR.lucene\",
     \"pt-PT.microsoft\", \"pt-PT.lucene\", \"pa.microsoft\", \"ro.microsoft\", \"ro.lucene\",
     \"ru.microsoft\", \"ru.lucene\", \"sr-cyrillic.microsoft\", \"sr-latin.microsoft\",
     \"sk.microsoft\", \"sl.microsoft\", \"es.microsoft\", \"es.lucene\", \"sv.microsoft\",
     \"sv.lucene\", \"ta.microsoft\", \"te.microsoft\", \"th.microsoft\", \"th.lucene\",
     \"tr.microsoft\", \"tr.lucene\", \"uk.microsoft\", \"ur.microsoft\", \"vi.microsoft\",
     \"standard.lucene\", \"standardasciifolding.lucene\", \"keyword\", \"pattern\", \"simple\",
     \"stop\", and \"whitespace\"."""
    search_analyzer: Optional[Union[str, "_models.LexicalAnalyzerName"]] = rest_field(
        name="searchAnalyzer", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the analyzer used at search time for the field. This option can be
     used only with searchable fields. It must be set together with indexAnalyzer
     and it cannot be set together with the analyzer option. This property cannot be
     set to the name of a language analyzer; use the analyzer property instead if
     you need a language analyzer. This analyzer can be updated on an existing
     field. Must be null for complex fields. Known values are: \"ar.microsoft\", \"ar.lucene\",
     \"hy.lucene\", \"bn.microsoft\", \"eu.lucene\", \"bg.microsoft\", \"bg.lucene\",
     \"ca.microsoft\", \"ca.lucene\", \"zh-Hans.microsoft\", \"zh-Hans.lucene\",
     \"zh-Hant.microsoft\", \"zh-Hant.lucene\", \"hr.microsoft\", \"cs.microsoft\", \"cs.lucene\",
     \"da.microsoft\", \"da.lucene\", \"nl.microsoft\", \"nl.lucene\", \"en.microsoft\",
     \"en.lucene\", \"et.microsoft\", \"fi.microsoft\", \"fi.lucene\", \"fr.microsoft\",
     \"fr.lucene\", \"gl.lucene\", \"de.microsoft\", \"de.lucene\", \"el.microsoft\", \"el.lucene\",
     \"gu.microsoft\", \"he.microsoft\", \"hi.microsoft\", \"hi.lucene\", \"hu.microsoft\",
     \"hu.lucene\", \"is.microsoft\", \"id.microsoft\", \"id.lucene\", \"ga.lucene\",
     \"it.microsoft\", \"it.lucene\", \"ja.microsoft\", \"ja.lucene\", \"kn.microsoft\",
     \"ko.microsoft\", \"ko.lucene\", \"lv.microsoft\", \"lv.lucene\", \"lt.microsoft\",
     \"ml.microsoft\", \"ms.microsoft\", \"mr.microsoft\", \"nb.microsoft\", \"no.lucene\",
     \"fa.lucene\", \"pl.microsoft\", \"pl.lucene\", \"pt-BR.microsoft\", \"pt-BR.lucene\",
     \"pt-PT.microsoft\", \"pt-PT.lucene\", \"pa.microsoft\", \"ro.microsoft\", \"ro.lucene\",
     \"ru.microsoft\", \"ru.lucene\", \"sr-cyrillic.microsoft\", \"sr-latin.microsoft\",
     \"sk.microsoft\", \"sl.microsoft\", \"es.microsoft\", \"es.lucene\", \"sv.microsoft\",
     \"sv.lucene\", \"ta.microsoft\", \"te.microsoft\", \"th.microsoft\", \"th.lucene\",
     \"tr.microsoft\", \"tr.lucene\", \"uk.microsoft\", \"ur.microsoft\", \"vi.microsoft\",
     \"standard.lucene\", \"standardasciifolding.lucene\", \"keyword\", \"pattern\", \"simple\",
     \"stop\", and \"whitespace\"."""
    index_analyzer: Optional[Union[str, "_models.LexicalAnalyzerName"]] = rest_field(
        name="indexAnalyzer", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the analyzer used at indexing time for the field. This option can
     be used only with searchable fields. It must be set together with
     searchAnalyzer and it cannot be set together with the analyzer option.  This
     property cannot be set to the name of a language analyzer; use the analyzer
     property instead if you need a language analyzer. Once the analyzer is chosen,
     it cannot be changed for the field. Must be null for complex fields. Known values are:
     \"ar.microsoft\", \"ar.lucene\", \"hy.lucene\", \"bn.microsoft\", \"eu.lucene\",
     \"bg.microsoft\", \"bg.lucene\", \"ca.microsoft\", \"ca.lucene\", \"zh-Hans.microsoft\",
     \"zh-Hans.lucene\", \"zh-Hant.microsoft\", \"zh-Hant.lucene\", \"hr.microsoft\",
     \"cs.microsoft\", \"cs.lucene\", \"da.microsoft\", \"da.lucene\", \"nl.microsoft\",
     \"nl.lucene\", \"en.microsoft\", \"en.lucene\", \"et.microsoft\", \"fi.microsoft\",
     \"fi.lucene\", \"fr.microsoft\", \"fr.lucene\", \"gl.lucene\", \"de.microsoft\", \"de.lucene\",
     \"el.microsoft\", \"el.lucene\", \"gu.microsoft\", \"he.microsoft\", \"hi.microsoft\",
     \"hi.lucene\", \"hu.microsoft\", \"hu.lucene\", \"is.microsoft\", \"id.microsoft\",
     \"id.lucene\", \"ga.lucene\", \"it.microsoft\", \"it.lucene\", \"ja.microsoft\", \"ja.lucene\",
     \"kn.microsoft\", \"ko.microsoft\", \"ko.lucene\", \"lv.microsoft\", \"lv.lucene\",
     \"lt.microsoft\", \"ml.microsoft\", \"ms.microsoft\", \"mr.microsoft\", \"nb.microsoft\",
     \"no.lucene\", \"fa.lucene\", \"pl.microsoft\", \"pl.lucene\", \"pt-BR.microsoft\",
     \"pt-BR.lucene\", \"pt-PT.microsoft\", \"pt-PT.lucene\", \"pa.microsoft\", \"ro.microsoft\",
     \"ro.lucene\", \"ru.microsoft\", \"ru.lucene\", \"sr-cyrillic.microsoft\",
     \"sr-latin.microsoft\", \"sk.microsoft\", \"sl.microsoft\", \"es.microsoft\", \"es.lucene\",
     \"sv.microsoft\", \"sv.lucene\", \"ta.microsoft\", \"te.microsoft\", \"th.microsoft\",
     \"th.lucene\", \"tr.microsoft\", \"tr.lucene\", \"uk.microsoft\", \"ur.microsoft\",
     \"vi.microsoft\", \"standard.lucene\", \"standardasciifolding.lucene\", \"keyword\",
     \"pattern\", \"simple\", \"stop\", and \"whitespace\"."""
    normalizer: Optional[Union[str, "_models.LexicalNormalizerName"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the normalizer to use for the field. This option can be used only
     with fields with filterable, sortable, or facetable enabled. Once the
     normalizer is chosen, it cannot be changed for the field. Must be null for
     complex fields. Known values are: \"asciifolding\", \"elision\", \"lowercase\", \"standard\",
     and \"uppercase\"."""
    vector_search_dimensions: Optional[int] = rest_field(
        name="dimensions", visibility=["read", "create", "update", "delete", "query"]
    )
    """The dimensionality of the vector field."""
    vector_search_profile_name: Optional[str] = rest_field(
        name="vectorSearchProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the vector search profile that specifies the algorithm and
     vectorizer to use when searching the vector field."""
    vector_encoding_format: Optional[Union[str, "_models.VectorEncodingFormat"]] = rest_field(
        name="vectorEncoding", visibility=["read", "create", "update", "delete", "query"]
    )
    """The encoding format to interpret the field contents. \"packedBit\""""
    synonym_maps: Optional[List[str]] = rest_field(
        name="synonymMaps", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of the names of synonym maps to associate with this field. This option
     can be used only with searchable fields. Currently only one synonym map per
     field is supported. Assigning a synonym map to a field ensures that query terms
     targeting that field are expanded at query-time using the rules in the synonym
     map. This attribute can be changed on existing fields. Must be null or an empty
     collection for complex fields."""
    fields: Optional[List["_models.SearchField"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of sub-fields if this is a field of type Edm.ComplexType or
     Collection(Edm.ComplexType). Must be null or empty for simple fields."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        type: Union[str, "_models.SearchFieldDataType"],
        key: Optional[bool] = None,
        retrievable: Optional[bool] = None,
        stored: Optional[bool] = None,
        searchable: Optional[bool] = None,
        filterable: Optional[bool] = None,
        sortable: Optional[bool] = None,
        facetable: Optional[bool] = None,
        analyzer: Optional[Union[str, "_models.LexicalAnalyzerName"]] = None,
        search_analyzer: Optional[Union[str, "_models.LexicalAnalyzerName"]] = None,
        index_analyzer: Optional[Union[str, "_models.LexicalAnalyzerName"]] = None,
        normalizer: Optional[Union[str, "_models.LexicalNormalizerName"]] = None,
        vector_search_dimensions: Optional[int] = None,
        vector_search_profile_name: Optional[str] = None,
        vector_encoding_format: Optional[Union[str, "_models.VectorEncodingFormat"]] = None,
        synonym_maps: Optional[List[str]] = None,
        fields: Optional[List["_models.SearchField"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndex(_model_base.Model):
    """Represents a search index definition, which describes the fields and search
    behavior of an index.


    :ivar name: The name of the index. Required.
    :vartype name: str
    :ivar fields: The fields of the index. Required.
    :vartype fields: list[~azure.search.documents.models.SearchField]
    :ivar scoring_profiles: The scoring profiles for the index.
    :vartype scoring_profiles: list[~azure.search.documents.models.ScoringProfile]
    :ivar default_scoring_profile: The name of the scoring profile to use if none is specified in
     the query. If
     this property is not set and no scoring profile is specified in the query, then
     default scoring (tf-idf) will be used.
    :vartype default_scoring_profile: str
    :ivar cors_options: Options to control Cross-Origin Resource Sharing (CORS) for the index.
    :vartype cors_options: ~azure.search.documents.models.CorsOptions
    :ivar suggesters: The suggesters for the index.
    :vartype suggesters: list[~azure.search.documents.models.SearchSuggester]
    :ivar analyzers: The analyzers for the index.
    :vartype analyzers: list[~azure.search.documents.models.LexicalAnalyzer]
    :ivar tokenizers: The tokenizers for the index.
    :vartype tokenizers: list[~azure.search.documents.models.LexicalTokenizer]
    :ivar token_filters: The token filters for the index.
    :vartype token_filters: list[~azure.search.documents.models.TokenFilter]
    :ivar char_filters: The character filters for the index.
    :vartype char_filters: list[~azure.search.documents.models.CharFilter]
    :ivar normalizers: The normalizers for the index.
    :vartype normalizers: list[~azure.search.documents.models.LexicalNormalizer]
    :ivar encryption_key: A description of an encryption key that you create in Azure Key Vault.
     This key
     is used to provide an additional level of encryption-at-rest for your data when
     you want full assurance that no one, not even Microsoft, can decrypt your data.
     Once you have encrypted your data, it will always remain encrypted. The search
     service will ignore attempts to set this property to null. You can change this
     property as needed if you want to rotate your encryption key; Your data will be
     unaffected. Encryption with customer-managed keys is not available for free
     search services, and is only available for paid services created on or after
     January 1, 2019.
    :vartype encryption_key: ~azure.search.documents.models.SearchResourceEncryptionKey
    :ivar similarity: The type of similarity algorithm to be used when scoring and ranking the
     documents matching a search query. The similarity algorithm can only be defined
     at index creation time and cannot be modified on existing indexes. If null, the
     ClassicSimilarity algorithm is used.
    :vartype similarity: ~azure.search.documents.models.SimilarityAlgorithm
    :ivar semantic_search: Defines parameters for a search index that influence semantic
     capabilities.
    :vartype semantic_search: ~azure.search.documents.models.SemanticSearch
    :ivar vector_search: Contains configuration options related to vector search.
    :vartype vector_search: ~azure.search.documents.models.VectorSearch
    :ivar e_tag: The ETag of the index.
    :vartype e_tag: str
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the index. Required."""
    fields: List["_models.SearchField"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The fields of the index. Required."""
    scoring_profiles: Optional[List["_models.ScoringProfile"]] = rest_field(
        name="scoringProfiles", visibility=["read", "create", "update", "delete", "query"]
    )
    """The scoring profiles for the index."""
    default_scoring_profile: Optional[str] = rest_field(
        name="defaultScoringProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the scoring profile to use if none is specified in the query. If
     this property is not set and no scoring profile is specified in the query, then
     default scoring (tf-idf) will be used."""
    cors_options: Optional["_models.CorsOptions"] = rest_field(
        name="corsOptions", visibility=["read", "create", "update", "delete", "query"]
    )
    """Options to control Cross-Origin Resource Sharing (CORS) for the index."""
    suggesters: Optional[List["_models.SearchSuggester"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The suggesters for the index."""
    analyzers: Optional[List["_models.LexicalAnalyzer"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The analyzers for the index."""
    tokenizers: Optional[List["_models.LexicalTokenizer"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The tokenizers for the index."""
    token_filters: Optional[List["_models.TokenFilter"]] = rest_field(
        name="tokenFilters", visibility=["read", "create", "update", "delete", "query"]
    )
    """The token filters for the index."""
    char_filters: Optional[List["_models.CharFilter"]] = rest_field(
        name="charFilters", visibility=["read", "create", "update", "delete", "query"]
    )
    """The character filters for the index."""
    normalizers: Optional[List["_models.LexicalNormalizer"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The normalizers for the index."""
    encryption_key: Optional["_models.SearchResourceEncryptionKey"] = rest_field(
        name="encryptionKey", visibility=["read", "create", "update", "delete", "query"]
    )
    """A description of an encryption key that you create in Azure Key Vault. This key
     is used to provide an additional level of encryption-at-rest for your data when
     you want full assurance that no one, not even Microsoft, can decrypt your data.
     Once you have encrypted your data, it will always remain encrypted. The search
     service will ignore attempts to set this property to null. You can change this
     property as needed if you want to rotate your encryption key; Your data will be
     unaffected. Encryption with customer-managed keys is not available for free
     search services, and is only available for paid services created on or after
     January 1, 2019."""
    similarity: Optional["_models.SimilarityAlgorithm"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of similarity algorithm to be used when scoring and ranking the
     documents matching a search query. The similarity algorithm can only be defined
     at index creation time and cannot be modified on existing indexes. If null, the
     ClassicSimilarity algorithm is used."""
    semantic_search: Optional["_models.SemanticSearch"] = rest_field(
        name="semantic", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines parameters for a search index that influence semantic capabilities."""
    vector_search: Optional["_models.VectorSearch"] = rest_field(
        name="vectorSearch", visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains configuration options related to vector search."""
    e_tag: Optional[str] = rest_field(name="@odata.etag", visibility=["read", "create", "update", "delete", "query"])
    """The ETag of the index."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        fields: List["_models.SearchField"],
        scoring_profiles: Optional[List["_models.ScoringProfile"]] = None,
        default_scoring_profile: Optional[str] = None,
        cors_options: Optional["_models.CorsOptions"] = None,
        suggesters: Optional[List["_models.SearchSuggester"]] = None,
        analyzers: Optional[List["_models.LexicalAnalyzer"]] = None,
        tokenizers: Optional[List["_models.LexicalTokenizer"]] = None,
        token_filters: Optional[List["_models.TokenFilter"]] = None,
        char_filters: Optional[List["_models.CharFilter"]] = None,
        normalizers: Optional[List["_models.LexicalNormalizer"]] = None,
        encryption_key: Optional["_models.SearchResourceEncryptionKey"] = None,
        similarity: Optional["_models.SimilarityAlgorithm"] = None,
        semantic_search: Optional["_models.SemanticSearch"] = None,
        vector_search: Optional["_models.VectorSearch"] = None,
        e_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexer(_model_base.Model):
    """Represents an indexer.


    :ivar name: The name of the indexer. Required.
    :vartype name: str
    :ivar description: The description of the indexer.
    :vartype description: str
    :ivar data_source_name: The name of the datasource from which this indexer reads data.
     Required.
    :vartype data_source_name: str
    :ivar skillset_name: The name of the skillset executing with this indexer.
    :vartype skillset_name: str
    :ivar target_index_name: The name of the index to which this indexer writes data. Required.
    :vartype target_index_name: str
    :ivar schedule: The schedule for this indexer.
    :vartype schedule: ~azure.search.documents.models.IndexingSchedule
    :ivar parameters: Parameters for indexer execution.
    :vartype parameters: ~azure.search.documents.models.IndexingParameters
    :ivar field_mappings: Defines mappings between fields in the data source and corresponding
     target
     fields in the index.
    :vartype field_mappings: list[~azure.search.documents.models.FieldMapping]
    :ivar output_field_mappings: Output field mappings are applied after enrichment and immediately
     before
     indexing.
    :vartype output_field_mappings: list[~azure.search.documents.models.FieldMapping]
    :ivar is_disabled: A value indicating whether the indexer is disabled. Default is false.
    :vartype is_disabled: bool
    :ivar e_tag: The ETag of the indexer.
    :vartype e_tag: str
    :ivar encryption_key: A description of an encryption key that you create in Azure Key Vault.
     This key
     is used to provide an additional level of encryption-at-rest for your indexer
     definition (as well as indexer execution status) when you want full assurance
     that no one, not even Microsoft, can decrypt them. Once you have encrypted your
     indexer definition, it will always remain encrypted. The search service will
     ignore attempts to set this property to null. You can change this property as
     needed if you want to rotate your encryption key; Your indexer definition (and
     indexer execution status) will be unaffected. Encryption with customer-managed
     keys is not available for free search services, and is only available for paid
     services created on or after January 1, 2019.
    :vartype encryption_key: ~azure.search.documents.models.SearchResourceEncryptionKey
    :ivar cache: Adds caching to an enrichment pipeline to allow for incremental modification
     steps without having to rebuild the index every time.
    :vartype cache: ~azure.search.documents.models.SearchIndexerCache
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the indexer. Required."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The description of the indexer."""
    data_source_name: str = rest_field(
        name="dataSourceName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the datasource from which this indexer reads data. Required."""
    skillset_name: Optional[str] = rest_field(
        name="skillsetName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the skillset executing with this indexer."""
    target_index_name: str = rest_field(
        name="targetIndexName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the index to which this indexer writes data. Required."""
    schedule: Optional["_models.IndexingSchedule"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The schedule for this indexer."""
    parameters: Optional["_models.IndexingParameters"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Parameters for indexer execution."""
    field_mappings: Optional[List["_models.FieldMapping"]] = rest_field(
        name="fieldMappings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines mappings between fields in the data source and corresponding target
     fields in the index."""
    output_field_mappings: Optional[List["_models.FieldMapping"]] = rest_field(
        name="outputFieldMappings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Output field mappings are applied after enrichment and immediately before
     indexing."""
    is_disabled: Optional[bool] = rest_field(
        name="disabled", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether the indexer is disabled. Default is false."""
    e_tag: Optional[str] = rest_field(name="@odata.etag", visibility=["read", "create", "update", "delete", "query"])
    """The ETag of the indexer."""
    encryption_key: Optional["_models.SearchResourceEncryptionKey"] = rest_field(
        name="encryptionKey", visibility=["read", "create", "update", "delete", "query"]
    )
    """A description of an encryption key that you create in Azure Key Vault. This key
     is used to provide an additional level of encryption-at-rest for your indexer
     definition (as well as indexer execution status) when you want full assurance
     that no one, not even Microsoft, can decrypt them. Once you have encrypted your
     indexer definition, it will always remain encrypted. The search service will
     ignore attempts to set this property to null. You can change this property as
     needed if you want to rotate your encryption key; Your indexer definition (and
     indexer execution status) will be unaffected. Encryption with customer-managed
     keys is not available for free search services, and is only available for paid
     services created on or after January 1, 2019."""
    cache: Optional["_models.SearchIndexerCache"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Adds caching to an enrichment pipeline to allow for incremental modification
     steps without having to rebuild the index every time."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        data_source_name: str,
        target_index_name: str,
        description: Optional[str] = None,
        skillset_name: Optional[str] = None,
        schedule: Optional["_models.IndexingSchedule"] = None,
        parameters: Optional["_models.IndexingParameters"] = None,
        field_mappings: Optional[List["_models.FieldMapping"]] = None,
        output_field_mappings: Optional[List["_models.FieldMapping"]] = None,
        is_disabled: Optional[bool] = None,
        e_tag: Optional[str] = None,
        encryption_key: Optional["_models.SearchResourceEncryptionKey"] = None,
        cache: Optional["_models.SearchIndexerCache"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerCache(_model_base.Model):
    """The type of the cache.

    :ivar storage_connection_string: The connection string to the storage account where the cache
     data will be
     persisted.
    :vartype storage_connection_string: str
    :ivar enable_reprocessing: Specifies whether incremental reprocessing is enabled.
    :vartype enable_reprocessing: bool
    :ivar identity: The user-assigned managed identity used for connections to the enrichment
     cache.  If the connection string indicates an identity (ResourceId) and it's
     not specified, the system-assigned managed identity is used. On updates to the
     indexer, if the identity is unspecified, the value remains unchanged. If set to
     "none", the value of this property is cleared.
    :vartype identity: ~azure.search.documents.models.SearchIndexerDataIdentity
    """

    storage_connection_string: Optional[str] = rest_field(
        name="storageConnectionString", visibility=["read", "create", "update", "delete", "query"]
    )
    """The connection string to the storage account where the cache data will be
     persisted."""
    enable_reprocessing: Optional[bool] = rest_field(
        name="enableReprocessing", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies whether incremental reprocessing is enabled."""
    identity: Optional["_models.SearchIndexerDataIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The user-assigned managed identity used for connections to the enrichment
     cache.  If the connection string indicates an identity (ResourceId) and it's
     not specified, the system-assigned managed identity is used. On updates to the
     indexer, if the identity is unspecified, the value remains unchanged. If set to
     \"none\", the value of this property is cleared."""

    @overload
    def __init__(
        self,
        *,
        storage_connection_string: Optional[str] = None,
        enable_reprocessing: Optional[bool] = None,
        identity: Optional["_models.SearchIndexerDataIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerDataContainer(_model_base.Model):
    """Represents information about the entity (such as Azure SQL table or CosmosDB
    collection) that will be indexed.


    :ivar name: The name of the table or view (for Azure SQL data source) or collection (for
     CosmosDB data source) that will be indexed. Required.
    :vartype name: str
    :ivar query: A query that is applied to this data container. The syntax and meaning of this
     parameter is datasource-specific. Not supported by Azure SQL datasources.
    :vartype query: str
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the table or view (for Azure SQL data source) or collection (for
     CosmosDB data source) that will be indexed. Required."""
    query: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A query that is applied to this data container. The syntax and meaning of this
     parameter is datasource-specific. Not supported by Azure SQL datasources."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        query: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerDataIdentity(_model_base.Model):
    """Abstract base type for data identities.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    SearchIndexerDataNoneIdentity, SearchIndexerDataUserAssignedIdentity


    :ivar odata_type: A URI fragment specifying the type of identity. Required. Default value is
     None.
    :vartype odata_type: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    odata_type: str = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])
    """A URI fragment specifying the type of identity. Required. Default value is None."""

    @overload
    def __init__(
        self,
        *,
        odata_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerDataNoneIdentity(
    SearchIndexerDataIdentity, discriminator="#Microsoft.Azure.Search.DataNoneIdentity"
):
    """Clears the identity property of a datasource.


    :ivar odata_type: The discriminator for derived types. Required. Default value is
     "#Microsoft.Azure.Search.DataNoneIdentity".
    :vartype odata_type: str
    """

    odata_type: Literal["#Microsoft.Azure.Search.DataNoneIdentity"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The discriminator for derived types. Required. Default value is
     \"#Microsoft.Azure.Search.DataNoneIdentity\"."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.DataNoneIdentity", **kwargs)


class SearchIndexerDataSource(_model_base.Model):
    """Represents a datasource definition, which can be used to configure an indexer.


    :ivar name: The name of the datasource. Required.
    :vartype name: str
    :ivar description: The description of the datasource.
    :vartype description: str
    :ivar type: The type of the datasource. Required. Known values are: "azuresql", "cosmosdb",
     "azureblob", "azuretable", "mysql", "adlsgen2", and "onelake".
    :vartype type: str or ~azure.search.documents.models.SearchIndexerDataSourceType
    :ivar credentials: Credentials for the datasource. Required.
    :vartype credentials: ~azure.search.documents.models.DataSourceCredentials
    :ivar container: The data container for the datasource. Required.
    :vartype container: ~azure.search.documents.models.SearchIndexerDataContainer
    :ivar identity: An explicit managed identity to use for this datasource. If not specified and
     the connection string is a managed identity, the system-assigned managed
     identity is used. If not specified, the value remains unchanged. If "none" is
     specified, the value of this property is cleared.
    :vartype identity: ~azure.search.documents.models.SearchIndexerDataIdentity
    :ivar data_change_detection_policy: The data change detection policy for the datasource.
    :vartype data_change_detection_policy: ~azure.search.documents.models.DataChangeDetectionPolicy
    :ivar data_deletion_detection_policy: The data deletion detection policy for the datasource.
    :vartype data_deletion_detection_policy:
     ~azure.search.documents.models.DataDeletionDetectionPolicy
    :ivar e_tag: The ETag of the data source.
    :vartype e_tag: str
    :ivar encryption_key: A description of an encryption key that you create in Azure Key Vault.
     This key
     is used to provide an additional level of encryption-at-rest for your
     datasource definition when you want full assurance that no one, not even
     Microsoft, can decrypt your data source definition. Once you have encrypted
     your data source definition, it will always remain encrypted. The search
     service will ignore attempts to set this property to null. You can change this
     property as needed if you want to rotate your encryption key; Your datasource
     definition will be unaffected. Encryption with customer-managed keys is not
     available for free search services, and is only available for paid services
     created on or after January 1, 2019.
    :vartype encryption_key: ~azure.search.documents.models.SearchResourceEncryptionKey
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the datasource. Required."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The description of the datasource."""
    type: Union[str, "_models.SearchIndexerDataSourceType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of the datasource. Required. Known values are: \"azuresql\", \"cosmosdb\",
     \"azureblob\", \"azuretable\", \"mysql\", \"adlsgen2\", and \"onelake\"."""
    credentials: "_models.DataSourceCredentials" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Credentials for the datasource. Required."""
    container: "_models.SearchIndexerDataContainer" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The data container for the datasource. Required."""
    identity: Optional["_models.SearchIndexerDataIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """An explicit managed identity to use for this datasource. If not specified and
     the connection string is a managed identity, the system-assigned managed
     identity is used. If not specified, the value remains unchanged. If \"none\" is
     specified, the value of this property is cleared."""
    data_change_detection_policy: Optional["_models.DataChangeDetectionPolicy"] = rest_field(
        name="dataChangeDetectionPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The data change detection policy for the datasource."""
    data_deletion_detection_policy: Optional["_models.DataDeletionDetectionPolicy"] = rest_field(
        name="dataDeletionDetectionPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The data deletion detection policy for the datasource."""
    e_tag: Optional[str] = rest_field(name="@odata.etag", visibility=["read", "create", "update", "delete", "query"])
    """The ETag of the data source."""
    encryption_key: Optional["_models.SearchResourceEncryptionKey"] = rest_field(
        name="encryptionKey", visibility=["read", "create", "update", "delete", "query"]
    )
    """A description of an encryption key that you create in Azure Key Vault. This key
     is used to provide an additional level of encryption-at-rest for your
     datasource definition when you want full assurance that no one, not even
     Microsoft, can decrypt your data source definition. Once you have encrypted
     your data source definition, it will always remain encrypted. The search
     service will ignore attempts to set this property to null. You can change this
     property as needed if you want to rotate your encryption key; Your datasource
     definition will be unaffected. Encryption with customer-managed keys is not
     available for free search services, and is only available for paid services
     created on or after January 1, 2019."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        type: Union[str, "_models.SearchIndexerDataSourceType"],
        credentials: "_models.DataSourceCredentials",
        container: "_models.SearchIndexerDataContainer",
        description: Optional[str] = None,
        identity: Optional["_models.SearchIndexerDataIdentity"] = None,
        data_change_detection_policy: Optional["_models.DataChangeDetectionPolicy"] = None,
        data_deletion_detection_policy: Optional["_models.DataDeletionDetectionPolicy"] = None,
        e_tag: Optional[str] = None,
        encryption_key: Optional["_models.SearchResourceEncryptionKey"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerDataUserAssignedIdentity(
    SearchIndexerDataIdentity, discriminator="#Microsoft.Azure.Search.DataUserAssignedIdentity"
):
    """Specifies the identity for a datasource to use.


    :ivar resource_id: The fully qualified Azure resource Id of a user assigned managed identity
     typically in the form
     "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
     that should have been assigned to the search service. Required.
    :vartype resource_id: str
    :ivar odata_type: A URI fragment specifying the type of identity. Required. Default value is
     "#Microsoft.Azure.Search.DataUserAssignedIdentity".
    :vartype odata_type: str
    """

    resource_id: str = rest_field(
        name="userAssignedIdentity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fully qualified Azure resource Id of a user assigned managed identity
     typically in the form
     \"/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId\"
     that should have been assigned to the search service. Required."""
    odata_type: Literal["#Microsoft.Azure.Search.DataUserAssignedIdentity"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of identity. Required. Default value is
     \"#Microsoft.Azure.Search.DataUserAssignedIdentity\"."""

    @overload
    def __init__(
        self,
        *,
        resource_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.DataUserAssignedIdentity", **kwargs)


class SearchIndexerError(_model_base.Model):
    """Represents an item- or document-level indexing error.


    :ivar key: The key of the item for which indexing failed.
    :vartype key: str
    :ivar error_message: The message describing the error that occurred while processing the item.
     Required.
    :vartype error_message: str
    :ivar status_code: The status code indicating why the indexing operation failed. Possible
     values
     include: 400 for a malformed input document, 404 for document not found, 409
     for a version conflict, 422 when the index is temporarily unavailable, or 503
     for when the service is too busy. Required.
    :vartype status_code: int
    :ivar name: The name of the source at which the error originated. For example, this could
     refer to a particular skill in the attached skillset. This may not be always
     available.
    :vartype name: str
    :ivar details: Additional, verbose details about the error to assist in debugging the indexer.
     This may not be always available.
    :vartype details: str
    :ivar documentation_link: A link to a troubleshooting guide for these classes of errors. This
     may not be
     always available.
    :vartype documentation_link: str
    """

    key: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The key of the item for which indexing failed."""
    error_message: str = rest_field(name="errorMessage", visibility=["read", "create", "update", "delete", "query"])
    """The message describing the error that occurred while processing the item. Required."""
    status_code: int = rest_field(name="statusCode", visibility=["read", "create", "update", "delete", "query"])
    """The status code indicating why the indexing operation failed. Possible values
     include: 400 for a malformed input document, 404 for document not found, 409
     for a version conflict, 422 when the index is temporarily unavailable, or 503
     for when the service is too busy. Required."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the source at which the error originated. For example, this could
     refer to a particular skill in the attached skillset. This may not be always
     available."""
    details: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Additional, verbose details about the error to assist in debugging the indexer.
     This may not be always available."""
    documentation_link: Optional[str] = rest_field(
        name="documentationLink", visibility=["read", "create", "update", "delete", "query"]
    )
    """A link to a troubleshooting guide for these classes of errors. This may not be
     always available."""

    @overload
    def __init__(
        self,
        *,
        error_message: str,
        status_code: int,
        key: Optional[str] = None,
        name: Optional[str] = None,
        details: Optional[str] = None,
        documentation_link: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerIndexProjection(_model_base.Model):
    """Definition of additional projections to secondary search indexes.


    :ivar selectors: A list of projections to be performed to secondary search indexes. Required.
    :vartype selectors: list[~azure.search.documents.models.SearchIndexerIndexProjectionSelector]
    :ivar parameters: A dictionary of index projection-specific configuration properties. Each name
     is the name of a specific property. Each value must be of a primitive type.
    :vartype parameters: ~azure.search.documents.models.SearchIndexerIndexProjectionsParameters
    """

    selectors: List["_models.SearchIndexerIndexProjectionSelector"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of projections to be performed to secondary search indexes. Required."""
    parameters: Optional["_models.SearchIndexerIndexProjectionsParameters"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A dictionary of index projection-specific configuration properties. Each name
     is the name of a specific property. Each value must be of a primitive type."""

    @overload
    def __init__(
        self,
        *,
        selectors: List["_models.SearchIndexerIndexProjectionSelector"],
        parameters: Optional["_models.SearchIndexerIndexProjectionsParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerIndexProjectionSelector(_model_base.Model):
    """Description for what data to store in the designated search index.


    :ivar target_index_name: Name of the search index to project to. Must have a key field with the
     'keyword' analyzer set. Required.
    :vartype target_index_name: str
    :ivar parent_key_field_name: Name of the field in the search index to map the parent document's
     key value
     to. Must be a string field that is filterable and not the key field. Required.
    :vartype parent_key_field_name: str
    :ivar source_context: Source context for the projections. Represents the cardinality at which
     the
     document will be split into multiple sub documents. Required.
    :vartype source_context: str
    :ivar mappings: Mappings for the projection, or which source should be mapped to which field in
     the target index. Required.
    :vartype mappings: list[~azure.search.documents.models.InputFieldMappingEntry]
    """

    target_index_name: str = rest_field(
        name="targetIndexName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of the search index to project to. Must have a key field with the 'keyword' analyzer set.
     Required."""
    parent_key_field_name: str = rest_field(
        name="parentKeyFieldName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of the field in the search index to map the parent document's key value
     to. Must be a string field that is filterable and not the key field. Required."""
    source_context: str = rest_field(name="sourceContext", visibility=["read", "create", "update", "delete", "query"])
    """Source context for the projections. Represents the cardinality at which the
     document will be split into multiple sub documents. Required."""
    mappings: List["_models.InputFieldMappingEntry"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Mappings for the projection, or which source should be mapped to which field in
     the target index. Required."""

    @overload
    def __init__(
        self,
        *,
        target_index_name: str,
        parent_key_field_name: str,
        source_context: str,
        mappings: List["_models.InputFieldMappingEntry"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerIndexProjectionsParameters(_model_base.Model):
    """A dictionary of index projection-specific configuration properties. Each name
    is the name of a specific property. Each value must be of a primitive type.

    :ivar projection_mode: Defines behavior of the index projections in relation to the rest of the
     indexer. Known values are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
    :vartype projection_mode: str or ~azure.search.documents.models.IndexProjectionMode
    """

    projection_mode: Optional[Union[str, "_models.IndexProjectionMode"]] = rest_field(
        name="projectionMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines behavior of the index projections in relation to the rest of the
     indexer. Known values are: \"skipIndexingParentDocuments\" and
     \"includeIndexingParentDocuments\"."""

    @overload
    def __init__(
        self,
        *,
        projection_mode: Optional[Union[str, "_models.IndexProjectionMode"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerKnowledgeStore(_model_base.Model):
    """Definition of additional projections to azure blob, table, or files, of
    enriched data.


    :ivar storage_connection_string: The connection string to the storage account projections will
     be stored in. Required.
    :vartype storage_connection_string: str
    :ivar projections: A list of additional projections to perform during indexing. Required.
    :vartype projections:
     list[~azure.search.documents.models.SearchIndexerKnowledgeStoreProjection]
    :ivar identity: The user-assigned managed identity used for connections to Azure Storage when
     writing knowledge store projections. If the connection string indicates an
     identity (ResourceId) and it's not specified, the system-assigned managed
     identity is used. On updates to the indexer, if the identity is unspecified,
     the value remains unchanged. If set to "none", the value of this property is
     cleared.
    :vartype identity: ~azure.search.documents.models.SearchIndexerDataIdentity
    :ivar parameters: A dictionary of knowledge store-specific configuration properties. Each name
     is
     the name of a specific property. Each value must be of a primitive type.
    :vartype parameters: ~azure.search.documents.models.SearchIndexerKnowledgeStoreParameters
    """

    storage_connection_string: str = rest_field(
        name="storageConnectionString", visibility=["read", "create", "update", "delete", "query"]
    )
    """The connection string to the storage account projections will be stored in. Required."""
    projections: List["_models.SearchIndexerKnowledgeStoreProjection"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of additional projections to perform during indexing. Required."""
    identity: Optional["_models.SearchIndexerDataIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The user-assigned managed identity used for connections to Azure Storage when
     writing knowledge store projections. If the connection string indicates an
     identity (ResourceId) and it's not specified, the system-assigned managed
     identity is used. On updates to the indexer, if the identity is unspecified,
     the value remains unchanged. If set to \"none\", the value of this property is
     cleared."""
    parameters: Optional["_models.SearchIndexerKnowledgeStoreParameters"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A dictionary of knowledge store-specific configuration properties. Each name is
     the name of a specific property. Each value must be of a primitive type."""

    @overload
    def __init__(
        self,
        *,
        storage_connection_string: str,
        projections: List["_models.SearchIndexerKnowledgeStoreProjection"],
        identity: Optional["_models.SearchIndexerDataIdentity"] = None,
        parameters: Optional["_models.SearchIndexerKnowledgeStoreParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerKnowledgeStoreProjectionSelector(_model_base.Model):  # pylint: disable=name-too-long
    """Abstract class to share properties between concrete selectors.

    :ivar reference_key_name: Name of reference key to different projection.
    :vartype reference_key_name: str
    :ivar generated_key_name: Name of generated key to store projection under.
    :vartype generated_key_name: str
    :ivar source: Source data to project.
    :vartype source: str
    :ivar source_context: Source context for complex projections.
    :vartype source_context: str
    :ivar inputs: Nested inputs for complex projections.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    """

    reference_key_name: Optional[str] = rest_field(
        name="referenceKeyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of reference key to different projection."""
    generated_key_name: Optional[str] = rest_field(
        name="generatedKeyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of generated key to store projection under."""
    source: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Source data to project."""
    source_context: Optional[str] = rest_field(
        name="sourceContext", visibility=["read", "create", "update", "delete", "query"]
    )
    """Source context for complex projections."""
    inputs: Optional[List["_models.InputFieldMappingEntry"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Nested inputs for complex projections."""

    @overload
    def __init__(
        self,
        *,
        reference_key_name: Optional[str] = None,
        generated_key_name: Optional[str] = None,
        source: Optional[str] = None,
        source_context: Optional[str] = None,
        inputs: Optional[List["_models.InputFieldMappingEntry"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerKnowledgeStoreBlobProjectionSelector(
    SearchIndexerKnowledgeStoreProjectionSelector
):  # pylint: disable=name-too-long
    """Abstract class to share properties between concrete selectors.


    :ivar reference_key_name: Name of reference key to different projection.
    :vartype reference_key_name: str
    :ivar generated_key_name: Name of generated key to store projection under.
    :vartype generated_key_name: str
    :ivar source: Source data to project.
    :vartype source: str
    :ivar source_context: Source context for complex projections.
    :vartype source_context: str
    :ivar inputs: Nested inputs for complex projections.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar storage_container: Blob container to store projections in. Required.
    :vartype storage_container: str
    """

    storage_container: str = rest_field(
        name="storageContainer", visibility=["read", "create", "update", "delete", "query"]
    )
    """Blob container to store projections in. Required."""

    @overload
    def __init__(
        self,
        *,
        storage_container: str,
        reference_key_name: Optional[str] = None,
        generated_key_name: Optional[str] = None,
        source: Optional[str] = None,
        source_context: Optional[str] = None,
        inputs: Optional[List["_models.InputFieldMappingEntry"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerKnowledgeStoreFileProjectionSelector(
    SearchIndexerKnowledgeStoreBlobProjectionSelector
):  # pylint: disable=name-too-long
    """Projection definition for what data to store in Azure Files.


    :ivar reference_key_name: Name of reference key to different projection.
    :vartype reference_key_name: str
    :ivar generated_key_name: Name of generated key to store projection under.
    :vartype generated_key_name: str
    :ivar source: Source data to project.
    :vartype source: str
    :ivar source_context: Source context for complex projections.
    :vartype source_context: str
    :ivar inputs: Nested inputs for complex projections.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar storage_container: Blob container to store projections in. Required.
    :vartype storage_container: str
    """

    @overload
    def __init__(
        self,
        *,
        storage_container: str,
        reference_key_name: Optional[str] = None,
        generated_key_name: Optional[str] = None,
        source: Optional[str] = None,
        source_context: Optional[str] = None,
        inputs: Optional[List["_models.InputFieldMappingEntry"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerKnowledgeStoreObjectProjectionSelector(
    SearchIndexerKnowledgeStoreBlobProjectionSelector
):  # pylint: disable=name-too-long
    """Projection definition for what data to store in Azure Blob.


    :ivar reference_key_name: Name of reference key to different projection.
    :vartype reference_key_name: str
    :ivar generated_key_name: Name of generated key to store projection under.
    :vartype generated_key_name: str
    :ivar source: Source data to project.
    :vartype source: str
    :ivar source_context: Source context for complex projections.
    :vartype source_context: str
    :ivar inputs: Nested inputs for complex projections.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar storage_container: Blob container to store projections in. Required.
    :vartype storage_container: str
    """

    @overload
    def __init__(
        self,
        *,
        storage_container: str,
        reference_key_name: Optional[str] = None,
        generated_key_name: Optional[str] = None,
        source: Optional[str] = None,
        source_context: Optional[str] = None,
        inputs: Optional[List["_models.InputFieldMappingEntry"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerKnowledgeStoreParameters(_model_base.Model):
    """A dictionary of knowledge store-specific configuration properties. Each name is
    the name of a specific property. Each value must be of a primitive type.

    :ivar synthesize_generated_key_name: Whether or not projections should synthesize a generated
     key name if one isn't
     already present.
    :vartype synthesize_generated_key_name: bool
    """

    synthesize_generated_key_name: Optional[bool] = rest_field(
        name="synthesizeGeneratedKeyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether or not projections should synthesize a generated key name if one isn't
     already present."""

    @overload
    def __init__(
        self,
        *,
        synthesize_generated_key_name: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerKnowledgeStoreProjection(_model_base.Model):
    """Container object for various projection selectors.

    :ivar tables: Projections to Azure Table storage.
    :vartype tables:
     list[~azure.search.documents.models.SearchIndexerKnowledgeStoreTableProjectionSelector]
    :ivar objects: Projections to Azure Blob storage.
    :vartype objects:
     list[~azure.search.documents.models.SearchIndexerKnowledgeStoreObjectProjectionSelector]
    :ivar files: Projections to Azure File storage.
    :vartype files:
     list[~azure.search.documents.models.SearchIndexerKnowledgeStoreFileProjectionSelector]
    """

    tables: Optional[List["_models.SearchIndexerKnowledgeStoreTableProjectionSelector"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Projections to Azure Table storage."""
    objects: Optional[List["_models.SearchIndexerKnowledgeStoreObjectProjectionSelector"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Projections to Azure Blob storage."""
    files: Optional[List["_models.SearchIndexerKnowledgeStoreFileProjectionSelector"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Projections to Azure File storage."""

    @overload
    def __init__(
        self,
        *,
        tables: Optional[List["_models.SearchIndexerKnowledgeStoreTableProjectionSelector"]] = None,
        objects: Optional[List["_models.SearchIndexerKnowledgeStoreObjectProjectionSelector"]] = None,
        files: Optional[List["_models.SearchIndexerKnowledgeStoreFileProjectionSelector"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerKnowledgeStoreTableProjectionSelector(
    SearchIndexerKnowledgeStoreProjectionSelector
):  # pylint: disable=name-too-long
    """Description for what data to store in Azure Tables.


    :ivar reference_key_name: Name of reference key to different projection.
    :vartype reference_key_name: str
    :ivar generated_key_name: Name of generated key to store projection under.
    :vartype generated_key_name: str
    :ivar source: Source data to project.
    :vartype source: str
    :ivar source_context: Source context for complex projections.
    :vartype source_context: str
    :ivar inputs: Nested inputs for complex projections.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar table_name: Name of the Azure table to store projected data in. Required.
    :vartype table_name: str
    """

    table_name: str = rest_field(name="tableName", visibility=["read", "create", "update", "delete", "query"])
    """Name of the Azure table to store projected data in. Required."""

    @overload
    def __init__(
        self,
        *,
        table_name: str,
        reference_key_name: Optional[str] = None,
        generated_key_name: Optional[str] = None,
        source: Optional[str] = None,
        source_context: Optional[str] = None,
        inputs: Optional[List["_models.InputFieldMappingEntry"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerLimits(_model_base.Model):
    """Represents the limits that can be applied to an indexer.

    :ivar max_run_time: The maximum duration that the indexer is permitted to run for one
     execution.
    :vartype max_run_time: ~datetime.timedelta
    :ivar max_document_extraction_size: The maximum size of a document, in bytes, which will be
     considered valid for
     indexing.
    :vartype max_document_extraction_size: int
    :ivar max_document_content_characters_to_extract: The maximum number of characters that will be
     extracted from a document picked
     up for indexing.
    :vartype max_document_content_characters_to_extract: int
    """

    max_run_time: Optional[datetime.timedelta] = rest_field(
        name="maxRunTime", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum duration that the indexer is permitted to run for one execution."""
    max_document_extraction_size: Optional[int] = rest_field(
        name="maxDocumentExtractionSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum size of a document, in bytes, which will be considered valid for
     indexing."""
    max_document_content_characters_to_extract: Optional[int] = rest_field(
        name="maxDocumentContentCharactersToExtract", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of characters that will be extracted from a document picked
     up for indexing."""

    @overload
    def __init__(
        self,
        *,
        max_run_time: Optional[datetime.timedelta] = None,
        max_document_extraction_size: Optional[int] = None,
        max_document_content_characters_to_extract: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerSkillset(_model_base.Model):
    """A list of skills.


    :ivar name: The name of the skillset. Required.
    :vartype name: str
    :ivar description: The description of the skillset.
    :vartype description: str
    :ivar skills: A list of skills in the skillset. Required.
    :vartype skills: list[~azure.search.documents.models.SearchIndexerSkill]
    :ivar cognitive_services_account: Details about the Azure AI service to be used when running
     skills.
    :vartype cognitive_services_account: ~azure.search.documents.models.CognitiveServicesAccount
    :ivar knowledge_store: Definition of additional projections to Azure blob, table, or files, of
     enriched data.
    :vartype knowledge_store: ~azure.search.documents.models.SearchIndexerKnowledgeStore
    :ivar index_projection: Definition of additional projections to secondary search index(es).
    :vartype index_projection: ~azure.search.documents.models.SearchIndexerIndexProjection
    :ivar e_tag: The ETag of the skillset.
    :vartype e_tag: str
    :ivar encryption_key: A description of an encryption key that you create in Azure Key Vault.
     This key
     is used to provide an additional level of encryption-at-rest for your skillset
     definition when you want full assurance that no one, not even Microsoft, can
     decrypt your skillset definition. Once you have encrypted your skillset
     definition, it will always remain encrypted. The search service will ignore
     attempts to set this property to null. You can change this property as needed
     if you want to rotate your encryption key; Your skillset definition will be
     unaffected. Encryption with customer-managed keys is not available for free
     search services, and is only available for paid services created on or after
     January 1, 2019.
    :vartype encryption_key: ~azure.search.documents.models.SearchResourceEncryptionKey
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the skillset. Required."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The description of the skillset."""
    skills: List["_models.SearchIndexerSkill"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A list of skills in the skillset. Required."""
    cognitive_services_account: Optional["_models.CognitiveServicesAccount"] = rest_field(
        name="cognitiveServices", visibility=["read", "create", "update", "delete", "query"]
    )
    """Details about the Azure AI service to be used when running skills."""
    knowledge_store: Optional["_models.SearchIndexerKnowledgeStore"] = rest_field(
        name="knowledgeStore", visibility=["read", "create", "update", "delete", "query"]
    )
    """Definition of additional projections to Azure blob, table, or files, of
     enriched data."""
    index_projection: Optional["_models.SearchIndexerIndexProjection"] = rest_field(
        name="indexProjections", visibility=["read", "create", "update", "delete", "query"]
    )
    """Definition of additional projections to secondary search index(es)."""
    e_tag: Optional[str] = rest_field(name="@odata.etag", visibility=["read", "create", "update", "delete", "query"])
    """The ETag of the skillset."""
    encryption_key: Optional["_models.SearchResourceEncryptionKey"] = rest_field(
        name="encryptionKey", visibility=["read", "create", "update", "delete", "query"]
    )
    """A description of an encryption key that you create in Azure Key Vault. This key
     is used to provide an additional level of encryption-at-rest for your skillset
     definition when you want full assurance that no one, not even Microsoft, can
     decrypt your skillset definition. Once you have encrypted your skillset
     definition, it will always remain encrypted. The search service will ignore
     attempts to set this property to null. You can change this property as needed
     if you want to rotate your encryption key; Your skillset definition will be
     unaffected. Encryption with customer-managed keys is not available for free
     search services, and is only available for paid services created on or after
     January 1, 2019."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        skills: List["_models.SearchIndexerSkill"],
        description: Optional[str] = None,
        cognitive_services_account: Optional["_models.CognitiveServicesAccount"] = None,
        knowledge_store: Optional["_models.SearchIndexerKnowledgeStore"] = None,
        index_projection: Optional["_models.SearchIndexerIndexProjection"] = None,
        e_tag: Optional[str] = None,
        encryption_key: Optional["_models.SearchResourceEncryptionKey"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerStatus(_model_base.Model):
    """Represents the current status and execution history of an indexer.


    :ivar status: Overall indexer status. Required. Known values are: "unknown", "error", and
     "running".
    :vartype status: str or ~azure.search.documents.models.IndexerStatus
    :ivar last_result: The result of the most recent or an in-progress indexer execution.
    :vartype last_result: ~azure.search.documents.models.IndexerExecutionResult
    :ivar execution_history: History of the recent indexer executions, sorted in reverse
     chronological order. Required.
    :vartype execution_history: list[~azure.search.documents.models.IndexerExecutionResult]
    :ivar limits: The execution limits for the indexer. Required.
    :vartype limits: ~azure.search.documents.models.SearchIndexerLimits
    """

    status: Union[str, "_models.IndexerStatus"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Overall indexer status. Required. Known values are: \"unknown\", \"error\", and \"running\"."""
    last_result: Optional["_models.IndexerExecutionResult"] = rest_field(
        name="lastResult", visibility=["read", "create", "update", "delete", "query"]
    )
    """The result of the most recent or an in-progress indexer execution."""
    execution_history: List["_models.IndexerExecutionResult"] = rest_field(
        name="executionHistory", visibility=["read", "create", "update", "delete", "query"]
    )
    """History of the recent indexer executions, sorted in reverse chronological order. Required."""
    limits: "_models.SearchIndexerLimits" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The execution limits for the indexer. Required."""

    @overload
    def __init__(
        self,
        *,
        status: Union[str, "_models.IndexerStatus"],
        execution_history: List["_models.IndexerExecutionResult"],
        limits: "_models.SearchIndexerLimits",
        last_result: Optional["_models.IndexerExecutionResult"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchIndexerWarning(_model_base.Model):
    """Represents an item-level warning.


    :ivar key: The key of the item which generated a warning.
    :vartype key: str
    :ivar message: The message describing the warning that occurred while processing the item.
     Required.
    :vartype message: str
    :ivar name: The name of the source at which the warning originated. For example, this could
     refer to a particular skill in the attached skillset. This may not be always
     available.
    :vartype name: str
    :ivar details: Additional, verbose details about the warning to assist in debugging the
     indexer. This may not be always available.
    :vartype details: str
    :ivar documentation_link: A link to a troubleshooting guide for these classes of warnings. This
     may not
     be always available.
    :vartype documentation_link: str
    """

    key: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The key of the item which generated a warning."""
    message: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The message describing the warning that occurred while processing the item. Required."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the source at which the warning originated. For example, this could
     refer to a particular skill in the attached skillset. This may not be always
     available."""
    details: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Additional, verbose details about the warning to assist in debugging the
     indexer. This may not be always available."""
    documentation_link: Optional[str] = rest_field(
        name="documentationLink", visibility=["read", "create", "update", "delete", "query"]
    )
    """A link to a troubleshooting guide for these classes of warnings. This may not
     be always available."""

    @overload
    def __init__(
        self,
        *,
        message: str,
        key: Optional[str] = None,
        name: Optional[str] = None,
        details: Optional[str] = None,
        documentation_link: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchRequest(_model_base.Model):
    """Parameters for filtering, sorting, faceting, paging, and other search query
    behaviors.

    :ivar include_total_result_count: A value that specifies whether to fetch the total count of
     results. Default is
     false. Setting this value to true may have a performance impact. Note that the
     count returned is an approximation.
    :vartype include_total_result_count: bool
    :ivar facets: The list of facet expressions to apply to the search query. Each facet
     expression contains a field name, optionally followed by a comma-separated list
     of name:value pairs.
    :vartype facets: list[str]
    :ivar filter: The OData $filter expression to apply to the search query.
    :vartype filter: str
    :ivar highlight_fields: The comma-separated list of field names to use for hit highlights. Only
     searchable fields can be used for hit highlighting.
    :vartype highlight_fields: str
    :ivar highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. Default is &lt;/em&gt;.
    :vartype highlight_post_tag: str
    :ivar highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. Default is &lt;em&gt;.
    :vartype highlight_pre_tag: str
    :ivar minimum_coverage: A number between 0 and 100 indicating the percentage of the index that
     must be
     covered by a search query in order for the query to be reported as a success.
     This parameter can be useful for ensuring search availability even for services
     with only one replica. The default is 100.
    :vartype minimum_coverage: float
    :ivar order_by: The comma-separated list of OData $orderby expressions by which to sort the
     results. Each expression can be either a field name or a call to either the
     geo.distance() or the search.score() functions. Each expression can be followed
     by asc to indicate ascending, or desc to indicate descending. The default is
     ascending order. Ties will be broken by the match scores of documents. If no
     $orderby is specified, the default sort order is descending by document match
     score. There can be at most 32 $orderby clauses.
    :vartype order_by: str
    :ivar query_type: A value that specifies the syntax of the search query. The default is
     'simple'.
     Use 'full' if your query uses the Lucene query syntax. Known values are: "simple", "full", and
     "semantic".
    :vartype query_type: str or ~azure.search.documents.models.QueryType
    :ivar scoring_statistics: A value that specifies whether we want to calculate scoring
     statistics (such as
     document frequency) globally for more consistent scoring, or locally, for lower
     latency. The default is 'local'. Use 'global' to aggregate scoring statistics
     globally before scoring. Using global scoring statistics can increase latency
     of search queries. Known values are: "local" and "global".
    :vartype scoring_statistics: str or ~azure.search.documents.models.ScoringStatistics
    :ivar session_id: A value to be used to create a sticky session, which can help getting more
     consistent results. As long as the same sessionId is used, a best-effort
     attempt will be made to target the same replica set. Be wary that reusing the
     same sessionID values repeatedly can interfere with the load balancing of the
     requests across replicas and adversely affect the performance of the search
     service. The value used as sessionId cannot start with a '_' character.
    :vartype session_id: str
    :ivar scoring_parameters: The list of parameter values to be used in scoring functions (for
     example,
     referencePointParameter) using the format name-values. For example, if the
     scoring profile defines a function with a parameter called 'mylocation' the
     parameter string would be "mylocation--122.2,44.8" (without the quotes).
    :vartype scoring_parameters: list[str]
    :ivar scoring_profile: The name of a scoring profile to evaluate match scores for matching
     documents
     in order to sort the results.
    :vartype scoring_profile: str
    :ivar debug: Enables a debugging tool that can be used to further explore your reranked
     results. Known values are: "disabled", "semantic", "vector", "queryRewrites", and "all".
    :vartype debug: str or ~azure.search.documents.models.QueryDebugMode
    :ivar search_text: A full-text search query expression; Use "*" or omit this parameter to match
     all documents.
    :vartype search_text: str
    :ivar search_fields: The comma-separated list of field names to which to scope the full-text
     search.
     When using fielded search (fieldName:searchExpression) in a full Lucene query,
     the field names of each fielded search expression take precedence over any
     field names listed in this parameter.
    :vartype search_fields: str
    :ivar search_mode: A value that specifies whether any or all of the search terms must be
     matched
     in order to count the document as a match. Known values are: "any" and "all".
    :vartype search_mode: str or ~azure.search.documents.models.SearchMode
    :ivar query_language: A value that specifies the language of the search query. Known values
     are: "none", "en-us", "en-gb", "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es",
     "es-mx", "zh-cn", "zh-tw", "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru", "cs-cz",
     "nl-be", "nl-nl", "hu-hu", "pl-pl", "sv-se", "tr-tr", "hi-in", "ar-sa", "ar-eg", "ar-ma",
     "ar-kw", "ar-jo", "da-dk", "no-no", "bg-bg", "hr-hr", "hr-ba", "ms-my", "ms-bn", "sl-sl",
     "ta-in", "vi-vn", "el-gr", "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua", "lv-lv",
     "et-ee", "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am", "bn-in",
     "eu-es", "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in", "mr-in", "fa-ae", "pa-in",
     "te-in", and "ur-pk".
    :vartype query_language: str or ~azure.search.documents.models.QueryLanguage
    :ivar speller: A value that specified the type of the speller to use to spell-correct
     individual search query terms. Known values are: "none" and "lexicon".
    :vartype speller: str or ~azure.search.documents.models.QuerySpellerType
    :ivar select: The comma-separated list of fields to retrieve. If unspecified, all fields
     marked as retrievable in the schema are included.
    :vartype select: str
    :ivar skip: The number of search results to skip. This value cannot be greater than
     100,000. If you need to scan documents in sequence, but cannot use skip due to
     this limitation, consider using orderby on a totally-ordered key and filter
     with a range query instead.
    :vartype skip: int
    :ivar top: The number of search results to retrieve. This can be used in conjunction with
     $skip to implement client-side paging of search results. If results are
     truncated due to server-side paging, the response will include a continuation
     token that can be used to issue another Search request for the next page of
     results.
    :vartype top: int
    :ivar semantic_configuration: The name of a semantic configuration that will be used when
     processing
     documents for queries of type semantic.
    :vartype semantic_configuration: str
    :ivar semantic_error_handling: Allows the user to choose whether a semantic call should fail
     completely
     (default / current behavior), or to return partial results. Known values are: "partial" and
     "fail".
    :vartype semantic_error_handling: str or ~azure.search.documents.models.SemanticErrorMode
    :ivar semantic_max_wait_in_milliseconds: Allows the user to set an upper bound on the amount of
     time it takes for
     semantic enrichment to finish processing before the request fails.
    :vartype semantic_max_wait_in_milliseconds: int
    :ivar semantic_query: Allows setting a separate search query that will be solely used for
     semantic
     reranking, semantic captions and semantic answers. Is useful for scenarios
     where there is a need to use different queries between the base retrieval and
     ranking phase, and the L2 semantic phase.
    :vartype semantic_query: str
    :ivar answers: A value that specifies whether answers should be returned as part of the search
     response. Known values are: "none" and "extractive".
    :vartype answers: str or ~azure.search.documents.models.QueryAnswerType
    :ivar captions: A value that specifies whether captions should be returned as part of the
     search response. Known values are: "none" and "extractive".
    :vartype captions: str or ~azure.search.documents.models.QueryCaptionType
    :ivar query_rewrites: A value that specifies whether query rewrites should be generated to
     augment
     the search query. Known values are: "none" and "generative".
    :vartype query_rewrites: str or ~azure.search.documents.models.QueryRewritesType
    :ivar semantic_fields: The comma-separated list of field names used for semantic ranking.
    :vartype semantic_fields: str
    :ivar vector_queries: The query parameters for vector and hybrid search queries.
    :vartype vector_queries: list[~azure.search.documents.models.VectorQuery]
    :ivar vector_filter_mode: Determines whether or not filters are applied before or after the
     vector search
     is performed. Default is 'preFilter' for new indexes. Known values are: "postFilter" and
     "preFilter".
    :vartype vector_filter_mode: str or ~azure.search.documents.models.VectorFilterMode
    :ivar hybrid_search: The query parameters to configure hybrid search behaviors.
    :vartype hybrid_search: ~azure.search.documents.models.HybridSearch
    """

    include_total_result_count: Optional[bool] = rest_field(
        name="count", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value that specifies whether to fetch the total count of results. Default is
     false. Setting this value to true may have a performance impact. Note that the
     count returned is an approximation."""
    facets: Optional[List[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The list of facet expressions to apply to the search query. Each facet
     expression contains a field name, optionally followed by a comma-separated list
     of name:value pairs."""
    filter: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The OData $filter expression to apply to the search query."""
    highlight_fields: Optional[str] = rest_field(
        name="highlight", visibility=["read", "create", "update", "delete", "query"]
    )
    """The comma-separated list of field names to use for hit highlights. Only
     searchable fields can be used for hit highlighting."""
    highlight_post_tag: Optional[str] = rest_field(
        name="highlightPostTag", visibility=["read", "create", "update", "delete", "query"]
    )
    """A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. Default is &lt;/em&gt;."""
    highlight_pre_tag: Optional[str] = rest_field(
        name="highlightPreTag", visibility=["read", "create", "update", "delete", "query"]
    )
    """A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. Default is &lt;em&gt;."""
    minimum_coverage: Optional[float] = rest_field(
        name="minimumCoverage", visibility=["read", "create", "update", "delete", "query"]
    )
    """A number between 0 and 100 indicating the percentage of the index that must be
     covered by a search query in order for the query to be reported as a success.
     This parameter can be useful for ensuring search availability even for services
     with only one replica. The default is 100."""
    order_by: Optional[str] = rest_field(name="orderby", visibility=["read", "create", "update", "delete", "query"])
    """The comma-separated list of OData $orderby expressions by which to sort the
     results. Each expression can be either a field name or a call to either the
     geo.distance() or the search.score() functions. Each expression can be followed
     by asc to indicate ascending, or desc to indicate descending. The default is
     ascending order. Ties will be broken by the match scores of documents. If no
     $orderby is specified, the default sort order is descending by document match
     score. There can be at most 32 $orderby clauses."""
    query_type: Optional[Union[str, "_models.QueryType"]] = rest_field(
        name="queryType", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value that specifies the syntax of the search query. The default is 'simple'.
     Use 'full' if your query uses the Lucene query syntax. Known values are: \"simple\", \"full\",
     and \"semantic\"."""
    scoring_statistics: Optional[Union[str, "_models.ScoringStatistics"]] = rest_field(
        name="scoringStatistics", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value that specifies whether we want to calculate scoring statistics (such as
     document frequency) globally for more consistent scoring, or locally, for lower
     latency. The default is 'local'. Use 'global' to aggregate scoring statistics
     globally before scoring. Using global scoring statistics can increase latency
     of search queries. Known values are: \"local\" and \"global\"."""
    session_id: Optional[str] = rest_field(name="sessionId", visibility=["read", "create", "update", "delete", "query"])
    """A value to be used to create a sticky session, which can help getting more
     consistent results. As long as the same sessionId is used, a best-effort
     attempt will be made to target the same replica set. Be wary that reusing the
     same sessionID values repeatedly can interfere with the load balancing of the
     requests across replicas and adversely affect the performance of the search
     service. The value used as sessionId cannot start with a '_' character."""
    scoring_parameters: Optional[List[str]] = rest_field(
        name="scoringParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of parameter values to be used in scoring functions (for example,
     referencePointParameter) using the format name-values. For example, if the
     scoring profile defines a function with a parameter called 'mylocation' the
     parameter string would be \"mylocation--122.2,44.8\" (without the quotes)."""
    scoring_profile: Optional[str] = rest_field(
        name="scoringProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of a scoring profile to evaluate match scores for matching documents
     in order to sort the results."""
    debug: Optional[Union[str, "_models.QueryDebugMode"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Enables a debugging tool that can be used to further explore your reranked
     results. Known values are: \"disabled\", \"semantic\", \"vector\", \"queryRewrites\", and
     \"all\"."""
    search_text: Optional[str] = rest_field(name="search", visibility=["read", "create", "update", "delete", "query"])
    """A full-text search query expression; Use \"*\" or omit this parameter to match
     all documents."""
    search_fields: Optional[str] = rest_field(
        name="searchFields", visibility=["read", "create", "update", "delete", "query"]
    )
    """The comma-separated list of field names to which to scope the full-text search.
     When using fielded search (fieldName:searchExpression) in a full Lucene query,
     the field names of each fielded search expression take precedence over any
     field names listed in this parameter."""
    search_mode: Optional[Union[str, "_models.SearchMode"]] = rest_field(
        name="searchMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value that specifies whether any or all of the search terms must be matched
     in order to count the document as a match. Known values are: \"any\" and \"all\"."""
    query_language: Optional[Union[str, "_models.QueryLanguage"]] = rest_field(
        name="queryLanguage", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value that specifies the language of the search query. Known values are: \"none\", \"en-us\",
     \"en-gb\", \"en-in\", \"en-ca\", \"en-au\", \"fr-fr\", \"fr-ca\", \"de-de\", \"es-es\",
     \"es-mx\", \"zh-cn\", \"zh-tw\", \"pt-br\", \"pt-pt\", \"it-it\", \"ja-jp\", \"ko-kr\",
     \"ru-ru\", \"cs-cz\", \"nl-be\", \"nl-nl\", \"hu-hu\", \"pl-pl\", \"sv-se\", \"tr-tr\",
     \"hi-in\", \"ar-sa\", \"ar-eg\", \"ar-ma\", \"ar-kw\", \"ar-jo\", \"da-dk\", \"no-no\",
     \"bg-bg\", \"hr-hr\", \"hr-ba\", \"ms-my\", \"ms-bn\", \"sl-sl\", \"ta-in\", \"vi-vn\",
     \"el-gr\", \"ro-ro\", \"is-is\", \"id-id\", \"th-th\", \"lt-lt\", \"uk-ua\", \"lv-lv\",
     \"et-ee\", \"ca-es\", \"fi-fi\", \"sr-ba\", \"sr-me\", \"sr-rs\", \"sk-sk\", \"nb-no\",
     \"hy-am\", \"bn-in\", \"eu-es\", \"gl-es\", \"gu-in\", \"he-il\", \"ga-ie\", \"kn-in\",
     \"ml-in\", \"mr-in\", \"fa-ae\", \"pa-in\", \"te-in\", and \"ur-pk\"."""
    speller: Optional[Union[str, "_models.QuerySpellerType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A value that specified the type of the speller to use to spell-correct
     individual search query terms. Known values are: \"none\" and \"lexicon\"."""
    select: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The comma-separated list of fields to retrieve. If unspecified, all fields
     marked as retrievable in the schema are included."""
    skip: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The number of search results to skip. This value cannot be greater than
     100,000. If you need to scan documents in sequence, but cannot use skip due to
     this limitation, consider using orderby on a totally-ordered key and filter
     with a range query instead."""
    top: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The number of search results to retrieve. This can be used in conjunction with
     $skip to implement client-side paging of search results. If results are
     truncated due to server-side paging, the response will include a continuation
     token that can be used to issue another Search request for the next page of
     results."""
    semantic_configuration: Optional[str] = rest_field(
        name="semanticConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of a semantic configuration that will be used when processing
     documents for queries of type semantic."""
    semantic_error_handling: Optional[Union[str, "_models.SemanticErrorMode"]] = rest_field(
        name="semanticErrorHandling", visibility=["read", "create", "update", "delete", "query"]
    )
    """Allows the user to choose whether a semantic call should fail completely
     (default / current behavior), or to return partial results. Known values are: \"partial\" and
     \"fail\"."""
    semantic_max_wait_in_milliseconds: Optional[int] = rest_field(
        name="semanticMaxWaitInMilliseconds", visibility=["read", "create", "update", "delete", "query"]
    )
    """Allows the user to set an upper bound on the amount of time it takes for
     semantic enrichment to finish processing before the request fails."""
    semantic_query: Optional[str] = rest_field(
        name="semanticQuery", visibility=["read", "create", "update", "delete", "query"]
    )
    """Allows setting a separate search query that will be solely used for semantic
     reranking, semantic captions and semantic answers. Is useful for scenarios
     where there is a need to use different queries between the base retrieval and
     ranking phase, and the L2 semantic phase."""
    answers: Optional[Union[str, "_models.QueryAnswerType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A value that specifies whether answers should be returned as part of the search
     response. Known values are: \"none\" and \"extractive\"."""
    captions: Optional[Union[str, "_models.QueryCaptionType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A value that specifies whether captions should be returned as part of the
     search response. Known values are: \"none\" and \"extractive\"."""
    query_rewrites: Optional[Union[str, "_models.QueryRewritesType"]] = rest_field(
        name="queryRewrites", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value that specifies whether query rewrites should be generated to augment
     the search query. Known values are: \"none\" and \"generative\"."""
    semantic_fields: Optional[str] = rest_field(
        name="semanticFields", visibility=["read", "create", "update", "delete", "query"]
    )
    """The comma-separated list of field names used for semantic ranking."""
    vector_queries: Optional[List["_models.VectorQuery"]] = rest_field(
        name="vectorQueries", visibility=["read", "create", "update", "delete", "query"]
    )
    """The query parameters for vector and hybrid search queries."""
    vector_filter_mode: Optional[Union[str, "_models.VectorFilterMode"]] = rest_field(
        name="vectorFilterMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines whether or not filters are applied before or after the vector search
     is performed. Default is 'preFilter' for new indexes. Known values are: \"postFilter\" and
     \"preFilter\"."""
    hybrid_search: Optional["_models.HybridSearch"] = rest_field(
        name="hybridSearch", visibility=["read", "create", "update", "delete", "query"]
    )
    """The query parameters to configure hybrid search behaviors."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        include_total_result_count: Optional[bool] = None,
        facets: Optional[List[str]] = None,
        filter: Optional[str] = None,  # pylint: disable=redefined-builtin
        highlight_fields: Optional[str] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        order_by: Optional[str] = None,
        query_type: Optional[Union[str, "_models.QueryType"]] = None,
        scoring_statistics: Optional[Union[str, "_models.ScoringStatistics"]] = None,
        session_id: Optional[str] = None,
        scoring_parameters: Optional[List[str]] = None,
        scoring_profile: Optional[str] = None,
        debug: Optional[Union[str, "_models.QueryDebugMode"]] = None,
        search_text: Optional[str] = None,
        search_fields: Optional[str] = None,
        search_mode: Optional[Union[str, "_models.SearchMode"]] = None,
        query_language: Optional[Union[str, "_models.QueryLanguage"]] = None,
        speller: Optional[Union[str, "_models.QuerySpellerType"]] = None,
        select: Optional[str] = None,
        skip: Optional[int] = None,
        top: Optional[int] = None,
        semantic_configuration: Optional[str] = None,
        semantic_error_handling: Optional[Union[str, "_models.SemanticErrorMode"]] = None,
        semantic_max_wait_in_milliseconds: Optional[int] = None,
        semantic_query: Optional[str] = None,
        answers: Optional[Union[str, "_models.QueryAnswerType"]] = None,
        captions: Optional[Union[str, "_models.QueryCaptionType"]] = None,
        query_rewrites: Optional[Union[str, "_models.QueryRewritesType"]] = None,
        semantic_fields: Optional[str] = None,
        vector_queries: Optional[List["_models.VectorQuery"]] = None,
        vector_filter_mode: Optional[Union[str, "_models.VectorFilterMode"]] = None,
        hybrid_search: Optional["_models.HybridSearch"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchResourceEncryptionKey(_model_base.Model):
    """A customer-managed encryption key in Azure Key Vault. Keys that you create and
    manage can be used to encrypt or decrypt data-at-rest, such as indexes and
    synonym maps.


    :ivar key_name: The name of your Azure Key Vault key to be used to encrypt your data at rest.
     Required.
    :vartype key_name: str
    :ivar key_version: The version of your Azure Key Vault key to be used to encrypt your data at
     rest. Required.
    :vartype key_version: str
    :ivar vault_uri: The URI of your Azure Key Vault, also referred to as DNS name, that contains
     the key to be used to encrypt your data at rest. An example URI might be
     ``https://my-keyvault-name.vault.azure.net``. Required.
    :vartype vault_uri: str
    :ivar access_credentials: Optional Azure Active Directory credentials used for accessing your
     Azure Key
     Vault. Not required if using managed identity instead.
    :vartype access_credentials:
     ~azure.search.documents.models.AzureActiveDirectoryApplicationCredentials
    :ivar identity: An explicit managed identity to use for this encryption key. If not specified
     and the access credentials property is null, the system-assigned managed
     identity is used. On update to the resource, if the explicit identity is
     unspecified, it remains unchanged. If "none" is specified, the value of this
     property is cleared.
    :vartype identity: ~azure.search.documents.models.SearchIndexerDataIdentity
    """

    key_name: str = rest_field(name="keyVaultKeyName", visibility=["read", "create", "update", "delete", "query"])
    """The name of your Azure Key Vault key to be used to encrypt your data at rest. Required."""
    key_version: str = rest_field(name="keyVaultKeyVersion", visibility=["read", "create", "update", "delete", "query"])
    """The version of your Azure Key Vault key to be used to encrypt your data at rest. Required."""
    vault_uri: str = rest_field(name="keyVaultUri", visibility=["read", "create", "update", "delete", "query"])
    """The URI of your Azure Key Vault, also referred to as DNS name, that contains
     the key to be used to encrypt your data at rest. An example URI might be
     ``https://my-keyvault-name.vault.azure.net``. Required."""
    access_credentials: Optional["_models.AzureActiveDirectoryApplicationCredentials"] = rest_field(
        name="accessCredentials", visibility=["read", "create", "update", "delete", "query"]
    )
    """Optional Azure Active Directory credentials used for accessing your Azure Key
     Vault. Not required if using managed identity instead."""
    identity: Optional["_models.SearchIndexerDataIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """An explicit managed identity to use for this encryption key. If not specified
     and the access credentials property is null, the system-assigned managed
     identity is used. On update to the resource, if the explicit identity is
     unspecified, it remains unchanged. If \"none\" is specified, the value of this
     property is cleared."""

    @overload
    def __init__(
        self,
        *,
        key_name: str,
        key_version: str,
        vault_uri: str,
        access_credentials: Optional["_models.AzureActiveDirectoryApplicationCredentials"] = None,
        identity: Optional["_models.SearchIndexerDataIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchResult(_model_base.Model):
    """Contains a document found by a search query, plus associated metadata.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar score: The relevance score of the document compared to other documents returned by the
     query. Required.
    :vartype score: float
    :ivar reranker_score: The relevance score computed by the semantic ranker for the top search
     results.
     Search results are sorted by the RerankerScore first and then by the Score.
     RerankerScore is only returned for queries of type 'semantic'.
    :vartype reranker_score: float
    :ivar highlights: Text fragments from the document that indicate the matching search terms,
     organized by each applicable field; null if hit highlighting was not enabled
     for the query.
    :vartype highlights: dict[str, list[str]]
    :ivar captions: Captions are the most representative passages from the document relatively to
     the search query. They are often used as document summary. Captions are only
     returned for queries of type 'semantic'.
    :vartype captions: list[~azure.search.documents.models.QueryCaptionResult]
    :ivar document_debug_info: Contains debugging information that can be used to further explore
     your search
     results.
    :vartype document_debug_info: list[~azure.search.documents.models.DocumentDebugInfo]
    """

    score: float = rest_field(name="@search.score", visibility=["read", "create", "update", "delete", "query"])
    """The relevance score of the document compared to other documents returned by the
     query. Required."""
    reranker_score: Optional[float] = rest_field(
        name="@search.rerankerScore", visibility=["read", "create", "update", "delete", "query"]
    )
    """The relevance score computed by the semantic ranker for the top search results.
     Search results are sorted by the RerankerScore first and then by the Score.
     RerankerScore is only returned for queries of type 'semantic'."""
    highlights: Optional[Dict[str, List[str]]] = rest_field(
        name="@search.highlights", visibility=["read", "create", "update", "delete", "query"]
    )
    """Text fragments from the document that indicate the matching search terms,
     organized by each applicable field; null if hit highlighting was not enabled
     for the query."""
    captions: Optional[List["_models.QueryCaptionResult"]] = rest_field(
        name="@search.captions", visibility=["read", "create", "update", "delete", "query"]
    )
    """Captions are the most representative passages from the document relatively to
     the search query. They are often used as document summary. Captions are only
     returned for queries of type 'semantic'."""
    document_debug_info: Optional[List["_models.DocumentDebugInfo"]] = rest_field(
        name="@search.documentDebugInfo", visibility=["read"]
    )
    """Contains debugging information that can be used to further explore your search
     results."""

    @overload
    def __init__(
        self,
        *,
        score: float,
        reranker_score: Optional[float] = None,
        highlights: Optional[Dict[str, List[str]]] = None,
        captions: Optional[List["_models.QueryCaptionResult"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorThreshold(_model_base.Model):
    """The threshold used for vector queries.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    SearchScoreThreshold, VectorSimilarityThreshold


    :ivar kind: Type of threshold. Required. Known values are: "vectorSimilarity" and
     "searchScore".
    :vartype kind: str or ~azure.search.documents.models.VectorThresholdKind
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    kind: str = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])
    """Type of threshold. Required. Known values are: \"vectorSimilarity\" and \"searchScore\"."""

    @overload
    def __init__(
        self,
        *,
        kind: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchScoreThreshold(VectorThreshold, discriminator="searchScore"):
    """The results of the vector query will filter based on the '@search.score' value.
    Note this is the @search.score returned as part of the search response. The
    threshold direction will be chosen for higher @search.score.


    :ivar value: The threshold will filter based on the '@search.score' value. Note this is the
     @search.score returned as part of the search response. The threshold direction
     will be chosen for higher @search.score. Required.
    :vartype value: float
    :ivar kind: The kind of threshold used to filter vector queries. Required. The results of the
     vector query will filter based on the '@search.score' value.
     Note this is the @search.score returned as part of the search response. The
     threshold direction will be chosen for higher @search.score.
    :vartype kind: str or ~azure.search.documents.models.SEARCH_SCORE
    """

    value: float = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The threshold will filter based on the '@search.score' value. Note this is the
     @search.score returned as part of the search response. The threshold direction
     will be chosen for higher @search.score. Required."""
    kind: Literal[VectorThresholdKind.SEARCH_SCORE] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The kind of threshold used to filter vector queries. Required. The results of the vector query
     will filter based on the '@search.score' value.
     Note this is the @search.score returned as part of the search response. The
     threshold direction will be chosen for higher @search.score."""

    @overload
    def __init__(
        self,
        *,
        value: float,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorThresholdKind.SEARCH_SCORE, **kwargs)


class SearchServiceCounters(_model_base.Model):
    """Represents service-level resource counters and quotas.


    :ivar alias_counter: Total number of aliases. Required.
    :vartype alias_counter: ~azure.search.documents.models.ResourceCounter
    :ivar document_counter: Total number of documents across all indexes in the service. Required.
    :vartype document_counter: ~azure.search.documents.models.ResourceCounter
    :ivar index_counter: Total number of indexes. Required.
    :vartype index_counter: ~azure.search.documents.models.ResourceCounter
    :ivar indexer_counter: Total number of indexers. Required.
    :vartype indexer_counter: ~azure.search.documents.models.ResourceCounter
    :ivar data_source_counter: Total number of data sources. Required.
    :vartype data_source_counter: ~azure.search.documents.models.ResourceCounter
    :ivar storage_size_counter: Total size of used storage in bytes. Required.
    :vartype storage_size_counter: ~azure.search.documents.models.ResourceCounter
    :ivar synonym_map_counter: Total number of synonym maps. Required.
    :vartype synonym_map_counter: ~azure.search.documents.models.ResourceCounter
    :ivar skillset_counter: Total number of skillsets. Required.
    :vartype skillset_counter: ~azure.search.documents.models.ResourceCounter
    :ivar vector_index_size_counter: Total memory consumption of all vector indexes within the
     service, in bytes. Required.
    :vartype vector_index_size_counter: ~azure.search.documents.models.ResourceCounter
    """

    alias_counter: "_models.ResourceCounter" = rest_field(
        name="aliasesCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Total number of aliases. Required."""
    document_counter: "_models.ResourceCounter" = rest_field(
        name="documentCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Total number of documents across all indexes in the service. Required."""
    index_counter: "_models.ResourceCounter" = rest_field(
        name="indexesCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Total number of indexes. Required."""
    indexer_counter: "_models.ResourceCounter" = rest_field(
        name="indexersCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Total number of indexers. Required."""
    data_source_counter: "_models.ResourceCounter" = rest_field(
        name="dataSourcesCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Total number of data sources. Required."""
    storage_size_counter: "_models.ResourceCounter" = rest_field(
        name="storageSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Total size of used storage in bytes. Required."""
    synonym_map_counter: "_models.ResourceCounter" = rest_field(
        name="synonymMaps", visibility=["read", "create", "update", "delete", "query"]
    )
    """Total number of synonym maps. Required."""
    skillset_counter: "_models.ResourceCounter" = rest_field(
        name="skillsetCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Total number of skillsets. Required."""
    vector_index_size_counter: "_models.ResourceCounter" = rest_field(
        name="vectorIndexSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Total memory consumption of all vector indexes within the service, in bytes. Required."""

    @overload
    def __init__(
        self,
        *,
        alias_counter: "_models.ResourceCounter",
        document_counter: "_models.ResourceCounter",
        index_counter: "_models.ResourceCounter",
        indexer_counter: "_models.ResourceCounter",
        data_source_counter: "_models.ResourceCounter",
        storage_size_counter: "_models.ResourceCounter",
        synonym_map_counter: "_models.ResourceCounter",
        skillset_counter: "_models.ResourceCounter",
        vector_index_size_counter: "_models.ResourceCounter",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchServiceLimits(_model_base.Model):
    """Represents various service level limits.

    :ivar max_fields_per_index: The maximum allowed fields per index.
    :vartype max_fields_per_index: int
    :ivar max_field_nesting_depth_per_index: The maximum depth which you can nest sub-fields in an
     index, including the
     top-level complex field. For example, a/b/c has a nesting depth of 3.
    :vartype max_field_nesting_depth_per_index: int
    :ivar max_complex_collection_fields_per_index: The maximum number of fields of type
     Collection(Edm.ComplexType) allowed in an
     index.
    :vartype max_complex_collection_fields_per_index: int
    :ivar max_complex_objects_in_collections_per_document: The maximum number of objects in complex
     collections allowed per document.
    :vartype max_complex_objects_in_collections_per_document: int
    :ivar max_storage_per_index_in_bytes: The maximum amount of storage in bytes allowed per index.
    :vartype max_storage_per_index_in_bytes: int
    """

    max_fields_per_index: Optional[int] = rest_field(
        name="maxFieldsPerIndex", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum allowed fields per index."""
    max_field_nesting_depth_per_index: Optional[int] = rest_field(
        name="maxFieldNestingDepthPerIndex", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum depth which you can nest sub-fields in an index, including the
     top-level complex field. For example, a/b/c has a nesting depth of 3."""
    max_complex_collection_fields_per_index: Optional[int] = rest_field(
        name="maxComplexCollectionFieldsPerIndex", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of fields of type Collection(Edm.ComplexType) allowed in an
     index."""
    max_complex_objects_in_collections_per_document: Optional[int] = rest_field(
        name="maxComplexObjectsInCollectionsPerDocument", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of objects in complex collections allowed per document."""
    max_storage_per_index_in_bytes: Optional[int] = rest_field(
        name="maxStoragePerIndex", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum amount of storage in bytes allowed per index."""

    @overload
    def __init__(
        self,
        *,
        max_fields_per_index: Optional[int] = None,
        max_field_nesting_depth_per_index: Optional[int] = None,
        max_complex_collection_fields_per_index: Optional[int] = None,
        max_complex_objects_in_collections_per_document: Optional[int] = None,
        max_storage_per_index_in_bytes: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchServiceStatistics(_model_base.Model):
    """Response from a get service statistics request. If successful, it includes
    service level counters and limits.


    :ivar counters: Service level resource counters. Required.
    :vartype counters: ~azure.search.documents.models.SearchServiceCounters
    :ivar limits: Service level general limits. Required.
    :vartype limits: ~azure.search.documents.models.SearchServiceLimits
    """

    counters: "_models.SearchServiceCounters" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Service level resource counters. Required."""
    limits: "_models.SearchServiceLimits" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Service level general limits. Required."""

    @overload
    def __init__(
        self,
        *,
        counters: "_models.SearchServiceCounters",
        limits: "_models.SearchServiceLimits",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SearchSuggester(_model_base.Model):
    """Defines how the Suggest API should apply to a group of fields in the index.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar name: The name of the suggester. Required.
    :vartype name: str
    :ivar search_mode: A value indicating the capabilities of the suggester. Required. Default
     value is "analyzingInfixMatching".
    :vartype search_mode: str
    :ivar source_fields: The list of field names to which the suggester applies. Each field must be
     searchable. Required.
    :vartype source_fields: list[str]
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the suggester. Required."""
    search_mode: Literal["analyzingInfixMatching"] = rest_field(
        name="searchMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating the capabilities of the suggester. Required. Default value is
     \"analyzingInfixMatching\"."""
    source_fields: List[str] = rest_field(
        name="sourceFields", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of field names to which the suggester applies. Each field must be
     searchable. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        source_fields: List[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.search_mode: Literal["analyzingInfixMatching"] = "analyzingInfixMatching"


class SemanticConfiguration(_model_base.Model):
    """Defines a specific configuration to be used in the context of semantic
    capabilities.


    :ivar name: The name of the semantic configuration. Required.
    :vartype name: str
    :ivar prioritized_fields: Describes the title, content, and keyword fields to be used for
     semantic
     ranking, captions, highlights, and answers. At least one of the three sub
     properties (titleField, prioritizedKeywordsFields and prioritizedContentFields)
     need to be set. Required.
    :vartype prioritized_fields: ~azure.search.documents.models.SemanticPrioritizedFields
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the semantic configuration. Required."""
    prioritized_fields: "_models.SemanticPrioritizedFields" = rest_field(
        name="prioritizedFields", visibility=["read", "create", "update", "delete", "query"]
    )
    """Describes the title, content, and keyword fields to be used for semantic
     ranking, captions, highlights, and answers. At least one of the three sub
     properties (titleField, prioritizedKeywordsFields and prioritizedContentFields)
     need to be set. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        prioritized_fields: "_models.SemanticPrioritizedFields",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SemanticDebugInfo(_model_base.Model):
    """Contains debugging information specific to semantic ranking requests.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar title_field: The title field that was sent to the semantic enrichment process, as well as
     how it was used.
    :vartype title_field: ~azure.search.documents.models.QueryResultDocumentSemanticField
    :ivar content_fields: The content fields that were sent to the semantic enrichment process, as
     well
     as how they were used.
    :vartype content_fields: list[~azure.search.documents.models.QueryResultDocumentSemanticField]
    :ivar keyword_fields: The keyword fields that were sent to the semantic enrichment process, as
     well
     as how they were used.
    :vartype keyword_fields: list[~azure.search.documents.models.QueryResultDocumentSemanticField]
    :ivar reranker_input: The raw concatenated strings that were sent to the semantic enrichment
     process.
    :vartype reranker_input: ~azure.search.documents.models.QueryResultDocumentRerankerInput
    """

    title_field: Optional["_models.QueryResultDocumentSemanticField"] = rest_field(
        name="titleField", visibility=["read"]
    )
    """The title field that was sent to the semantic enrichment process, as well as
     how it was used."""
    content_fields: Optional[List["_models.QueryResultDocumentSemanticField"]] = rest_field(
        name="contentFields", visibility=["read"]
    )
    """The content fields that were sent to the semantic enrichment process, as well
     as how they were used."""
    keyword_fields: Optional[List["_models.QueryResultDocumentSemanticField"]] = rest_field(
        name="keywordFields", visibility=["read"]
    )
    """The keyword fields that were sent to the semantic enrichment process, as well
     as how they were used."""
    reranker_input: Optional["_models.QueryResultDocumentRerankerInput"] = rest_field(
        name="rerankerInput", visibility=["read"]
    )
    """The raw concatenated strings that were sent to the semantic enrichment process."""


class SemanticField(_model_base.Model):
    """A field that is used as part of the semantic configuration.


    :ivar field_name: File name. Required.
    :vartype field_name: str
    """

    field_name: str = rest_field(name="fieldName", visibility=["read", "create", "update", "delete", "query"])
    """File name. Required."""

    @overload
    def __init__(
        self,
        *,
        field_name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SemanticPrioritizedFields(_model_base.Model):
    """Describes the title, content, and keywords fields to be used for semantic
    ranking, captions, highlights, and answers.

    :ivar title_field: Defines the title field to be used for semantic ranking, captions,
     highlights,
     and answers. If you don't have a title field in your index, leave this blank.
    :vartype title_field: ~azure.search.documents.models.SemanticField
    :ivar content_fields: Defines the content fields to be used for semantic ranking, captions,
     highlights, and answers. For the best result, the selected fields should
     contain text in natural language form. The order of the fields in the array
     represents their priority. Fields with lower priority may get truncated if the
     content is long.
    :vartype content_fields: list[~azure.search.documents.models.SemanticField]
    :ivar keywords_fields: Defines the keyword fields to be used for semantic ranking, captions,
     highlights, and answers. For the best result, the selected fields should
     contain a list of keywords. The order of the fields in the array represents
     their priority. Fields with lower priority may get truncated if the content is
     long.
    :vartype keywords_fields: list[~azure.search.documents.models.SemanticField]
    """

    title_field: Optional["_models.SemanticField"] = rest_field(
        name="titleField", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines the title field to be used for semantic ranking, captions, highlights,
     and answers. If you don't have a title field in your index, leave this blank."""
    content_fields: Optional[List["_models.SemanticField"]] = rest_field(
        name="prioritizedContentFields", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines the content fields to be used for semantic ranking, captions,
     highlights, and answers. For the best result, the selected fields should
     contain text in natural language form. The order of the fields in the array
     represents their priority. Fields with lower priority may get truncated if the
     content is long."""
    keywords_fields: Optional[List["_models.SemanticField"]] = rest_field(
        name="prioritizedKeywordsFields", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines the keyword fields to be used for semantic ranking, captions,
     highlights, and answers. For the best result, the selected fields should
     contain a list of keywords. The order of the fields in the array represents
     their priority. Fields with lower priority may get truncated if the content is
     long."""

    @overload
    def __init__(
        self,
        *,
        title_field: Optional["_models.SemanticField"] = None,
        content_fields: Optional[List["_models.SemanticField"]] = None,
        keywords_fields: Optional[List["_models.SemanticField"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SemanticSearch(_model_base.Model):
    """Defines parameters for a search index that influence semantic capabilities.

    :ivar default_configuration_name: Allows you to set the name of a default semantic
     configuration in your index,
     making it optional to pass it on as a query parameter every time.
    :vartype default_configuration_name: str
    :ivar configurations: The semantic configurations for the index.
    :vartype configurations: list[~azure.search.documents.models.SemanticConfiguration]
    """

    default_configuration_name: Optional[str] = rest_field(
        name="defaultConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """Allows you to set the name of a default semantic configuration in your index,
     making it optional to pass it on as a query parameter every time."""
    configurations: Optional[List["_models.SemanticConfiguration"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The semantic configurations for the index."""

    @overload
    def __init__(
        self,
        *,
        default_configuration_name: Optional[str] = None,
        configurations: Optional[List["_models.SemanticConfiguration"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SentimentSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.SentimentSkill"):
    """This skill is deprecated. Use the V3.SentimentSkill instead.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar default_language_code: A value indicating which language code to use. Default is ``en``.
     Known values are: "da", "nl", "en", "fi", "fr", "de", "el", "it", "no", "pl", "pt-PT", "ru",
     "es", "sv", and "tr".
    :vartype default_language_code: str or ~azure.search.documents.models.SentimentSkillLanguage
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.SentimentSkill".
    :vartype odata_type: str
    """

    default_language_code: Optional[Union[str, "_models.SentimentSkillLanguage"]] = rest_field(
        name="defaultLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which language code to use. Default is ``en``. Known values are: \"da\",
     \"nl\", \"en\", \"fi\", \"fr\", \"de\", \"el\", \"it\", \"no\", \"pl\", \"pt-PT\", \"ru\",
     \"es\", \"sv\", and \"tr\"."""
    odata_type: Literal["#Microsoft.Skills.Text.SentimentSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.SentimentSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        default_language_code: Optional[Union[str, "_models.SentimentSkillLanguage"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.SentimentSkill", **kwargs)


class SentimentSkillV3(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.V3.SentimentSkill"):
    """Using the Text Analytics API, evaluates unstructured text and for each record,
    provides sentiment labels (such as "negative", "neutral" and "positive") based
    on the highest confidence score found by the service at a sentence and
    document-level.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar default_language_code: A value indicating which language code to use. Default is ``en``.
    :vartype default_language_code: str
    :ivar include_opinion_mining: If set to true, the skill output will include information from
     Text Analytics
     for opinion mining, namely targets (nouns or verbs) and their associated
     assessment (adjective) in the text. Default is false.
    :vartype include_opinion_mining: bool
    :ivar model_version: The version of the model to use when calling the Text Analytics service.
     It
     will default to the latest available when not specified. We recommend you do
     not specify this value unless absolutely necessary.
    :vartype model_version: str
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.V3.SentimentSkill".
    :vartype odata_type: str
    """

    default_language_code: Optional[str] = rest_field(
        name="defaultLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which language code to use. Default is ``en``."""
    include_opinion_mining: Optional[bool] = rest_field(
        name="includeOpinionMining", visibility=["read", "create", "update", "delete", "query"]
    )
    """If set to true, the skill output will include information from Text Analytics
     for opinion mining, namely targets (nouns or verbs) and their associated
     assessment (adjective) in the text. Default is false."""
    model_version: Optional[str] = rest_field(
        name="modelVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The version of the model to use when calling the Text Analytics service. It
     will default to the latest available when not specified. We recommend you do
     not specify this value unless absolutely necessary."""
    odata_type: Literal["#Microsoft.Skills.Text.V3.SentimentSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.V3.SentimentSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        default_language_code: Optional[str] = None,
        include_opinion_mining: Optional[bool] = None,
        model_version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.V3.SentimentSkill", **kwargs)


class ShaperSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Util.ShaperSkill"):
    """A skill for reshaping the outputs. It creates a complex type to support
    composite fields (also known as multipart fields).


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Util.ShaperSkill".
    :vartype odata_type: str
    """

    odata_type: Literal["#Microsoft.Skills.Util.ShaperSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Util.ShaperSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Util.ShaperSkill", **kwargs)


class ShingleTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.ShingleTokenFilter"):
    """Creates combinations of tokens as a single token. This token filter is
    implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar max_shingle_size: The maximum shingle size. Default and minimum value is 2.
    :vartype max_shingle_size: int
    :ivar min_shingle_size: The minimum shingle size. Default and minimum value is 2. Must be less
     than the
     value of maxShingleSize.
    :vartype min_shingle_size: int
    :ivar output_unigrams: A value indicating whether the output stream will contain the input
     tokens
     (unigrams) as well as shingles. Default is true.
    :vartype output_unigrams: bool
    :ivar output_unigrams_if_no_shingles: A value indicating whether to output unigrams for those
     times when no shingles
     are available. This property takes precedence when outputUnigrams is set to
     false. Default is false.
    :vartype output_unigrams_if_no_shingles: bool
    :ivar token_separator: The string to use when joining adjacent tokens to form a shingle.
     Default is a
     single space (" ").
    :vartype token_separator: str
    :ivar filter_token: The string to insert for each position at which there is no token. Default
     is
     an underscore ("_").
    :vartype filter_token: str
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.ShingleTokenFilter".
    :vartype odata_type: str
    """

    max_shingle_size: Optional[int] = rest_field(
        name="maxShingleSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum shingle size. Default and minimum value is 2."""
    min_shingle_size: Optional[int] = rest_field(
        name="minShingleSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The minimum shingle size. Default and minimum value is 2. Must be less than the
     value of maxShingleSize."""
    output_unigrams: Optional[bool] = rest_field(
        name="outputUnigrams", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether the output stream will contain the input tokens
     (unigrams) as well as shingles. Default is true."""
    output_unigrams_if_no_shingles: Optional[bool] = rest_field(
        name="outputUnigramsIfNoShingles", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to output unigrams for those times when no shingles
     are available. This property takes precedence when outputUnigrams is set to
     false. Default is false."""
    token_separator: Optional[str] = rest_field(
        name="tokenSeparator", visibility=["read", "create", "update", "delete", "query"]
    )
    """The string to use when joining adjacent tokens to form a shingle. Default is a
     single space (\" \")."""
    filter_token: Optional[str] = rest_field(
        name="filterToken", visibility=["read", "create", "update", "delete", "query"]
    )
    """The string to insert for each position at which there is no token. Default is
     an underscore (\"_\")."""
    odata_type: Literal["#Microsoft.Azure.Search.ShingleTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.ShingleTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        max_shingle_size: Optional[int] = None,
        min_shingle_size: Optional[int] = None,
        output_unigrams: Optional[bool] = None,
        output_unigrams_if_no_shingles: Optional[bool] = None,
        token_separator: Optional[str] = None,
        filter_token: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.ShingleTokenFilter", **kwargs)


class SingleVectorFieldResult(_model_base.Model):
    """A single vector field result. Both @search.score and vector similarity values
    are returned. Vector similarity is related to @search.score by an equation.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar search_score: The @search.score value that is calculated from the vector similarity
     score.
     This is the score that's visible in a pure single-field single-vector query.
    :vartype search_score: float
    :ivar vector_similarity: The vector similarity score for this document. Note this is the
     canonical
     definition of similarity metric, not the 'distance' version. For example,
     cosine similarity instead of cosine distance.
    :vartype vector_similarity: float
    """

    search_score: Optional[float] = rest_field(name="searchScore", visibility=["read"])
    """The @search.score value that is calculated from the vector similarity score.
     This is the score that's visible in a pure single-field single-vector query."""
    vector_similarity: Optional[float] = rest_field(name="vectorSimilarity", visibility=["read"])
    """The vector similarity score for this document. Note this is the canonical
     definition of similarity metric, not the 'distance' version. For example,
     cosine similarity instead of cosine distance."""


class SkillNames(_model_base.Model):
    """The type of the skill names.

    :ivar skill_names: the names of skills to be reset.
    :vartype skill_names: list[str]
    """

    skill_names: Optional[List[str]] = rest_field(
        name="skillNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """the names of skills to be reset."""

    @overload
    def __init__(
        self,
        *,
        skill_names: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SnowballTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.SnowballTokenFilter"):
    """A filter that stems words using a Snowball-generated stemmer. This token filter
    is implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar language: The language to use. Required. Known values are: "armenian", "basque",
     "catalan", "danish", "dutch", "english", "finnish", "french", "german", "german2", "hungarian",
     "italian", "kp", "lovins", "norwegian", "porter", "portuguese", "romanian", "russian",
     "spanish", "swedish", and "turkish".
    :vartype language: str or ~azure.search.documents.models.SnowballTokenFilterLanguage
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.SnowballTokenFilter".
    :vartype odata_type: str
    """

    language: Union[str, "_models.SnowballTokenFilterLanguage"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The language to use. Required. Known values are: \"armenian\", \"basque\", \"catalan\",
     \"danish\", \"dutch\", \"english\", \"finnish\", \"french\", \"german\", \"german2\",
     \"hungarian\", \"italian\", \"kp\", \"lovins\", \"norwegian\", \"porter\", \"portuguese\",
     \"romanian\", \"russian\", \"spanish\", \"swedish\", and \"turkish\"."""
    odata_type: Literal["#Microsoft.Azure.Search.SnowballTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.SnowballTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        language: Union[str, "_models.SnowballTokenFilterLanguage"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.SnowballTokenFilter", **kwargs)


class SoftDeleteColumnDeletionDetectionPolicy(
    DataDeletionDetectionPolicy, discriminator="#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
):
    """Defines a data deletion detection policy that implements a soft-deletion
    strategy. It determines whether an item should be deleted based on the value of
    a designated 'soft delete' column.


    :ivar soft_delete_column_name: The name of the column to use for soft-deletion detection.
    :vartype soft_delete_column_name: str
    :ivar soft_delete_marker_value: The marker value that identifies an item as deleted.
    :vartype soft_delete_marker_value: str
    :ivar odata_type: A URI fragment specifying the type of data deletion detection policy.
     Required. Default value is "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy".
    :vartype odata_type: str
    """

    soft_delete_column_name: Optional[str] = rest_field(
        name="softDeleteColumnName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the column to use for soft-deletion detection."""
    soft_delete_marker_value: Optional[str] = rest_field(
        name="softDeleteMarkerValue", visibility=["read", "create", "update", "delete", "query"]
    )
    """The marker value that identifies an item as deleted."""
    odata_type: Literal["#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of data deletion detection policy. Required. Default value
     is \"#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy\"."""

    @overload
    def __init__(
        self,
        *,
        soft_delete_column_name: Optional[str] = None,
        soft_delete_marker_value: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy", **kwargs)


class SplitSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.SplitSkill"):
    """A skill to split a string into chunks of text.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar default_language_code: A value indicating which language code to use. Default is ``en``.
     Known values are: "am", "bs", "cs", "da", "de", "en", "es", "et", "fi", "fr", "he", "hi", "hr",
     "hu", "id", "is", "it", "ja", "ko", "lv", "nb", "nl", "pl", "pt", "pt-br", "ru", "sk", "sl",
     "sr", "sv", "tr", "ur", and "zh".
    :vartype default_language_code: str or ~azure.search.documents.models.SplitSkillLanguage
    :ivar text_split_mode: A value indicating which split mode to perform. Known values are:
     "pages" and "sentences".
    :vartype text_split_mode: str or ~azure.search.documents.models.TextSplitMode
    :ivar maximum_page_length: The desired maximum page length. Default is 10000.
    :vartype maximum_page_length: int
    :ivar page_overlap_length: Only applicable when textSplitMode is set to 'pages'. If specified,
     n+1th chunk
     will start with this number of characters/tokens from the end of the nth chunk.
    :vartype page_overlap_length: int
    :ivar maximum_pages_to_take: Only applicable when textSplitMode is set to 'pages'. If
     specified, the
     SplitSkill will discontinue splitting after processing the first 'maximumPagesToTake'
     pages, in order to improve performance when only a few
     initial pages are needed from each document.
    :vartype maximum_pages_to_take: int
    :ivar unit: Only applies if textSplitMode is set to pages. There are two possible values.
     The choice of the values will decide the length (maximumPageLength and
     pageOverlapLength) measurement. The default is 'characters', which means the
     length will be measured by character. Known values are: "characters" and "azureOpenAITokens".
    :vartype unit: str or ~azure.search.documents.models.SplitSkillUnit
    :ivar azure_open_ai_tokenizer_parameters: Only applies if the unit is set to azureOpenAITokens.
     If specified, the
     splitSkill will use these parameters when performing the tokenization. The
     parameters are a valid 'encoderModelName' and an optional 'allowedSpecialTokens' property.
    :vartype azure_open_ai_tokenizer_parameters:
     ~azure.search.documents.models.AzureOpenAITokenizerParameters
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.SplitSkill".
    :vartype odata_type: str
    """

    default_language_code: Optional[Union[str, "_models.SplitSkillLanguage"]] = rest_field(
        name="defaultLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which language code to use. Default is ``en``. Known values are: \"am\",
     \"bs\", \"cs\", \"da\", \"de\", \"en\", \"es\", \"et\", \"fi\", \"fr\", \"he\", \"hi\", \"hr\",
     \"hu\", \"id\", \"is\", \"it\", \"ja\", \"ko\", \"lv\", \"nb\", \"nl\", \"pl\", \"pt\",
     \"pt-br\", \"ru\", \"sk\", \"sl\", \"sr\", \"sv\", \"tr\", \"ur\", and \"zh\"."""
    text_split_mode: Optional[Union[str, "_models.TextSplitMode"]] = rest_field(
        name="textSplitMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating which split mode to perform. Known values are: \"pages\" and \"sentences\"."""
    maximum_page_length: Optional[int] = rest_field(
        name="maximumPageLength", visibility=["read", "create", "update", "delete", "query"]
    )
    """The desired maximum page length. Default is 10000."""
    page_overlap_length: Optional[int] = rest_field(
        name="pageOverlapLength", visibility=["read", "create", "update", "delete", "query"]
    )
    """Only applicable when textSplitMode is set to 'pages'. If specified, n+1th chunk
     will start with this number of characters/tokens from the end of the nth chunk."""
    maximum_pages_to_take: Optional[int] = rest_field(
        name="maximumPagesToTake", visibility=["read", "create", "update", "delete", "query"]
    )
    """Only applicable when textSplitMode is set to 'pages'. If specified, the
     SplitSkill will discontinue splitting after processing the first 'maximumPagesToTake'
     pages, in order to improve performance when only a few
     initial pages are needed from each document."""
    unit: Optional[Union[str, "_models.SplitSkillUnit"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Only applies if textSplitMode is set to pages. There are two possible values.
     The choice of the values will decide the length (maximumPageLength and
     pageOverlapLength) measurement. The default is 'characters', which means the
     length will be measured by character. Known values are: \"characters\" and
     \"azureOpenAITokens\"."""
    azure_open_ai_tokenizer_parameters: Optional["_models.AzureOpenAITokenizerParameters"] = rest_field(
        name="azureOpenAITokenizerParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """Only applies if the unit is set to azureOpenAITokens. If specified, the
     splitSkill will use these parameters when performing the tokenization. The
     parameters are a valid 'encoderModelName' and an optional 'allowedSpecialTokens' property."""
    odata_type: Literal["#Microsoft.Skills.Text.SplitSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.SplitSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        default_language_code: Optional[Union[str, "_models.SplitSkillLanguage"]] = None,
        text_split_mode: Optional[Union[str, "_models.TextSplitMode"]] = None,
        maximum_page_length: Optional[int] = None,
        page_overlap_length: Optional[int] = None,
        maximum_pages_to_take: Optional[int] = None,
        unit: Optional[Union[str, "_models.SplitSkillUnit"]] = None,
        azure_open_ai_tokenizer_parameters: Optional["_models.AzureOpenAITokenizerParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.SplitSkill", **kwargs)


class SqlIntegratedChangeTrackingPolicy(
    DataChangeDetectionPolicy, discriminator="#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
):
    """Defines a data change detection policy that captures changes using the
    Integrated Change Tracking feature of Azure SQL Database.


    :ivar odata_type: A URI fragment specifying the type of data change detection policy. Required.
     Default value is "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy".
    :vartype odata_type: str
    """

    odata_type: Literal["#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of data change detection policy. Required. Default value is
     \"#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy\"."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy", **kwargs)


class StemmerOverrideTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.StemmerOverrideTokenFilter"):
    """Provides the ability to override other stemming filters with custom
    dictionary-based stemming. Any dictionary-stemmed terms will be marked as
    keywords so that they will not be stemmed with stemmers down the chain. Must be
    placed before any stemming filters. This token filter is implemented using
    Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar rules: A list of stemming rules in the following format: "word => stem", for example:
     "ran => run". Required.
    :vartype rules: list[str]
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.StemmerOverrideTokenFilter".
    :vartype odata_type: str
    """

    rules: List[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A list of stemming rules in the following format: \"word => stem\", for example:
     \"ran => run\". Required."""
    odata_type: Literal["#Microsoft.Azure.Search.StemmerOverrideTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.StemmerOverrideTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        rules: List[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.StemmerOverrideTokenFilter", **kwargs)


class StemmerTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.StemmerTokenFilter"):
    """Language specific stemming filter. This token filter is implemented using
    Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar language: The language to use. Required. Known values are: "arabic", "armenian",
     "basque", "brazilian", "bulgarian", "catalan", "czech", "danish", "dutch", "dutchKp",
     "english", "lightEnglish", "minimalEnglish", "possessiveEnglish", "porter2", "lovins",
     "finnish", "lightFinnish", "french", "lightFrench", "minimalFrench", "galician",
     "minimalGalician", "german", "german2", "lightGerman", "minimalGerman", "greek", "hindi",
     "hungarian", "lightHungarian", "indonesian", "irish", "italian", "lightItalian", "sorani",
     "latvian", "norwegian", "lightNorwegian", "minimalNorwegian", "lightNynorsk", "minimalNynorsk",
     "portuguese", "lightPortuguese", "minimalPortuguese", "portugueseRslp", "romanian", "russian",
     "lightRussian", "spanish", "lightSpanish", "swedish", "lightSwedish", and "turkish".
    :vartype language: str or ~azure.search.documents.models.StemmerTokenFilterLanguage
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.StemmerTokenFilter".
    :vartype odata_type: str
    """

    language: Union[str, "_models.StemmerTokenFilterLanguage"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The language to use. Required. Known values are: \"arabic\", \"armenian\", \"basque\",
     \"brazilian\", \"bulgarian\", \"catalan\", \"czech\", \"danish\", \"dutch\", \"dutchKp\",
     \"english\", \"lightEnglish\", \"minimalEnglish\", \"possessiveEnglish\", \"porter2\",
     \"lovins\", \"finnish\", \"lightFinnish\", \"french\", \"lightFrench\", \"minimalFrench\",
     \"galician\", \"minimalGalician\", \"german\", \"german2\", \"lightGerman\", \"minimalGerman\",
     \"greek\", \"hindi\", \"hungarian\", \"lightHungarian\", \"indonesian\", \"irish\",
     \"italian\", \"lightItalian\", \"sorani\", \"latvian\", \"norwegian\", \"lightNorwegian\",
     \"minimalNorwegian\", \"lightNynorsk\", \"minimalNynorsk\", \"portuguese\",
     \"lightPortuguese\", \"minimalPortuguese\", \"portugueseRslp\", \"romanian\", \"russian\",
     \"lightRussian\", \"spanish\", \"lightSpanish\", \"swedish\", \"lightSwedish\", and
     \"turkish\"."""
    odata_type: Literal["#Microsoft.Azure.Search.StemmerTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.StemmerTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        language: Union[str, "_models.StemmerTokenFilterLanguage"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.StemmerTokenFilter", **kwargs)


class StopAnalyzer(LexicalAnalyzer, discriminator="#Microsoft.Azure.Search.StopAnalyzer"):
    """Divides text at non-letters; Applies the lowercase and stopword token filters.
    This analyzer is implemented using Apache Lucene.


    :ivar name: The name of the analyzer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar stopwords: A list of stopwords.
    :vartype stopwords: list[str]
    :ivar odata_type: A URI fragment specifying the type of analyzer. Required. Default value is
     "#Microsoft.Azure.Search.StopAnalyzer".
    :vartype odata_type: str
    """

    stopwords: Optional[List[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A list of stopwords."""
    odata_type: Literal["#Microsoft.Azure.Search.StopAnalyzer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of analyzer. Required. Default value is
     \"#Microsoft.Azure.Search.StopAnalyzer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        stopwords: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.StopAnalyzer", **kwargs)


class StopwordsTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.StopwordsTokenFilter"):
    """Removes stop words from a token stream. This token filter is implemented using
    Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar stopwords: The list of stopwords. This property and the stopwords list property cannot
     both be set.
    :vartype stopwords: list[str]
    :ivar stopwords_list: A predefined list of stopwords to use. This property and the stopwords
     property
     cannot both be set. Default is English. Known values are: "arabic", "armenian", "basque",
     "brazilian", "bulgarian", "catalan", "czech", "danish", "dutch", "english", "finnish",
     "french", "galician", "german", "greek", "hindi", "hungarian", "indonesian", "irish",
     "italian", "latvian", "norwegian", "persian", "portuguese", "romanian", "russian", "sorani",
     "spanish", "swedish", "thai", and "turkish".
    :vartype stopwords_list: str or ~azure.search.documents.models.StopwordsList
    :ivar ignore_case: A value indicating whether to ignore case. If true, all words are converted
     to
     lower case first. Default is false.
    :vartype ignore_case: bool
    :ivar remove_trailing_stop_words: A value indicating whether to ignore the last search term if
     it's a stop word.
     Default is true.
    :vartype remove_trailing_stop_words: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.StopwordsTokenFilter".
    :vartype odata_type: str
    """

    stopwords: Optional[List[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The list of stopwords. This property and the stopwords list property cannot
     both be set."""
    stopwords_list: Optional[Union[str, "_models.StopwordsList"]] = rest_field(
        name="stopwordsList", visibility=["read", "create", "update", "delete", "query"]
    )
    """A predefined list of stopwords to use. This property and the stopwords property
     cannot both be set. Default is English. Known values are: \"arabic\", \"armenian\", \"basque\",
     \"brazilian\", \"bulgarian\", \"catalan\", \"czech\", \"danish\", \"dutch\", \"english\",
     \"finnish\", \"french\", \"galician\", \"german\", \"greek\", \"hindi\", \"hungarian\",
     \"indonesian\", \"irish\", \"italian\", \"latvian\", \"norwegian\", \"persian\",
     \"portuguese\", \"romanian\", \"russian\", \"sorani\", \"spanish\", \"swedish\", \"thai\", and
     \"turkish\"."""
    ignore_case: Optional[bool] = rest_field(
        name="ignoreCase", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to ignore case. If true, all words are converted to
     lower case first. Default is false."""
    remove_trailing_stop_words: Optional[bool] = rest_field(
        name="removeTrailing", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to ignore the last search term if it's a stop word.
     Default is true."""
    odata_type: Literal["#Microsoft.Azure.Search.StopwordsTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.StopwordsTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        stopwords: Optional[List[str]] = None,
        stopwords_list: Optional[Union[str, "_models.StopwordsList"]] = None,
        ignore_case: Optional[bool] = None,
        remove_trailing_stop_words: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.StopwordsTokenFilter", **kwargs)


class SuggestDocumentsResult(_model_base.Model):
    """Response containing suggestion query results from an index.


    :ivar results: The sequence of results returned by the query. Required.
    :vartype results: list[~azure.search.documents.models.SuggestResult]
    :ivar coverage: A value indicating the percentage of the index that was included in the query,
     or null if minimumCoverage was not set in the request.
    :vartype coverage: float
    """

    results: List["_models.SuggestResult"] = rest_field(
        name="value", visibility=["read", "create", "update", "delete", "query"]
    )
    """The sequence of results returned by the query. Required."""
    coverage: Optional[float] = rest_field(
        name="@search.coverage", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating the percentage of the index that was included in the query,
     or null if minimumCoverage was not set in the request."""

    @overload
    def __init__(
        self,
        *,
        results: List["_models.SuggestResult"],
        coverage: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SuggestRequest(_model_base.Model):
    """Parameters for filtering, sorting, fuzzy matching, and other suggestions query
    behaviors.

    All required parameters must be populated in order to send to server.

    :ivar filter: An OData expression that filters the documents considered for suggestions.
    :vartype filter: str
    :ivar use_fuzzy_matching: A value indicating whether to use fuzzy matching for the suggestion
     query.
     Default is false. When set to true, the query will find suggestions even if
     there's a substituted or missing character in the search text. While this
     provides a better experience in some scenarios, it comes at a performance cost
     as fuzzy suggestion searches are slower and consume more resources.
    :vartype use_fuzzy_matching: bool
    :ivar highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. If omitted, hit highlighting of suggestions is disabled.
    :vartype highlight_post_tag: str
    :ivar highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. If omitted, hit highlighting of suggestions is disabled.
    :vartype highlight_pre_tag: str
    :ivar minimum_coverage: A number between 0 and 100 indicating the percentage of the index that
     must be
     covered by a suggestion query in order for the query to be reported as a
     success. This parameter can be useful for ensuring search availability even for
     services with only one replica. The default is 80.
    :vartype minimum_coverage: float
    :ivar order_by: The comma-separated list of OData $orderby expressions by which to sort the
     results. Each expression can be either a field name or a call to either the
     geo.distance() or the search.score() functions. Each expression can be followed
     by asc to indicate ascending, or desc to indicate descending. The default is
     ascending order. Ties will be broken by the match scores of documents. If no
     $orderby is specified, the default sort order is descending by document match
     score. There can be at most 32 $orderby clauses.
    :vartype order_by: str
    :ivar search_text: The search text to use to suggest documents. Must be at least 1 character,
     and
     no more than 100 characters. Required.
    :vartype search_text: str
    :ivar search_fields: The comma-separated list of field names to search for the specified search
     text. Target fields must be included in the specified suggester.
    :vartype search_fields: str
    :ivar select: The comma-separated list of fields to retrieve. If unspecified, only the key
     field will be included in the results.
    :vartype select: str
    :ivar suggester_name: The name of the suggester as specified in the suggesters collection
     that's part
     of the index definition. Required.
    :vartype suggester_name: str
    :ivar top: The number of suggestions to retrieve. This must be a value between 1 and 100.
     The default is 5.
    :vartype top: int
    """

    filter: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """An OData expression that filters the documents considered for suggestions."""
    use_fuzzy_matching: Optional[bool] = rest_field(
        name="fuzzy", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to use fuzzy matching for the suggestion query.
     Default is false. When set to true, the query will find suggestions even if
     there's a substituted or missing character in the search text. While this
     provides a better experience in some scenarios, it comes at a performance cost
     as fuzzy suggestion searches are slower and consume more resources."""
    highlight_post_tag: Optional[str] = rest_field(
        name="highlightPostTag", visibility=["read", "create", "update", "delete", "query"]
    )
    """A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. If omitted, hit highlighting of suggestions is disabled."""
    highlight_pre_tag: Optional[str] = rest_field(
        name="highlightPreTag", visibility=["read", "create", "update", "delete", "query"]
    )
    """A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. If omitted, hit highlighting of suggestions is disabled."""
    minimum_coverage: Optional[float] = rest_field(
        name="minimumCoverage", visibility=["read", "create", "update", "delete", "query"]
    )
    """A number between 0 and 100 indicating the percentage of the index that must be
     covered by a suggestion query in order for the query to be reported as a
     success. This parameter can be useful for ensuring search availability even for
     services with only one replica. The default is 80."""
    order_by: Optional[str] = rest_field(name="orderby", visibility=["read", "create", "update", "delete", "query"])
    """The comma-separated list of OData $orderby expressions by which to sort the
     results. Each expression can be either a field name or a call to either the
     geo.distance() or the search.score() functions. Each expression can be followed
     by asc to indicate ascending, or desc to indicate descending. The default is
     ascending order. Ties will be broken by the match scores of documents. If no
     $orderby is specified, the default sort order is descending by document match
     score. There can be at most 32 $orderby clauses."""
    search_text: str = rest_field(name="search", visibility=["read", "create", "update", "delete", "query"])
    """The search text to use to suggest documents. Must be at least 1 character, and
     no more than 100 characters. Required."""
    search_fields: Optional[str] = rest_field(
        name="searchFields", visibility=["read", "create", "update", "delete", "query"]
    )
    """The comma-separated list of field names to search for the specified search
     text. Target fields must be included in the specified suggester."""
    select: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The comma-separated list of fields to retrieve. If unspecified, only the key
     field will be included in the results."""
    suggester_name: str = rest_field(name="suggesterName", visibility=["read", "create", "update", "delete", "query"])
    """The name of the suggester as specified in the suggesters collection that's part
     of the index definition. Required."""
    top: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The number of suggestions to retrieve. This must be a value between 1 and 100.
     The default is 5."""

    @overload
    def __init__(
        self,
        *,
        search_text: str,
        suggester_name: str,
        filter: Optional[str] = None,  # pylint: disable=redefined-builtin
        use_fuzzy_matching: Optional[bool] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        order_by: Optional[str] = None,
        search_fields: Optional[str] = None,
        select: Optional[str] = None,
        top: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SuggestResult(_model_base.Model):
    """A result containing a document found by a suggestion query, plus associated
    metadata.


    :ivar text: The text of the suggestion result. Required.
    :vartype text: str
    """

    text: str = rest_field(name="@search.text", visibility=["read", "create", "update", "delete", "query"])
    """The text of the suggestion result. Required."""

    @overload
    def __init__(
        self,
        *,
        text: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SynonymMap(_model_base.Model):
    """Represents a synonym map definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar name: The name of the synonym map. Required.
    :vartype name: str
    :ivar format: The format of the synonym map. Only the 'solr' format is currently supported.
     Required. Default value is "solr".
    :vartype format: str
    :ivar synonyms: A series of synonym rules in the specified synonym map format. The rules must
     be separated by newlines. Required.
    :vartype synonyms: str
    :ivar encryption_key: A description of an encryption key that you create in Azure Key Vault.
     This key
     is used to provide an additional level of encryption-at-rest for your data when
     you want full assurance that no one, not even Microsoft, can decrypt your data.
     Once you have encrypted your data, it will always remain encrypted. The search
     service will ignore attempts to set this property to null. You can change this
     property as needed if you want to rotate your encryption key; Your data will be
     unaffected. Encryption with customer-managed keys is not available for free
     search services, and is only available for paid services created on or after
     January 1, 2019.
    :vartype encryption_key: ~azure.search.documents.models.SearchResourceEncryptionKey
    :ivar e_tag: The ETag of the synonym map.
    :vartype e_tag: str
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the synonym map. Required."""
    format: Literal["solr"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The format of the synonym map. Only the 'solr' format is currently supported. Required. Default
     value is \"solr\"."""
    synonyms: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A series of synonym rules in the specified synonym map format. The rules must
     be separated by newlines. Required."""
    encryption_key: Optional["_models.SearchResourceEncryptionKey"] = rest_field(
        name="encryptionKey", visibility=["read", "create", "update", "delete", "query"]
    )
    """A description of an encryption key that you create in Azure Key Vault. This key
     is used to provide an additional level of encryption-at-rest for your data when
     you want full assurance that no one, not even Microsoft, can decrypt your data.
     Once you have encrypted your data, it will always remain encrypted. The search
     service will ignore attempts to set this property to null. You can change this
     property as needed if you want to rotate your encryption key; Your data will be
     unaffected. Encryption with customer-managed keys is not available for free
     search services, and is only available for paid services created on or after
     January 1, 2019."""
    e_tag: Optional[str] = rest_field(name="@odata.etag", visibility=["read", "create", "update", "delete", "query"])
    """The ETag of the synonym map."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        synonyms: str,
        encryption_key: Optional["_models.SearchResourceEncryptionKey"] = None,
        e_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.format: Literal["solr"] = "solr"


class SynonymTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.SynonymTokenFilter"):
    """Matches single or multi-word synonyms in a token stream. This token filter is
    implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar synonyms: A list of synonyms in following one of two formats: 1. incredible,
     unbelievable, fabulous => amazing - all terms on the left side of => symbol
     will be replaced with all terms on its right side; 2. incredible, unbelievable,
     fabulous, amazing - comma separated list of equivalent words. Set the expand
     option to change how this list is interpreted. Required.
    :vartype synonyms: list[str]
    :ivar ignore_case: A value indicating whether to case-fold input for matching. Default is
     false.
    :vartype ignore_case: bool
    :ivar expand: A value indicating whether all words in the list of synonyms (if => notation is
     not used) will map to one another. If true, all words in the list of synonyms
     (if => notation is not used) will map to one another. The following list:
     incredible, unbelievable, fabulous, amazing is equivalent to: incredible,
     unbelievable, fabulous, amazing => incredible, unbelievable, fabulous, amazing.
     If false, the following list: incredible, unbelievable, fabulous, amazing will
     be equivalent to: incredible, unbelievable, fabulous, amazing => incredible.
     Default is true.
    :vartype expand: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.SynonymTokenFilter".
    :vartype odata_type: str
    """

    synonyms: List[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A list of synonyms in following one of two formats: 1. incredible,
     unbelievable, fabulous => amazing - all terms on the left side of => symbol
     will be replaced with all terms on its right side; 2. incredible, unbelievable,
     fabulous, amazing - comma separated list of equivalent words. Set the expand
     option to change how this list is interpreted. Required."""
    ignore_case: Optional[bool] = rest_field(
        name="ignoreCase", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to case-fold input for matching. Default is false."""
    expand: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A value indicating whether all words in the list of synonyms (if => notation is
     not used) will map to one another. If true, all words in the list of synonyms
     (if => notation is not used) will map to one another. The following list:
     incredible, unbelievable, fabulous, amazing is equivalent to: incredible,
     unbelievable, fabulous, amazing => incredible, unbelievable, fabulous, amazing.
     If false, the following list: incredible, unbelievable, fabulous, amazing will
     be equivalent to: incredible, unbelievable, fabulous, amazing => incredible.
     Default is true."""
    odata_type: Literal["#Microsoft.Azure.Search.SynonymTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.SynonymTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        synonyms: List[str],
        ignore_case: Optional[bool] = None,
        expand: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.SynonymTokenFilter", **kwargs)


class TagScoringFunction(ScoringFunction, discriminator="tag"):
    """Defines a function that boosts scores of documents with string values matching
    a given list of tags.


    :ivar field_name: The name of the field used as input to the scoring function. Required.
    :vartype field_name: str
    :ivar boost: A multiplier for the raw score. Must be a positive number not equal to 1.0.
     Required.
    :vartype boost: float
    :ivar interpolation: A value indicating how boosting will be interpolated across document
     scores;
     defaults to "Linear". Known values are: "linear", "constant", "quadratic", and "logarithmic".
    :vartype interpolation: str or ~azure.search.documents.models.ScoringFunctionInterpolation
    :ivar parameters: Parameter values for the tag scoring function. Required.
    :vartype parameters: ~azure.search.documents.models.TagScoringParameters
    :ivar type: Indicates the type of function to use. Valid values include magnitude,
     freshness, distance, and tag. The function type must be lower case. Required. Default value is
     "tag".
    :vartype type: str
    """

    parameters: "_models.TagScoringParameters" = rest_field(
        name="tag", visibility=["read", "create", "update", "delete", "query"]
    )
    """Parameter values for the tag scoring function. Required."""
    type: Literal["tag"] = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Indicates the type of function to use. Valid values include magnitude,
     freshness, distance, and tag. The function type must be lower case. Required. Default value is
     \"tag\"."""

    @overload
    def __init__(
        self,
        *,
        field_name: str,
        boost: float,
        parameters: "_models.TagScoringParameters",
        interpolation: Optional[Union[str, "_models.ScoringFunctionInterpolation"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="tag", **kwargs)


class TagScoringParameters(_model_base.Model):
    """Provides parameter values to a tag scoring function.


    :ivar tags_parameter: The name of the parameter passed in search queries to specify the list of
     tags
     to compare against the target field. Required.
    :vartype tags_parameter: str
    """

    tags_parameter: str = rest_field(name="tagsParameter", visibility=["read", "create", "update", "delete", "query"])
    """The name of the parameter passed in search queries to specify the list of tags
     to compare against the target field. Required."""

    @overload
    def __init__(
        self,
        *,
        tags_parameter: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TextResult(_model_base.Model):
    """The BM25 or Classic score for the text portion of the query.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar search_score: The BM25 or Classic score for the text portion of the query.
    :vartype search_score: float
    """

    search_score: Optional[float] = rest_field(name="searchScore", visibility=["read"])
    """The BM25 or Classic score for the text portion of the query."""


class TextTranslationSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Text.TranslationSkill"):
    """A skill to translate text from one language to another.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar default_to_language_code: The language code to translate documents into for documents
     that don't specify
     the to language explicitly. Required. Known values are: "af", "ar", "bn", "bs", "bg", "yue",
     "ca", "zh-Hans", "zh-Hant", "hr", "cs", "da", "nl", "en", "et", "fj", "fil", "fi", "fr", "de",
     "el", "ht", "he", "hi", "mww", "hu", "is", "id", "it", "ja", "sw", "tlh", "tlh-Latn",
     "tlh-Piqd", "ko", "lv", "lt", "mg", "ms", "mt", "nb", "fa", "pl", "pt", "pt-br", "pt-PT",
     "otq", "ro", "ru", "sm", "sr-Cyrl", "sr-Latn", "sk", "sl", "es", "sv", "ty", "ta", "te", "th",
     "to", "tr", "uk", "ur", "vi", "cy", "yua", "ga", "kn", "mi", "ml", and "pa".
    :vartype default_to_language_code: str or
     ~azure.search.documents.models.TextTranslationSkillLanguage
    :ivar default_from_language_code: The language code to translate documents from for documents
     that don't specify
     the from language explicitly. Known values are: "af", "ar", "bn", "bs", "bg", "yue", "ca",
     "zh-Hans", "zh-Hant", "hr", "cs", "da", "nl", "en", "et", "fj", "fil", "fi", "fr", "de", "el",
     "ht", "he", "hi", "mww", "hu", "is", "id", "it", "ja", "sw", "tlh", "tlh-Latn", "tlh-Piqd",
     "ko", "lv", "lt", "mg", "ms", "mt", "nb", "fa", "pl", "pt", "pt-br", "pt-PT", "otq", "ro",
     "ru", "sm", "sr-Cyrl", "sr-Latn", "sk", "sl", "es", "sv", "ty", "ta", "te", "th", "to", "tr",
     "uk", "ur", "vi", "cy", "yua", "ga", "kn", "mi", "ml", and "pa".
    :vartype default_from_language_code: str or
     ~azure.search.documents.models.TextTranslationSkillLanguage
    :ivar suggested_from: The language code to translate documents from when neither the
     fromLanguageCode
     input nor the defaultFromLanguageCode parameter are provided, and the automatic
     language detection is unsuccessful. Default is ``en``. Known values are: "af", "ar", "bn",
     "bs", "bg", "yue", "ca", "zh-Hans", "zh-Hant", "hr", "cs", "da", "nl", "en", "et", "fj", "fil",
     "fi", "fr", "de", "el", "ht", "he", "hi", "mww", "hu", "is", "id", "it", "ja", "sw", "tlh",
     "tlh-Latn", "tlh-Piqd", "ko", "lv", "lt", "mg", "ms", "mt", "nb", "fa", "pl", "pt", "pt-br",
     "pt-PT", "otq", "ro", "ru", "sm", "sr-Cyrl", "sr-Latn", "sk", "sl", "es", "sv", "ty", "ta",
     "te", "th", "to", "tr", "uk", "ur", "vi", "cy", "yua", "ga", "kn", "mi", "ml", and "pa".
    :vartype suggested_from: str or ~azure.search.documents.models.TextTranslationSkillLanguage
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Text.TranslationSkill".
    :vartype odata_type: str
    """

    default_to_language_code: Union[str, "_models.TextTranslationSkillLanguage"] = rest_field(
        name="defaultToLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The language code to translate documents into for documents that don't specify
     the to language explicitly. Required. Known values are: \"af\", \"ar\", \"bn\", \"bs\", \"bg\",
     \"yue\", \"ca\", \"zh-Hans\", \"zh-Hant\", \"hr\", \"cs\", \"da\", \"nl\", \"en\", \"et\",
     \"fj\", \"fil\", \"fi\", \"fr\", \"de\", \"el\", \"ht\", \"he\", \"hi\", \"mww\", \"hu\",
     \"is\", \"id\", \"it\", \"ja\", \"sw\", \"tlh\", \"tlh-Latn\", \"tlh-Piqd\", \"ko\", \"lv\",
     \"lt\", \"mg\", \"ms\", \"mt\", \"nb\", \"fa\", \"pl\", \"pt\", \"pt-br\", \"pt-PT\", \"otq\",
     \"ro\", \"ru\", \"sm\", \"sr-Cyrl\", \"sr-Latn\", \"sk\", \"sl\", \"es\", \"sv\", \"ty\",
     \"ta\", \"te\", \"th\", \"to\", \"tr\", \"uk\", \"ur\", \"vi\", \"cy\", \"yua\", \"ga\",
     \"kn\", \"mi\", \"ml\", and \"pa\"."""
    default_from_language_code: Optional[Union[str, "_models.TextTranslationSkillLanguage"]] = rest_field(
        name="defaultFromLanguageCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The language code to translate documents from for documents that don't specify
     the from language explicitly. Known values are: \"af\", \"ar\", \"bn\", \"bs\", \"bg\",
     \"yue\", \"ca\", \"zh-Hans\", \"zh-Hant\", \"hr\", \"cs\", \"da\", \"nl\", \"en\", \"et\",
     \"fj\", \"fil\", \"fi\", \"fr\", \"de\", \"el\", \"ht\", \"he\", \"hi\", \"mww\", \"hu\",
     \"is\", \"id\", \"it\", \"ja\", \"sw\", \"tlh\", \"tlh-Latn\", \"tlh-Piqd\", \"ko\", \"lv\",
     \"lt\", \"mg\", \"ms\", \"mt\", \"nb\", \"fa\", \"pl\", \"pt\", \"pt-br\", \"pt-PT\", \"otq\",
     \"ro\", \"ru\", \"sm\", \"sr-Cyrl\", \"sr-Latn\", \"sk\", \"sl\", \"es\", \"sv\", \"ty\",
     \"ta\", \"te\", \"th\", \"to\", \"tr\", \"uk\", \"ur\", \"vi\", \"cy\", \"yua\", \"ga\",
     \"kn\", \"mi\", \"ml\", and \"pa\"."""
    suggested_from: Optional[Union[str, "_models.TextTranslationSkillLanguage"]] = rest_field(
        name="suggestedFrom", visibility=["read", "create", "update", "delete", "query"]
    )
    """The language code to translate documents from when neither the fromLanguageCode
     input nor the defaultFromLanguageCode parameter are provided, and the automatic
     language detection is unsuccessful. Default is ``en``. Known values are: \"af\", \"ar\",
     \"bn\", \"bs\", \"bg\", \"yue\", \"ca\", \"zh-Hans\", \"zh-Hant\", \"hr\", \"cs\", \"da\",
     \"nl\", \"en\", \"et\", \"fj\", \"fil\", \"fi\", \"fr\", \"de\", \"el\", \"ht\", \"he\",
     \"hi\", \"mww\", \"hu\", \"is\", \"id\", \"it\", \"ja\", \"sw\", \"tlh\", \"tlh-Latn\",
     \"tlh-Piqd\", \"ko\", \"lv\", \"lt\", \"mg\", \"ms\", \"mt\", \"nb\", \"fa\", \"pl\", \"pt\",
     \"pt-br\", \"pt-PT\", \"otq\", \"ro\", \"ru\", \"sm\", \"sr-Cyrl\", \"sr-Latn\", \"sk\",
     \"sl\", \"es\", \"sv\", \"ty\", \"ta\", \"te\", \"th\", \"to\", \"tr\", \"uk\", \"ur\", \"vi\",
     \"cy\", \"yua\", \"ga\", \"kn\", \"mi\", \"ml\", and \"pa\"."""
    odata_type: Literal["#Microsoft.Skills.Text.TranslationSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Text.TranslationSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        default_to_language_code: Union[str, "_models.TextTranslationSkillLanguage"],
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        default_from_language_code: Optional[Union[str, "_models.TextTranslationSkillLanguage"]] = None,
        suggested_from: Optional[Union[str, "_models.TextTranslationSkillLanguage"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Text.TranslationSkill", **kwargs)


class TextWeights(_model_base.Model):
    """Defines weights on index fields for which matches should boost scoring in
    search queries.


    :ivar weights: The dictionary of per-field weights to boost document scoring. The keys are
     field names and the values are the weights for each field. Required.
    :vartype weights: dict[str, float]
    """

    weights: Dict[str, float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The dictionary of per-field weights to boost document scoring. The keys are
     field names and the values are the weights for each field. Required."""

    @overload
    def __init__(
        self,
        *,
        weights: Dict[str, float],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TruncateTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.TruncateTokenFilter"):
    """Truncates the terms to a specific length. This token filter is implemented
    using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar length: The length at which terms will be truncated. Default and maximum is 300.
    :vartype length: int
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.TruncateTokenFilter".
    :vartype odata_type: str
    """

    length: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The length at which terms will be truncated. Default and maximum is 300."""
    odata_type: Literal["#Microsoft.Azure.Search.TruncateTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.TruncateTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        length: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.TruncateTokenFilter", **kwargs)


class UaxUrlEmailTokenizer(LexicalTokenizer, discriminator="#Microsoft.Azure.Search.UaxUrlEmailTokenizer"):
    """Tokenizes urls and emails as one token. This tokenizer is implemented using
    Apache Lucene.


    :ivar name: The name of the tokenizer. It must only contain letters, digits, spaces, dashes
     or underscores, can only start and end with alphanumeric characters, and is
     limited to 128 characters. Required.
    :vartype name: str
    :ivar max_token_length: The maximum token length. Default is 255. Tokens longer than the
     maximum length
     are split. The maximum token length that can be used is 300 characters.
    :vartype max_token_length: int
    :ivar odata_type: A URI fragment specifying the type of tokenizer. Required. Default value is
     "#Microsoft.Azure.Search.UaxUrlEmailTokenizer".
    :vartype odata_type: str
    """

    max_token_length: Optional[int] = rest_field(
        name="maxTokenLength", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum token length. Default is 255. Tokens longer than the maximum length
     are split. The maximum token length that can be used is 300 characters."""
    odata_type: Literal["#Microsoft.Azure.Search.UaxUrlEmailTokenizer"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of tokenizer. Required. Default value is
     \"#Microsoft.Azure.Search.UaxUrlEmailTokenizer\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        max_token_length: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.UaxUrlEmailTokenizer", **kwargs)


class UniqueTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.UniqueTokenFilter"):
    """Filters out tokens with same text as the previous token. This token filter is
    implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar only_on_same_position: A value indicating whether to remove duplicates only at the same
     position.
     Default is false.
    :vartype only_on_same_position: bool
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.UniqueTokenFilter".
    :vartype odata_type: str
    """

    only_on_same_position: Optional[bool] = rest_field(
        name="onlyOnSamePosition", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to remove duplicates only at the same position.
     Default is false."""
    odata_type: Literal["#Microsoft.Azure.Search.UniqueTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.UniqueTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        only_on_same_position: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.UniqueTokenFilter", **kwargs)


class VectorQuery(_model_base.Model):
    """The query parameters for vector and hybrid search queries.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    VectorizableImageBinaryQuery, VectorizableImageUrlQuery, VectorizableTextQuery, VectorizedQuery


    :ivar k_nearest_neighbors: Number of nearest neighbors to return as top hits.
    :vartype k_nearest_neighbors: int
    :ivar fields: Vector Fields of type Collection(Edm.Single) to be included in the vector
     searched.
    :vartype fields: str
    :ivar exhaustive: When true, triggers an exhaustive k-nearest neighbor search across all
     vectors
     within the vector index. Useful for scenarios where exact matches are critical,
     such as determining ground truth values.
    :vartype exhaustive: bool
    :ivar oversampling: Oversampling factor. Minimum value is 1. It overrides the
     'defaultOversampling'
     parameter configured in the index definition. It can be set only when
     'rerankWithOriginalVectors'
     is true. This parameter is only permitted when a
     compression method is used on the underlying vector field.
    :vartype oversampling: float
    :ivar weight: Relative weight of the vector query when compared to other vector query and/or
     the text query within the same search request. This value is used when
     combining the results of multiple ranking lists produced by the different
     vector queries and/or the results retrieved through the text query. The higher
     the weight, the higher the documents that matched that query will be in the
     final ranking. Default is 1.0 and the value needs to be a positive number
     larger than zero.
    :vartype weight: float
    :ivar threshold: The threshold used for vector queries. Note this can only be set if all
     'fields' use the same similarity metric.
    :vartype threshold: ~azure.search.documents.models.VectorThreshold
    :ivar filter_override: The OData filter expression to apply to this specific vector query. If
     no
     filter expression is defined at the vector level, the expression defined in the
     top level filter parameter is used instead.
    :vartype filter_override: str
    :ivar kind: Type of query. Required. Known values are: "vector", "text", "imageUrl", and
     "imageBinary".
    :vartype kind: str or ~azure.search.documents.models.VectorQueryKind
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    k_nearest_neighbors: Optional[int] = rest_field(
        name="k", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of nearest neighbors to return as top hits."""
    fields: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Vector Fields of type Collection(Edm.Single) to be included in the vector
     searched."""
    exhaustive: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """When true, triggers an exhaustive k-nearest neighbor search across all vectors
     within the vector index. Useful for scenarios where exact matches are critical,
     such as determining ground truth values."""
    oversampling: Optional[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Oversampling factor. Minimum value is 1. It overrides the 'defaultOversampling'
     parameter configured in the index definition. It can be set only when
     'rerankWithOriginalVectors'
     is true. This parameter is only permitted when a
     compression method is used on the underlying vector field."""
    weight: Optional[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Relative weight of the vector query when compared to other vector query and/or
     the text query within the same search request. This value is used when
     combining the results of multiple ranking lists produced by the different
     vector queries and/or the results retrieved through the text query. The higher
     the weight, the higher the documents that matched that query will be in the
     final ranking. Default is 1.0 and the value needs to be a positive number
     larger than zero."""
    threshold: Optional["_models.VectorThreshold"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The threshold used for vector queries. Note this can only be set if all 'fields' use the same
     similarity metric."""
    filter_override: Optional[str] = rest_field(
        name="filterOverride", visibility=["read", "create", "update", "delete", "query"]
    )
    """The OData filter expression to apply to this specific vector query. If no
     filter expression is defined at the vector level, the expression defined in the
     top level filter parameter is used instead."""
    kind: str = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])
    """Type of query. Required. Known values are: \"vector\", \"text\", \"imageUrl\", and
     \"imageBinary\"."""

    @overload
    def __init__(
        self,
        *,
        kind: str,
        k_nearest_neighbors: Optional[int] = None,
        fields: Optional[str] = None,
        exhaustive: Optional[bool] = None,
        oversampling: Optional[float] = None,
        weight: Optional[float] = None,
        threshold: Optional["_models.VectorThreshold"] = None,
        filter_override: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorizableImageBinaryQuery(VectorQuery, discriminator="imageBinary"):
    """The query parameters to use for vector search when a base 64 encoded binary of
    an image that needs to be vectorized is provided.


    :ivar k_nearest_neighbors: Number of nearest neighbors to return as top hits.
    :vartype k_nearest_neighbors: int
    :ivar fields: Vector Fields of type Collection(Edm.Single) to be included in the vector
     searched.
    :vartype fields: str
    :ivar exhaustive: When true, triggers an exhaustive k-nearest neighbor search across all
     vectors
     within the vector index. Useful for scenarios where exact matches are critical,
     such as determining ground truth values.
    :vartype exhaustive: bool
    :ivar oversampling: Oversampling factor. Minimum value is 1. It overrides the
     'defaultOversampling'
     parameter configured in the index definition. It can be set only when
     'rerankWithOriginalVectors'
     is true. This parameter is only permitted when a
     compression method is used on the underlying vector field.
    :vartype oversampling: float
    :ivar weight: Relative weight of the vector query when compared to other vector query and/or
     the text query within the same search request. This value is used when
     combining the results of multiple ranking lists produced by the different
     vector queries and/or the results retrieved through the text query. The higher
     the weight, the higher the documents that matched that query will be in the
     final ranking. Default is 1.0 and the value needs to be a positive number
     larger than zero.
    :vartype weight: float
    :ivar threshold: The threshold used for vector queries. Note this can only be set if all
     'fields' use the same similarity metric.
    :vartype threshold: ~azure.search.documents.models.VectorThreshold
    :ivar filter_override: The OData filter expression to apply to this specific vector query. If
     no
     filter expression is defined at the vector level, the expression defined in the
     top level filter parameter is used instead.
    :vartype filter_override: str
    :ivar base64_image: The base 64 encoded binary of an image to be vectorized to perform a vector
     search query.
    :vartype base64_image: str
    :ivar kind: The kind of vector query being performed. Required. Vector query where a base 64
     encoded binary of an image that needs to be
     vectorized is provided.
    :vartype kind: str or ~azure.search.documents.models.IMAGE_BINARY
    """

    base64_image: Optional[str] = rest_field(
        name="base64Image", visibility=["read", "create", "update", "delete", "query"]
    )
    """The base 64 encoded binary of an image to be vectorized to perform a vector
     search query."""
    kind: Literal[VectorQueryKind.IMAGE_BINARY] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The kind of vector query being performed. Required. Vector query where a base 64 encoded binary
     of an image that needs to be
     vectorized is provided."""

    @overload
    def __init__(
        self,
        *,
        k_nearest_neighbors: Optional[int] = None,
        fields: Optional[str] = None,
        exhaustive: Optional[bool] = None,
        oversampling: Optional[float] = None,
        weight: Optional[float] = None,
        threshold: Optional["_models.VectorThreshold"] = None,
        filter_override: Optional[str] = None,
        base64_image: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorQueryKind.IMAGE_BINARY, **kwargs)


class VectorizableImageUrlQuery(VectorQuery, discriminator="imageUrl"):
    """The query parameters to use for vector search when an url that represents an
    image value that needs to be vectorized is provided.


    :ivar k_nearest_neighbors: Number of nearest neighbors to return as top hits.
    :vartype k_nearest_neighbors: int
    :ivar fields: Vector Fields of type Collection(Edm.Single) to be included in the vector
     searched.
    :vartype fields: str
    :ivar exhaustive: When true, triggers an exhaustive k-nearest neighbor search across all
     vectors
     within the vector index. Useful for scenarios where exact matches are critical,
     such as determining ground truth values.
    :vartype exhaustive: bool
    :ivar oversampling: Oversampling factor. Minimum value is 1. It overrides the
     'defaultOversampling'
     parameter configured in the index definition. It can be set only when
     'rerankWithOriginalVectors'
     is true. This parameter is only permitted when a
     compression method is used on the underlying vector field.
    :vartype oversampling: float
    :ivar weight: Relative weight of the vector query when compared to other vector query and/or
     the text query within the same search request. This value is used when
     combining the results of multiple ranking lists produced by the different
     vector queries and/or the results retrieved through the text query. The higher
     the weight, the higher the documents that matched that query will be in the
     final ranking. Default is 1.0 and the value needs to be a positive number
     larger than zero.
    :vartype weight: float
    :ivar threshold: The threshold used for vector queries. Note this can only be set if all
     'fields' use the same similarity metric.
    :vartype threshold: ~azure.search.documents.models.VectorThreshold
    :ivar filter_override: The OData filter expression to apply to this specific vector query. If
     no
     filter expression is defined at the vector level, the expression defined in the
     top level filter parameter is used instead.
    :vartype filter_override: str
    :ivar url: The URL of an image to be vectorized to perform a vector search query.
    :vartype url: str
    :ivar kind: The kind of vector query being performed. Required. Vector query where an url that
     represents an image value that needs to be
     vectorized is provided.
    :vartype kind: str or ~azure.search.documents.models.IMAGE_URL
    """

    url: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The URL of an image to be vectorized to perform a vector search query."""
    kind: Literal[VectorQueryKind.IMAGE_URL] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The kind of vector query being performed. Required. Vector query where an url that represents
     an image value that needs to be
     vectorized is provided."""

    @overload
    def __init__(
        self,
        *,
        k_nearest_neighbors: Optional[int] = None,
        fields: Optional[str] = None,
        exhaustive: Optional[bool] = None,
        oversampling: Optional[float] = None,
        weight: Optional[float] = None,
        threshold: Optional["_models.VectorThreshold"] = None,
        filter_override: Optional[str] = None,
        url: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorQueryKind.IMAGE_URL, **kwargs)


class VectorizableTextQuery(VectorQuery, discriminator="text"):
    """The query parameters to use for vector search when a text value that needs to
    be vectorized is provided.


    :ivar k_nearest_neighbors: Number of nearest neighbors to return as top hits.
    :vartype k_nearest_neighbors: int
    :ivar fields: Vector Fields of type Collection(Edm.Single) to be included in the vector
     searched.
    :vartype fields: str
    :ivar exhaustive: When true, triggers an exhaustive k-nearest neighbor search across all
     vectors
     within the vector index. Useful for scenarios where exact matches are critical,
     such as determining ground truth values.
    :vartype exhaustive: bool
    :ivar oversampling: Oversampling factor. Minimum value is 1. It overrides the
     'defaultOversampling'
     parameter configured in the index definition. It can be set only when
     'rerankWithOriginalVectors'
     is true. This parameter is only permitted when a
     compression method is used on the underlying vector field.
    :vartype oversampling: float
    :ivar weight: Relative weight of the vector query when compared to other vector query and/or
     the text query within the same search request. This value is used when
     combining the results of multiple ranking lists produced by the different
     vector queries and/or the results retrieved through the text query. The higher
     the weight, the higher the documents that matched that query will be in the
     final ranking. Default is 1.0 and the value needs to be a positive number
     larger than zero.
    :vartype weight: float
    :ivar threshold: The threshold used for vector queries. Note this can only be set if all
     'fields' use the same similarity metric.
    :vartype threshold: ~azure.search.documents.models.VectorThreshold
    :ivar filter_override: The OData filter expression to apply to this specific vector query. If
     no
     filter expression is defined at the vector level, the expression defined in the
     top level filter parameter is used instead.
    :vartype filter_override: str
    :ivar text: The text to be vectorized to perform a vector search query. Required.
    :vartype text: str
    :ivar query_rewrites: Can be configured to let a generative model rewrite the query before
     sending it
     to be vectorized. Known values are: "none" and "generative".
    :vartype query_rewrites: str or ~azure.search.documents.models.QueryRewritesType
    :ivar kind: The kind of vector query being performed. Required. Vector query where a text value
     that needs to be vectorized is provided.
    :vartype kind: str or ~azure.search.documents.models.TEXT
    """

    text: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The text to be vectorized to perform a vector search query. Required."""
    query_rewrites: Optional[Union[str, "_models.QueryRewritesType"]] = rest_field(
        name="queryRewrites", visibility=["read", "create", "update", "delete", "query"]
    )
    """Can be configured to let a generative model rewrite the query before sending it
     to be vectorized. Known values are: \"none\" and \"generative\"."""
    kind: Literal[VectorQueryKind.TEXT] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The kind of vector query being performed. Required. Vector query where a text value that needs
     to be vectorized is provided."""

    @overload
    def __init__(
        self,
        *,
        text: str,
        k_nearest_neighbors: Optional[int] = None,
        fields: Optional[str] = None,
        exhaustive: Optional[bool] = None,
        oversampling: Optional[float] = None,
        weight: Optional[float] = None,
        threshold: Optional["_models.VectorThreshold"] = None,
        filter_override: Optional[str] = None,
        query_rewrites: Optional[Union[str, "_models.QueryRewritesType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorQueryKind.TEXT, **kwargs)


class VectorizedQuery(VectorQuery, discriminator="vector"):
    """The query parameters to use for vector search when a raw vector value is
    provided.


    :ivar k_nearest_neighbors: Number of nearest neighbors to return as top hits.
    :vartype k_nearest_neighbors: int
    :ivar fields: Vector Fields of type Collection(Edm.Single) to be included in the vector
     searched.
    :vartype fields: str
    :ivar exhaustive: When true, triggers an exhaustive k-nearest neighbor search across all
     vectors
     within the vector index. Useful for scenarios where exact matches are critical,
     such as determining ground truth values.
    :vartype exhaustive: bool
    :ivar oversampling: Oversampling factor. Minimum value is 1. It overrides the
     'defaultOversampling'
     parameter configured in the index definition. It can be set only when
     'rerankWithOriginalVectors'
     is true. This parameter is only permitted when a
     compression method is used on the underlying vector field.
    :vartype oversampling: float
    :ivar weight: Relative weight of the vector query when compared to other vector query and/or
     the text query within the same search request. This value is used when
     combining the results of multiple ranking lists produced by the different
     vector queries and/or the results retrieved through the text query. The higher
     the weight, the higher the documents that matched that query will be in the
     final ranking. Default is 1.0 and the value needs to be a positive number
     larger than zero.
    :vartype weight: float
    :ivar threshold: The threshold used for vector queries. Note this can only be set if all
     'fields' use the same similarity metric.
    :vartype threshold: ~azure.search.documents.models.VectorThreshold
    :ivar filter_override: The OData filter expression to apply to this specific vector query. If
     no
     filter expression is defined at the vector level, the expression defined in the
     top level filter parameter is used instead.
    :vartype filter_override: str
    :ivar vector: The vector representation of a search query. Required.
    :vartype vector: list[float]
    :ivar kind: The kind of vector query being performed. Required. Vector query where a raw vector
     value is provided.
    :vartype kind: str or ~azure.search.documents.models.VECTOR
    """

    vector: List[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The vector representation of a search query. Required."""
    kind: Literal[VectorQueryKind.VECTOR] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The kind of vector query being performed. Required. Vector query where a raw vector value is
     provided."""

    @overload
    def __init__(
        self,
        *,
        vector: List[float],
        k_nearest_neighbors: Optional[int] = None,
        fields: Optional[str] = None,
        exhaustive: Optional[bool] = None,
        oversampling: Optional[float] = None,
        weight: Optional[float] = None,
        threshold: Optional["_models.VectorThreshold"] = None,
        filter_override: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorQueryKind.VECTOR, **kwargs)


class VectorsDebugInfo(_model_base.Model):
    """ "Contains debugging information specific to vector and hybrid search.").

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar subscores: The breakdown of subscores of the document prior to the chosen result set
     fusion/combination method such as RRF.
    :vartype subscores: ~azure.search.documents.models.QueryResultDocumentSubscores
    """

    subscores: Optional["_models.QueryResultDocumentSubscores"] = rest_field(visibility=["read"])
    """The breakdown of subscores of the document prior to the chosen result set
     fusion/combination method such as RRF."""


class VectorSearch(_model_base.Model):
    """Contains configuration options related to vector search.

    :ivar profiles: Defines combinations of configurations to use with vector search.
    :vartype profiles: list[~azure.search.documents.models.VectorSearchProfile]
    :ivar algorithms: Contains configuration options specific to the algorithm used during indexing
     or querying.
    :vartype algorithms: list[~azure.search.documents.models.VectorSearchAlgorithmConfiguration]
    :ivar vectorizers: Contains configuration options on how to vectorize text vector queries.
    :vartype vectorizers: list[~azure.search.documents.models.VectorSearchVectorizer]
    :ivar compressions: Contains configuration options specific to the compression method used
     during
     indexing or querying.
    :vartype compressions: list[~azure.search.documents.models.VectorSearchCompression]
    """

    profiles: Optional[List["_models.VectorSearchProfile"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines combinations of configurations to use with vector search."""
    algorithms: Optional[List["_models.VectorSearchAlgorithmConfiguration"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains configuration options specific to the algorithm used during indexing
     or querying."""
    vectorizers: Optional[List["_models.VectorSearchVectorizer"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains configuration options on how to vectorize text vector queries."""
    compressions: Optional[List["_models.VectorSearchCompression"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains configuration options specific to the compression method used during
     indexing or querying."""

    @overload
    def __init__(
        self,
        *,
        profiles: Optional[List["_models.VectorSearchProfile"]] = None,
        algorithms: Optional[List["_models.VectorSearchAlgorithmConfiguration"]] = None,
        vectorizers: Optional[List["_models.VectorSearchVectorizer"]] = None,
        compressions: Optional[List["_models.VectorSearchCompression"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorSearchProfile(_model_base.Model):
    """Defines a combination of configurations to use with vector search.


    :ivar name: The name to associate with this particular vector search profile. Required.
    :vartype name: str
    :ivar algorithm_configuration_name: The name of the vector search algorithm configuration that
     specifies the
     algorithm and optional parameters. Required.
    :vartype algorithm_configuration_name: str
    :ivar vectorizer_name: The name of the vectorization being configured for use with vector
     search.
    :vartype vectorizer_name: str
    :ivar compression_name: The name of the compression method configuration that specifies the
     compression
     method and optional parameters.
    :vartype compression_name: str
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name to associate with this particular vector search profile. Required."""
    algorithm_configuration_name: str = rest_field(
        name="algorithm", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the vector search algorithm configuration that specifies the
     algorithm and optional parameters. Required."""
    vectorizer_name: Optional[str] = rest_field(
        name="vectorizer", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the vectorization being configured for use with vector search."""
    compression_name: Optional[str] = rest_field(
        name="compression", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the compression method configuration that specifies the compression
     method and optional parameters."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        algorithm_configuration_name: str,
        vectorizer_name: Optional[str] = None,
        compression_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorSimilarityThreshold(VectorThreshold, discriminator="vectorSimilarity"):
    """The results of the vector query will be filtered based on the vector similarity
    metric. Note this is the canonical definition of similarity metric, not the 'distance'
    version. The threshold direction (larger or smaller) will be chosen
    automatically according to the metric used by the field.


    :ivar value: The threshold will filter based on the similarity metric value. Note this is
     the canonical definition of similarity metric, not the 'distance' version. The
     threshold direction (larger or smaller) will be chosen automatically according
     to the metric used by the field. Required.
    :vartype value: float
    :ivar kind: The kind of threshold used to filter vector queries. Required. The results of the
     vector query will be filtered based on the vector similarity
     metric. Note this is the canonical definition of similarity metric, not the 'distance'
     version. The threshold direction (larger or smaller) will be chosen
     automatically according to the metric used by the field.
    :vartype kind: str or ~azure.search.documents.models.VECTOR_SIMILARITY
    """

    value: float = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The threshold will filter based on the similarity metric value. Note this is
     the canonical definition of similarity metric, not the 'distance' version. The
     threshold direction (larger or smaller) will be chosen automatically according
     to the metric used by the field. Required."""
    kind: Literal[VectorThresholdKind.VECTOR_SIMILARITY] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The kind of threshold used to filter vector queries. Required. The results of the vector query
     will be filtered based on the vector similarity
     metric. Note this is the canonical definition of similarity metric, not the 'distance'
     version. The threshold direction (larger or smaller) will be chosen
     automatically according to the metric used by the field."""

    @overload
    def __init__(
        self,
        *,
        value: float,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorThresholdKind.VECTOR_SIMILARITY, **kwargs)


class VisionVectorizeSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Vision.VectorizeSkill"):
    """Allows you to generate a vector embedding for a given image or text input using
    the Azure AI Services Vision Vectorize API.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar model_version: The version of the model to use when calling the AI Services Vision
     service. It
     will default to the latest available when not specified. Required.
    :vartype model_version: str
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Vision.VectorizeSkill".
    :vartype odata_type: str
    """

    model_version: str = rest_field(name="modelVersion", visibility=["read", "create", "update", "delete", "query"])
    """The version of the model to use when calling the AI Services Vision service. It
     will default to the latest available when not specified. Required."""
    odata_type: Literal["#Microsoft.Skills.Vision.VectorizeSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Vision.VectorizeSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        model_version: str,
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Vision.VectorizeSkill", **kwargs)


class WebApiSkill(SearchIndexerSkill, discriminator="#Microsoft.Skills.Custom.WebApiSkill"):
    """A skill that can call a Web API endpoint, allowing you to extend a skillset by
    having it call your custom code.


    :ivar name: The name of the skill which uniquely identifies it within the skillset. A skill
     with no name defined will be given a default name of its 1-based index in the
     skills array, prefixed with the character '#'.
    :vartype name: str
    :ivar description: The description of the skill which describes the inputs, outputs, and usage
     of
     the skill.
    :vartype description: str
    :ivar context: Represents the level at which operations take place, such as the document root
     or document content (for example, /document or /document/content). The default
     is /document.
    :vartype context: str
    :ivar inputs: Inputs of the skills could be a column in the source data set, or the output of
     an upstream skill. Required.
    :vartype inputs: list[~azure.search.documents.models.InputFieldMappingEntry]
    :ivar outputs: The output of a skill is either a field in a search index, or a value that can
     be consumed as an input by another skill. Required.
    :vartype outputs: list[~azure.search.documents.models.OutputFieldMappingEntry]
    :ivar uri: The url for the Web API. Required.
    :vartype uri: str
    :ivar http_headers: The headers required to make the http request.
    :vartype http_headers: dict[str, str]
    :ivar http_method: The method for the http request.
    :vartype http_method: str
    :ivar timeout: The desired timeout for the request. Default is 30 seconds.
    :vartype timeout: ~datetime.timedelta
    :ivar batch_size: The desired batch size which indicates number of documents.
    :vartype batch_size: int
    :ivar degree_of_parallelism: If set, the number of parallel calls that can be made to the Web
     API.
    :vartype degree_of_parallelism: int
    :ivar auth_resource_id: Applies to custom skills that connect to external code in an Azure
     function or
     some other application that provides the transformations. This value should be
     the application ID created for the function or app when it was registered with
     Azure Active Directory. When specified, the custom skill connects to the
     function or app using a managed ID (either system or user-assigned) of the
     search service and the access token of the function or app, using this value as
     the resource id for creating the scope of the access token.
    :vartype auth_resource_id: str
    :ivar auth_identity: The user-assigned managed identity used for outbound connections. If an
     authResourceId is provided and it's not specified, the system-assigned managed
     identity is used. On updates to the indexer, if the identity is unspecified,
     the value remains unchanged. If set to "none", the value of this property is
     cleared.
    :vartype auth_identity: ~azure.search.documents.models.SearchIndexerDataIdentity
    :ivar odata_type: A URI fragment specifying the type of skill. Required. Default value is
     "#Microsoft.Skills.Custom.WebApiSkill".
    :vartype odata_type: str
    """

    uri: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The url for the Web API. Required."""
    http_headers: Optional[Dict[str, str]] = rest_field(
        name="httpHeaders", visibility=["read", "create", "update", "delete", "query"]
    )
    """The headers required to make the http request."""
    http_method: Optional[str] = rest_field(
        name="httpMethod", visibility=["read", "create", "update", "delete", "query"]
    )
    """The method for the http request."""
    timeout: Optional[datetime.timedelta] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The desired timeout for the request. Default is 30 seconds."""
    batch_size: Optional[int] = rest_field(name="batchSize", visibility=["read", "create", "update", "delete", "query"])
    """The desired batch size which indicates number of documents."""
    degree_of_parallelism: Optional[int] = rest_field(
        name="degreeOfParallelism", visibility=["read", "create", "update", "delete", "query"]
    )
    """If set, the number of parallel calls that can be made to the Web API."""
    auth_resource_id: Optional[str] = rest_field(
        name="authResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Applies to custom skills that connect to external code in an Azure function or
     some other application that provides the transformations. This value should be
     the application ID created for the function or app when it was registered with
     Azure Active Directory. When specified, the custom skill connects to the
     function or app using a managed ID (either system or user-assigned) of the
     search service and the access token of the function or app, using this value as
     the resource id for creating the scope of the access token."""
    auth_identity: Optional["_models.SearchIndexerDataIdentity"] = rest_field(
        name="authIdentity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The user-assigned managed identity used for outbound connections. If an
     authResourceId is provided and it's not specified, the system-assigned managed
     identity is used. On updates to the indexer, if the identity is unspecified,
     the value remains unchanged. If set to \"none\", the value of this property is
     cleared."""
    odata_type: Literal["#Microsoft.Skills.Custom.WebApiSkill"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of skill. Required. Default value is
     \"#Microsoft.Skills.Custom.WebApiSkill\"."""

    @overload
    def __init__(
        self,
        *,
        inputs: List["_models.InputFieldMappingEntry"],
        outputs: List["_models.OutputFieldMappingEntry"],
        uri: str,
        name: Optional[str] = None,
        description: Optional[str] = None,
        context: Optional[str] = None,
        http_headers: Optional[Dict[str, str]] = None,
        http_method: Optional[str] = None,
        timeout: Optional[datetime.timedelta] = None,
        batch_size: Optional[int] = None,
        degree_of_parallelism: Optional[int] = None,
        auth_resource_id: Optional[str] = None,
        auth_identity: Optional["_models.SearchIndexerDataIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Skills.Custom.WebApiSkill", **kwargs)


class WebApiVectorizer(VectorSearchVectorizer, discriminator="customWebApi"):
    """Specifies a user-defined vectorizer for generating the vector embedding of a
    query string. Integration of an external vectorizer is achieved using the
    custom Web API interface of a skillset.


    :ivar vectorizer_name: The name to associate with this particular vectorization method.
     Required.
    :vartype vectorizer_name: str
    :ivar web_api_parameters: Specifies the properties of the user-defined vectorizer.
    :vartype web_api_parameters: ~azure.search.documents.models.WebApiVectorizerParameters
    :ivar kind: The name of the kind of vectorization method being configured for use with
     vector search. Required. Generate embeddings using a custom web endpoint at query time.
    :vartype kind: str or ~azure.search.documents.models.CUSTOM_WEB_API
    """

    web_api_parameters: Optional["_models.WebApiVectorizerParameters"] = rest_field(
        name="customWebApiParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the properties of the user-defined vectorizer."""
    kind: Literal[VectorSearchVectorizerKind.CUSTOM_WEB_API] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The name of the kind of vectorization method being configured for use with
     vector search. Required. Generate embeddings using a custom web endpoint at query time."""

    @overload
    def __init__(
        self,
        *,
        vectorizer_name: str,
        web_api_parameters: Optional["_models.WebApiVectorizerParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, kind=VectorSearchVectorizerKind.CUSTOM_WEB_API, **kwargs)


class WebApiVectorizerParameters(_model_base.Model):
    """Specifies the properties for connecting to a user-defined vectorizer.

    :ivar url: The URI of the Web API providing the vectorizer.
    :vartype url: str
    :ivar http_headers: The headers required to make the HTTP request.
    :vartype http_headers: dict[str, str]
    :ivar http_method: The method for the HTTP request.
    :vartype http_method: str
    :ivar timeout: The desired timeout for the request. Default is 30 seconds.
    :vartype timeout: ~datetime.timedelta
    :ivar auth_resource_id: Applies to custom endpoints that connect to external code in an Azure
     function
     or some other application that provides the transformations. This value should
     be the application ID created for the function or app when it was registered
     with Azure Active Directory. When specified, the vectorization connects to the
     function or app using a managed ID (either system or user-assigned) of the
     search service and the access token of the function or app, using this value as
     the resource id for creating the scope of the access token.
    :vartype auth_resource_id: str
    :ivar auth_identity: The user-assigned managed identity used for outbound connections. If an
     authResourceId is provided and it's not specified, the system-assigned managed
     identity is used. On updates to the indexer, if the identity is unspecified,
     the value remains unchanged. If set to "none", the value of this property is
     cleared.
    :vartype auth_identity: ~azure.search.documents.models.SearchIndexerDataIdentity
    """

    url: Optional[str] = rest_field(name="uri", visibility=["read", "create", "update", "delete", "query"])
    """The URI of the Web API providing the vectorizer."""
    http_headers: Optional[Dict[str, str]] = rest_field(
        name="httpHeaders", visibility=["read", "create", "update", "delete", "query"]
    )
    """The headers required to make the HTTP request."""
    http_method: Optional[str] = rest_field(
        name="httpMethod", visibility=["read", "create", "update", "delete", "query"]
    )
    """The method for the HTTP request."""
    timeout: Optional[datetime.timedelta] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The desired timeout for the request. Default is 30 seconds."""
    auth_resource_id: Optional[str] = rest_field(
        name="authResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Applies to custom endpoints that connect to external code in an Azure function
     or some other application that provides the transformations. This value should
     be the application ID created for the function or app when it was registered
     with Azure Active Directory. When specified, the vectorization connects to the
     function or app using a managed ID (either system or user-assigned) of the
     search service and the access token of the function or app, using this value as
     the resource id for creating the scope of the access token."""
    auth_identity: Optional["_models.SearchIndexerDataIdentity"] = rest_field(
        name="authIdentity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The user-assigned managed identity used for outbound connections. If an
     authResourceId is provided and it's not specified, the system-assigned managed
     identity is used. On updates to the indexer, if the identity is unspecified,
     the value remains unchanged. If set to \"none\", the value of this property is
     cleared."""

    @overload
    def __init__(
        self,
        *,
        url: Optional[str] = None,
        http_headers: Optional[Dict[str, str]] = None,
        http_method: Optional[str] = None,
        timeout: Optional[datetime.timedelta] = None,
        auth_resource_id: Optional[str] = None,
        auth_identity: Optional["_models.SearchIndexerDataIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WordDelimiterTokenFilter(TokenFilter, discriminator="#Microsoft.Azure.Search.WordDelimiterTokenFilter"):
    """Splits words into subwords and performs optional transformations on subword
    groups. This token filter is implemented using Apache Lucene.


    :ivar name: The name of the token filter. It must only contain letters, digits, spaces,
     dashes or underscores, can only start and end with alphanumeric characters, and
     is limited to 128 characters. Required.
    :vartype name: str
    :ivar generate_word_parts: A value indicating whether to generate part words. If set, causes
     parts of
     words to be generated; for example "AzureSearch" becomes "Azure" "Search".
     Default is true.
    :vartype generate_word_parts: bool
    :ivar generate_number_parts: A value indicating whether to generate number subwords. Default is
     true.
    :vartype generate_number_parts: bool
    :ivar catenate_words: A value indicating whether maximum runs of word parts will be catenated.
     For
     example, if this is set to true, "Azure-Search" becomes "AzureSearch". Default
     is false.
    :vartype catenate_words: bool
    :ivar catenate_numbers: A value indicating whether maximum runs of number parts will be
     catenated. For
     example, if this is set to true, "1-2" becomes "12". Default is false.
    :vartype catenate_numbers: bool
    :ivar catenate_all: A value indicating whether all subword parts will be catenated. For
     example, if
     this is set to true, "Azure-Search-1" becomes "AzureSearch1". Default is false.
    :vartype catenate_all: bool
    :ivar split_on_case_change: A value indicating whether to split words on caseChange. For
     example, if this
     is set to true, "AzureSearch" becomes "Azure" "Search". Default is true.
    :vartype split_on_case_change: bool
    :ivar preserve_original: A value indicating whether original words will be preserved and added
     to the
     subword list. Default is false.
    :vartype preserve_original: bool
    :ivar split_on_numerics: A value indicating whether to split on numbers. For example, if this
     is set to
     true, "Azure1Search" becomes "Azure" "1" "Search". Default is true.
    :vartype split_on_numerics: bool
    :ivar stem_english_possessive: A value indicating whether to remove trailing "'s" for each
     subword. Default is
     true.
    :vartype stem_english_possessive: bool
    :ivar protected_words: A list of tokens to protect from being delimited.
    :vartype protected_words: list[str]
    :ivar odata_type: A URI fragment specifying the type of token filter. Required. Default value
     is "#Microsoft.Azure.Search.WordDelimiterTokenFilter".
    :vartype odata_type: str
    """

    generate_word_parts: Optional[bool] = rest_field(
        name="generateWordParts", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to generate part words. If set, causes parts of
     words to be generated; for example \"AzureSearch\" becomes \"Azure\" \"Search\".
     Default is true."""
    generate_number_parts: Optional[bool] = rest_field(
        name="generateNumberParts", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to generate number subwords. Default is true."""
    catenate_words: Optional[bool] = rest_field(
        name="catenateWords", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether maximum runs of word parts will be catenated. For
     example, if this is set to true, \"Azure-Search\" becomes \"AzureSearch\". Default
     is false."""
    catenate_numbers: Optional[bool] = rest_field(
        name="catenateNumbers", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether maximum runs of number parts will be catenated. For
     example, if this is set to true, \"1-2\" becomes \"12\". Default is false."""
    catenate_all: Optional[bool] = rest_field(
        name="catenateAll", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether all subword parts will be catenated. For example, if
     this is set to true, \"Azure-Search-1\" becomes \"AzureSearch1\". Default is false."""
    split_on_case_change: Optional[bool] = rest_field(
        name="splitOnCaseChange", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to split words on caseChange. For example, if this
     is set to true, \"AzureSearch\" becomes \"Azure\" \"Search\". Default is true."""
    preserve_original: Optional[bool] = rest_field(
        name="preserveOriginal", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether original words will be preserved and added to the
     subword list. Default is false."""
    split_on_numerics: Optional[bool] = rest_field(
        name="splitOnNumerics", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to split on numbers. For example, if this is set to
     true, \"Azure1Search\" becomes \"Azure\" \"1\" \"Search\". Default is true."""
    stem_english_possessive: Optional[bool] = rest_field(
        name="stemEnglishPossessive", visibility=["read", "create", "update", "delete", "query"]
    )
    """A value indicating whether to remove trailing \"'s\" for each subword. Default is
     true."""
    protected_words: Optional[List[str]] = rest_field(
        name="protectedWords", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of tokens to protect from being delimited."""
    odata_type: Literal["#Microsoft.Azure.Search.WordDelimiterTokenFilter"] = rest_discriminator(name="@odata.type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """A URI fragment specifying the type of token filter. Required. Default value is
     \"#Microsoft.Azure.Search.WordDelimiterTokenFilter\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        generate_word_parts: Optional[bool] = None,
        generate_number_parts: Optional[bool] = None,
        catenate_words: Optional[bool] = None,
        catenate_numbers: Optional[bool] = None,
        catenate_all: Optional[bool] = None,
        split_on_case_change: Optional[bool] = None,
        preserve_original: Optional[bool] = None,
        split_on_numerics: Optional[bool] = None,
        stem_english_possessive: Optional[bool] = None,
        protected_words: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, odata_type="#Microsoft.Azure.Search.WordDelimiterTokenFilter", **kwargs)
