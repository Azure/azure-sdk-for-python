# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model
from msrest.exceptions import HttpOperationError


class ScalingMechanism(Model):
    """Describes the mechanism for performing a scaling operation.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AddRemoveIncrementalNamedPartitionScalingMechanism,
    PartitionInstanceCountScaleMechanism

    All required parameters must be populated in order to send to Azure.

    :param kind: Required. Constant filled by server.
    :type kind: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'AddRemoveIncrementalNamedPartition': 'AddRemoveIncrementalNamedPartitionScalingMechanism', 'ScalePartitionInstanceCount': 'PartitionInstanceCountScaleMechanism'}
    }

    def __init__(self, **kwargs):
        super(ScalingMechanism, self).__init__(**kwargs)
        self.kind = None


class AddRemoveIncrementalNamedPartitionScalingMechanism(ScalingMechanism):
    """Represents a scaling mechanism for adding or removing named partitions of a
    stateless service. Partition names are in the format '0','1'...'N-1'.

    All required parameters must be populated in order to send to Azure.

    :param kind: Required. Constant filled by server.
    :type kind: str
    :param min_partition_count: Required. Minimum number of named partitions
     of the service.
    :type min_partition_count: int
    :param max_partition_count: Required. Maximum number of named partitions
     of the service.
    :type max_partition_count: int
    :param scale_increment: Required. The number of instances to add or remove
     during a scaling operation.
    :type scale_increment: int
    """

    _validation = {
        'kind': {'required': True},
        'min_partition_count': {'required': True},
        'max_partition_count': {'required': True},
        'scale_increment': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'min_partition_count': {'key': 'minPartitionCount', 'type': 'int'},
        'max_partition_count': {'key': 'maxPartitionCount', 'type': 'int'},
        'scale_increment': {'key': 'scaleIncrement', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(AddRemoveIncrementalNamedPartitionScalingMechanism, self).__init__(**kwargs)
        self.min_partition_count = kwargs.get('min_partition_count', None)
        self.max_partition_count = kwargs.get('max_partition_count', None)
        self.scale_increment = kwargs.get('scale_increment', None)
        self.kind = 'AddRemoveIncrementalNamedPartition'


class ApplicationHealthPolicy(Model):
    """Defines a health policy used to evaluate the health of an application or
    one of its children entities.
    .

    All required parameters must be populated in order to send to Azure.

    :param consider_warning_as_error: Required. Indicates whether warnings are
     treated with the same severity as errors.
    :type consider_warning_as_error: bool
    :param max_percent_unhealthy_deployed_applications: Required. The maximum
     allowed percentage of unhealthy deployed applications. Allowed values are
     Byte values from zero to 100.
     The percentage represents the maximum tolerated percentage of deployed
     applications that can be unhealthy before the application is considered in
     error.
     This is calculated by dividing the number of unhealthy deployed
     applications over the number of nodes where the application is currently
     deployed on in the cluster.
     The computation rounds up to tolerate one failure on small numbers of
     nodes. Default percentage is zero.
    :type max_percent_unhealthy_deployed_applications: int
    :param default_service_type_health_policy: The health policy used by
     default to evaluate the health of a service type.
    :type default_service_type_health_policy:
     ~azure.mgmt.servicefabricmanagedclusters.models.ServiceTypeHealthPolicy
    :param service_type_health_policy_map: The map with service type health
     policy per service type name. The map is empty by default.
    :type service_type_health_policy_map: dict[str,
     ~azure.mgmt.servicefabricmanagedclusters.models.ServiceTypeHealthPolicy]
    """

    _validation = {
        'consider_warning_as_error': {'required': True},
        'max_percent_unhealthy_deployed_applications': {'required': True},
    }

    _attribute_map = {
        'consider_warning_as_error': {'key': 'considerWarningAsError', 'type': 'bool'},
        'max_percent_unhealthy_deployed_applications': {'key': 'maxPercentUnhealthyDeployedApplications', 'type': 'int'},
        'default_service_type_health_policy': {'key': 'defaultServiceTypeHealthPolicy', 'type': 'ServiceTypeHealthPolicy'},
        'service_type_health_policy_map': {'key': 'serviceTypeHealthPolicyMap', 'type': '{ServiceTypeHealthPolicy}'},
    }

    def __init__(self, **kwargs):
        super(ApplicationHealthPolicy, self).__init__(**kwargs)
        self.consider_warning_as_error = kwargs.get('consider_warning_as_error', None)
        self.max_percent_unhealthy_deployed_applications = kwargs.get('max_percent_unhealthy_deployed_applications', None)
        self.default_service_type_health_policy = kwargs.get('default_service_type_health_policy', None)
        self.service_type_health_policy_map = kwargs.get('service_type_health_policy_map', None)


class ProxyResource(Model):
    """The resource model definition for proxy-only resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Resource location depends on the parent resource.
    :type location: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :param system_data:
    :type system_data:
     ~azure.mgmt.servicefabricmanagedclusters.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(self, **kwargs):
        super(ProxyResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = kwargs.get('location', None)
        self.tags = kwargs.get('tags', None)
        self.system_data = kwargs.get('system_data', None)


class ApplicationResource(ProxyResource):
    """The application resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Resource location depends on the parent resource.
    :type location: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :param system_data:
    :type system_data:
     ~azure.mgmt.servicefabricmanagedclusters.models.SystemData
    :param identity:
    :type identity:
     ~azure.mgmt.servicefabricmanagedclusters.models.ManagedIdentity
    :ivar provisioning_state: The current deployment or provisioning state,
     which only appears in the response
    :vartype provisioning_state: str
    :param version:
    :type version: str
    :param parameters:
    :type parameters: dict[str, str]
    :param upgrade_policy:
    :type upgrade_policy:
     ~azure.mgmt.servicefabricmanagedclusters.models.ApplicationUpgradePolicy
    :param managed_identities: List of user assigned identities for the
     application, each mapped to a friendly name.
    :type managed_identities:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ApplicationUserAssignedIdentity]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'identity': {'key': 'identity', 'type': 'ManagedIdentity'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'version': {'key': 'properties.version', 'type': 'str'},
        'parameters': {'key': 'properties.parameters', 'type': '{str}'},
        'upgrade_policy': {'key': 'properties.upgradePolicy', 'type': 'ApplicationUpgradePolicy'},
        'managed_identities': {'key': 'properties.managedIdentities', 'type': '[ApplicationUserAssignedIdentity]'},
    }

    def __init__(self, **kwargs):
        super(ApplicationResource, self).__init__(**kwargs)
        self.identity = kwargs.get('identity', None)
        self.provisioning_state = None
        self.version = kwargs.get('version', None)
        self.parameters = kwargs.get('parameters', None)
        self.upgrade_policy = kwargs.get('upgrade_policy', None)
        self.managed_identities = kwargs.get('managed_identities', None)


class ApplicationTypeResource(ProxyResource):
    """The application type name resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Resource location depends on the parent resource.
    :type location: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :param system_data:
    :type system_data:
     ~azure.mgmt.servicefabricmanagedclusters.models.SystemData
    :ivar provisioning_state: The current deployment or provisioning state,
     which only appears in the response.
    :vartype provisioning_state: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ApplicationTypeResource, self).__init__(**kwargs)
        self.provisioning_state = None


class ApplicationTypeUpdateParameters(Model):
    """Application type update request.

    :param tags: Application type update parameters
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(ApplicationTypeUpdateParameters, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)


class ApplicationTypeVersionResource(ProxyResource):
    """An application type version resource for the specified application type
    name resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Resource location depends on the parent resource.
    :type location: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :param system_data:
    :type system_data:
     ~azure.mgmt.servicefabricmanagedclusters.models.SystemData
    :ivar provisioning_state: The current deployment or provisioning state,
     which only appears in the response
    :vartype provisioning_state: str
    :param app_package_url: Required. The URL to the application package
    :type app_package_url: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'app_package_url': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'app_package_url': {'key': 'properties.appPackageUrl', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ApplicationTypeVersionResource, self).__init__(**kwargs)
        self.provisioning_state = None
        self.app_package_url = kwargs.get('app_package_url', None)


class ApplicationTypeVersionsCleanupPolicy(Model):
    """The policy used to clean up unused versions.

    All required parameters must be populated in order to send to Azure.

    :param max_unused_versions_to_keep: Required. Number of unused versions
     per application type to keep.
    :type max_unused_versions_to_keep: int
    """

    _validation = {
        'max_unused_versions_to_keep': {'required': True, 'minimum': 0},
    }

    _attribute_map = {
        'max_unused_versions_to_keep': {'key': 'maxUnusedVersionsToKeep', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(ApplicationTypeVersionsCleanupPolicy, self).__init__(**kwargs)
        self.max_unused_versions_to_keep = kwargs.get('max_unused_versions_to_keep', None)


class ApplicationTypeVersionUpdateParameters(Model):
    """Application type version update request.

    :param tags: Application type version update parameters
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(ApplicationTypeVersionUpdateParameters, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)


class ApplicationUpdateParameters(Model):
    """Application update request.

    :param tags: Application update parameters
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(ApplicationUpdateParameters, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)


class ApplicationUpgradePolicy(Model):
    """Describes the policy for a monitored application upgrade.

    :param application_health_policy:
    :type application_health_policy:
     ~azure.mgmt.servicefabricmanagedclusters.models.ApplicationHealthPolicy
    :param force_restart:
    :type force_restart: bool
    :param rolling_upgrade_monitoring_policy:
    :type rolling_upgrade_monitoring_policy:
     ~azure.mgmt.servicefabricmanagedclusters.models.RollingUpgradeMonitoringPolicy
    :param instance_close_delay_duration: Duration in seconds, to wait before
     a stateless instance is closed, to allow the active requests to drain
     gracefully. This would be effective when the instance is closing during
     the application/cluster upgrade, only for those instances which have a
     non-zero delay duration configured in the service description. See
     InstanceCloseDelayDurationSeconds property in StatelessServiceDescription
     for details. Note, the default value of
     InstanceCloseDelayDurationInSeconds is 4294967295, which indicates that
     the behavior will entirely depend on the delay configured in the stateless
     service description.
    :type instance_close_delay_duration: long
    :param upgrade_mode: Possible values include: 'Monitored',
     'UnmonitoredAuto'
    :type upgrade_mode: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.RollingUpgradeMode
    :param upgrade_replica_set_check_timeout: The maximum amount of time to
     block processing of an upgrade domain and prevent loss of availability
     when there are unexpected issues. When this timeout expires, processing of
     the upgrade domain will proceed regardless of availability loss issues.
     The timeout is reset at the start of each upgrade domain. Valid values are
     between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
    :type upgrade_replica_set_check_timeout: long
    :param recreate_application: Determines whether the application should be
     recreated on update. If value=true, the rest of the upgrade policy
     parameters are not allowed.
    :type recreate_application: bool
    """

    _attribute_map = {
        'application_health_policy': {'key': 'applicationHealthPolicy', 'type': 'ApplicationHealthPolicy'},
        'force_restart': {'key': 'forceRestart', 'type': 'bool'},
        'rolling_upgrade_monitoring_policy': {'key': 'rollingUpgradeMonitoringPolicy', 'type': 'RollingUpgradeMonitoringPolicy'},
        'instance_close_delay_duration': {'key': 'instanceCloseDelayDuration', 'type': 'long'},
        'upgrade_mode': {'key': 'upgradeMode', 'type': 'str'},
        'upgrade_replica_set_check_timeout': {'key': 'upgradeReplicaSetCheckTimeout', 'type': 'long'},
        'recreate_application': {'key': 'recreateApplication', 'type': 'bool'},
    }

    def __init__(self, **kwargs):
        super(ApplicationUpgradePolicy, self).__init__(**kwargs)
        self.application_health_policy = kwargs.get('application_health_policy', None)
        self.force_restart = kwargs.get('force_restart', None)
        self.rolling_upgrade_monitoring_policy = kwargs.get('rolling_upgrade_monitoring_policy', None)
        self.instance_close_delay_duration = kwargs.get('instance_close_delay_duration', None)
        self.upgrade_mode = kwargs.get('upgrade_mode', None)
        self.upgrade_replica_set_check_timeout = kwargs.get('upgrade_replica_set_check_timeout', None)
        self.recreate_application = kwargs.get('recreate_application', None)


class ApplicationUserAssignedIdentity(Model):
    """ApplicationUserAssignedIdentity.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The friendly name of user assigned identity.
    :type name: str
    :param principal_id: Required. The principal id of user assigned identity.
    :type principal_id: str
    """

    _validation = {
        'name': {'required': True},
        'principal_id': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'principal_id': {'key': 'principalId', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ApplicationUserAssignedIdentity, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.principal_id = kwargs.get('principal_id', None)


class AvailableOperationDisplay(Model):
    """Operation supported by the Service Fabric resource provider.

    :param provider: The name of the provider.
    :type provider: str
    :param resource: The resource on which the operation is performed
    :type resource: str
    :param operation: The operation that can be performed.
    :type operation: str
    :param description: Operation description
    :type description: str
    """

    _attribute_map = {
        'provider': {'key': 'provider', 'type': 'str'},
        'resource': {'key': 'resource', 'type': 'str'},
        'operation': {'key': 'operation', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AvailableOperationDisplay, self).__init__(**kwargs)
        self.provider = kwargs.get('provider', None)
        self.resource = kwargs.get('resource', None)
        self.operation = kwargs.get('operation', None)
        self.description = kwargs.get('description', None)


class ScalingTrigger(Model):
    """Describes the trigger for performing a scaling operation.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AveragePartitionLoadScalingTrigger,
    AverageServiceLoadScalingTrigger

    All required parameters must be populated in order to send to Azure.

    :param kind: Required. Constant filled by server.
    :type kind: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'AveragePartitionLoadTrigger': 'AveragePartitionLoadScalingTrigger', 'AverageServiceLoadTrigger': 'AverageServiceLoadScalingTrigger'}
    }

    def __init__(self, **kwargs):
        super(ScalingTrigger, self).__init__(**kwargs)
        self.kind = None


class AveragePartitionLoadScalingTrigger(ScalingTrigger):
    """Represents a scaling trigger related to an average load of a
    metric/resource of a partition.

    All required parameters must be populated in order to send to Azure.

    :param kind: Required. Constant filled by server.
    :type kind: str
    :param metric_name: Required. The name of the metric for which usage
     should be tracked.
    :type metric_name: str
    :param lower_load_threshold: Required. The lower limit of the load below
     which a scale in operation should be performed.
    :type lower_load_threshold: float
    :param upper_load_threshold: Required. The upper limit of the load beyond
     which a scale out operation should be performed.
    :type upper_load_threshold: float
    :param scale_interval: Required. The period in seconds on which a decision
     is made whether to scale or not. This property should come in ISO 8601
     format "hh:mm:ss".
    :type scale_interval: str
    """

    _validation = {
        'kind': {'required': True},
        'metric_name': {'required': True},
        'lower_load_threshold': {'required': True},
        'upper_load_threshold': {'required': True},
        'scale_interval': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'metric_name': {'key': 'metricName', 'type': 'str'},
        'lower_load_threshold': {'key': 'lowerLoadThreshold', 'type': 'float'},
        'upper_load_threshold': {'key': 'upperLoadThreshold', 'type': 'float'},
        'scale_interval': {'key': 'scaleInterval', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AveragePartitionLoadScalingTrigger, self).__init__(**kwargs)
        self.metric_name = kwargs.get('metric_name', None)
        self.lower_load_threshold = kwargs.get('lower_load_threshold', None)
        self.upper_load_threshold = kwargs.get('upper_load_threshold', None)
        self.scale_interval = kwargs.get('scale_interval', None)
        self.kind = 'AveragePartitionLoadTrigger'


class AverageServiceLoadScalingTrigger(ScalingTrigger):
    """Represents a scaling policy related to an average load of a metric/resource
    of a service.

    All required parameters must be populated in order to send to Azure.

    :param kind: Required. Constant filled by server.
    :type kind: str
    :param metric_name: Required. The name of the metric for which usage
     should be tracked.
    :type metric_name: str
    :param lower_load_threshold: Required. The lower limit of the load below
     which a scale in operation should be performed.
    :type lower_load_threshold: float
    :param upper_load_threshold: Required. The upper limit of the load beyond
     which a scale out operation should be performed.
    :type upper_load_threshold: float
    :param scale_interval: Required. The period in seconds on which a decision
     is made whether to scale or not. This property should come in ISO 8601
     format "hh:mm:ss".
    :type scale_interval: str
    """

    _validation = {
        'kind': {'required': True},
        'metric_name': {'required': True},
        'lower_load_threshold': {'required': True},
        'upper_load_threshold': {'required': True},
        'scale_interval': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'metric_name': {'key': 'metricName', 'type': 'str'},
        'lower_load_threshold': {'key': 'lowerLoadThreshold', 'type': 'float'},
        'upper_load_threshold': {'key': 'upperLoadThreshold', 'type': 'float'},
        'scale_interval': {'key': 'scaleInterval', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AverageServiceLoadScalingTrigger, self).__init__(**kwargs)
        self.metric_name = kwargs.get('metric_name', None)
        self.lower_load_threshold = kwargs.get('lower_load_threshold', None)
        self.upper_load_threshold = kwargs.get('upper_load_threshold', None)
        self.scale_interval = kwargs.get('scale_interval', None)
        self.kind = 'AverageServiceLoadTrigger'


class AzureActiveDirectory(Model):
    """The settings to enable AAD authentication on the cluster.

    :param tenant_id: Azure active directory tenant id.
    :type tenant_id: str
    :param cluster_application: Azure active directory cluster application id.
    :type cluster_application: str
    :param client_application: Azure active directory client application id.
    :type client_application: str
    """

    _attribute_map = {
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
        'cluster_application': {'key': 'clusterApplication', 'type': 'str'},
        'client_application': {'key': 'clientApplication', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(AzureActiveDirectory, self).__init__(**kwargs)
        self.tenant_id = kwargs.get('tenant_id', None)
        self.cluster_application = kwargs.get('cluster_application', None)
        self.client_application = kwargs.get('client_application', None)


class ClientCertificate(Model):
    """Client certificate definition.

    All required parameters must be populated in order to send to Azure.

    :param is_admin: Required. Indicates if the client certificate has admin
     access to the cluster. Non admin clients can perform only read only
     operations on the cluster.
    :type is_admin: bool
    :param thumbprint: Certificate thumbprint.
    :type thumbprint: str
    :param common_name: Certificate common name.
    :type common_name: str
    :param issuer_thumbprint: Issuer thumbprint for the certificate. Only used
     together with CommonName.
    :type issuer_thumbprint: str
    """

    _validation = {
        'is_admin': {'required': True},
    }

    _attribute_map = {
        'is_admin': {'key': 'isAdmin', 'type': 'bool'},
        'thumbprint': {'key': 'thumbprint', 'type': 'str'},
        'common_name': {'key': 'commonName', 'type': 'str'},
        'issuer_thumbprint': {'key': 'issuerThumbprint', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ClientCertificate, self).__init__(**kwargs)
        self.is_admin = kwargs.get('is_admin', None)
        self.thumbprint = kwargs.get('thumbprint', None)
        self.common_name = kwargs.get('common_name', None)
        self.issuer_thumbprint = kwargs.get('issuer_thumbprint', None)


class CloudError(Model):
    """CloudError.
    """

    _attribute_map = {
    }


class EndpointRangeDescription(Model):
    """Port range details.

    All required parameters must be populated in order to send to Azure.

    :param start_port: Required. Starting port of a range of ports
    :type start_port: int
    :param end_port: Required. End port of a range of ports
    :type end_port: int
    """

    _validation = {
        'start_port': {'required': True},
        'end_port': {'required': True},
    }

    _attribute_map = {
        'start_port': {'key': 'startPort', 'type': 'int'},
        'end_port': {'key': 'endPort', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(EndpointRangeDescription, self).__init__(**kwargs)
        self.start_port = kwargs.get('start_port', None)
        self.end_port = kwargs.get('end_port', None)


class ErrorModel(Model):
    """The structure of the error.

    :param error: The error details.
    :type error:
     ~azure.mgmt.servicefabricmanagedclusters.models.ErrorModelError
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'ErrorModelError'},
    }

    def __init__(self, **kwargs):
        super(ErrorModel, self).__init__(**kwargs)
        self.error = kwargs.get('error', None)


class ErrorModelException(HttpOperationError):
    """Server responsed with exception of type: 'ErrorModel'.

    :param deserialize: A deserializer
    :param response: Server response to be deserialized.
    """

    def __init__(self, deserialize, response, *args):

        super(ErrorModelException, self).__init__(deserialize, response, 'ErrorModel', *args)


class ErrorModelError(Model):
    """The error details.

    :param code: The error code.
    :type code: str
    :param message: The error message.
    :type message: str
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ErrorModelError, self).__init__(**kwargs)
        self.code = kwargs.get('code', None)
        self.message = kwargs.get('message', None)


class LoadBalancingRule(Model):
    """Describes a load balancing rule.

    All required parameters must be populated in order to send to Azure.

    :param frontend_port: Required. The port for the external endpoint. Port
     numbers for each rule must be unique within the Load Balancer. Acceptable
     values are between 1 and 65534.
    :type frontend_port: int
    :param backend_port: Required. The port used for internal connections on
     the endpoint. Acceptable values are between 1 and 65535.
    :type backend_port: int
    :param protocol: Required. The reference to the transport protocol used by
     the load balancing rule. Possible values include: 'tcp', 'udp'
    :type protocol: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.Protocol
    :param probe_protocol: Required. the reference to the load balancer probe
     used by the load balancing rule. Possible values include: 'tcp', 'http',
     'https'
    :type probe_protocol: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.ProbeProtocol
    :param probe_request_path: The probe request path. Only supported for
     HTTP/HTTPS probes.
    :type probe_request_path: str
    """

    _validation = {
        'frontend_port': {'required': True, 'maximum': 65534, 'minimum': 1},
        'backend_port': {'required': True, 'maximum': 65534, 'minimum': 1},
        'protocol': {'required': True},
        'probe_protocol': {'required': True},
    }

    _attribute_map = {
        'frontend_port': {'key': 'frontendPort', 'type': 'int'},
        'backend_port': {'key': 'backendPort', 'type': 'int'},
        'protocol': {'key': 'protocol', 'type': 'str'},
        'probe_protocol': {'key': 'probeProtocol', 'type': 'str'},
        'probe_request_path': {'key': 'probeRequestPath', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(LoadBalancingRule, self).__init__(**kwargs)
        self.frontend_port = kwargs.get('frontend_port', None)
        self.backend_port = kwargs.get('backend_port', None)
        self.protocol = kwargs.get('protocol', None)
        self.probe_protocol = kwargs.get('probe_protocol', None)
        self.probe_request_path = kwargs.get('probe_request_path', None)


class Resource(Model):
    """The resource model definition.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Azure resource location.
    :type location: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :ivar etag: Azure resource etag.
    :vartype etag: str
    :param system_data:
    :type system_data:
     ~azure.mgmt.servicefabricmanagedclusters.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'etag': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'etag': {'key': 'etag', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(self, **kwargs):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = kwargs.get('location', None)
        self.tags = kwargs.get('tags', None)
        self.etag = None
        self.system_data = kwargs.get('system_data', None)


class ManagedCluster(Resource):
    """The manged cluster resource
    .

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Azure resource location.
    :type location: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :ivar etag: Azure resource etag.
    :vartype etag: str
    :param system_data:
    :type system_data:
     ~azure.mgmt.servicefabricmanagedclusters.models.SystemData
    :param dns_name: Required. The cluster dns name.
    :type dns_name: str
    :ivar fqdn: The fully qualified domain name associated with the public
     load balancer of the cluster.
    :vartype fqdn: str
    :ivar ipv4_address: The IPv4 address associated with the public load
     balancer of the cluster.
    :vartype ipv4_address: str
    :ivar cluster_id: A service generated unique identifier for the cluster
     resource.
    :vartype cluster_id: str
    :ivar cluster_state: The current state of the cluster. Possible values
     include: 'WaitingForNodes', 'Deploying', 'BaselineUpgrade', 'Upgrading',
     'UpgradeFailed', 'Ready'
    :vartype cluster_state: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.enum
    :ivar cluster_certificate_thumbprints: List of thumbprints of the cluster
     certificates.
    :vartype cluster_certificate_thumbprints: list[str]
    :param client_connection_port: The port used for client connections to the
     cluster. Default value: 19000 .
    :type client_connection_port: int
    :param http_gateway_connection_port: The port used for HTTP connections to
     the cluster. Default value: 19080 .
    :type http_gateway_connection_port: int
    :param admin_user_name: Required. VM admin user name.
    :type admin_user_name: str
    :param admin_password: VM admin user password.
    :type admin_password: str
    :param load_balancing_rules: Load balancing rules that are applied to the
     public load balancer of the cluster.
    :type load_balancing_rules:
     list[~azure.mgmt.servicefabricmanagedclusters.models.LoadBalancingRule]
    :param allow_rdp_access: Setting this to true enables RDP access to the
     VM. The default NSG rule opens RDP port to internet which can be
     overridden with custom Network Security Rules. The default value for this
     setting is false.
    :type allow_rdp_access: bool
    :param network_security_rules: Custom Network Security Rules that are
     applied to the virtual network of the cluster.
    :type network_security_rules:
     list[~azure.mgmt.servicefabricmanagedclusters.models.NetworkSecurityRule]
    :param clients: Client certificates that are allowed to manage the
     cluster.
    :type clients:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ClientCertificate]
    :param azure_active_directory: The AAD authentication settings of the
     cluster.
    :type azure_active_directory:
     ~azure.mgmt.servicefabricmanagedclusters.models.AzureActiveDirectory
    :param fabric_settings: The list of custom fabric settings to configure
     the cluster.
    :type fabric_settings:
     list[~azure.mgmt.servicefabricmanagedclusters.models.SettingsSectionDescription]
    :ivar provisioning_state: The provisioning state of the managed cluster
     resource. Possible values include: 'None', 'Creating', 'Created',
     'Updating', 'Succeeded', 'Failed', 'Canceled', 'Deleting', 'Deleted',
     'Other'
    :vartype provisioning_state: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.enum
    :param cluster_code_version: The Service Fabric runtime version of the
     cluster. This property can only by set the user when **upgradeMode** is
     set to 'Manual'. To get list of available Service Fabric versions for new
     clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of
     available version for existing clusters use **availableClusterVersions**.
    :type cluster_code_version: str
    :param addon_features: List of add-on features to enable on the cluster.
    :type addon_features: list[str]
    :param enable_auto_os_upgrade: Setting this to true enables automatic OS
     upgrade for the node types that are created using any platform OS image
     with version 'latest'. The default value for this setting is false.
    :type enable_auto_os_upgrade: bool
    :param application_type_versions_cleanup_policy: The policy used to clean
     up unused versions.
    :type application_type_versions_cleanup_policy:
     ~azure.mgmt.servicefabricmanagedclusters.models.ApplicationTypeVersionsCleanupPolicy
    :param sku: The sku of the managed cluster
    :type sku: ~azure.mgmt.servicefabricmanagedclusters.models.Sku
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'etag': {'readonly': True},
        'dns_name': {'required': True},
        'fqdn': {'readonly': True},
        'ipv4_address': {'readonly': True},
        'cluster_id': {'readonly': True},
        'cluster_state': {'readonly': True},
        'cluster_certificate_thumbprints': {'readonly': True},
        'admin_user_name': {'required': True},
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'etag': {'key': 'etag', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'dns_name': {'key': 'properties.dnsName', 'type': 'str'},
        'fqdn': {'key': 'properties.fqdn', 'type': 'str'},
        'ipv4_address': {'key': 'properties.ipv4Address', 'type': 'str'},
        'cluster_id': {'key': 'properties.clusterId', 'type': 'str'},
        'cluster_state': {'key': 'properties.clusterState', 'type': 'str'},
        'cluster_certificate_thumbprints': {'key': 'properties.clusterCertificateThumbprints', 'type': '[str]'},
        'client_connection_port': {'key': 'properties.clientConnectionPort', 'type': 'int'},
        'http_gateway_connection_port': {'key': 'properties.httpGatewayConnectionPort', 'type': 'int'},
        'admin_user_name': {'key': 'properties.adminUserName', 'type': 'str'},
        'admin_password': {'key': 'properties.adminPassword', 'type': 'str'},
        'load_balancing_rules': {'key': 'properties.loadBalancingRules', 'type': '[LoadBalancingRule]'},
        'allow_rdp_access': {'key': 'properties.allowRdpAccess', 'type': 'bool'},
        'network_security_rules': {'key': 'properties.networkSecurityRules', 'type': '[NetworkSecurityRule]'},
        'clients': {'key': 'properties.clients', 'type': '[ClientCertificate]'},
        'azure_active_directory': {'key': 'properties.azureActiveDirectory', 'type': 'AzureActiveDirectory'},
        'fabric_settings': {'key': 'properties.fabricSettings', 'type': '[SettingsSectionDescription]'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'cluster_code_version': {'key': 'properties.clusterCodeVersion', 'type': 'str'},
        'addon_features': {'key': 'properties.addonFeatures', 'type': '[str]'},
        'enable_auto_os_upgrade': {'key': 'properties.enableAutoOSUpgrade', 'type': 'bool'},
        'application_type_versions_cleanup_policy': {'key': 'properties.applicationTypeVersionsCleanupPolicy', 'type': 'ApplicationTypeVersionsCleanupPolicy'},
        'sku': {'key': 'sku', 'type': 'Sku'},
    }

    def __init__(self, **kwargs):
        super(ManagedCluster, self).__init__(**kwargs)
        self.dns_name = kwargs.get('dns_name', None)
        self.fqdn = None
        self.ipv4_address = None
        self.cluster_id = None
        self.cluster_state = None
        self.cluster_certificate_thumbprints = None
        self.client_connection_port = kwargs.get('client_connection_port', 19000)
        self.http_gateway_connection_port = kwargs.get('http_gateway_connection_port', 19080)
        self.admin_user_name = kwargs.get('admin_user_name', None)
        self.admin_password = kwargs.get('admin_password', None)
        self.load_balancing_rules = kwargs.get('load_balancing_rules', None)
        self.allow_rdp_access = kwargs.get('allow_rdp_access', None)
        self.network_security_rules = kwargs.get('network_security_rules', None)
        self.clients = kwargs.get('clients', None)
        self.azure_active_directory = kwargs.get('azure_active_directory', None)
        self.fabric_settings = kwargs.get('fabric_settings', None)
        self.provisioning_state = None
        self.cluster_code_version = kwargs.get('cluster_code_version', None)
        self.addon_features = kwargs.get('addon_features', None)
        self.enable_auto_os_upgrade = kwargs.get('enable_auto_os_upgrade', None)
        self.application_type_versions_cleanup_policy = kwargs.get('application_type_versions_cleanup_policy', None)
        self.sku = kwargs.get('sku', None)


class ManagedClusterUpdateParameters(Model):
    """Managed cluster update request.

    :param tags: Managed cluster update parameters
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(ManagedClusterUpdateParameters, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)


class ManagedIdentity(Model):
    """Describes the managed identities for an Azure resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar principal_id: The principal id of the managed identity. This
     property will only be provided for a system assigned identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant id of the managed identity. This property will
     only be provided for a system assigned identity.
    :vartype tenant_id: str
    :param type: Possible values include: 'None', 'SystemAssigned',
     'UserAssigned', 'SystemAssigned, UserAssigned'
    :type type: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.ManagedIdentityType
    :param user_assigned_identities:
    :type user_assigned_identities: dict[str,
     ~azure.mgmt.servicefabricmanagedclusters.models.UserAssignedIdentity]
    """

    _validation = {
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
    }

    _attribute_map = {
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
        'type': {'key': 'type', 'type': 'ManagedIdentityType'},
        'user_assigned_identities': {'key': 'userAssignedIdentities', 'type': '{UserAssignedIdentity}'},
    }

    def __init__(self, **kwargs):
        super(ManagedIdentity, self).__init__(**kwargs)
        self.principal_id = None
        self.tenant_id = None
        self.type = kwargs.get('type', None)
        self.user_assigned_identities = kwargs.get('user_assigned_identities', None)


class ManagedProxyResource(Model):
    """The resource model definition for proxy-only resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :param system_data:
    :type system_data:
     ~azure.mgmt.servicefabricmanagedclusters.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(self, **kwargs):
        super(ManagedProxyResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.tags = kwargs.get('tags', None)
        self.system_data = kwargs.get('system_data', None)


class Partition(Model):
    """Describes how the service is partitioned.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: NamedPartitionScheme, SingletonPartitionScheme,
    UniformInt64RangePartitionScheme

    All required parameters must be populated in order to send to Azure.

    :param partition_scheme: Required. Constant filled by server.
    :type partition_scheme: str
    """

    _validation = {
        'partition_scheme': {'required': True},
    }

    _attribute_map = {
        'partition_scheme': {'key': 'partitionScheme', 'type': 'str'},
    }

    _subtype_map = {
        'partition_scheme': {'Named': 'NamedPartitionScheme', 'Singleton': 'SingletonPartitionScheme', 'UniformInt64Range': 'UniformInt64RangePartitionScheme'}
    }

    def __init__(self, **kwargs):
        super(Partition, self).__init__(**kwargs)
        self.partition_scheme = None


class NamedPartitionScheme(Partition):
    """Describes the named partition scheme of the service.

    All required parameters must be populated in order to send to Azure.

    :param partition_scheme: Required. Constant filled by server.
    :type partition_scheme: str
    :param names: Required. Array for the names of the partitions.
    :type names: list[str]
    """

    _validation = {
        'partition_scheme': {'required': True},
        'names': {'required': True},
    }

    _attribute_map = {
        'partition_scheme': {'key': 'partitionScheme', 'type': 'str'},
        'names': {'key': 'names', 'type': '[str]'},
    }

    def __init__(self, **kwargs):
        super(NamedPartitionScheme, self).__init__(**kwargs)
        self.names = kwargs.get('names', None)
        self.partition_scheme = 'Named'


class NetworkSecurityRule(Model):
    """Describes a network security rule.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. Network security rule name.
    :type name: str
    :param description: Network security rule description.
    :type description: str
    :param protocol: Required. Network protocol this rule applies to. Possible
     values include: 'http', 'https', 'tcp', 'udp', 'icmp', 'ah', 'esp'
    :type protocol: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.NsgProtocol
    :param source_address_prefixes: The CIDR or source IP ranges.
    :type source_address_prefixes: list[str]
    :param destination_address_prefixes: The destination address prefixes.
     CIDR or destination IP ranges.
    :type destination_address_prefixes: list[str]
    :param source_port_ranges: The source port ranges.
    :type source_port_ranges: list[str]
    :param destination_port_ranges: The destination port ranges.
    :type destination_port_ranges: list[str]
    :param access: Required. The network traffic is allowed or denied.
     Possible values include: 'allow', 'deny'
    :type access: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.Access
    :param priority: Required. The priority of the rule. The value can be in
     the range 1000 to 3000. Values outside this range are reserved for Service
     Fabric ManagerCluster Resource Provider. The priority number must be
     unique for each rule in the collection. The lower the priority number, the
     higher the priority of the rule.
    :type priority: int
    :param direction: Required. Network security rule direction. Possible
     values include: 'inbound', 'outbound'
    :type direction: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.Direction
    """

    _validation = {
        'name': {'required': True},
        'protocol': {'required': True},
        'access': {'required': True},
        'priority': {'required': True, 'maximum': 3000, 'minimum': 1000},
        'direction': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'protocol': {'key': 'protocol', 'type': 'str'},
        'source_address_prefixes': {'key': 'sourceAddressPrefixes', 'type': '[str]'},
        'destination_address_prefixes': {'key': 'destinationAddressPrefixes', 'type': '[str]'},
        'source_port_ranges': {'key': 'sourcePortRanges', 'type': '[str]'},
        'destination_port_ranges': {'key': 'destinationPortRanges', 'type': '[str]'},
        'access': {'key': 'access', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'direction': {'key': 'direction', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(NetworkSecurityRule, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.description = kwargs.get('description', None)
        self.protocol = kwargs.get('protocol', None)
        self.source_address_prefixes = kwargs.get('source_address_prefixes', None)
        self.destination_address_prefixes = kwargs.get('destination_address_prefixes', None)
        self.source_port_ranges = kwargs.get('source_port_ranges', None)
        self.destination_port_ranges = kwargs.get('destination_port_ranges', None)
        self.access = kwargs.get('access', None)
        self.priority = kwargs.get('priority', None)
        self.direction = kwargs.get('direction', None)


class NodeType(ManagedProxyResource):
    """Describes a node type in the cluster, each node type represents sub set of
    nodes in the cluster.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :param system_data:
    :type system_data:
     ~azure.mgmt.servicefabricmanagedclusters.models.SystemData
    :param is_primary: Required. The node type on which system services will
     run. Only one node type should be marked as primary. Primary node type
     cannot be deleted or changed for existing clusters.
    :type is_primary: bool
    :param vm_instance_count: Required. The number of nodes in the node type.
    :type vm_instance_count: int
    :param data_disk_size_gb: Required. Disk size for each vm in the node type
     in GBs.
    :type data_disk_size_gb: int
    :param placement_properties: The placement tags applied to nodes in the
     node type, which can be used to indicate where certain services (workload)
     should run.
    :type placement_properties: dict[str, str]
    :param capacities: The capacity tags applied to the nodes in the node
     type, the cluster resource manager uses these tags to understand how much
     resource a node has.
    :type capacities: dict[str, str]
    :param application_ports: The range of ports from which cluster assigned
     port to Service Fabric applications.
    :type application_ports:
     ~azure.mgmt.servicefabricmanagedclusters.models.EndpointRangeDescription
    :param ephemeral_ports: The range of ephemeral ports that nodes in this
     node type should be configured with.
    :type ephemeral_ports:
     ~azure.mgmt.servicefabricmanagedclusters.models.EndpointRangeDescription
    :param vm_size: The size of virtual machines in the pool. All virtual
     machines in a pool are the same size. For example, Standard_D3.
    :type vm_size: str
    :param vm_image_publisher: The publisher of the Azure Virtual Machines
     Marketplace image. For example, Canonical or MicrosoftWindowsServer.
    :type vm_image_publisher: str
    :param vm_image_offer: The offer type of the Azure Virtual Machines
     Marketplace image. For example, UbuntuServer or WindowsServer.
    :type vm_image_offer: str
    :param vm_image_sku: The SKU of the Azure Virtual Machines Marketplace
     image. For example, 14.04.0-LTS or 2012-R2-Datacenter.
    :type vm_image_sku: str
    :param vm_image_version: The version of the Azure Virtual Machines
     Marketplace image. A value of 'latest' can be specified to select the
     latest version of an image. If omitted, the default is 'latest'.
    :type vm_image_version: str
    :param vm_secrets: virtual machine secretes. The secrets to install in the
     virtual machines.
    :type vm_secrets:
     list[~azure.mgmt.servicefabricmanagedclusters.models.VaultSecretGroup]
    :param vm_extensions: virtual machine extensions. Set of extensions that
     should be installed onto the virtual machines.
    :type vm_extensions:
     list[~azure.mgmt.servicefabricmanagedclusters.models.VMSSExtension]
    :param vm_managed_identity:
    :type vm_managed_identity:
     ~azure.mgmt.servicefabricmanagedclusters.models.VmManagedIdentity
    :ivar provisioning_state: The provisioning state of the managed cluster
     resource. Possible values include: 'None', 'Creating', 'Created',
     'Updating', 'Succeeded', 'Failed', 'Canceled', 'Deleting', 'Deleted',
     'Other'
    :vartype provisioning_state: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.enum
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'is_primary': {'required': True},
        'vm_instance_count': {'required': True, 'maximum': 2147483647, 'minimum': 1},
        'data_disk_size_gb': {'required': True},
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'is_primary': {'key': 'properties.isPrimary', 'type': 'bool'},
        'vm_instance_count': {'key': 'properties.vmInstanceCount', 'type': 'int'},
        'data_disk_size_gb': {'key': 'properties.dataDiskSizeGB', 'type': 'int'},
        'placement_properties': {'key': 'properties.placementProperties', 'type': '{str}'},
        'capacities': {'key': 'properties.capacities', 'type': '{str}'},
        'application_ports': {'key': 'properties.applicationPorts', 'type': 'EndpointRangeDescription'},
        'ephemeral_ports': {'key': 'properties.ephemeralPorts', 'type': 'EndpointRangeDescription'},
        'vm_size': {'key': 'properties.vmSize', 'type': 'str'},
        'vm_image_publisher': {'key': 'properties.vmImagePublisher', 'type': 'str'},
        'vm_image_offer': {'key': 'properties.vmImageOffer', 'type': 'str'},
        'vm_image_sku': {'key': 'properties.vmImageSku', 'type': 'str'},
        'vm_image_version': {'key': 'properties.vmImageVersion', 'type': 'str'},
        'vm_secrets': {'key': 'properties.vmSecrets', 'type': '[VaultSecretGroup]'},
        'vm_extensions': {'key': 'properties.vmExtensions', 'type': '[VMSSExtension]'},
        'vm_managed_identity': {'key': 'properties.vmManagedIdentity', 'type': 'VmManagedIdentity'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(NodeType, self).__init__(**kwargs)
        self.is_primary = kwargs.get('is_primary', None)
        self.vm_instance_count = kwargs.get('vm_instance_count', None)
        self.data_disk_size_gb = kwargs.get('data_disk_size_gb', None)
        self.placement_properties = kwargs.get('placement_properties', None)
        self.capacities = kwargs.get('capacities', None)
        self.application_ports = kwargs.get('application_ports', None)
        self.ephemeral_ports = kwargs.get('ephemeral_ports', None)
        self.vm_size = kwargs.get('vm_size', None)
        self.vm_image_publisher = kwargs.get('vm_image_publisher', None)
        self.vm_image_offer = kwargs.get('vm_image_offer', None)
        self.vm_image_sku = kwargs.get('vm_image_sku', None)
        self.vm_image_version = kwargs.get('vm_image_version', None)
        self.vm_secrets = kwargs.get('vm_secrets', None)
        self.vm_extensions = kwargs.get('vm_extensions', None)
        self.vm_managed_identity = kwargs.get('vm_managed_identity', None)
        self.provisioning_state = None


class NodeTypeActionParameters(Model):
    """Parameters for Node type action.

    All required parameters must be populated in order to send to Azure.

    :param nodes: Required. List of node names from the node type.
    :type nodes: list[str]
    :param force: Force the action to go through.
    :type force: bool
    """

    _validation = {
        'nodes': {'required': True},
    }

    _attribute_map = {
        'nodes': {'key': 'nodes', 'type': '[str]'},
        'force': {'key': 'force', 'type': 'bool'},
    }

    def __init__(self, **kwargs):
        super(NodeTypeActionParameters, self).__init__(**kwargs)
        self.nodes = kwargs.get('nodes', None)
        self.force = kwargs.get('force', None)


class NodeTypeUpdateParameters(Model):
    """Node type update request.

    :param tags: Node type update parameters
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(NodeTypeUpdateParameters, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)


class OperationResult(Model):
    """Available operation list result.

    :param name: The name of the operation.
    :type name: str
    :param is_data_action: Indicates whether the operation is a data action
    :type is_data_action: bool
    :param display: The object that represents the operation.
    :type display:
     ~azure.mgmt.servicefabricmanagedclusters.models.AvailableOperationDisplay
    :param origin: Origin result
    :type origin: str
    :param next_link: The URL to use for getting the next set of results.
    :type next_link: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'is_data_action': {'key': 'isDataAction', 'type': 'bool'},
        'display': {'key': 'display', 'type': 'AvailableOperationDisplay'},
        'origin': {'key': 'origin', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(OperationResult, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.is_data_action = kwargs.get('is_data_action', None)
        self.display = kwargs.get('display', None)
        self.origin = kwargs.get('origin', None)
        self.next_link = kwargs.get('next_link', None)


class PartitionInstanceCountScaleMechanism(ScalingMechanism):
    """Represents a scaling mechanism for adding or removing instances of
    stateless service partition.

    All required parameters must be populated in order to send to Azure.

    :param kind: Required. Constant filled by server.
    :type kind: str
    :param min_instance_count: Required. Minimum number of instances of the
     partition.
    :type min_instance_count: int
    :param max_instance_count: Required. Maximum number of instances of the
     partition.
    :type max_instance_count: int
    :param scale_increment: Required. The number of instances to add or remove
     during a scaling operation.
    :type scale_increment: int
    """

    _validation = {
        'kind': {'required': True},
        'min_instance_count': {'required': True},
        'max_instance_count': {'required': True},
        'scale_increment': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'min_instance_count': {'key': 'minInstanceCount', 'type': 'int'},
        'max_instance_count': {'key': 'maxInstanceCount', 'type': 'int'},
        'scale_increment': {'key': 'scaleIncrement', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(PartitionInstanceCountScaleMechanism, self).__init__(**kwargs)
        self.min_instance_count = kwargs.get('min_instance_count', None)
        self.max_instance_count = kwargs.get('max_instance_count', None)
        self.scale_increment = kwargs.get('scale_increment', None)
        self.kind = 'ScalePartitionInstanceCount'


class RollingUpgradeMonitoringPolicy(Model):
    """The policy used for monitoring the application upgrade.

    All required parameters must be populated in order to send to Azure.

    :param failure_action: Required. The compensating action to perform when a
     Monitored upgrade encounters monitoring policy or health policy
     violations. Invalid indicates the failure action is invalid. Rollback
     specifies that the upgrade will start rolling back automatically. Manual
     indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
     Possible values include: 'Rollback', 'Manual'
    :type failure_action: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.FailureAction
    :param health_check_wait_duration: Required.
    :type health_check_wait_duration: str
    :param health_check_stable_duration: Required.
    :type health_check_stable_duration: str
    :param health_check_retry_timeout: Required.
    :type health_check_retry_timeout: str
    :param upgrade_timeout: Required.
    :type upgrade_timeout: str
    :param upgrade_domain_timeout: Required.
    :type upgrade_domain_timeout: str
    """

    _validation = {
        'failure_action': {'required': True},
        'health_check_wait_duration': {'required': True},
        'health_check_stable_duration': {'required': True},
        'health_check_retry_timeout': {'required': True},
        'upgrade_timeout': {'required': True},
        'upgrade_domain_timeout': {'required': True},
    }

    _attribute_map = {
        'failure_action': {'key': 'failureAction', 'type': 'str'},
        'health_check_wait_duration': {'key': 'healthCheckWaitDuration', 'type': 'str'},
        'health_check_stable_duration': {'key': 'healthCheckStableDuration', 'type': 'str'},
        'health_check_retry_timeout': {'key': 'healthCheckRetryTimeout', 'type': 'str'},
        'upgrade_timeout': {'key': 'upgradeTimeout', 'type': 'str'},
        'upgrade_domain_timeout': {'key': 'upgradeDomainTimeout', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(RollingUpgradeMonitoringPolicy, self).__init__(**kwargs)
        self.failure_action = kwargs.get('failure_action', None)
        self.health_check_wait_duration = kwargs.get('health_check_wait_duration', None)
        self.health_check_stable_duration = kwargs.get('health_check_stable_duration', None)
        self.health_check_retry_timeout = kwargs.get('health_check_retry_timeout', None)
        self.upgrade_timeout = kwargs.get('upgrade_timeout', None)
        self.upgrade_domain_timeout = kwargs.get('upgrade_domain_timeout', None)


class ScalingPolicy(Model):
    """Specifies a metric to load balance a service during runtime.

    All required parameters must be populated in order to send to Azure.

    :param scaling_mechanism: Required. Specifies the mechanism associated
     with this scaling policy
    :type scaling_mechanism:
     ~azure.mgmt.servicefabricmanagedclusters.models.ScalingMechanism
    :param scaling_trigger: Required. Specifies the trigger associated with
     this scaling policy.
    :type scaling_trigger:
     ~azure.mgmt.servicefabricmanagedclusters.models.ScalingTrigger
    """

    _validation = {
        'scaling_mechanism': {'required': True},
        'scaling_trigger': {'required': True},
    }

    _attribute_map = {
        'scaling_mechanism': {'key': 'scalingMechanism', 'type': 'ScalingMechanism'},
        'scaling_trigger': {'key': 'scalingTrigger', 'type': 'ScalingTrigger'},
    }

    def __init__(self, **kwargs):
        super(ScalingPolicy, self).__init__(**kwargs)
        self.scaling_mechanism = kwargs.get('scaling_mechanism', None)
        self.scaling_trigger = kwargs.get('scaling_trigger', None)


class ServiceCorrelation(Model):
    """Creates a particular correlation between services.

    All required parameters must be populated in order to send to Azure.

    :param scheme: Required. The ServiceCorrelationScheme which describes the
     relationship between this service and the service specified via
     ServiceName. Possible values include: 'AlignedAffinity',
     'NonAlignedAffinity'
    :type scheme: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.ServiceCorrelationScheme
    :param service_name: Required. The Arm Resource ID of the service that the
     correlation relationship is established with.
    :type service_name: str
    """

    _validation = {
        'scheme': {'required': True},
        'service_name': {'required': True},
    }

    _attribute_map = {
        'scheme': {'key': 'scheme', 'type': 'str'},
        'service_name': {'key': 'serviceName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ServiceCorrelation, self).__init__(**kwargs)
        self.scheme = kwargs.get('scheme', None)
        self.service_name = kwargs.get('service_name', None)


class ServiceLoadMetric(Model):
    """Specifies a metric to load balance a service during runtime.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the metric. If the service chooses to
     report load during runtime, the load metric name should match the name
     that is specified in Name exactly. Note that metric names are case
     sensitive.
    :type name: str
    :param weight: The service load metric relative weight, compared to other
     metrics configured for this service, as a number. Possible values include:
     'Zero', 'Low', 'Medium', 'High'
    :type weight: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.ServiceLoadMetricWeight
    :param primary_default_load: Used only for Stateful services. The default
     amount of load, as a number, that this service creates for this metric
     when it is a Primary replica.
    :type primary_default_load: int
    :param secondary_default_load: Used only for Stateful services. The
     default amount of load, as a number, that this service creates for this
     metric when it is a Secondary replica.
    :type secondary_default_load: int
    :param default_load: Used only for Stateless services. The default amount
     of load, as a number, that this service creates for this metric.
    :type default_load: int
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'weight': {'key': 'weight', 'type': 'str'},
        'primary_default_load': {'key': 'primaryDefaultLoad', 'type': 'int'},
        'secondary_default_load': {'key': 'secondaryDefaultLoad', 'type': 'int'},
        'default_load': {'key': 'defaultLoad', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(ServiceLoadMetric, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.weight = kwargs.get('weight', None)
        self.primary_default_load = kwargs.get('primary_default_load', None)
        self.secondary_default_load = kwargs.get('secondary_default_load', None)
        self.default_load = kwargs.get('default_load', None)


class ServicePlacementPolicy(Model):
    """Describes the policy to be used for placement of a Service Fabric service.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ServicePlacementInvalidDomainPolicy,
    ServicePlacementNonPartiallyPlaceServicePolicy,
    ServicePlacementPreferPrimaryDomainPolicy,
    ServicePlacementRequiredDomainPolicy,
    ServicePlacementRequireDomainDistributionPolicy

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Constant filled by server.
    :type type: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'InvalidDomain': 'ServicePlacementInvalidDomainPolicy', 'NonPartiallyPlaceService': 'ServicePlacementNonPartiallyPlaceServicePolicy', 'PreferredPrimaryDomain': 'ServicePlacementPreferPrimaryDomainPolicy', 'RequiredDomain': 'ServicePlacementRequiredDomainPolicy', 'RequiredDomainDistribution': 'ServicePlacementRequireDomainDistributionPolicy'}
    }

    def __init__(self, **kwargs):
        super(ServicePlacementPolicy, self).__init__(**kwargs)
        self.type = None


class ServicePlacementInvalidDomainPolicy(ServicePlacementPolicy):
    """Describes the policy to be used for placement of a Service Fabric service
    where a particular fault or upgrade domain should not be used for placement
    of the instances or replicas of that service.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Constant filled by server.
    :type type: str
    :param domain_name: Required. The name of the domain that should not be
     used for placement.
    :type domain_name: str
    """

    _validation = {
        'type': {'required': True},
        'domain_name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'domain_name': {'key': 'domainName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ServicePlacementInvalidDomainPolicy, self).__init__(**kwargs)
        self.domain_name = kwargs.get('domain_name', None)
        self.type = 'InvalidDomain'


class ServicePlacementNonPartiallyPlaceServicePolicy(ServicePlacementPolicy):
    """The name of the domain that should used for placement as per this policy.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Constant filled by server.
    :type type: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ServicePlacementNonPartiallyPlaceServicePolicy, self).__init__(**kwargs)
        self.type = 'NonPartiallyPlaceService'


class ServicePlacementPreferPrimaryDomainPolicy(ServicePlacementPolicy):
    """Describes the policy to be used for placement of a Service Fabric service
    where the service's
    Primary replicas should optimally be placed in a particular domain.
    This placement policy is usually used with fault domains in scenarios where
    the Service Fabric
    cluster is geographically distributed in order to indicate that a service's
    primary replica should
    be located in a particular fault domain, which in geo-distributed scenarios
    usually aligns with regional
    or datacenter boundaries. Note that since this is an optimization it is
    possible that the Primary replica
    may not end up located in this domain due to failures, capacity limits, or
    other constraints.
    .

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Constant filled by server.
    :type type: str
    :param domain_name: Required. The name of the domain that should used for
     placement as per this policy.
    :type domain_name: str
    """

    _validation = {
        'type': {'required': True},
        'domain_name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'domain_name': {'key': 'domainName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ServicePlacementPreferPrimaryDomainPolicy, self).__init__(**kwargs)
        self.domain_name = kwargs.get('domain_name', None)
        self.type = 'PreferredPrimaryDomain'


class ServicePlacementRequiredDomainPolicy(ServicePlacementPolicy):
    """Describes the policy to be used for placement of a Service Fabric service
    where the instances or replicas of that service must be placed in a
    particular domain.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Constant filled by server.
    :type type: str
    :param domain_name: Required. The name of the domain that should used for
     placement as per this policy.
    :type domain_name: str
    """

    _validation = {
        'type': {'required': True},
        'domain_name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'domain_name': {'key': 'domainName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ServicePlacementRequiredDomainPolicy, self).__init__(**kwargs)
        self.domain_name = kwargs.get('domain_name', None)
        self.type = 'RequiredDomain'


class ServicePlacementRequireDomainDistributionPolicy(ServicePlacementPolicy):
    """Describes the policy to be used for placement of a Service Fabric service
    where two replicas
    from the same partition should never be placed in the same fault or upgrade
    domain.
    While this is not common it can expose the service to an increased risk of
    concurrent failures
    due to unplanned outages or other cases of subsequent/concurrent failures.
    As an example, consider
    a case where replicas are deployed across different data center, with one
    replica per location.
    In the event that one of the datacenters goes offline, normally the replica
    that was placed in that
    datacenter will be packed into one of the remaining datacenters. If this is
    not desirable then this
    policy should be set.
    .

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Constant filled by server.
    :type type: str
    :param domain_name: Required. The name of the domain that should used for
     placement as per this policy.
    :type domain_name: str
    """

    _validation = {
        'type': {'required': True},
        'domain_name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'domain_name': {'key': 'domainName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ServicePlacementRequireDomainDistributionPolicy, self).__init__(**kwargs)
        self.domain_name = kwargs.get('domain_name', None)
        self.type = 'RequiredDomainDistribution'


class ServiceResource(ProxyResource):
    """The service resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource identifier.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Resource location depends on the parent resource.
    :type location: str
    :param tags: Azure resource tags.
    :type tags: dict[str, str]
    :param system_data:
    :type system_data:
     ~azure.mgmt.servicefabricmanagedclusters.models.SystemData
    :param placement_constraints: The placement constraints as a string.
     Placement constraints are boolean expressions on node properties and allow
     for restricting a service to particular nodes based on the service
     requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :type placement_constraints: str
    :param correlation_scheme:
    :type correlation_scheme:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServiceCorrelation]
    :param service_load_metrics:
    :type service_load_metrics:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServiceLoadMetric]
    :param service_placement_policies:
    :type service_placement_policies:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServicePlacementPolicy]
    :param default_move_cost: Possible values include: 'Zero', 'Low',
     'Medium', 'High'
    :type default_move_cost: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.MoveCost
    :param scaling_policies:
    :type scaling_policies:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ScalingPolicy]
    :ivar provisioning_state: The current deployment or provisioning state,
     which only appears in the response
    :vartype provisioning_state: str
    :param service_type_name: Required. The name of the service type
    :type service_type_name: str
    :param partition_description: Required.
    :type partition_description:
     ~azure.mgmt.servicefabricmanagedclusters.models.Partition
    :param service_package_activation_mode: The activation Mode of the service
     package. Possible values include: 'SharedProcess', 'ExclusiveProcess'
    :type service_package_activation_mode: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.ServicePackageActivationMode
    :param service_dns_name: The DNS name of the service. It requires the DNS
     system service to be enabled in Service Fabric cluster.
    :type service_dns_name: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'service_type_name': {'required': True},
        'partition_description': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'placement_constraints': {'key': 'properties.placementConstraints', 'type': 'str'},
        'correlation_scheme': {'key': 'properties.correlationScheme', 'type': '[ServiceCorrelation]'},
        'service_load_metrics': {'key': 'properties.serviceLoadMetrics', 'type': '[ServiceLoadMetric]'},
        'service_placement_policies': {'key': 'properties.servicePlacementPolicies', 'type': '[ServicePlacementPolicy]'},
        'default_move_cost': {'key': 'properties.defaultMoveCost', 'type': 'str'},
        'scaling_policies': {'key': 'properties.scalingPolicies', 'type': '[ScalingPolicy]'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'service_type_name': {'key': 'properties.serviceTypeName', 'type': 'str'},
        'partition_description': {'key': 'properties.partitionDescription', 'type': 'Partition'},
        'service_package_activation_mode': {'key': 'properties.servicePackageActivationMode', 'type': 'str'},
        'service_dns_name': {'key': 'properties.serviceDnsName', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ServiceResource, self).__init__(**kwargs)
        self.placement_constraints = kwargs.get('placement_constraints', None)
        self.correlation_scheme = kwargs.get('correlation_scheme', None)
        self.service_load_metrics = kwargs.get('service_load_metrics', None)
        self.service_placement_policies = kwargs.get('service_placement_policies', None)
        self.default_move_cost = kwargs.get('default_move_cost', None)
        self.scaling_policies = kwargs.get('scaling_policies', None)
        self.provisioning_state = None
        self.service_type_name = kwargs.get('service_type_name', None)
        self.partition_description = kwargs.get('partition_description', None)
        self.service_package_activation_mode = kwargs.get('service_package_activation_mode', None)
        self.service_dns_name = kwargs.get('service_dns_name', None)


class ServiceResourcePropertiesBase(Model):
    """The common service resource properties.

    :param placement_constraints: The placement constraints as a string.
     Placement constraints are boolean expressions on node properties and allow
     for restricting a service to particular nodes based on the service
     requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :type placement_constraints: str
    :param correlation_scheme:
    :type correlation_scheme:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServiceCorrelation]
    :param service_load_metrics:
    :type service_load_metrics:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServiceLoadMetric]
    :param service_placement_policies:
    :type service_placement_policies:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServicePlacementPolicy]
    :param default_move_cost: Possible values include: 'Zero', 'Low',
     'Medium', 'High'
    :type default_move_cost: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.MoveCost
    :param scaling_policies:
    :type scaling_policies:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ScalingPolicy]
    """

    _attribute_map = {
        'placement_constraints': {'key': 'placementConstraints', 'type': 'str'},
        'correlation_scheme': {'key': 'correlationScheme', 'type': '[ServiceCorrelation]'},
        'service_load_metrics': {'key': 'serviceLoadMetrics', 'type': '[ServiceLoadMetric]'},
        'service_placement_policies': {'key': 'servicePlacementPolicies', 'type': '[ServicePlacementPolicy]'},
        'default_move_cost': {'key': 'defaultMoveCost', 'type': 'str'},
        'scaling_policies': {'key': 'scalingPolicies', 'type': '[ScalingPolicy]'},
    }

    def __init__(self, **kwargs):
        super(ServiceResourcePropertiesBase, self).__init__(**kwargs)
        self.placement_constraints = kwargs.get('placement_constraints', None)
        self.correlation_scheme = kwargs.get('correlation_scheme', None)
        self.service_load_metrics = kwargs.get('service_load_metrics', None)
        self.service_placement_policies = kwargs.get('service_placement_policies', None)
        self.default_move_cost = kwargs.get('default_move_cost', None)
        self.scaling_policies = kwargs.get('scaling_policies', None)


class ServiceResourceProperties(ServiceResourcePropertiesBase):
    """The service resource properties.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: StatefulServiceProperties, StatelessServiceProperties

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param placement_constraints: The placement constraints as a string.
     Placement constraints are boolean expressions on node properties and allow
     for restricting a service to particular nodes based on the service
     requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :type placement_constraints: str
    :param correlation_scheme:
    :type correlation_scheme:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServiceCorrelation]
    :param service_load_metrics:
    :type service_load_metrics:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServiceLoadMetric]
    :param service_placement_policies:
    :type service_placement_policies:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServicePlacementPolicy]
    :param default_move_cost: Possible values include: 'Zero', 'Low',
     'Medium', 'High'
    :type default_move_cost: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.MoveCost
    :param scaling_policies:
    :type scaling_policies:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ScalingPolicy]
    :ivar provisioning_state: The current deployment or provisioning state,
     which only appears in the response
    :vartype provisioning_state: str
    :param service_type_name: Required. The name of the service type
    :type service_type_name: str
    :param partition_description: Required.
    :type partition_description:
     ~azure.mgmt.servicefabricmanagedclusters.models.Partition
    :param service_package_activation_mode: The activation Mode of the service
     package. Possible values include: 'SharedProcess', 'ExclusiveProcess'
    :type service_package_activation_mode: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.ServicePackageActivationMode
    :param service_dns_name: The DNS name of the service. It requires the DNS
     system service to be enabled in Service Fabric cluster.
    :type service_dns_name: str
    :param service_kind: Required. Constant filled by server.
    :type service_kind: str
    """

    _validation = {
        'provisioning_state': {'readonly': True},
        'service_type_name': {'required': True},
        'partition_description': {'required': True},
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'placement_constraints': {'key': 'placementConstraints', 'type': 'str'},
        'correlation_scheme': {'key': 'correlationScheme', 'type': '[ServiceCorrelation]'},
        'service_load_metrics': {'key': 'serviceLoadMetrics', 'type': '[ServiceLoadMetric]'},
        'service_placement_policies': {'key': 'servicePlacementPolicies', 'type': '[ServicePlacementPolicy]'},
        'default_move_cost': {'key': 'defaultMoveCost', 'type': 'str'},
        'scaling_policies': {'key': 'scalingPolicies', 'type': '[ScalingPolicy]'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'service_type_name': {'key': 'serviceTypeName', 'type': 'str'},
        'partition_description': {'key': 'partitionDescription', 'type': 'Partition'},
        'service_package_activation_mode': {'key': 'servicePackageActivationMode', 'type': 'str'},
        'service_dns_name': {'key': 'serviceDnsName', 'type': 'str'},
        'service_kind': {'key': 'serviceKind', 'type': 'str'},
    }

    _subtype_map = {
        'service_kind': {'Stateful': 'StatefulServiceProperties', 'Stateless': 'StatelessServiceProperties'}
    }

    def __init__(self, **kwargs):
        super(ServiceResourceProperties, self).__init__(**kwargs)
        self.provisioning_state = None
        self.service_type_name = kwargs.get('service_type_name', None)
        self.partition_description = kwargs.get('partition_description', None)
        self.service_package_activation_mode = kwargs.get('service_package_activation_mode', None)
        self.service_dns_name = kwargs.get('service_dns_name', None)
        self.service_kind = None
        self.service_kind = 'ServiceResourceProperties'


class ServiceTypeHealthPolicy(Model):
    """Represents the health policy used to evaluate the health of services
    belonging to a service type.
    .

    All required parameters must be populated in order to send to Azure.

    :param max_percent_unhealthy_services: Required. The maximum allowed
     percentage of unhealthy services.
     The percentage represents the maximum tolerated percentage of services
     that can be unhealthy before the application is considered in error.
     If the percentage is respected but there is at least one unhealthy
     service, the health is evaluated as Warning.
     This is calculated by dividing the number of unhealthy services of the
     specific service type over the total number of services of the specific
     service type.
     The computation rounds up to tolerate one failure on small numbers of
     services.
    :type max_percent_unhealthy_services: int
    :param max_percent_unhealthy_partitions_per_service: Required. The maximum
     allowed percentage of unhealthy partitions per service.
     The percentage represents the maximum tolerated percentage of partitions
     that can be unhealthy before the service is considered in error.
     If the percentage is respected but there is at least one unhealthy
     partition, the health is evaluated as Warning.
     The percentage is calculated by dividing the number of unhealthy
     partitions over the total number of partitions in the service.
     The computation rounds up to tolerate one failure on small numbers of
     partitions.
    :type max_percent_unhealthy_partitions_per_service: int
    :param max_percent_unhealthy_replicas_per_partition: Required. The maximum
     allowed percentage of unhealthy replicas per partition.
     The percentage represents the maximum tolerated percentage of replicas
     that can be unhealthy before the partition is considered in error.
     If the percentage is respected but there is at least one unhealthy
     replica, the health is evaluated as Warning.
     The percentage is calculated by dividing the number of unhealthy replicas
     over the total number of replicas in the partition.
     The computation rounds up to tolerate one failure on small numbers of
     replicas.
    :type max_percent_unhealthy_replicas_per_partition: int
    """

    _validation = {
        'max_percent_unhealthy_services': {'required': True, 'maximum': 100, 'minimum': 0},
        'max_percent_unhealthy_partitions_per_service': {'required': True, 'maximum': 100, 'minimum': 0},
        'max_percent_unhealthy_replicas_per_partition': {'required': True, 'maximum': 100, 'minimum': 0},
    }

    _attribute_map = {
        'max_percent_unhealthy_services': {'key': 'maxPercentUnhealthyServices', 'type': 'int'},
        'max_percent_unhealthy_partitions_per_service': {'key': 'maxPercentUnhealthyPartitionsPerService', 'type': 'int'},
        'max_percent_unhealthy_replicas_per_partition': {'key': 'maxPercentUnhealthyReplicasPerPartition', 'type': 'int'},
    }

    def __init__(self, **kwargs):
        super(ServiceTypeHealthPolicy, self).__init__(**kwargs)
        self.max_percent_unhealthy_services = kwargs.get('max_percent_unhealthy_services', None)
        self.max_percent_unhealthy_partitions_per_service = kwargs.get('max_percent_unhealthy_partitions_per_service', None)
        self.max_percent_unhealthy_replicas_per_partition = kwargs.get('max_percent_unhealthy_replicas_per_partition', None)


class ServiceUpdateParameters(Model):
    """Service update request.

    :param tags: Service update parameters
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs):
        super(ServiceUpdateParameters, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)


class SettingsParameterDescription(Model):
    """Describes a parameter in fabric settings of the cluster.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The parameter name of fabric setting.
    :type name: str
    :param value: Required. The parameter value of fabric setting.
    :type value: str
    """

    _validation = {
        'name': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(SettingsParameterDescription, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)


class SettingsSectionDescription(Model):
    """Describes a section in the fabric settings of the cluster.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The section name of the fabric settings.
    :type name: str
    :param parameters: Required. The collection of parameters in the section.
    :type parameters:
     list[~azure.mgmt.servicefabricmanagedclusters.models.SettingsParameterDescription]
    """

    _validation = {
        'name': {'required': True},
        'parameters': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'parameters': {'key': 'parameters', 'type': '[SettingsParameterDescription]'},
    }

    def __init__(self, **kwargs):
        super(SettingsSectionDescription, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.parameters = kwargs.get('parameters', None)


class SingletonPartitionScheme(Partition):
    """Describes the partition scheme of a singleton-partitioned, or
    non-partitioned service.

    All required parameters must be populated in order to send to Azure.

    :param partition_scheme: Required. Constant filled by server.
    :type partition_scheme: str
    """

    _validation = {
        'partition_scheme': {'required': True},
    }

    _attribute_map = {
        'partition_scheme': {'key': 'partitionScheme', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(SingletonPartitionScheme, self).__init__(**kwargs)
        self.partition_scheme = 'Singleton'


class Sku(Model):
    """Service Fabric managed cluster Sku definition.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. Sku Name. Possible values include: 'Basic',
     'Standard'
    :type name: str or ~azure.mgmt.servicefabricmanagedclusters.models.enum
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(Sku, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)


class StatefulServiceProperties(ServiceResourceProperties):
    """The properties of a stateful service resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param placement_constraints: The placement constraints as a string.
     Placement constraints are boolean expressions on node properties and allow
     for restricting a service to particular nodes based on the service
     requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :type placement_constraints: str
    :param correlation_scheme:
    :type correlation_scheme:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServiceCorrelation]
    :param service_load_metrics:
    :type service_load_metrics:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServiceLoadMetric]
    :param service_placement_policies:
    :type service_placement_policies:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServicePlacementPolicy]
    :param default_move_cost: Possible values include: 'Zero', 'Low',
     'Medium', 'High'
    :type default_move_cost: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.MoveCost
    :param scaling_policies:
    :type scaling_policies:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ScalingPolicy]
    :ivar provisioning_state: The current deployment or provisioning state,
     which only appears in the response
    :vartype provisioning_state: str
    :param service_type_name: Required. The name of the service type
    :type service_type_name: str
    :param partition_description: Required.
    :type partition_description:
     ~azure.mgmt.servicefabricmanagedclusters.models.Partition
    :param service_package_activation_mode: The activation Mode of the service
     package. Possible values include: 'SharedProcess', 'ExclusiveProcess'
    :type service_package_activation_mode: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.ServicePackageActivationMode
    :param service_dns_name: The DNS name of the service. It requires the DNS
     system service to be enabled in Service Fabric cluster.
    :type service_dns_name: str
    :param service_kind: Required. Constant filled by server.
    :type service_kind: str
    :param has_persisted_state: A flag indicating whether this is a persistent
     service which stores states on the local disk. If it is then the value of
     this property is true, if not it is false.
    :type has_persisted_state: bool
    :param target_replica_set_size: The target replica set size as a number.
    :type target_replica_set_size: int
    :param min_replica_set_size: The minimum replica set size as a number.
    :type min_replica_set_size: int
    :param replica_restart_wait_duration: The duration between when a replica
     goes down and when a new replica is created, represented in ISO 8601
     format "hh:mm:ss".
    :type replica_restart_wait_duration: str
    :param quorum_loss_wait_duration: The maximum duration for which a
     partition is allowed to be in a state of quorum loss, represented in ISO
     8601 format "hh:mm:ss".
    :type quorum_loss_wait_duration: str
    :param stand_by_replica_keep_duration: The definition on how long StandBy
     replicas should be maintained before being removed, represented in ISO
     8601 format "hh:mm:ss".
    :type stand_by_replica_keep_duration: str
    :param service_placement_time_limit: The duration for which replicas can
     stay InBuild before reporting that build is stuck, represented in ISO 8601
     format "hh:mm:ss".
    :type service_placement_time_limit: str
    :param drop_source_replica_on_move: Indicates whether to drop source
     Secondary replica even if the target replica has not finished build. If
     desired behavior is to drop it as soon as possible the value of this
     property is true, if not it is false.
    :type drop_source_replica_on_move: bool
    """

    _validation = {
        'provisioning_state': {'readonly': True},
        'service_type_name': {'required': True},
        'partition_description': {'required': True},
        'service_kind': {'required': True},
        'target_replica_set_size': {'minimum': 1},
        'min_replica_set_size': {'minimum': 1},
    }

    _attribute_map = {
        'placement_constraints': {'key': 'placementConstraints', 'type': 'str'},
        'correlation_scheme': {'key': 'correlationScheme', 'type': '[ServiceCorrelation]'},
        'service_load_metrics': {'key': 'serviceLoadMetrics', 'type': '[ServiceLoadMetric]'},
        'service_placement_policies': {'key': 'servicePlacementPolicies', 'type': '[ServicePlacementPolicy]'},
        'default_move_cost': {'key': 'defaultMoveCost', 'type': 'str'},
        'scaling_policies': {'key': 'scalingPolicies', 'type': '[ScalingPolicy]'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'service_type_name': {'key': 'serviceTypeName', 'type': 'str'},
        'partition_description': {'key': 'partitionDescription', 'type': 'Partition'},
        'service_package_activation_mode': {'key': 'servicePackageActivationMode', 'type': 'str'},
        'service_dns_name': {'key': 'serviceDnsName', 'type': 'str'},
        'service_kind': {'key': 'serviceKind', 'type': 'str'},
        'has_persisted_state': {'key': 'hasPersistedState', 'type': 'bool'},
        'target_replica_set_size': {'key': 'targetReplicaSetSize', 'type': 'int'},
        'min_replica_set_size': {'key': 'minReplicaSetSize', 'type': 'int'},
        'replica_restart_wait_duration': {'key': 'replicaRestartWaitDuration', 'type': 'str'},
        'quorum_loss_wait_duration': {'key': 'quorumLossWaitDuration', 'type': 'str'},
        'stand_by_replica_keep_duration': {'key': 'standByReplicaKeepDuration', 'type': 'str'},
        'service_placement_time_limit': {'key': 'servicePlacementTimeLimit', 'type': 'str'},
        'drop_source_replica_on_move': {'key': 'dropSourceReplicaOnMove', 'type': 'bool'},
    }

    def __init__(self, **kwargs):
        super(StatefulServiceProperties, self).__init__(**kwargs)
        self.has_persisted_state = kwargs.get('has_persisted_state', None)
        self.target_replica_set_size = kwargs.get('target_replica_set_size', None)
        self.min_replica_set_size = kwargs.get('min_replica_set_size', None)
        self.replica_restart_wait_duration = kwargs.get('replica_restart_wait_duration', None)
        self.quorum_loss_wait_duration = kwargs.get('quorum_loss_wait_duration', None)
        self.stand_by_replica_keep_duration = kwargs.get('stand_by_replica_keep_duration', None)
        self.service_placement_time_limit = kwargs.get('service_placement_time_limit', None)
        self.drop_source_replica_on_move = kwargs.get('drop_source_replica_on_move', None)
        self.service_kind = 'Stateful'


class StatelessServiceProperties(ServiceResourceProperties):
    """The properties of a stateless service resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param placement_constraints: The placement constraints as a string.
     Placement constraints are boolean expressions on node properties and allow
     for restricting a service to particular nodes based on the service
     requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :type placement_constraints: str
    :param correlation_scheme:
    :type correlation_scheme:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServiceCorrelation]
    :param service_load_metrics:
    :type service_load_metrics:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServiceLoadMetric]
    :param service_placement_policies:
    :type service_placement_policies:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ServicePlacementPolicy]
    :param default_move_cost: Possible values include: 'Zero', 'Low',
     'Medium', 'High'
    :type default_move_cost: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.MoveCost
    :param scaling_policies:
    :type scaling_policies:
     list[~azure.mgmt.servicefabricmanagedclusters.models.ScalingPolicy]
    :ivar provisioning_state: The current deployment or provisioning state,
     which only appears in the response
    :vartype provisioning_state: str
    :param service_type_name: Required. The name of the service type
    :type service_type_name: str
    :param partition_description: Required.
    :type partition_description:
     ~azure.mgmt.servicefabricmanagedclusters.models.Partition
    :param service_package_activation_mode: The activation Mode of the service
     package. Possible values include: 'SharedProcess', 'ExclusiveProcess'
    :type service_package_activation_mode: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.ServicePackageActivationMode
    :param service_dns_name: The DNS name of the service. It requires the DNS
     system service to be enabled in Service Fabric cluster.
    :type service_dns_name: str
    :param service_kind: Required. Constant filled by server.
    :type service_kind: str
    :param instance_count: Required. The instance count.
    :type instance_count: int
    :param min_instance_count: MinInstanceCount is the minimum number of
     instances that must be up to meet the EnsureAvailability safety check
     during operations like upgrade or deactivate node. The actual number that
     is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
     InstanceCount) ). Note, if InstanceCount is set to -1, during
     MinInstanceCount computation -1 is first converted into the number of
     nodes on which the instances are allowed to be placed according to the
     placement constraints on the service.
    :type min_instance_count: int
    :param min_instance_percentage: MinInstancePercentage is the minimum
     percentage of InstanceCount that must be up to meet the EnsureAvailability
     safety check during operations like upgrade or deactivate node. The actual
     number that is used is max( MinInstanceCount, ceil(
     MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is
     set to -1, during MinInstancePercentage computation, -1 is first converted
     into the number of nodes on which the instances are allowed to be placed
     according to the placement constraints on the service.
    :type min_instance_percentage: int
    :param instance_close_delay_duration: Duration represented in ISO 8601
     format "hh:mm:ss", to wait before a stateless instance is closed, to allow
     the active requests to drain gracefully. This would be effective when the
     instance is closing during the application/cluster upgrade and disabling
     node. The endpoint exposed on this instance is removed prior to starting
     the delay, which prevents new connections to this instance. In addition,
     clients that have subscribed to service endpoint change
     events(https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.servicemanagementclient.registerservicenotificationfilterasync),
     can do the following upon receiving the endpoint removal notification: -
     Stop sending new requests to this instance. - Close existing connections
     after in-flight requests have completed. - Connect to a different instance
     of the service partition for future requests. Note, the default value of
     InstanceCloseDelayDuration is 0, which indicates that there won't be any
     delay or removal of the endpoint prior to closing the instance. Default
     value: "0" .
    :type instance_close_delay_duration: str
    """

    _validation = {
        'provisioning_state': {'readonly': True},
        'service_type_name': {'required': True},
        'partition_description': {'required': True},
        'service_kind': {'required': True},
        'instance_count': {'required': True, 'minimum': -1},
    }

    _attribute_map = {
        'placement_constraints': {'key': 'placementConstraints', 'type': 'str'},
        'correlation_scheme': {'key': 'correlationScheme', 'type': '[ServiceCorrelation]'},
        'service_load_metrics': {'key': 'serviceLoadMetrics', 'type': '[ServiceLoadMetric]'},
        'service_placement_policies': {'key': 'servicePlacementPolicies', 'type': '[ServicePlacementPolicy]'},
        'default_move_cost': {'key': 'defaultMoveCost', 'type': 'str'},
        'scaling_policies': {'key': 'scalingPolicies', 'type': '[ScalingPolicy]'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'service_type_name': {'key': 'serviceTypeName', 'type': 'str'},
        'partition_description': {'key': 'partitionDescription', 'type': 'Partition'},
        'service_package_activation_mode': {'key': 'servicePackageActivationMode', 'type': 'str'},
        'service_dns_name': {'key': 'serviceDnsName', 'type': 'str'},
        'service_kind': {'key': 'serviceKind', 'type': 'str'},
        'instance_count': {'key': 'instanceCount', 'type': 'int'},
        'min_instance_count': {'key': 'minInstanceCount', 'type': 'int'},
        'min_instance_percentage': {'key': 'minInstancePercentage', 'type': 'int'},
        'instance_close_delay_duration': {'key': 'instanceCloseDelayDuration', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(StatelessServiceProperties, self).__init__(**kwargs)
        self.instance_count = kwargs.get('instance_count', None)
        self.min_instance_count = kwargs.get('min_instance_count', None)
        self.min_instance_percentage = kwargs.get('min_instance_percentage', None)
        self.instance_close_delay_duration = kwargs.get('instance_close_delay_duration', "0")
        self.service_kind = 'Stateless'


class SubResource(Model):
    """Azure resource identifier.

    :param id: Azure resource identifier.
    :type id: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(SubResource, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)


class SystemData(Model):
    """Metadata pertaining to creation and last modification of the resource.

    :param created_by: The identity that created the resource.
    :type created_by: str
    :param created_by_type: The type of identity that created the resource.
     Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
    :type created_by_type: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.CreatedByType
    :param created_at: The timestamp of resource creation (UTC).
    :type created_at: datetime
    :param last_modified_by: The identity that last modified the resource.
    :type last_modified_by: str
    :param last_modified_by_type: The type of identity that last modified the
     resource. Possible values include: 'User', 'Application',
     'ManagedIdentity', 'Key'
    :type last_modified_by_type: str or
     ~azure.mgmt.servicefabricmanagedclusters.models.CreatedByType
    :param last_modified_at: The timestamp of resource last modification
     (UTC).
    :type last_modified_at: datetime
    """

    _attribute_map = {
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'created_by_type': {'key': 'createdByType', 'type': 'str'},
        'created_at': {'key': 'createdAt', 'type': 'iso-8601'},
        'last_modified_by': {'key': 'lastModifiedBy', 'type': 'str'},
        'last_modified_by_type': {'key': 'lastModifiedByType', 'type': 'str'},
        'last_modified_at': {'key': 'lastModifiedAt', 'type': 'iso-8601'},
    }

    def __init__(self, **kwargs):
        super(SystemData, self).__init__(**kwargs)
        self.created_by = kwargs.get('created_by', None)
        self.created_by_type = kwargs.get('created_by_type', None)
        self.created_at = kwargs.get('created_at', None)
        self.last_modified_by = kwargs.get('last_modified_by', None)
        self.last_modified_by_type = kwargs.get('last_modified_by_type', None)
        self.last_modified_at = kwargs.get('last_modified_at', None)


class UniformInt64RangePartitionScheme(Partition):
    """Describes a partitioning scheme where an integer range is allocated evenly
    across a number of partitions.

    All required parameters must be populated in order to send to Azure.

    :param partition_scheme: Required. Constant filled by server.
    :type partition_scheme: str
    :param count: Required. The number of partitions.
    :type count: int
    :param low_key: Required. The lower bound of the partition key range that
     should be split between the partition Count
    :type low_key: long
    :param high_key: Required. The upper bound of the partition key range that
     should be split between the partition Count
    :type high_key: long
    """

    _validation = {
        'partition_scheme': {'required': True},
        'count': {'required': True},
        'low_key': {'required': True},
        'high_key': {'required': True},
    }

    _attribute_map = {
        'partition_scheme': {'key': 'partitionScheme', 'type': 'str'},
        'count': {'key': 'count', 'type': 'int'},
        'low_key': {'key': 'lowKey', 'type': 'long'},
        'high_key': {'key': 'highKey', 'type': 'long'},
    }

    def __init__(self, **kwargs):
        super(UniformInt64RangePartitionScheme, self).__init__(**kwargs)
        self.count = kwargs.get('count', None)
        self.low_key = kwargs.get('low_key', None)
        self.high_key = kwargs.get('high_key', None)
        self.partition_scheme = 'UniformInt64Range'


class UserAssignedIdentity(Model):
    """UserAssignedIdentity.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar principal_id: The principal id of user assigned identity.
    :vartype principal_id: str
    :ivar client_id: The client id of user assigned identity.
    :vartype client_id: str
    """

    _validation = {
        'principal_id': {'readonly': True},
        'client_id': {'readonly': True},
    }

    _attribute_map = {
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(UserAssignedIdentity, self).__init__(**kwargs)
        self.principal_id = None
        self.client_id = None


class VaultCertificate(Model):
    """Describes a single certificate reference in a Key Vault, and where the
    certificate should reside on the VM.

    All required parameters must be populated in order to send to Azure.

    :param certificate_url: Required. This is the URL of a certificate that
     has been uploaded to Key Vault as a secret. For adding a secret to the Key
     Vault, see [Add a key or secret to the key
     vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
     In this case, your certificate needs to be It is the Base64 encoding of
     the following JSON Object which is encoded in UTF-8: <br><br> {<br>
     "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>
     "password":"<pfx-file-password>"<br>}
    :type certificate_url: str
    :param certificate_store: Required. For Windows VMs, specifies the
     certificate store on the Virtual Machine to which the certificate should
     be added. The specified certificate store is implicitly in the
     LocalMachine account. <br><br>For Linux VMs, the certificate file is
     placed under the /var/lib/waagent directory, with the file name
     <UppercaseThumbprint>.crt for the X509 certificate file and
     <UppercaseThumbprint>.prv for private key. Both of these files are .pem
     formatted.
    :type certificate_store: str
    """

    _validation = {
        'certificate_url': {'required': True},
        'certificate_store': {'required': True},
    }

    _attribute_map = {
        'certificate_url': {'key': 'certificateUrl', 'type': 'str'},
        'certificate_store': {'key': 'certificateStore', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(VaultCertificate, self).__init__(**kwargs)
        self.certificate_url = kwargs.get('certificate_url', None)
        self.certificate_store = kwargs.get('certificate_store', None)


class VaultSecretGroup(Model):
    """Specifies set of certificates that should be installed onto the virtual
    machines.

    All required parameters must be populated in order to send to Azure.

    :param source_vault: Required. The relative URL of the Key Vault
     containing all of the certificates in VaultCertificates.
    :type source_vault:
     ~azure.mgmt.servicefabricmanagedclusters.models.SubResource
    :param vault_certificates: Required. The list of key vault references in
     SourceVault which contain certificates.
    :type vault_certificates:
     list[~azure.mgmt.servicefabricmanagedclusters.models.VaultCertificate]
    """

    _validation = {
        'source_vault': {'required': True},
        'vault_certificates': {'required': True},
    }

    _attribute_map = {
        'source_vault': {'key': 'sourceVault', 'type': 'SubResource'},
        'vault_certificates': {'key': 'vaultCertificates', 'type': '[VaultCertificate]'},
    }

    def __init__(self, **kwargs):
        super(VaultSecretGroup, self).__init__(**kwargs)
        self.source_vault = kwargs.get('source_vault', None)
        self.vault_certificates = kwargs.get('vault_certificates', None)


class VmManagedIdentity(Model):
    """Identities for the virtual machine scale set under the node type.

    :param user_assigned_identities: The list of user identities associated
     with the virtual machine scale set under the node type. Each entry will be
     an ARM resource ids in the form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
    :type user_assigned_identities: list[str]
    """

    _attribute_map = {
        'user_assigned_identities': {'key': 'userAssignedIdentities', 'type': '[str]'},
    }

    def __init__(self, **kwargs):
        super(VmManagedIdentity, self).__init__(**kwargs)
        self.user_assigned_identities = kwargs.get('user_assigned_identities', None)


class VMSSExtension(Model):
    """Specifies set of extensions that should be installed onto the virtual
    machines.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the extension.
    :type name: str
    :param publisher: Required. The name of the extension handler publisher.
    :type publisher: str
    :param type: Required. Specifies the type of the extension; an example is
     "CustomScriptExtension".
    :type type: str
    :param type_handler_version: Required. Specifies the version of the script
     handler.
    :type type_handler_version: str
    :param auto_upgrade_minor_version: Indicates whether the extension should
     use a newer minor version if one is available at deployment time. Once
     deployed, however, the extension will not upgrade minor versions unless
     redeployed, even with this property set to true.
    :type auto_upgrade_minor_version: bool
    :param settings: Json formatted public settings for the extension.
    :type settings: object
    :param protected_settings: The extension can contain either
     protectedSettings or protectedSettingsFromKeyVault or no protected
     settings at all.
    :type protected_settings: object
    :param force_update_tag: If a value is provided and is different from the
     previous value, the extension handler will be forced to update even if the
     extension configuration has not changed.
    :type force_update_tag: str
    :param provision_after_extensions: Collection of extension names after
     which this extension needs to be provisioned.
    :type provision_after_extensions: list[str]
    :ivar provisioning_state: The provisioning state, which only appears in
     the response.
    :vartype provisioning_state: str
    """

    _validation = {
        'name': {'required': True},
        'publisher': {'required': True},
        'type': {'required': True},
        'type_handler_version': {'required': True},
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'publisher': {'key': 'properties.publisher', 'type': 'str'},
        'type': {'key': 'properties.type', 'type': 'str'},
        'type_handler_version': {'key': 'properties.typeHandlerVersion', 'type': 'str'},
        'auto_upgrade_minor_version': {'key': 'properties.autoUpgradeMinorVersion', 'type': 'bool'},
        'settings': {'key': 'properties.settings', 'type': 'object'},
        'protected_settings': {'key': 'properties.protectedSettings', 'type': 'object'},
        'force_update_tag': {'key': 'properties.forceUpdateTag', 'type': 'str'},
        'provision_after_extensions': {'key': 'properties.provisionAfterExtensions', 'type': '[str]'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(VMSSExtension, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.publisher = kwargs.get('publisher', None)
        self.type = kwargs.get('type', None)
        self.type_handler_version = kwargs.get('type_handler_version', None)
        self.auto_upgrade_minor_version = kwargs.get('auto_upgrade_minor_version', None)
        self.settings = kwargs.get('settings', None)
        self.protected_settings = kwargs.get('protected_settings', None)
        self.force_update_tag = kwargs.get('force_update_tag', None)
        self.provision_after_extensions = kwargs.get('provision_after_extensions', None)
        self.provisioning_state = None
