# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model
from msrest.exceptions import HttpOperationError


class SubResource(Model):
    """Reference to another subresource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Resource ID.
    :vartype id: str
    :ivar name: The name of the resource that is unique within a resource
     group. This name can be used to access the resource.
    :vartype name: str
    :ivar type: Resource type
    :vartype type: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(self, **kwargs) -> None:
        super(SubResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None


class AgentPool(SubResource):
    """Agent Pool.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Resource ID.
    :vartype id: str
    :ivar name: The name of the resource that is unique within a resource
     group. This name can be used to access the resource.
    :vartype name: str
    :ivar type: Resource type
    :vartype type: str
    :param count: Number of agents (VMs) to host docker containers. Allowed
     values must be in the range of 0 to 100 (inclusive) for user pools and in
     the range of 1 to 100 (inclusive) for system pools. The default value is
     1.
    :type count: int
    :param vm_size: Size of agent VMs. Possible values include: 'Standard_A1',
     'Standard_A10', 'Standard_A11', 'Standard_A1_v2', 'Standard_A2',
     'Standard_A2_v2', 'Standard_A2m_v2', 'Standard_A3', 'Standard_A4',
     'Standard_A4_v2', 'Standard_A4m_v2', 'Standard_A5', 'Standard_A6',
     'Standard_A7', 'Standard_A8', 'Standard_A8_v2', 'Standard_A8m_v2',
     'Standard_A9', 'Standard_B2ms', 'Standard_B2s', 'Standard_B4ms',
     'Standard_B8ms', 'Standard_D1', 'Standard_D11', 'Standard_D11_v2',
     'Standard_D11_v2_Promo', 'Standard_D12', 'Standard_D12_v2',
     'Standard_D12_v2_Promo', 'Standard_D13', 'Standard_D13_v2',
     'Standard_D13_v2_Promo', 'Standard_D14', 'Standard_D14_v2',
     'Standard_D14_v2_Promo', 'Standard_D15_v2', 'Standard_D16_v3',
     'Standard_D16s_v3', 'Standard_D1_v2', 'Standard_D2', 'Standard_D2_v2',
     'Standard_D2_v2_Promo', 'Standard_D2_v3', 'Standard_D2s_v3',
     'Standard_D3', 'Standard_D32_v3', 'Standard_D32s_v3', 'Standard_D3_v2',
     'Standard_D3_v2_Promo', 'Standard_D4', 'Standard_D4_v2',
     'Standard_D4_v2_Promo', 'Standard_D4_v3', 'Standard_D4s_v3',
     'Standard_D5_v2', 'Standard_D5_v2_Promo', 'Standard_D64_v3',
     'Standard_D64s_v3', 'Standard_D8_v3', 'Standard_D8s_v3', 'Standard_DS1',
     'Standard_DS11', 'Standard_DS11_v2', 'Standard_DS11_v2_Promo',
     'Standard_DS12', 'Standard_DS12_v2', 'Standard_DS12_v2_Promo',
     'Standard_DS13', 'Standard_DS13-2_v2', 'Standard_DS13-4_v2',
     'Standard_DS13_v2', 'Standard_DS13_v2_Promo', 'Standard_DS14',
     'Standard_DS14-4_v2', 'Standard_DS14-8_v2', 'Standard_DS14_v2',
     'Standard_DS14_v2_Promo', 'Standard_DS15_v2', 'Standard_DS1_v2',
     'Standard_DS2', 'Standard_DS2_v2', 'Standard_DS2_v2_Promo',
     'Standard_DS3', 'Standard_DS3_v2', 'Standard_DS3_v2_Promo',
     'Standard_DS4', 'Standard_DS4_v2', 'Standard_DS4_v2_Promo',
     'Standard_DS5_v2', 'Standard_DS5_v2_Promo', 'Standard_E16_v3',
     'Standard_E16s_v3', 'Standard_E2_v3', 'Standard_E2s_v3',
     'Standard_E32-16s_v3', 'Standard_E32-8s_v3', 'Standard_E32_v3',
     'Standard_E32s_v3', 'Standard_E4_v3', 'Standard_E4s_v3',
     'Standard_E64-16s_v3', 'Standard_E64-32s_v3', 'Standard_E64_v3',
     'Standard_E64s_v3', 'Standard_E8_v3', 'Standard_E8s_v3', 'Standard_F1',
     'Standard_F16', 'Standard_F16s', 'Standard_F16s_v2', 'Standard_F1s',
     'Standard_F2', 'Standard_F2s', 'Standard_F2s_v2', 'Standard_F32s_v2',
     'Standard_F4', 'Standard_F4s', 'Standard_F4s_v2', 'Standard_F64s_v2',
     'Standard_F72s_v2', 'Standard_F8', 'Standard_F8s', 'Standard_F8s_v2',
     'Standard_G1', 'Standard_G2', 'Standard_G3', 'Standard_G4', 'Standard_G5',
     'Standard_GS1', 'Standard_GS2', 'Standard_GS3', 'Standard_GS4',
     'Standard_GS4-4', 'Standard_GS4-8', 'Standard_GS5', 'Standard_GS5-16',
     'Standard_GS5-8', 'Standard_H16', 'Standard_H16m', 'Standard_H16mr',
     'Standard_H16r', 'Standard_H8', 'Standard_H8m', 'Standard_L16s',
     'Standard_L32s', 'Standard_L4s', 'Standard_L8s', 'Standard_M128-32ms',
     'Standard_M128-64ms', 'Standard_M128ms', 'Standard_M128s',
     'Standard_M64-16ms', 'Standard_M64-32ms', 'Standard_M64ms',
     'Standard_M64s', 'Standard_NC12', 'Standard_NC12s_v2',
     'Standard_NC12s_v3', 'Standard_NC24', 'Standard_NC24r',
     'Standard_NC24rs_v2', 'Standard_NC24rs_v3', 'Standard_NC24s_v2',
     'Standard_NC24s_v3', 'Standard_NC6', 'Standard_NC6s_v2',
     'Standard_NC6s_v3', 'Standard_ND12s', 'Standard_ND24rs', 'Standard_ND24s',
     'Standard_ND6s', 'Standard_NV12', 'Standard_NV24', 'Standard_NV6'
    :type vm_size: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ContainerServiceVMSizeTypes
    :param os_disk_size_gb: OS Disk Size in GB to be used to specify the disk
     size for every machine in this master/agent pool. If you specify 0, it
     will apply the default osDisk size according to the vmSize specified.
    :type os_disk_size_gb: int
    :param os_disk_type: OS disk type to be used for machines in a given agent
     pool. Allowed values are 'Ephemeral' and 'Managed'. If unspecified,
     defaults to 'Ephemeral' when the VM supports ephemeral OS and has a cache
     disk larger than the requested OSDiskSizeGB. Otherwise, defaults to
     'Managed'. May not be changed after creation. Possible values include:
     'Managed', 'Ephemeral'
    :type os_disk_type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.OSDiskType
    :param vnet_subnet_id: VNet SubnetID specifies the VNet's subnet
     identifier for nodes and maybe pods
    :type vnet_subnet_id: str
    :param pod_subnet_id: Pod SubnetID specifies the VNet's subnet identifier
     for pods.
    :type pod_subnet_id: str
    :param max_pods: Maximum number of pods that can run on a node.
    :type max_pods: int
    :param os_type: OsType to be used to specify os type. Choose from Linux
     and Windows. Default to Linux. Possible values include: 'Linux',
     'Windows'. Default value: "Linux" .
    :type os_type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.OSType
    :param max_count: Maximum number of nodes for auto-scaling
    :type max_count: int
    :param min_count: Minimum number of nodes for auto-scaling
    :type min_count: int
    :param enable_auto_scaling: Whether to enable auto-scaler
    :type enable_auto_scaling: bool
    :param agent_pool_type: AgentPoolType represents types of an agent pool.
     Possible values include: 'VirtualMachineScaleSets', 'AvailabilitySet'
    :type agent_pool_type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.AgentPoolType
    :param mode: AgentPoolMode represents mode of an agent pool. Possible
     values include: 'System', 'User'
    :type mode: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.AgentPoolMode
    :param orchestrator_version: Version of orchestrator specified when
     creating the managed cluster.
    :type orchestrator_version: str
    :ivar node_image_version: Version of node image
    :vartype node_image_version: str
    :param upgrade_settings: Settings for upgrading the agentpool
    :type upgrade_settings:
     ~azure.mgmt.containerservice.v2020_11_01.models.AgentPoolUpgradeSettings
    :ivar provisioning_state: The current deployment or provisioning state,
     which only appears in the response.
    :vartype provisioning_state: str
    :ivar power_state: Describes whether the Agent Pool is Running or Stopped
    :vartype power_state:
     ~azure.mgmt.containerservice.v2020_11_01.models.PowerState
    :param availability_zones: Availability zones for nodes. Must use
     VirtualMachineScaleSets AgentPoolType.
    :type availability_zones: list[str]
    :param enable_node_public_ip: Enable public IP for nodes
    :type enable_node_public_ip: bool
    :param scale_set_priority: ScaleSetPriority to be used to specify virtual
     machine scale set priority. Default to regular. Possible values include:
     'Spot', 'Regular'. Default value: "Regular" .
    :type scale_set_priority: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ScaleSetPriority
    :param scale_set_eviction_policy: ScaleSetEvictionPolicy to be used to
     specify eviction policy for Spot virtual machine scale set. Default to
     Delete. Possible values include: 'Delete', 'Deallocate'. Default value:
     "Delete" .
    :type scale_set_eviction_policy: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ScaleSetEvictionPolicy
    :param spot_max_price: SpotMaxPrice to be used to specify the maximum
     price you are willing to pay in US Dollars. Possible values are any
     decimal value greater than zero or -1 which indicates default price to be
     up-to on-demand.
    :type spot_max_price: float
    :param tags: Agent pool tags to be persisted on the agent pool virtual
     machine scale set.
    :type tags: dict[str, str]
    :param node_labels: Agent pool node labels to be persisted across all
     nodes in agent pool.
    :type node_labels: dict[str, str]
    :param node_taints: Taints added to new nodes during node pool create and
     scale. For example, key=value:NoSchedule.
    :type node_taints: list[str]
    :param proximity_placement_group_id: The ID for Proximity Placement Group.
    :type proximity_placement_group_id: str
    :param kubelet_config: KubeletConfig specifies the configuration of
     kubelet on agent nodes.
    :type kubelet_config:
     ~azure.mgmt.containerservice.v2020_11_01.models.KubeletConfig
    :param linux_os_config: LinuxOSConfig specifies the OS configuration of
     linux agent nodes.
    :type linux_os_config:
     ~azure.mgmt.containerservice.v2020_11_01.models.LinuxOSConfig
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'node_image_version': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'power_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'count': {'key': 'properties.count', 'type': 'int'},
        'vm_size': {'key': 'properties.vmSize', 'type': 'str'},
        'os_disk_size_gb': {'key': 'properties.osDiskSizeGB', 'type': 'int'},
        'os_disk_type': {'key': 'properties.osDiskType', 'type': 'str'},
        'vnet_subnet_id': {'key': 'properties.vnetSubnetID', 'type': 'str'},
        'pod_subnet_id': {'key': 'properties.podSubnetID', 'type': 'str'},
        'max_pods': {'key': 'properties.maxPods', 'type': 'int'},
        'os_type': {'key': 'properties.osType', 'type': 'str'},
        'max_count': {'key': 'properties.maxCount', 'type': 'int'},
        'min_count': {'key': 'properties.minCount', 'type': 'int'},
        'enable_auto_scaling': {'key': 'properties.enableAutoScaling', 'type': 'bool'},
        'agent_pool_type': {'key': 'properties.type', 'type': 'str'},
        'mode': {'key': 'properties.mode', 'type': 'str'},
        'orchestrator_version': {'key': 'properties.orchestratorVersion', 'type': 'str'},
        'node_image_version': {'key': 'properties.nodeImageVersion', 'type': 'str'},
        'upgrade_settings': {'key': 'properties.upgradeSettings', 'type': 'AgentPoolUpgradeSettings'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'power_state': {'key': 'properties.powerState', 'type': 'PowerState'},
        'availability_zones': {'key': 'properties.availabilityZones', 'type': '[str]'},
        'enable_node_public_ip': {'key': 'properties.enableNodePublicIP', 'type': 'bool'},
        'scale_set_priority': {'key': 'properties.scaleSetPriority', 'type': 'str'},
        'scale_set_eviction_policy': {'key': 'properties.scaleSetEvictionPolicy', 'type': 'str'},
        'spot_max_price': {'key': 'properties.spotMaxPrice', 'type': 'float'},
        'tags': {'key': 'properties.tags', 'type': '{str}'},
        'node_labels': {'key': 'properties.nodeLabels', 'type': '{str}'},
        'node_taints': {'key': 'properties.nodeTaints', 'type': '[str]'},
        'proximity_placement_group_id': {'key': 'properties.proximityPlacementGroupID', 'type': 'str'},
        'kubelet_config': {'key': 'properties.kubeletConfig', 'type': 'KubeletConfig'},
        'linux_os_config': {'key': 'properties.linuxOSConfig', 'type': 'LinuxOSConfig'},
    }

    def __init__(self, *, count: int=None, vm_size=None, os_disk_size_gb: int=None, os_disk_type=None, vnet_subnet_id: str=None, pod_subnet_id: str=None, max_pods: int=None, os_type="Linux", max_count: int=None, min_count: int=None, enable_auto_scaling: bool=None, agent_pool_type=None, mode=None, orchestrator_version: str=None, upgrade_settings=None, availability_zones=None, enable_node_public_ip: bool=None, scale_set_priority="Regular", scale_set_eviction_policy="Delete", spot_max_price: float=None, tags=None, node_labels=None, node_taints=None, proximity_placement_group_id: str=None, kubelet_config=None, linux_os_config=None, **kwargs) -> None:
        super(AgentPool, self).__init__(**kwargs)
        self.count = count
        self.vm_size = vm_size
        self.os_disk_size_gb = os_disk_size_gb
        self.os_disk_type = os_disk_type
        self.vnet_subnet_id = vnet_subnet_id
        self.pod_subnet_id = pod_subnet_id
        self.max_pods = max_pods
        self.os_type = os_type
        self.max_count = max_count
        self.min_count = min_count
        self.enable_auto_scaling = enable_auto_scaling
        self.agent_pool_type = agent_pool_type
        self.mode = mode
        self.orchestrator_version = orchestrator_version
        self.node_image_version = None
        self.upgrade_settings = upgrade_settings
        self.provisioning_state = None
        self.power_state = None
        self.availability_zones = availability_zones
        self.enable_node_public_ip = enable_node_public_ip
        self.scale_set_priority = scale_set_priority
        self.scale_set_eviction_policy = scale_set_eviction_policy
        self.spot_max_price = spot_max_price
        self.tags = tags
        self.node_labels = node_labels
        self.node_taints = node_taints
        self.proximity_placement_group_id = proximity_placement_group_id
        self.kubelet_config = kubelet_config
        self.linux_os_config = linux_os_config


class AgentPoolAvailableVersions(Model):
    """The list of available versions for an agent pool.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Id of the agent pool available versions.
    :vartype id: str
    :ivar name: Name of the agent pool available versions.
    :vartype name: str
    :ivar type: Type of the agent pool  available versions.
    :vartype type: str
    :param agent_pool_versions: List of versions available for agent pool.
    :type agent_pool_versions:
     list[~azure.mgmt.containerservice.v2020_11_01.models.AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'agent_pool_versions': {'key': 'properties.agentPoolVersions', 'type': '[AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem]'},
    }

    def __init__(self, *, agent_pool_versions=None, **kwargs) -> None:
        super(AgentPoolAvailableVersions, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.agent_pool_versions = agent_pool_versions


class AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem(Model):
    """AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem.

    :param default: Whether this version is the default agent pool version.
    :type default: bool
    :param kubernetes_version: Kubernetes version (major, minor, patch).
    :type kubernetes_version: str
    :param is_preview: Whether Kubernetes version is currently in preview.
    :type is_preview: bool
    """

    _attribute_map = {
        'default': {'key': 'default', 'type': 'bool'},
        'kubernetes_version': {'key': 'kubernetesVersion', 'type': 'str'},
        'is_preview': {'key': 'isPreview', 'type': 'bool'},
    }

    def __init__(self, *, default: bool=None, kubernetes_version: str=None, is_preview: bool=None, **kwargs) -> None:
        super(AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem, self).__init__(**kwargs)
        self.default = default
        self.kubernetes_version = kubernetes_version
        self.is_preview = is_preview


class AgentPoolUpgradeProfile(Model):
    """The list of available upgrades for an agent pool.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Id of the agent pool upgrade profile.
    :vartype id: str
    :ivar name: Name of the agent pool upgrade profile.
    :vartype name: str
    :ivar type: Type of the agent pool upgrade profile.
    :vartype type: str
    :param kubernetes_version: Required. Kubernetes version (major, minor,
     patch).
    :type kubernetes_version: str
    :param os_type: Required. OsType to be used to specify os type. Choose
     from Linux and Windows. Default to Linux. Possible values include:
     'Linux', 'Windows'. Default value: "Linux" .
    :type os_type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.OSType
    :param upgrades: List of orchestrator types and versions available for
     upgrade.
    :type upgrades:
     list[~azure.mgmt.containerservice.v2020_11_01.models.AgentPoolUpgradeProfilePropertiesUpgradesItem]
    :param latest_node_image_version: LatestNodeImageVersion is the latest AKS
     supported node image version.
    :type latest_node_image_version: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'kubernetes_version': {'required': True},
        'os_type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'kubernetes_version': {'key': 'properties.kubernetesVersion', 'type': 'str'},
        'os_type': {'key': 'properties.osType', 'type': 'str'},
        'upgrades': {'key': 'properties.upgrades', 'type': '[AgentPoolUpgradeProfilePropertiesUpgradesItem]'},
        'latest_node_image_version': {'key': 'properties.latestNodeImageVersion', 'type': 'str'},
    }

    def __init__(self, *, kubernetes_version: str, os_type="Linux", upgrades=None, latest_node_image_version: str=None, **kwargs) -> None:
        super(AgentPoolUpgradeProfile, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.kubernetes_version = kubernetes_version
        self.os_type = os_type
        self.upgrades = upgrades
        self.latest_node_image_version = latest_node_image_version


class AgentPoolUpgradeProfilePropertiesUpgradesItem(Model):
    """AgentPoolUpgradeProfilePropertiesUpgradesItem.

    :param kubernetes_version: Kubernetes version (major, minor, patch).
    :type kubernetes_version: str
    :param is_preview: Whether Kubernetes version is currently in preview.
    :type is_preview: bool
    """

    _attribute_map = {
        'kubernetes_version': {'key': 'kubernetesVersion', 'type': 'str'},
        'is_preview': {'key': 'isPreview', 'type': 'bool'},
    }

    def __init__(self, *, kubernetes_version: str=None, is_preview: bool=None, **kwargs) -> None:
        super(AgentPoolUpgradeProfilePropertiesUpgradesItem, self).__init__(**kwargs)
        self.kubernetes_version = kubernetes_version
        self.is_preview = is_preview


class AgentPoolUpgradeSettings(Model):
    """Settings for upgrading an agentpool.

    :param max_surge: Count or percentage of additional nodes to be added
     during upgrade. If empty uses AKS default
    :type max_surge: str
    """

    _attribute_map = {
        'max_surge': {'key': 'maxSurge', 'type': 'str'},
    }

    def __init__(self, *, max_surge: str=None, **kwargs) -> None:
        super(AgentPoolUpgradeSettings, self).__init__(**kwargs)
        self.max_surge = max_surge


class CloudError(Model):
    """An error response from the Container service.

    :param error: Details about the error.
    :type error:
     ~azure.mgmt.containerservice.v2020_11_01.models.CloudErrorBody
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'CloudErrorBody'},
    }

    def __init__(self, *, error=None, **kwargs) -> None:
        super(CloudError, self).__init__(**kwargs)
        self.error = error


class CloudErrorException(HttpOperationError):
    """Server responsed with exception of type: 'CloudError'.

    :param deserialize: A deserializer
    :param response: Server response to be deserialized.
    """

    def __init__(self, deserialize, response, *args):

        super(CloudErrorException, self).__init__(deserialize, response, 'CloudError', *args)


class CloudErrorBody(Model):
    """An error response from the Container service.

    :param code: An identifier for the error. Codes are invariant and are
     intended to be consumed programmatically.
    :type code: str
    :param message: A message describing the error, intended to be suitable
     for display in a user interface.
    :type message: str
    :param target: The target of the particular error. For example, the name
     of the property in error.
    :type target: str
    :param details: A list of additional details about the error.
    :type details:
     list[~azure.mgmt.containerservice.v2020_11_01.models.CloudErrorBody]
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[CloudErrorBody]'},
    }

    def __init__(self, *, code: str=None, message: str=None, target: str=None, details=None, **kwargs) -> None:
        super(CloudErrorBody, self).__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details


class ContainerServiceDiagnosticsProfile(Model):
    """Profile for diagnostics on the container service cluster.

    All required parameters must be populated in order to send to Azure.

    :param vm_diagnostics: Required. Profile for diagnostics on the container
     service VMs.
    :type vm_diagnostics:
     ~azure.mgmt.containerservice.v2020_11_01.models.ContainerServiceVMDiagnostics
    """

    _validation = {
        'vm_diagnostics': {'required': True},
    }

    _attribute_map = {
        'vm_diagnostics': {'key': 'vmDiagnostics', 'type': 'ContainerServiceVMDiagnostics'},
    }

    def __init__(self, *, vm_diagnostics, **kwargs) -> None:
        super(ContainerServiceDiagnosticsProfile, self).__init__(**kwargs)
        self.vm_diagnostics = vm_diagnostics


class ContainerServiceLinuxProfile(Model):
    """Profile for Linux VMs in the container service cluster.

    All required parameters must be populated in order to send to Azure.

    :param admin_username: Required. The administrator username to use for
     Linux VMs.
    :type admin_username: str
    :param ssh: Required. SSH configuration for Linux-based VMs running on
     Azure.
    :type ssh:
     ~azure.mgmt.containerservice.v2020_11_01.models.ContainerServiceSshConfiguration
    """

    _validation = {
        'admin_username': {'required': True, 'pattern': r'^[A-Za-z][-A-Za-z0-9_]*$'},
        'ssh': {'required': True},
    }

    _attribute_map = {
        'admin_username': {'key': 'adminUsername', 'type': 'str'},
        'ssh': {'key': 'ssh', 'type': 'ContainerServiceSshConfiguration'},
    }

    def __init__(self, *, admin_username: str, ssh, **kwargs) -> None:
        super(ContainerServiceLinuxProfile, self).__init__(**kwargs)
        self.admin_username = admin_username
        self.ssh = ssh


class ContainerServiceMasterProfile(Model):
    """Profile for the container service master.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param count: Number of masters (VMs) in the container service cluster.
     Allowed values are 1, 3, and 5. The default value is 1. Default value: 1 .
    :type count: int
    :param dns_prefix: Required. DNS prefix to be used to create the FQDN for
     the master pool.
    :type dns_prefix: str
    :param vm_size: Required. Size of agent VMs. Possible values include:
     'Standard_A1', 'Standard_A10', 'Standard_A11', 'Standard_A1_v2',
     'Standard_A2', 'Standard_A2_v2', 'Standard_A2m_v2', 'Standard_A3',
     'Standard_A4', 'Standard_A4_v2', 'Standard_A4m_v2', 'Standard_A5',
     'Standard_A6', 'Standard_A7', 'Standard_A8', 'Standard_A8_v2',
     'Standard_A8m_v2', 'Standard_A9', 'Standard_B2ms', 'Standard_B2s',
     'Standard_B4ms', 'Standard_B8ms', 'Standard_D1', 'Standard_D11',
     'Standard_D11_v2', 'Standard_D11_v2_Promo', 'Standard_D12',
     'Standard_D12_v2', 'Standard_D12_v2_Promo', 'Standard_D13',
     'Standard_D13_v2', 'Standard_D13_v2_Promo', 'Standard_D14',
     'Standard_D14_v2', 'Standard_D14_v2_Promo', 'Standard_D15_v2',
     'Standard_D16_v3', 'Standard_D16s_v3', 'Standard_D1_v2', 'Standard_D2',
     'Standard_D2_v2', 'Standard_D2_v2_Promo', 'Standard_D2_v3',
     'Standard_D2s_v3', 'Standard_D3', 'Standard_D32_v3', 'Standard_D32s_v3',
     'Standard_D3_v2', 'Standard_D3_v2_Promo', 'Standard_D4', 'Standard_D4_v2',
     'Standard_D4_v2_Promo', 'Standard_D4_v3', 'Standard_D4s_v3',
     'Standard_D5_v2', 'Standard_D5_v2_Promo', 'Standard_D64_v3',
     'Standard_D64s_v3', 'Standard_D8_v3', 'Standard_D8s_v3', 'Standard_DS1',
     'Standard_DS11', 'Standard_DS11_v2', 'Standard_DS11_v2_Promo',
     'Standard_DS12', 'Standard_DS12_v2', 'Standard_DS12_v2_Promo',
     'Standard_DS13', 'Standard_DS13-2_v2', 'Standard_DS13-4_v2',
     'Standard_DS13_v2', 'Standard_DS13_v2_Promo', 'Standard_DS14',
     'Standard_DS14-4_v2', 'Standard_DS14-8_v2', 'Standard_DS14_v2',
     'Standard_DS14_v2_Promo', 'Standard_DS15_v2', 'Standard_DS1_v2',
     'Standard_DS2', 'Standard_DS2_v2', 'Standard_DS2_v2_Promo',
     'Standard_DS3', 'Standard_DS3_v2', 'Standard_DS3_v2_Promo',
     'Standard_DS4', 'Standard_DS4_v2', 'Standard_DS4_v2_Promo',
     'Standard_DS5_v2', 'Standard_DS5_v2_Promo', 'Standard_E16_v3',
     'Standard_E16s_v3', 'Standard_E2_v3', 'Standard_E2s_v3',
     'Standard_E32-16s_v3', 'Standard_E32-8s_v3', 'Standard_E32_v3',
     'Standard_E32s_v3', 'Standard_E4_v3', 'Standard_E4s_v3',
     'Standard_E64-16s_v3', 'Standard_E64-32s_v3', 'Standard_E64_v3',
     'Standard_E64s_v3', 'Standard_E8_v3', 'Standard_E8s_v3', 'Standard_F1',
     'Standard_F16', 'Standard_F16s', 'Standard_F16s_v2', 'Standard_F1s',
     'Standard_F2', 'Standard_F2s', 'Standard_F2s_v2', 'Standard_F32s_v2',
     'Standard_F4', 'Standard_F4s', 'Standard_F4s_v2', 'Standard_F64s_v2',
     'Standard_F72s_v2', 'Standard_F8', 'Standard_F8s', 'Standard_F8s_v2',
     'Standard_G1', 'Standard_G2', 'Standard_G3', 'Standard_G4', 'Standard_G5',
     'Standard_GS1', 'Standard_GS2', 'Standard_GS3', 'Standard_GS4',
     'Standard_GS4-4', 'Standard_GS4-8', 'Standard_GS5', 'Standard_GS5-16',
     'Standard_GS5-8', 'Standard_H16', 'Standard_H16m', 'Standard_H16mr',
     'Standard_H16r', 'Standard_H8', 'Standard_H8m', 'Standard_L16s',
     'Standard_L32s', 'Standard_L4s', 'Standard_L8s', 'Standard_M128-32ms',
     'Standard_M128-64ms', 'Standard_M128ms', 'Standard_M128s',
     'Standard_M64-16ms', 'Standard_M64-32ms', 'Standard_M64ms',
     'Standard_M64s', 'Standard_NC12', 'Standard_NC12s_v2',
     'Standard_NC12s_v3', 'Standard_NC24', 'Standard_NC24r',
     'Standard_NC24rs_v2', 'Standard_NC24rs_v3', 'Standard_NC24s_v2',
     'Standard_NC24s_v3', 'Standard_NC6', 'Standard_NC6s_v2',
     'Standard_NC6s_v3', 'Standard_ND12s', 'Standard_ND24rs', 'Standard_ND24s',
     'Standard_ND6s', 'Standard_NV12', 'Standard_NV24', 'Standard_NV6'
    :type vm_size: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ContainerServiceVMSizeTypes
    :param os_disk_size_gb: OS Disk Size in GB to be used to specify the disk
     size for every machine in this master/agent pool. If you specify 0, it
     will apply the default osDisk size according to the vmSize specified.
    :type os_disk_size_gb: int
    :param vnet_subnet_id: VNet SubnetID specifies the VNet's subnet
     identifier.
    :type vnet_subnet_id: str
    :param first_consecutive_static_ip: FirstConsecutiveStaticIP used to
     specify the first static ip of masters. Default value: "10.240.255.5" .
    :type first_consecutive_static_ip: str
    :param storage_profile: Storage profile specifies what kind of storage
     used. Choose from StorageAccount and ManagedDisks. Leave it empty, we will
     choose for you based on the orchestrator choice. Possible values include:
     'StorageAccount', 'ManagedDisks'
    :type storage_profile: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ContainerServiceStorageProfileTypes
    :ivar fqdn: FQDN for the master pool.
    :vartype fqdn: str
    """

    _validation = {
        'dns_prefix': {'required': True},
        'vm_size': {'required': True},
        'fqdn': {'readonly': True},
    }

    _attribute_map = {
        'count': {'key': 'count', 'type': 'int'},
        'dns_prefix': {'key': 'dnsPrefix', 'type': 'str'},
        'vm_size': {'key': 'vmSize', 'type': 'str'},
        'os_disk_size_gb': {'key': 'osDiskSizeGB', 'type': 'int'},
        'vnet_subnet_id': {'key': 'vnetSubnetID', 'type': 'str'},
        'first_consecutive_static_ip': {'key': 'firstConsecutiveStaticIP', 'type': 'str'},
        'storage_profile': {'key': 'storageProfile', 'type': 'str'},
        'fqdn': {'key': 'fqdn', 'type': 'str'},
    }

    def __init__(self, *, dns_prefix: str, vm_size, count: int=1, os_disk_size_gb: int=None, vnet_subnet_id: str=None, first_consecutive_static_ip: str="10.240.255.5", storage_profile=None, **kwargs) -> None:
        super(ContainerServiceMasterProfile, self).__init__(**kwargs)
        self.count = count
        self.dns_prefix = dns_prefix
        self.vm_size = vm_size
        self.os_disk_size_gb = os_disk_size_gb
        self.vnet_subnet_id = vnet_subnet_id
        self.first_consecutive_static_ip = first_consecutive_static_ip
        self.storage_profile = storage_profile
        self.fqdn = None


class ContainerServiceNetworkProfile(Model):
    """Profile of network configuration.

    :param network_plugin: Network plugin used for building Kubernetes
     network. Possible values include: 'azure', 'kubenet'. Default value:
     "kubenet" .
    :type network_plugin: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.NetworkPlugin
    :param network_policy: Network policy used for building Kubernetes
     network. Possible values include: 'calico', 'azure'
    :type network_policy: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.NetworkPolicy
    :param network_mode: Network mode used for building Kubernetes network.
     Possible values include: 'transparent', 'bridge'
    :type network_mode: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.NetworkMode
    :param pod_cidr: A CIDR notation IP range from which to assign pod IPs
     when kubenet is used. Default value: "10.244.0.0/16" .
    :type pod_cidr: str
    :param service_cidr: A CIDR notation IP range from which to assign service
     cluster IPs. It must not overlap with any Subnet IP ranges. Default value:
     "10.0.0.0/16" .
    :type service_cidr: str
    :param dns_service_ip: An IP address assigned to the Kubernetes DNS
     service. It must be within the Kubernetes service address range specified
     in serviceCidr. Default value: "10.0.0.10" .
    :type dns_service_ip: str
    :param docker_bridge_cidr: A CIDR notation IP range assigned to the Docker
     bridge network. It must not overlap with any Subnet IP ranges or the
     Kubernetes service address range. Default value: "172.17.0.1/16" .
    :type docker_bridge_cidr: str
    :param outbound_type: The outbound (egress) routing method. Possible
     values include: 'loadBalancer', 'userDefinedRouting'. Default value:
     "loadBalancer" .
    :type outbound_type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.OutboundType
    :param load_balancer_sku: The load balancer sku for the managed cluster.
     Possible values include: 'standard', 'basic'
    :type load_balancer_sku: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.LoadBalancerSku
    :param load_balancer_profile: Profile of the cluster load balancer.
    :type load_balancer_profile:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterLoadBalancerProfile
    """

    _validation = {
        'pod_cidr': {'pattern': r'^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$'},
        'service_cidr': {'pattern': r'^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$'},
        'dns_service_ip': {'pattern': r'^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'},
        'docker_bridge_cidr': {'pattern': r'^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$'},
    }

    _attribute_map = {
        'network_plugin': {'key': 'networkPlugin', 'type': 'str'},
        'network_policy': {'key': 'networkPolicy', 'type': 'str'},
        'network_mode': {'key': 'networkMode', 'type': 'str'},
        'pod_cidr': {'key': 'podCidr', 'type': 'str'},
        'service_cidr': {'key': 'serviceCidr', 'type': 'str'},
        'dns_service_ip': {'key': 'dnsServiceIP', 'type': 'str'},
        'docker_bridge_cidr': {'key': 'dockerBridgeCidr', 'type': 'str'},
        'outbound_type': {'key': 'outboundType', 'type': 'str'},
        'load_balancer_sku': {'key': 'loadBalancerSku', 'type': 'str'},
        'load_balancer_profile': {'key': 'loadBalancerProfile', 'type': 'ManagedClusterLoadBalancerProfile'},
    }

    def __init__(self, *, network_plugin="kubenet", network_policy=None, network_mode=None, pod_cidr: str="10.244.0.0/16", service_cidr: str="10.0.0.0/16", dns_service_ip: str="10.0.0.10", docker_bridge_cidr: str="172.17.0.1/16", outbound_type="loadBalancer", load_balancer_sku=None, load_balancer_profile=None, **kwargs) -> None:
        super(ContainerServiceNetworkProfile, self).__init__(**kwargs)
        self.network_plugin = network_plugin
        self.network_policy = network_policy
        self.network_mode = network_mode
        self.pod_cidr = pod_cidr
        self.service_cidr = service_cidr
        self.dns_service_ip = dns_service_ip
        self.docker_bridge_cidr = docker_bridge_cidr
        self.outbound_type = outbound_type
        self.load_balancer_sku = load_balancer_sku
        self.load_balancer_profile = load_balancer_profile


class ContainerServiceSshConfiguration(Model):
    """SSH configuration for Linux-based VMs running on Azure.

    All required parameters must be populated in order to send to Azure.

    :param public_keys: Required. The list of SSH public keys used to
     authenticate with Linux-based VMs. Only expect one key specified.
    :type public_keys:
     list[~azure.mgmt.containerservice.v2020_11_01.models.ContainerServiceSshPublicKey]
    """

    _validation = {
        'public_keys': {'required': True},
    }

    _attribute_map = {
        'public_keys': {'key': 'publicKeys', 'type': '[ContainerServiceSshPublicKey]'},
    }

    def __init__(self, *, public_keys, **kwargs) -> None:
        super(ContainerServiceSshConfiguration, self).__init__(**kwargs)
        self.public_keys = public_keys


class ContainerServiceSshPublicKey(Model):
    """Contains information about SSH certificate public key data.

    All required parameters must be populated in order to send to Azure.

    :param key_data: Required. Certificate public key used to authenticate
     with VMs through SSH. The certificate must be in PEM format with or
     without headers.
    :type key_data: str
    """

    _validation = {
        'key_data': {'required': True},
    }

    _attribute_map = {
        'key_data': {'key': 'keyData', 'type': 'str'},
    }

    def __init__(self, *, key_data: str, **kwargs) -> None:
        super(ContainerServiceSshPublicKey, self).__init__(**kwargs)
        self.key_data = key_data


class ContainerServiceVMDiagnostics(Model):
    """Profile for diagnostics on the container service VMs.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param enabled: Required. Whether the VM diagnostic agent is provisioned
     on the VM.
    :type enabled: bool
    :ivar storage_uri: The URI of the storage account where diagnostics are
     stored.
    :vartype storage_uri: str
    """

    _validation = {
        'enabled': {'required': True},
        'storage_uri': {'readonly': True},
    }

    _attribute_map = {
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'storage_uri': {'key': 'storageUri', 'type': 'str'},
    }

    def __init__(self, *, enabled: bool, **kwargs) -> None:
        super(ContainerServiceVMDiagnostics, self).__init__(**kwargs)
        self.enabled = enabled
        self.storage_uri = None


class CredentialResult(Model):
    """The credential result response.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar name: The name of the credential.
    :vartype name: str
    :ivar value: Base64-encoded Kubernetes configuration file.
    :vartype value: bytearray
    """

    _validation = {
        'name': {'readonly': True},
        'value': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'bytearray'},
    }

    def __init__(self, **kwargs) -> None:
        super(CredentialResult, self).__init__(**kwargs)
        self.name = None
        self.value = None


class CredentialResults(Model):
    """The list of credential result response.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar kubeconfigs: Base64-encoded Kubernetes configuration file.
    :vartype kubeconfigs:
     list[~azure.mgmt.containerservice.v2020_11_01.models.CredentialResult]
    """

    _validation = {
        'kubeconfigs': {'readonly': True},
    }

    _attribute_map = {
        'kubeconfigs': {'key': 'kubeconfigs', 'type': '[CredentialResult]'},
    }

    def __init__(self, **kwargs) -> None:
        super(CredentialResults, self).__init__(**kwargs)
        self.kubeconfigs = None


class KubeletConfig(Model):
    """Kubelet configurations of agent nodes.

    :param cpu_manager_policy: CPU Manager policy to use.
    :type cpu_manager_policy: str
    :param cpu_cfs_quota: Enable CPU CFS quota enforcement for containers that
     specify CPU limits.
    :type cpu_cfs_quota: bool
    :param cpu_cfs_quota_period: Sets CPU CFS quota period value.
    :type cpu_cfs_quota_period: str
    :param image_gc_high_threshold: The percent of disk usage after which
     image garbage collection is always run.
    :type image_gc_high_threshold: int
    :param image_gc_low_threshold: The percent of disk usage before which
     image garbage collection is never run.
    :type image_gc_low_threshold: int
    :param topology_manager_policy: Topology Manager policy to use.
    :type topology_manager_policy: str
    :param allowed_unsafe_sysctls: Allowlist of unsafe sysctls or unsafe
     sysctl patterns (ending in `*`).
    :type allowed_unsafe_sysctls: list[str]
    :param fail_swap_on: If set to true it will make the Kubelet fail to start
     if swap is enabled on the node.
    :type fail_swap_on: bool
    """

    _attribute_map = {
        'cpu_manager_policy': {'key': 'cpuManagerPolicy', 'type': 'str'},
        'cpu_cfs_quota': {'key': 'cpuCfsQuota', 'type': 'bool'},
        'cpu_cfs_quota_period': {'key': 'cpuCfsQuotaPeriod', 'type': 'str'},
        'image_gc_high_threshold': {'key': 'imageGcHighThreshold', 'type': 'int'},
        'image_gc_low_threshold': {'key': 'imageGcLowThreshold', 'type': 'int'},
        'topology_manager_policy': {'key': 'topologyManagerPolicy', 'type': 'str'},
        'allowed_unsafe_sysctls': {'key': 'allowedUnsafeSysctls', 'type': '[str]'},
        'fail_swap_on': {'key': 'failSwapOn', 'type': 'bool'},
    }

    def __init__(self, *, cpu_manager_policy: str=None, cpu_cfs_quota: bool=None, cpu_cfs_quota_period: str=None, image_gc_high_threshold: int=None, image_gc_low_threshold: int=None, topology_manager_policy: str=None, allowed_unsafe_sysctls=None, fail_swap_on: bool=None, **kwargs) -> None:
        super(KubeletConfig, self).__init__(**kwargs)
        self.cpu_manager_policy = cpu_manager_policy
        self.cpu_cfs_quota = cpu_cfs_quota
        self.cpu_cfs_quota_period = cpu_cfs_quota_period
        self.image_gc_high_threshold = image_gc_high_threshold
        self.image_gc_low_threshold = image_gc_low_threshold
        self.topology_manager_policy = topology_manager_policy
        self.allowed_unsafe_sysctls = allowed_unsafe_sysctls
        self.fail_swap_on = fail_swap_on


class LinuxOSConfig(Model):
    """OS configurations of Linux agent nodes.

    :param sysctls: Sysctl settings for Linux agent nodes.
    :type sysctls:
     ~azure.mgmt.containerservice.v2020_11_01.models.SysctlConfig
    :param transparent_huge_page_enabled: Transparent Huge Page enabled
     configuration.
    :type transparent_huge_page_enabled: str
    :param transparent_huge_page_defrag: Transparent Huge Page defrag
     configuration.
    :type transparent_huge_page_defrag: str
    :param swap_file_size_mb: SwapFileSizeMB specifies size in MB of a swap
     file will be created on each node.
    :type swap_file_size_mb: int
    """

    _attribute_map = {
        'sysctls': {'key': 'sysctls', 'type': 'SysctlConfig'},
        'transparent_huge_page_enabled': {'key': 'transparentHugePageEnabled', 'type': 'str'},
        'transparent_huge_page_defrag': {'key': 'transparentHugePageDefrag', 'type': 'str'},
        'swap_file_size_mb': {'key': 'swapFileSizeMB', 'type': 'int'},
    }

    def __init__(self, *, sysctls=None, transparent_huge_page_enabled: str=None, transparent_huge_page_defrag: str=None, swap_file_size_mb: int=None, **kwargs) -> None:
        super(LinuxOSConfig, self).__init__(**kwargs)
        self.sysctls = sysctls
        self.transparent_huge_page_enabled = transparent_huge_page_enabled
        self.transparent_huge_page_defrag = transparent_huge_page_defrag
        self.swap_file_size_mb = swap_file_size_mb


class Resource(Model):
    """The Resource model definition.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Resource Id
    :vartype id: str
    :ivar name: Resource name
    :vartype name: str
    :ivar type: Resource type
    :vartype type: str
    :param location: Required. Resource location
    :type location: str
    :param tags: Resource tags
    :type tags: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, *, location: str, tags=None, **kwargs) -> None:
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = location
        self.tags = tags


class ManagedCluster(Resource):
    """Managed cluster.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Resource Id
    :vartype id: str
    :ivar name: Resource name
    :vartype name: str
    :ivar type: Resource type
    :vartype type: str
    :param location: Required. Resource location
    :type location: str
    :param tags: Resource tags
    :type tags: dict[str, str]
    :ivar provisioning_state: The current deployment or provisioning state,
     which only appears in the response.
    :vartype provisioning_state: str
    :ivar power_state: Represents the Power State of the cluster
    :vartype power_state:
     ~azure.mgmt.containerservice.v2020_11_01.models.PowerState
    :ivar max_agent_pools: The max number of agent pools for the managed
     cluster.
    :vartype max_agent_pools: int
    :param kubernetes_version: Version of Kubernetes specified when creating
     the managed cluster.
    :type kubernetes_version: str
    :param dns_prefix: DNS prefix specified when creating the managed cluster.
    :type dns_prefix: str
    :ivar fqdn: FQDN for the master pool.
    :vartype fqdn: str
    :ivar private_fqdn: FQDN of private cluster.
    :vartype private_fqdn: str
    :param agent_pool_profiles: Properties of the agent pool.
    :type agent_pool_profiles:
     list[~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterAgentPoolProfile]
    :param linux_profile: Profile for Linux VMs in the container service
     cluster.
    :type linux_profile:
     ~azure.mgmt.containerservice.v2020_11_01.models.ContainerServiceLinuxProfile
    :param windows_profile: Profile for Windows VMs in the container service
     cluster.
    :type windows_profile:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterWindowsProfile
    :param service_principal_profile: Information about a service principal
     identity for the cluster to use for manipulating Azure APIs.
    :type service_principal_profile:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterServicePrincipalProfile
    :param addon_profiles: Profile of managed cluster add-on.
    :type addon_profiles: dict[str,
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterAddonProfile]
    :param pod_identity_profile: Profile of managed cluster pod identity.
    :type pod_identity_profile:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterPodIdentityProfile
    :param node_resource_group: Name of the resource group containing agent
     pool nodes.
    :type node_resource_group: str
    :param enable_rbac: Whether to enable Kubernetes Role-Based Access
     Control.
    :type enable_rbac: bool
    :param enable_pod_security_policy: (DEPRECATING) Whether to enable
     Kubernetes pod security policy (preview). This feature is set for removal
     on October 15th, 2020. Learn more at aka.ms/aks/azpodpolicy.
    :type enable_pod_security_policy: bool
    :param network_profile: Profile of network configuration.
    :type network_profile:
     ~azure.mgmt.containerservice.v2020_11_01.models.ContainerServiceNetworkProfile
    :param aad_profile: Profile of Azure Active Directory configuration.
    :type aad_profile:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterAADProfile
    :param auto_upgrade_profile: Profile of auto upgrade configuration.
    :type auto_upgrade_profile:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterAutoUpgradeProfile
    :param auto_scaler_profile: Parameters to be applied to the
     cluster-autoscaler when enabled
    :type auto_scaler_profile:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterPropertiesAutoScalerProfile
    :param api_server_access_profile: Access profile for managed cluster API
     server.
    :type api_server_access_profile:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterAPIServerAccessProfile
    :param disk_encryption_set_id: ResourceId of the disk encryption set to
     use for enabling encryption at rest.
    :type disk_encryption_set_id: str
    :param identity_profile: Identities associated with the cluster.
    :type identity_profile: dict[str,
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterPropertiesIdentityProfileValue]
    :param identity: The identity of the managed cluster, if configured.
    :type identity:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterIdentity
    :param sku: The managed cluster SKU.
    :type sku:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterSKU
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'provisioning_state': {'readonly': True},
        'power_state': {'readonly': True},
        'max_agent_pools': {'readonly': True},
        'fqdn': {'readonly': True},
        'private_fqdn': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'power_state': {'key': 'properties.powerState', 'type': 'PowerState'},
        'max_agent_pools': {'key': 'properties.maxAgentPools', 'type': 'int'},
        'kubernetes_version': {'key': 'properties.kubernetesVersion', 'type': 'str'},
        'dns_prefix': {'key': 'properties.dnsPrefix', 'type': 'str'},
        'fqdn': {'key': 'properties.fqdn', 'type': 'str'},
        'private_fqdn': {'key': 'properties.privateFQDN', 'type': 'str'},
        'agent_pool_profiles': {'key': 'properties.agentPoolProfiles', 'type': '[ManagedClusterAgentPoolProfile]'},
        'linux_profile': {'key': 'properties.linuxProfile', 'type': 'ContainerServiceLinuxProfile'},
        'windows_profile': {'key': 'properties.windowsProfile', 'type': 'ManagedClusterWindowsProfile'},
        'service_principal_profile': {'key': 'properties.servicePrincipalProfile', 'type': 'ManagedClusterServicePrincipalProfile'},
        'addon_profiles': {'key': 'properties.addonProfiles', 'type': '{ManagedClusterAddonProfile}'},
        'pod_identity_profile': {'key': 'properties.podIdentityProfile', 'type': 'ManagedClusterPodIdentityProfile'},
        'node_resource_group': {'key': 'properties.nodeResourceGroup', 'type': 'str'},
        'enable_rbac': {'key': 'properties.enableRBAC', 'type': 'bool'},
        'enable_pod_security_policy': {'key': 'properties.enablePodSecurityPolicy', 'type': 'bool'},
        'network_profile': {'key': 'properties.networkProfile', 'type': 'ContainerServiceNetworkProfile'},
        'aad_profile': {'key': 'properties.aadProfile', 'type': 'ManagedClusterAADProfile'},
        'auto_upgrade_profile': {'key': 'properties.autoUpgradeProfile', 'type': 'ManagedClusterAutoUpgradeProfile'},
        'auto_scaler_profile': {'key': 'properties.autoScalerProfile', 'type': 'ManagedClusterPropertiesAutoScalerProfile'},
        'api_server_access_profile': {'key': 'properties.apiServerAccessProfile', 'type': 'ManagedClusterAPIServerAccessProfile'},
        'disk_encryption_set_id': {'key': 'properties.diskEncryptionSetID', 'type': 'str'},
        'identity_profile': {'key': 'properties.identityProfile', 'type': '{ManagedClusterPropertiesIdentityProfileValue}'},
        'identity': {'key': 'identity', 'type': 'ManagedClusterIdentity'},
        'sku': {'key': 'sku', 'type': 'ManagedClusterSKU'},
    }

    def __init__(self, *, location: str, tags=None, kubernetes_version: str=None, dns_prefix: str=None, agent_pool_profiles=None, linux_profile=None, windows_profile=None, service_principal_profile=None, addon_profiles=None, pod_identity_profile=None, node_resource_group: str=None, enable_rbac: bool=None, enable_pod_security_policy: bool=None, network_profile=None, aad_profile=None, auto_upgrade_profile=None, auto_scaler_profile=None, api_server_access_profile=None, disk_encryption_set_id: str=None, identity_profile=None, identity=None, sku=None, **kwargs) -> None:
        super(ManagedCluster, self).__init__(location=location, tags=tags, **kwargs)
        self.provisioning_state = None
        self.power_state = None
        self.max_agent_pools = None
        self.kubernetes_version = kubernetes_version
        self.dns_prefix = dns_prefix
        self.fqdn = None
        self.private_fqdn = None
        self.agent_pool_profiles = agent_pool_profiles
        self.linux_profile = linux_profile
        self.windows_profile = windows_profile
        self.service_principal_profile = service_principal_profile
        self.addon_profiles = addon_profiles
        self.pod_identity_profile = pod_identity_profile
        self.node_resource_group = node_resource_group
        self.enable_rbac = enable_rbac
        self.enable_pod_security_policy = enable_pod_security_policy
        self.network_profile = network_profile
        self.aad_profile = aad_profile
        self.auto_upgrade_profile = auto_upgrade_profile
        self.auto_scaler_profile = auto_scaler_profile
        self.api_server_access_profile = api_server_access_profile
        self.disk_encryption_set_id = disk_encryption_set_id
        self.identity_profile = identity_profile
        self.identity = identity
        self.sku = sku


class ManagedClusterAADProfile(Model):
    """AADProfile specifies attributes for Azure Active Directory integration.

    :param managed: Whether to enable managed AAD.
    :type managed: bool
    :param enable_azure_rbac: Whether to enable Azure RBAC for Kubernetes
     authorization.
    :type enable_azure_rbac: bool
    :param admin_group_object_ids: AAD group object IDs that will have admin
     role of the cluster.
    :type admin_group_object_ids: list[str]
    :param client_app_id: The client AAD application ID.
    :type client_app_id: str
    :param server_app_id: The server AAD application ID.
    :type server_app_id: str
    :param server_app_secret: The server AAD application secret.
    :type server_app_secret: str
    :param tenant_id: The AAD tenant ID to use for authentication. If not
     specified, will use the tenant of the deployment subscription.
    :type tenant_id: str
    """

    _attribute_map = {
        'managed': {'key': 'managed', 'type': 'bool'},
        'enable_azure_rbac': {'key': 'enableAzureRBAC', 'type': 'bool'},
        'admin_group_object_ids': {'key': 'adminGroupObjectIDs', 'type': '[str]'},
        'client_app_id': {'key': 'clientAppID', 'type': 'str'},
        'server_app_id': {'key': 'serverAppID', 'type': 'str'},
        'server_app_secret': {'key': 'serverAppSecret', 'type': 'str'},
        'tenant_id': {'key': 'tenantID', 'type': 'str'},
    }

    def __init__(self, *, managed: bool=None, enable_azure_rbac: bool=None, admin_group_object_ids=None, client_app_id: str=None, server_app_id: str=None, server_app_secret: str=None, tenant_id: str=None, **kwargs) -> None:
        super(ManagedClusterAADProfile, self).__init__(**kwargs)
        self.managed = managed
        self.enable_azure_rbac = enable_azure_rbac
        self.admin_group_object_ids = admin_group_object_ids
        self.client_app_id = client_app_id
        self.server_app_id = server_app_id
        self.server_app_secret = server_app_secret
        self.tenant_id = tenant_id


class ManagedClusterAccessProfile(Resource):
    """Managed cluster Access Profile.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Resource Id
    :vartype id: str
    :ivar name: Resource name
    :vartype name: str
    :ivar type: Resource type
    :vartype type: str
    :param location: Required. Resource location
    :type location: str
    :param tags: Resource tags
    :type tags: dict[str, str]
    :param kube_config: Base64-encoded Kubernetes configuration file.
    :type kube_config: bytearray
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'kube_config': {'key': 'properties.kubeConfig', 'type': 'bytearray'},
    }

    def __init__(self, *, location: str, tags=None, kube_config: bytearray=None, **kwargs) -> None:
        super(ManagedClusterAccessProfile, self).__init__(location=location, tags=tags, **kwargs)
        self.kube_config = kube_config


class ManagedClusterAddonProfile(Model):
    """A Kubernetes add-on profile for a managed cluster.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param enabled: Required. Whether the add-on is enabled or not.
    :type enabled: bool
    :param config: Key-value pairs for configuring an add-on.
    :type config: dict[str, str]
    :ivar identity: Information of user assigned identity used by this add-on.
    :vartype identity:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterAddonProfileIdentity
    """

    _validation = {
        'enabled': {'required': True},
        'identity': {'readonly': True},
    }

    _attribute_map = {
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'config': {'key': 'config', 'type': '{str}'},
        'identity': {'key': 'identity', 'type': 'ManagedClusterAddonProfileIdentity'},
    }

    def __init__(self, *, enabled: bool, config=None, **kwargs) -> None:
        super(ManagedClusterAddonProfile, self).__init__(**kwargs)
        self.enabled = enabled
        self.config = config
        self.identity = None


class UserAssignedIdentity(Model):
    """UserAssignedIdentity.

    :param resource_id: The resource id of the user assigned identity.
    :type resource_id: str
    :param client_id: The client id of the user assigned identity.
    :type client_id: str
    :param object_id: The object id of the user assigned identity.
    :type object_id: str
    """

    _attribute_map = {
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
        'object_id': {'key': 'objectId', 'type': 'str'},
    }

    def __init__(self, *, resource_id: str=None, client_id: str=None, object_id: str=None, **kwargs) -> None:
        super(UserAssignedIdentity, self).__init__(**kwargs)
        self.resource_id = resource_id
        self.client_id = client_id
        self.object_id = object_id


class ManagedClusterAddonProfileIdentity(UserAssignedIdentity):
    """Information of user assigned identity used by this add-on.

    :param resource_id: The resource id of the user assigned identity.
    :type resource_id: str
    :param client_id: The client id of the user assigned identity.
    :type client_id: str
    :param object_id: The object id of the user assigned identity.
    :type object_id: str
    """

    _attribute_map = {
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
        'object_id': {'key': 'objectId', 'type': 'str'},
    }

    def __init__(self, *, resource_id: str=None, client_id: str=None, object_id: str=None, **kwargs) -> None:
        super(ManagedClusterAddonProfileIdentity, self).__init__(resource_id=resource_id, client_id=client_id, object_id=object_id, **kwargs)


class ManagedClusterAgentPoolProfileProperties(Model):
    """Properties for the container service agent pool profile.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :param count: Number of agents (VMs) to host docker containers. Allowed
     values must be in the range of 0 to 100 (inclusive) for user pools and in
     the range of 1 to 100 (inclusive) for system pools. The default value is
     1.
    :type count: int
    :param vm_size: Size of agent VMs. Possible values include: 'Standard_A1',
     'Standard_A10', 'Standard_A11', 'Standard_A1_v2', 'Standard_A2',
     'Standard_A2_v2', 'Standard_A2m_v2', 'Standard_A3', 'Standard_A4',
     'Standard_A4_v2', 'Standard_A4m_v2', 'Standard_A5', 'Standard_A6',
     'Standard_A7', 'Standard_A8', 'Standard_A8_v2', 'Standard_A8m_v2',
     'Standard_A9', 'Standard_B2ms', 'Standard_B2s', 'Standard_B4ms',
     'Standard_B8ms', 'Standard_D1', 'Standard_D11', 'Standard_D11_v2',
     'Standard_D11_v2_Promo', 'Standard_D12', 'Standard_D12_v2',
     'Standard_D12_v2_Promo', 'Standard_D13', 'Standard_D13_v2',
     'Standard_D13_v2_Promo', 'Standard_D14', 'Standard_D14_v2',
     'Standard_D14_v2_Promo', 'Standard_D15_v2', 'Standard_D16_v3',
     'Standard_D16s_v3', 'Standard_D1_v2', 'Standard_D2', 'Standard_D2_v2',
     'Standard_D2_v2_Promo', 'Standard_D2_v3', 'Standard_D2s_v3',
     'Standard_D3', 'Standard_D32_v3', 'Standard_D32s_v3', 'Standard_D3_v2',
     'Standard_D3_v2_Promo', 'Standard_D4', 'Standard_D4_v2',
     'Standard_D4_v2_Promo', 'Standard_D4_v3', 'Standard_D4s_v3',
     'Standard_D5_v2', 'Standard_D5_v2_Promo', 'Standard_D64_v3',
     'Standard_D64s_v3', 'Standard_D8_v3', 'Standard_D8s_v3', 'Standard_DS1',
     'Standard_DS11', 'Standard_DS11_v2', 'Standard_DS11_v2_Promo',
     'Standard_DS12', 'Standard_DS12_v2', 'Standard_DS12_v2_Promo',
     'Standard_DS13', 'Standard_DS13-2_v2', 'Standard_DS13-4_v2',
     'Standard_DS13_v2', 'Standard_DS13_v2_Promo', 'Standard_DS14',
     'Standard_DS14-4_v2', 'Standard_DS14-8_v2', 'Standard_DS14_v2',
     'Standard_DS14_v2_Promo', 'Standard_DS15_v2', 'Standard_DS1_v2',
     'Standard_DS2', 'Standard_DS2_v2', 'Standard_DS2_v2_Promo',
     'Standard_DS3', 'Standard_DS3_v2', 'Standard_DS3_v2_Promo',
     'Standard_DS4', 'Standard_DS4_v2', 'Standard_DS4_v2_Promo',
     'Standard_DS5_v2', 'Standard_DS5_v2_Promo', 'Standard_E16_v3',
     'Standard_E16s_v3', 'Standard_E2_v3', 'Standard_E2s_v3',
     'Standard_E32-16s_v3', 'Standard_E32-8s_v3', 'Standard_E32_v3',
     'Standard_E32s_v3', 'Standard_E4_v3', 'Standard_E4s_v3',
     'Standard_E64-16s_v3', 'Standard_E64-32s_v3', 'Standard_E64_v3',
     'Standard_E64s_v3', 'Standard_E8_v3', 'Standard_E8s_v3', 'Standard_F1',
     'Standard_F16', 'Standard_F16s', 'Standard_F16s_v2', 'Standard_F1s',
     'Standard_F2', 'Standard_F2s', 'Standard_F2s_v2', 'Standard_F32s_v2',
     'Standard_F4', 'Standard_F4s', 'Standard_F4s_v2', 'Standard_F64s_v2',
     'Standard_F72s_v2', 'Standard_F8', 'Standard_F8s', 'Standard_F8s_v2',
     'Standard_G1', 'Standard_G2', 'Standard_G3', 'Standard_G4', 'Standard_G5',
     'Standard_GS1', 'Standard_GS2', 'Standard_GS3', 'Standard_GS4',
     'Standard_GS4-4', 'Standard_GS4-8', 'Standard_GS5', 'Standard_GS5-16',
     'Standard_GS5-8', 'Standard_H16', 'Standard_H16m', 'Standard_H16mr',
     'Standard_H16r', 'Standard_H8', 'Standard_H8m', 'Standard_L16s',
     'Standard_L32s', 'Standard_L4s', 'Standard_L8s', 'Standard_M128-32ms',
     'Standard_M128-64ms', 'Standard_M128ms', 'Standard_M128s',
     'Standard_M64-16ms', 'Standard_M64-32ms', 'Standard_M64ms',
     'Standard_M64s', 'Standard_NC12', 'Standard_NC12s_v2',
     'Standard_NC12s_v3', 'Standard_NC24', 'Standard_NC24r',
     'Standard_NC24rs_v2', 'Standard_NC24rs_v3', 'Standard_NC24s_v2',
     'Standard_NC24s_v3', 'Standard_NC6', 'Standard_NC6s_v2',
     'Standard_NC6s_v3', 'Standard_ND12s', 'Standard_ND24rs', 'Standard_ND24s',
     'Standard_ND6s', 'Standard_NV12', 'Standard_NV24', 'Standard_NV6'
    :type vm_size: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ContainerServiceVMSizeTypes
    :param os_disk_size_gb: OS Disk Size in GB to be used to specify the disk
     size for every machine in this master/agent pool. If you specify 0, it
     will apply the default osDisk size according to the vmSize specified.
    :type os_disk_size_gb: int
    :param os_disk_type: OS disk type to be used for machines in a given agent
     pool. Allowed values are 'Ephemeral' and 'Managed'. If unspecified,
     defaults to 'Ephemeral' when the VM supports ephemeral OS and has a cache
     disk larger than the requested OSDiskSizeGB. Otherwise, defaults to
     'Managed'. May not be changed after creation. Possible values include:
     'Managed', 'Ephemeral'
    :type os_disk_type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.OSDiskType
    :param vnet_subnet_id: VNet SubnetID specifies the VNet's subnet
     identifier for nodes and maybe pods
    :type vnet_subnet_id: str
    :param pod_subnet_id: Pod SubnetID specifies the VNet's subnet identifier
     for pods.
    :type pod_subnet_id: str
    :param max_pods: Maximum number of pods that can run on a node.
    :type max_pods: int
    :param os_type: OsType to be used to specify os type. Choose from Linux
     and Windows. Default to Linux. Possible values include: 'Linux',
     'Windows'. Default value: "Linux" .
    :type os_type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.OSType
    :param max_count: Maximum number of nodes for auto-scaling
    :type max_count: int
    :param min_count: Minimum number of nodes for auto-scaling
    :type min_count: int
    :param enable_auto_scaling: Whether to enable auto-scaler
    :type enable_auto_scaling: bool
    :param type: AgentPoolType represents types of an agent pool. Possible
     values include: 'VirtualMachineScaleSets', 'AvailabilitySet'
    :type type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.AgentPoolType
    :param mode: AgentPoolMode represents mode of an agent pool. Possible
     values include: 'System', 'User'
    :type mode: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.AgentPoolMode
    :param orchestrator_version: Version of orchestrator specified when
     creating the managed cluster.
    :type orchestrator_version: str
    :ivar node_image_version: Version of node image
    :vartype node_image_version: str
    :param upgrade_settings: Settings for upgrading the agentpool
    :type upgrade_settings:
     ~azure.mgmt.containerservice.v2020_11_01.models.AgentPoolUpgradeSettings
    :ivar provisioning_state: The current deployment or provisioning state,
     which only appears in the response.
    :vartype provisioning_state: str
    :ivar power_state: Describes whether the Agent Pool is Running or Stopped
    :vartype power_state:
     ~azure.mgmt.containerservice.v2020_11_01.models.PowerState
    :param availability_zones: Availability zones for nodes. Must use
     VirtualMachineScaleSets AgentPoolType.
    :type availability_zones: list[str]
    :param enable_node_public_ip: Enable public IP for nodes
    :type enable_node_public_ip: bool
    :param scale_set_priority: ScaleSetPriority to be used to specify virtual
     machine scale set priority. Default to regular. Possible values include:
     'Spot', 'Regular'. Default value: "Regular" .
    :type scale_set_priority: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ScaleSetPriority
    :param scale_set_eviction_policy: ScaleSetEvictionPolicy to be used to
     specify eviction policy for Spot virtual machine scale set. Default to
     Delete. Possible values include: 'Delete', 'Deallocate'. Default value:
     "Delete" .
    :type scale_set_eviction_policy: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ScaleSetEvictionPolicy
    :param spot_max_price: SpotMaxPrice to be used to specify the maximum
     price you are willing to pay in US Dollars. Possible values are any
     decimal value greater than zero or -1 which indicates default price to be
     up-to on-demand.
    :type spot_max_price: float
    :param tags: Agent pool tags to be persisted on the agent pool virtual
     machine scale set.
    :type tags: dict[str, str]
    :param node_labels: Agent pool node labels to be persisted across all
     nodes in agent pool.
    :type node_labels: dict[str, str]
    :param node_taints: Taints added to new nodes during node pool create and
     scale. For example, key=value:NoSchedule.
    :type node_taints: list[str]
    :param proximity_placement_group_id: The ID for Proximity Placement Group.
    :type proximity_placement_group_id: str
    :param kubelet_config: KubeletConfig specifies the configuration of
     kubelet on agent nodes.
    :type kubelet_config:
     ~azure.mgmt.containerservice.v2020_11_01.models.KubeletConfig
    :param linux_os_config: LinuxOSConfig specifies the OS configuration of
     linux agent nodes.
    :type linux_os_config:
     ~azure.mgmt.containerservice.v2020_11_01.models.LinuxOSConfig
    """

    _validation = {
        'node_image_version': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'power_state': {'readonly': True},
    }

    _attribute_map = {
        'count': {'key': 'count', 'type': 'int'},
        'vm_size': {'key': 'vmSize', 'type': 'str'},
        'os_disk_size_gb': {'key': 'osDiskSizeGB', 'type': 'int'},
        'os_disk_type': {'key': 'osDiskType', 'type': 'str'},
        'vnet_subnet_id': {'key': 'vnetSubnetID', 'type': 'str'},
        'pod_subnet_id': {'key': 'podSubnetID', 'type': 'str'},
        'max_pods': {'key': 'maxPods', 'type': 'int'},
        'os_type': {'key': 'osType', 'type': 'str'},
        'max_count': {'key': 'maxCount', 'type': 'int'},
        'min_count': {'key': 'minCount', 'type': 'int'},
        'enable_auto_scaling': {'key': 'enableAutoScaling', 'type': 'bool'},
        'type': {'key': 'type', 'type': 'str'},
        'mode': {'key': 'mode', 'type': 'str'},
        'orchestrator_version': {'key': 'orchestratorVersion', 'type': 'str'},
        'node_image_version': {'key': 'nodeImageVersion', 'type': 'str'},
        'upgrade_settings': {'key': 'upgradeSettings', 'type': 'AgentPoolUpgradeSettings'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'power_state': {'key': 'powerState', 'type': 'PowerState'},
        'availability_zones': {'key': 'availabilityZones', 'type': '[str]'},
        'enable_node_public_ip': {'key': 'enableNodePublicIP', 'type': 'bool'},
        'scale_set_priority': {'key': 'scaleSetPriority', 'type': 'str'},
        'scale_set_eviction_policy': {'key': 'scaleSetEvictionPolicy', 'type': 'str'},
        'spot_max_price': {'key': 'spotMaxPrice', 'type': 'float'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'node_labels': {'key': 'nodeLabels', 'type': '{str}'},
        'node_taints': {'key': 'nodeTaints', 'type': '[str]'},
        'proximity_placement_group_id': {'key': 'proximityPlacementGroupID', 'type': 'str'},
        'kubelet_config': {'key': 'kubeletConfig', 'type': 'KubeletConfig'},
        'linux_os_config': {'key': 'linuxOSConfig', 'type': 'LinuxOSConfig'},
    }

    def __init__(self, *, count: int=None, vm_size=None, os_disk_size_gb: int=None, os_disk_type=None, vnet_subnet_id: str=None, pod_subnet_id: str=None, max_pods: int=None, os_type="Linux", max_count: int=None, min_count: int=None, enable_auto_scaling: bool=None, type=None, mode=None, orchestrator_version: str=None, upgrade_settings=None, availability_zones=None, enable_node_public_ip: bool=None, scale_set_priority="Regular", scale_set_eviction_policy="Delete", spot_max_price: float=None, tags=None, node_labels=None, node_taints=None, proximity_placement_group_id: str=None, kubelet_config=None, linux_os_config=None, **kwargs) -> None:
        super(ManagedClusterAgentPoolProfileProperties, self).__init__(**kwargs)
        self.count = count
        self.vm_size = vm_size
        self.os_disk_size_gb = os_disk_size_gb
        self.os_disk_type = os_disk_type
        self.vnet_subnet_id = vnet_subnet_id
        self.pod_subnet_id = pod_subnet_id
        self.max_pods = max_pods
        self.os_type = os_type
        self.max_count = max_count
        self.min_count = min_count
        self.enable_auto_scaling = enable_auto_scaling
        self.type = type
        self.mode = mode
        self.orchestrator_version = orchestrator_version
        self.node_image_version = None
        self.upgrade_settings = upgrade_settings
        self.provisioning_state = None
        self.power_state = None
        self.availability_zones = availability_zones
        self.enable_node_public_ip = enable_node_public_ip
        self.scale_set_priority = scale_set_priority
        self.scale_set_eviction_policy = scale_set_eviction_policy
        self.spot_max_price = spot_max_price
        self.tags = tags
        self.node_labels = node_labels
        self.node_taints = node_taints
        self.proximity_placement_group_id = proximity_placement_group_id
        self.kubelet_config = kubelet_config
        self.linux_os_config = linux_os_config


class ManagedClusterAgentPoolProfile(ManagedClusterAgentPoolProfileProperties):
    """Profile for the container service agent pool.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param count: Number of agents (VMs) to host docker containers. Allowed
     values must be in the range of 0 to 100 (inclusive) for user pools and in
     the range of 1 to 100 (inclusive) for system pools. The default value is
     1.
    :type count: int
    :param vm_size: Size of agent VMs. Possible values include: 'Standard_A1',
     'Standard_A10', 'Standard_A11', 'Standard_A1_v2', 'Standard_A2',
     'Standard_A2_v2', 'Standard_A2m_v2', 'Standard_A3', 'Standard_A4',
     'Standard_A4_v2', 'Standard_A4m_v2', 'Standard_A5', 'Standard_A6',
     'Standard_A7', 'Standard_A8', 'Standard_A8_v2', 'Standard_A8m_v2',
     'Standard_A9', 'Standard_B2ms', 'Standard_B2s', 'Standard_B4ms',
     'Standard_B8ms', 'Standard_D1', 'Standard_D11', 'Standard_D11_v2',
     'Standard_D11_v2_Promo', 'Standard_D12', 'Standard_D12_v2',
     'Standard_D12_v2_Promo', 'Standard_D13', 'Standard_D13_v2',
     'Standard_D13_v2_Promo', 'Standard_D14', 'Standard_D14_v2',
     'Standard_D14_v2_Promo', 'Standard_D15_v2', 'Standard_D16_v3',
     'Standard_D16s_v3', 'Standard_D1_v2', 'Standard_D2', 'Standard_D2_v2',
     'Standard_D2_v2_Promo', 'Standard_D2_v3', 'Standard_D2s_v3',
     'Standard_D3', 'Standard_D32_v3', 'Standard_D32s_v3', 'Standard_D3_v2',
     'Standard_D3_v2_Promo', 'Standard_D4', 'Standard_D4_v2',
     'Standard_D4_v2_Promo', 'Standard_D4_v3', 'Standard_D4s_v3',
     'Standard_D5_v2', 'Standard_D5_v2_Promo', 'Standard_D64_v3',
     'Standard_D64s_v3', 'Standard_D8_v3', 'Standard_D8s_v3', 'Standard_DS1',
     'Standard_DS11', 'Standard_DS11_v2', 'Standard_DS11_v2_Promo',
     'Standard_DS12', 'Standard_DS12_v2', 'Standard_DS12_v2_Promo',
     'Standard_DS13', 'Standard_DS13-2_v2', 'Standard_DS13-4_v2',
     'Standard_DS13_v2', 'Standard_DS13_v2_Promo', 'Standard_DS14',
     'Standard_DS14-4_v2', 'Standard_DS14-8_v2', 'Standard_DS14_v2',
     'Standard_DS14_v2_Promo', 'Standard_DS15_v2', 'Standard_DS1_v2',
     'Standard_DS2', 'Standard_DS2_v2', 'Standard_DS2_v2_Promo',
     'Standard_DS3', 'Standard_DS3_v2', 'Standard_DS3_v2_Promo',
     'Standard_DS4', 'Standard_DS4_v2', 'Standard_DS4_v2_Promo',
     'Standard_DS5_v2', 'Standard_DS5_v2_Promo', 'Standard_E16_v3',
     'Standard_E16s_v3', 'Standard_E2_v3', 'Standard_E2s_v3',
     'Standard_E32-16s_v3', 'Standard_E32-8s_v3', 'Standard_E32_v3',
     'Standard_E32s_v3', 'Standard_E4_v3', 'Standard_E4s_v3',
     'Standard_E64-16s_v3', 'Standard_E64-32s_v3', 'Standard_E64_v3',
     'Standard_E64s_v3', 'Standard_E8_v3', 'Standard_E8s_v3', 'Standard_F1',
     'Standard_F16', 'Standard_F16s', 'Standard_F16s_v2', 'Standard_F1s',
     'Standard_F2', 'Standard_F2s', 'Standard_F2s_v2', 'Standard_F32s_v2',
     'Standard_F4', 'Standard_F4s', 'Standard_F4s_v2', 'Standard_F64s_v2',
     'Standard_F72s_v2', 'Standard_F8', 'Standard_F8s', 'Standard_F8s_v2',
     'Standard_G1', 'Standard_G2', 'Standard_G3', 'Standard_G4', 'Standard_G5',
     'Standard_GS1', 'Standard_GS2', 'Standard_GS3', 'Standard_GS4',
     'Standard_GS4-4', 'Standard_GS4-8', 'Standard_GS5', 'Standard_GS5-16',
     'Standard_GS5-8', 'Standard_H16', 'Standard_H16m', 'Standard_H16mr',
     'Standard_H16r', 'Standard_H8', 'Standard_H8m', 'Standard_L16s',
     'Standard_L32s', 'Standard_L4s', 'Standard_L8s', 'Standard_M128-32ms',
     'Standard_M128-64ms', 'Standard_M128ms', 'Standard_M128s',
     'Standard_M64-16ms', 'Standard_M64-32ms', 'Standard_M64ms',
     'Standard_M64s', 'Standard_NC12', 'Standard_NC12s_v2',
     'Standard_NC12s_v3', 'Standard_NC24', 'Standard_NC24r',
     'Standard_NC24rs_v2', 'Standard_NC24rs_v3', 'Standard_NC24s_v2',
     'Standard_NC24s_v3', 'Standard_NC6', 'Standard_NC6s_v2',
     'Standard_NC6s_v3', 'Standard_ND12s', 'Standard_ND24rs', 'Standard_ND24s',
     'Standard_ND6s', 'Standard_NV12', 'Standard_NV24', 'Standard_NV6'
    :type vm_size: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ContainerServiceVMSizeTypes
    :param os_disk_size_gb: OS Disk Size in GB to be used to specify the disk
     size for every machine in this master/agent pool. If you specify 0, it
     will apply the default osDisk size according to the vmSize specified.
    :type os_disk_size_gb: int
    :param os_disk_type: OS disk type to be used for machines in a given agent
     pool. Allowed values are 'Ephemeral' and 'Managed'. If unspecified,
     defaults to 'Ephemeral' when the VM supports ephemeral OS and has a cache
     disk larger than the requested OSDiskSizeGB. Otherwise, defaults to
     'Managed'. May not be changed after creation. Possible values include:
     'Managed', 'Ephemeral'
    :type os_disk_type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.OSDiskType
    :param vnet_subnet_id: VNet SubnetID specifies the VNet's subnet
     identifier for nodes and maybe pods
    :type vnet_subnet_id: str
    :param pod_subnet_id: Pod SubnetID specifies the VNet's subnet identifier
     for pods.
    :type pod_subnet_id: str
    :param max_pods: Maximum number of pods that can run on a node.
    :type max_pods: int
    :param os_type: OsType to be used to specify os type. Choose from Linux
     and Windows. Default to Linux. Possible values include: 'Linux',
     'Windows'. Default value: "Linux" .
    :type os_type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.OSType
    :param max_count: Maximum number of nodes for auto-scaling
    :type max_count: int
    :param min_count: Minimum number of nodes for auto-scaling
    :type min_count: int
    :param enable_auto_scaling: Whether to enable auto-scaler
    :type enable_auto_scaling: bool
    :param type: AgentPoolType represents types of an agent pool. Possible
     values include: 'VirtualMachineScaleSets', 'AvailabilitySet'
    :type type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.AgentPoolType
    :param mode: AgentPoolMode represents mode of an agent pool. Possible
     values include: 'System', 'User'
    :type mode: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.AgentPoolMode
    :param orchestrator_version: Version of orchestrator specified when
     creating the managed cluster.
    :type orchestrator_version: str
    :ivar node_image_version: Version of node image
    :vartype node_image_version: str
    :param upgrade_settings: Settings for upgrading the agentpool
    :type upgrade_settings:
     ~azure.mgmt.containerservice.v2020_11_01.models.AgentPoolUpgradeSettings
    :ivar provisioning_state: The current deployment or provisioning state,
     which only appears in the response.
    :vartype provisioning_state: str
    :ivar power_state: Describes whether the Agent Pool is Running or Stopped
    :vartype power_state:
     ~azure.mgmt.containerservice.v2020_11_01.models.PowerState
    :param availability_zones: Availability zones for nodes. Must use
     VirtualMachineScaleSets AgentPoolType.
    :type availability_zones: list[str]
    :param enable_node_public_ip: Enable public IP for nodes
    :type enable_node_public_ip: bool
    :param scale_set_priority: ScaleSetPriority to be used to specify virtual
     machine scale set priority. Default to regular. Possible values include:
     'Spot', 'Regular'. Default value: "Regular" .
    :type scale_set_priority: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ScaleSetPriority
    :param scale_set_eviction_policy: ScaleSetEvictionPolicy to be used to
     specify eviction policy for Spot virtual machine scale set. Default to
     Delete. Possible values include: 'Delete', 'Deallocate'. Default value:
     "Delete" .
    :type scale_set_eviction_policy: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ScaleSetEvictionPolicy
    :param spot_max_price: SpotMaxPrice to be used to specify the maximum
     price you are willing to pay in US Dollars. Possible values are any
     decimal value greater than zero or -1 which indicates default price to be
     up-to on-demand.
    :type spot_max_price: float
    :param tags: Agent pool tags to be persisted on the agent pool virtual
     machine scale set.
    :type tags: dict[str, str]
    :param node_labels: Agent pool node labels to be persisted across all
     nodes in agent pool.
    :type node_labels: dict[str, str]
    :param node_taints: Taints added to new nodes during node pool create and
     scale. For example, key=value:NoSchedule.
    :type node_taints: list[str]
    :param proximity_placement_group_id: The ID for Proximity Placement Group.
    :type proximity_placement_group_id: str
    :param kubelet_config: KubeletConfig specifies the configuration of
     kubelet on agent nodes.
    :type kubelet_config:
     ~azure.mgmt.containerservice.v2020_11_01.models.KubeletConfig
    :param linux_os_config: LinuxOSConfig specifies the OS configuration of
     linux agent nodes.
    :type linux_os_config:
     ~azure.mgmt.containerservice.v2020_11_01.models.LinuxOSConfig
    :param name: Required. Unique name of the agent pool profile in the
     context of the subscription and resource group.
    :type name: str
    """

    _validation = {
        'node_image_version': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'power_state': {'readonly': True},
        'name': {'required': True, 'pattern': r'^[a-z][a-z0-9]{0,11}$'},
    }

    _attribute_map = {
        'count': {'key': 'count', 'type': 'int'},
        'vm_size': {'key': 'vmSize', 'type': 'str'},
        'os_disk_size_gb': {'key': 'osDiskSizeGB', 'type': 'int'},
        'os_disk_type': {'key': 'osDiskType', 'type': 'str'},
        'vnet_subnet_id': {'key': 'vnetSubnetID', 'type': 'str'},
        'pod_subnet_id': {'key': 'podSubnetID', 'type': 'str'},
        'max_pods': {'key': 'maxPods', 'type': 'int'},
        'os_type': {'key': 'osType', 'type': 'str'},
        'max_count': {'key': 'maxCount', 'type': 'int'},
        'min_count': {'key': 'minCount', 'type': 'int'},
        'enable_auto_scaling': {'key': 'enableAutoScaling', 'type': 'bool'},
        'type': {'key': 'type', 'type': 'str'},
        'mode': {'key': 'mode', 'type': 'str'},
        'orchestrator_version': {'key': 'orchestratorVersion', 'type': 'str'},
        'node_image_version': {'key': 'nodeImageVersion', 'type': 'str'},
        'upgrade_settings': {'key': 'upgradeSettings', 'type': 'AgentPoolUpgradeSettings'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'power_state': {'key': 'powerState', 'type': 'PowerState'},
        'availability_zones': {'key': 'availabilityZones', 'type': '[str]'},
        'enable_node_public_ip': {'key': 'enableNodePublicIP', 'type': 'bool'},
        'scale_set_priority': {'key': 'scaleSetPriority', 'type': 'str'},
        'scale_set_eviction_policy': {'key': 'scaleSetEvictionPolicy', 'type': 'str'},
        'spot_max_price': {'key': 'spotMaxPrice', 'type': 'float'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'node_labels': {'key': 'nodeLabels', 'type': '{str}'},
        'node_taints': {'key': 'nodeTaints', 'type': '[str]'},
        'proximity_placement_group_id': {'key': 'proximityPlacementGroupID', 'type': 'str'},
        'kubelet_config': {'key': 'kubeletConfig', 'type': 'KubeletConfig'},
        'linux_os_config': {'key': 'linuxOSConfig', 'type': 'LinuxOSConfig'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(self, *, name: str, count: int=None, vm_size=None, os_disk_size_gb: int=None, os_disk_type=None, vnet_subnet_id: str=None, pod_subnet_id: str=None, max_pods: int=None, os_type="Linux", max_count: int=None, min_count: int=None, enable_auto_scaling: bool=None, type=None, mode=None, orchestrator_version: str=None, upgrade_settings=None, availability_zones=None, enable_node_public_ip: bool=None, scale_set_priority="Regular", scale_set_eviction_policy="Delete", spot_max_price: float=None, tags=None, node_labels=None, node_taints=None, proximity_placement_group_id: str=None, kubelet_config=None, linux_os_config=None, **kwargs) -> None:
        super(ManagedClusterAgentPoolProfile, self).__init__(count=count, vm_size=vm_size, os_disk_size_gb=os_disk_size_gb, os_disk_type=os_disk_type, vnet_subnet_id=vnet_subnet_id, pod_subnet_id=pod_subnet_id, max_pods=max_pods, os_type=os_type, max_count=max_count, min_count=min_count, enable_auto_scaling=enable_auto_scaling, type=type, mode=mode, orchestrator_version=orchestrator_version, upgrade_settings=upgrade_settings, availability_zones=availability_zones, enable_node_public_ip=enable_node_public_ip, scale_set_priority=scale_set_priority, scale_set_eviction_policy=scale_set_eviction_policy, spot_max_price=spot_max_price, tags=tags, node_labels=node_labels, node_taints=node_taints, proximity_placement_group_id=proximity_placement_group_id, kubelet_config=kubelet_config, linux_os_config=linux_os_config, **kwargs)
        self.name = name


class ManagedClusterAPIServerAccessProfile(Model):
    """Access profile for managed cluster API server.

    :param authorized_ip_ranges: Authorized IP Ranges to kubernetes API
     server.
    :type authorized_ip_ranges: list[str]
    :param enable_private_cluster: Whether to create the cluster as a private
     cluster or not.
    :type enable_private_cluster: bool
    :param private_dns_zone: Private dns zone mode for private cluster.
    :type private_dns_zone: str
    """

    _attribute_map = {
        'authorized_ip_ranges': {'key': 'authorizedIPRanges', 'type': '[str]'},
        'enable_private_cluster': {'key': 'enablePrivateCluster', 'type': 'bool'},
        'private_dns_zone': {'key': 'privateDNSZone', 'type': 'str'},
    }

    def __init__(self, *, authorized_ip_ranges=None, enable_private_cluster: bool=None, private_dns_zone: str=None, **kwargs) -> None:
        super(ManagedClusterAPIServerAccessProfile, self).__init__(**kwargs)
        self.authorized_ip_ranges = authorized_ip_ranges
        self.enable_private_cluster = enable_private_cluster
        self.private_dns_zone = private_dns_zone


class ManagedClusterAutoUpgradeProfile(Model):
    """Auto upgrade profile for a managed cluster.

    :param upgrade_channel: upgrade channel for auto upgrade. Possible values
     include: 'rapid', 'stable', 'patch', 'none'
    :type upgrade_channel: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.UpgradeChannel
    """

    _attribute_map = {
        'upgrade_channel': {'key': 'upgradeChannel', 'type': 'str'},
    }

    def __init__(self, *, upgrade_channel=None, **kwargs) -> None:
        super(ManagedClusterAutoUpgradeProfile, self).__init__(**kwargs)
        self.upgrade_channel = upgrade_channel


class ManagedClusterIdentity(Model):
    """Identity for the managed cluster.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar principal_id: The principal id of the system assigned identity which
     is used by master components.
    :vartype principal_id: str
    :ivar tenant_id: The tenant id of the system assigned identity which is
     used by master components.
    :vartype tenant_id: str
    :param type: The type of identity used for the managed cluster. Type
     'SystemAssigned' will use an implicitly created identity in master
     components and an auto-created user assigned identity in MC_ resource
     group in agent nodes. Type 'None' will not use MSI for the managed
     cluster, service principal will be used instead. Possible values include:
     'SystemAssigned', 'UserAssigned', 'None'
    :type type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ResourceIdentityType
    :param user_assigned_identities: The user identity associated with the
     managed cluster. This identity will be used in control plane and only one
     user assigned identity is allowed. The user identity dictionary key
     references will be ARM resource ids in the form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
    :type user_assigned_identities: dict[str,
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterIdentityUserAssignedIdentitiesValue]
    """

    _validation = {
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
    }

    _attribute_map = {
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
        'type': {'key': 'type', 'type': 'ResourceIdentityType'},
        'user_assigned_identities': {'key': 'userAssignedIdentities', 'type': '{ManagedClusterIdentityUserAssignedIdentitiesValue}'},
    }

    def __init__(self, *, type=None, user_assigned_identities=None, **kwargs) -> None:
        super(ManagedClusterIdentity, self).__init__(**kwargs)
        self.principal_id = None
        self.tenant_id = None
        self.type = type
        self.user_assigned_identities = user_assigned_identities


class ManagedClusterIdentityUserAssignedIdentitiesValue(Model):
    """ManagedClusterIdentityUserAssignedIdentitiesValue.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar principal_id: The principal id of user assigned identity.
    :vartype principal_id: str
    :ivar client_id: The client id of user assigned identity.
    :vartype client_id: str
    """

    _validation = {
        'principal_id': {'readonly': True},
        'client_id': {'readonly': True},
    }

    _attribute_map = {
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
    }

    def __init__(self, **kwargs) -> None:
        super(ManagedClusterIdentityUserAssignedIdentitiesValue, self).__init__(**kwargs)
        self.principal_id = None
        self.client_id = None


class ManagedClusterLoadBalancerProfile(Model):
    """Profile of the managed cluster load balancer.

    :param managed_outbound_ips: Desired managed outbound IPs for the cluster
     load balancer.
    :type managed_outbound_ips:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterLoadBalancerProfileManagedOutboundIPs
    :param outbound_ip_prefixes: Desired outbound IP Prefix resources for the
     cluster load balancer.
    :type outbound_ip_prefixes:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterLoadBalancerProfileOutboundIPPrefixes
    :param outbound_ips: Desired outbound IP resources for the cluster load
     balancer.
    :type outbound_ips:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterLoadBalancerProfileOutboundIPs
    :param effective_outbound_ips: The effective outbound IP resources of the
     cluster load balancer.
    :type effective_outbound_ips:
     list[~azure.mgmt.containerservice.v2020_11_01.models.ResourceReference]
    :param allocated_outbound_ports: Desired number of allocated SNAT ports
     per VM. Allowed values must be in the range of 0 to 64000 (inclusive). The
     default value is 0 which results in Azure dynamically allocating ports.
     Default value: 0 .
    :type allocated_outbound_ports: int
    :param idle_timeout_in_minutes: Desired outbound flow idle timeout in
     minutes. Allowed values must be in the range of 4 to 120 (inclusive). The
     default value is 30 minutes. Default value: 30 .
    :type idle_timeout_in_minutes: int
    """

    _validation = {
        'allocated_outbound_ports': {'maximum': 64000, 'minimum': 0},
        'idle_timeout_in_minutes': {'maximum': 120, 'minimum': 4},
    }

    _attribute_map = {
        'managed_outbound_ips': {'key': 'managedOutboundIPs', 'type': 'ManagedClusterLoadBalancerProfileManagedOutboundIPs'},
        'outbound_ip_prefixes': {'key': 'outboundIPPrefixes', 'type': 'ManagedClusterLoadBalancerProfileOutboundIPPrefixes'},
        'outbound_ips': {'key': 'outboundIPs', 'type': 'ManagedClusterLoadBalancerProfileOutboundIPs'},
        'effective_outbound_ips': {'key': 'effectiveOutboundIPs', 'type': '[ResourceReference]'},
        'allocated_outbound_ports': {'key': 'allocatedOutboundPorts', 'type': 'int'},
        'idle_timeout_in_minutes': {'key': 'idleTimeoutInMinutes', 'type': 'int'},
    }

    def __init__(self, *, managed_outbound_ips=None, outbound_ip_prefixes=None, outbound_ips=None, effective_outbound_ips=None, allocated_outbound_ports: int=0, idle_timeout_in_minutes: int=30, **kwargs) -> None:
        super(ManagedClusterLoadBalancerProfile, self).__init__(**kwargs)
        self.managed_outbound_ips = managed_outbound_ips
        self.outbound_ip_prefixes = outbound_ip_prefixes
        self.outbound_ips = outbound_ips
        self.effective_outbound_ips = effective_outbound_ips
        self.allocated_outbound_ports = allocated_outbound_ports
        self.idle_timeout_in_minutes = idle_timeout_in_minutes


class ManagedClusterLoadBalancerProfileManagedOutboundIPs(Model):
    """Desired managed outbound IPs for the cluster load balancer.

    :param count: Desired number of outbound IP created/managed by Azure for
     the cluster load balancer. Allowed values must be in the range of 1 to 100
     (inclusive). The default value is 1. . Default value: 1 .
    :type count: int
    """

    _validation = {
        'count': {'maximum': 100, 'minimum': 1},
    }

    _attribute_map = {
        'count': {'key': 'count', 'type': 'int'},
    }

    def __init__(self, *, count: int=1, **kwargs) -> None:
        super(ManagedClusterLoadBalancerProfileManagedOutboundIPs, self).__init__(**kwargs)
        self.count = count


class ManagedClusterLoadBalancerProfileOutboundIPPrefixes(Model):
    """Desired outbound IP Prefix resources for the cluster load balancer.

    :param public_ip_prefixes: A list of public IP prefix resources.
    :type public_ip_prefixes:
     list[~azure.mgmt.containerservice.v2020_11_01.models.ResourceReference]
    """

    _attribute_map = {
        'public_ip_prefixes': {'key': 'publicIPPrefixes', 'type': '[ResourceReference]'},
    }

    def __init__(self, *, public_ip_prefixes=None, **kwargs) -> None:
        super(ManagedClusterLoadBalancerProfileOutboundIPPrefixes, self).__init__(**kwargs)
        self.public_ip_prefixes = public_ip_prefixes


class ManagedClusterLoadBalancerProfileOutboundIPs(Model):
    """Desired outbound IP resources for the cluster load balancer.

    :param public_ips: A list of public IP resources.
    :type public_ips:
     list[~azure.mgmt.containerservice.v2020_11_01.models.ResourceReference]
    """

    _attribute_map = {
        'public_ips': {'key': 'publicIPs', 'type': '[ResourceReference]'},
    }

    def __init__(self, *, public_ips=None, **kwargs) -> None:
        super(ManagedClusterLoadBalancerProfileOutboundIPs, self).__init__(**kwargs)
        self.public_ips = public_ips


class ManagedClusterPodIdentity(Model):
    """ManagedClusterPodIdentity.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. Name of the pod identity.
    :type name: str
    :param namespace: Required. Namespace of the pod identity.
    :type namespace: str
    :param identity: Required. Information of the user assigned identity.
    :type identity:
     ~azure.mgmt.containerservice.v2020_11_01.models.UserAssignedIdentity
    :ivar provisioning_state: The current provisioning state of the pod
     identity. Possible values include: 'Assigned', 'Updating', 'Deleting',
     'Failed'
    :vartype provisioning_state: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterPodIdentityProvisioningState
    :ivar provisioning_info:
    :vartype provisioning_info:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterPodIdentityProvisioningInfo
    """

    _validation = {
        'name': {'required': True},
        'namespace': {'required': True},
        'identity': {'required': True},
        'provisioning_state': {'readonly': True},
        'provisioning_info': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'identity': {'key': 'identity', 'type': 'UserAssignedIdentity'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'provisioning_info': {'key': 'provisioningInfo', 'type': 'ManagedClusterPodIdentityProvisioningInfo'},
    }

    def __init__(self, *, name: str, namespace: str, identity, **kwargs) -> None:
        super(ManagedClusterPodIdentity, self).__init__(**kwargs)
        self.name = name
        self.namespace = namespace
        self.identity = identity
        self.provisioning_state = None
        self.provisioning_info = None


class ManagedClusterPodIdentityException(Model):
    """ManagedClusterPodIdentityException.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. Name of the pod identity exception.
    :type name: str
    :param namespace: Required. Namespace of the pod identity exception.
    :type namespace: str
    :param pod_labels: Required. Pod labels to match.
    :type pod_labels: dict[str, str]
    """

    _validation = {
        'name': {'required': True},
        'namespace': {'required': True},
        'pod_labels': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'pod_labels': {'key': 'podLabels', 'type': '{str}'},
    }

    def __init__(self, *, name: str, namespace: str, pod_labels, **kwargs) -> None:
        super(ManagedClusterPodIdentityException, self).__init__(**kwargs)
        self.name = name
        self.namespace = namespace
        self.pod_labels = pod_labels


class ManagedClusterPodIdentityProfile(Model):
    """ManagedClusterPodIdentityProfile.

    :param enabled: Whether the pod identity addon is enabled.
    :type enabled: bool
    :param user_assigned_identities: User assigned pod identity settings.
    :type user_assigned_identities:
     list[~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterPodIdentity]
    :param user_assigned_identity_exceptions: User assigned pod identity
     exception settings.
    :type user_assigned_identity_exceptions:
     list[~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterPodIdentityException]
    """

    _attribute_map = {
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'user_assigned_identities': {'key': 'userAssignedIdentities', 'type': '[ManagedClusterPodIdentity]'},
        'user_assigned_identity_exceptions': {'key': 'userAssignedIdentityExceptions', 'type': '[ManagedClusterPodIdentityException]'},
    }

    def __init__(self, *, enabled: bool=None, user_assigned_identities=None, user_assigned_identity_exceptions=None, **kwargs) -> None:
        super(ManagedClusterPodIdentityProfile, self).__init__(**kwargs)
        self.enabled = enabled
        self.user_assigned_identities = user_assigned_identities
        self.user_assigned_identity_exceptions = user_assigned_identity_exceptions


class ManagedClusterPodIdentityProvisioningInfo(Model):
    """ManagedClusterPodIdentityProvisioningInfo.

    :param error: Pod identity assignment error (if any).
    :type error: ~azure.mgmt.containerservice.v2020_11_01.models.CloudError
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'CloudError'},
    }

    def __init__(self, *, error=None, **kwargs) -> None:
        super(ManagedClusterPodIdentityProvisioningInfo, self).__init__(**kwargs)
        self.error = error


class ManagedClusterPoolUpgradeProfile(Model):
    """The list of available upgrade versions.

    All required parameters must be populated in order to send to Azure.

    :param kubernetes_version: Required. Kubernetes version (major, minor,
     patch).
    :type kubernetes_version: str
    :param name: Pool name.
    :type name: str
    :param os_type: Required. OsType to be used to specify os type. Choose
     from Linux and Windows. Default to Linux. Possible values include:
     'Linux', 'Windows'. Default value: "Linux" .
    :type os_type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.OSType
    :param upgrades: List of orchestrator types and versions available for
     upgrade.
    :type upgrades:
     list[~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterPoolUpgradeProfileUpgradesItem]
    """

    _validation = {
        'kubernetes_version': {'required': True},
        'os_type': {'required': True},
    }

    _attribute_map = {
        'kubernetes_version': {'key': 'kubernetesVersion', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'os_type': {'key': 'osType', 'type': 'str'},
        'upgrades': {'key': 'upgrades', 'type': '[ManagedClusterPoolUpgradeProfileUpgradesItem]'},
    }

    def __init__(self, *, kubernetes_version: str, name: str=None, os_type="Linux", upgrades=None, **kwargs) -> None:
        super(ManagedClusterPoolUpgradeProfile, self).__init__(**kwargs)
        self.kubernetes_version = kubernetes_version
        self.name = name
        self.os_type = os_type
        self.upgrades = upgrades


class ManagedClusterPoolUpgradeProfileUpgradesItem(Model):
    """ManagedClusterPoolUpgradeProfileUpgradesItem.

    :param kubernetes_version: Kubernetes version (major, minor, patch).
    :type kubernetes_version: str
    :param is_preview: Whether Kubernetes version is currently in preview.
    :type is_preview: bool
    """

    _attribute_map = {
        'kubernetes_version': {'key': 'kubernetesVersion', 'type': 'str'},
        'is_preview': {'key': 'isPreview', 'type': 'bool'},
    }

    def __init__(self, *, kubernetes_version: str=None, is_preview: bool=None, **kwargs) -> None:
        super(ManagedClusterPoolUpgradeProfileUpgradesItem, self).__init__(**kwargs)
        self.kubernetes_version = kubernetes_version
        self.is_preview = is_preview


class ManagedClusterPropertiesAutoScalerProfile(Model):
    """Parameters to be applied to the cluster-autoscaler when enabled.

    :param balance_similar_node_groups:
    :type balance_similar_node_groups: str
    :param expander: Possible values include: 'least-waste', 'most-pods',
     'random'
    :type expander: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.Expander
    :param max_empty_bulk_delete:
    :type max_empty_bulk_delete: str
    :param max_graceful_termination_sec:
    :type max_graceful_termination_sec: str
    :param max_total_unready_percentage:
    :type max_total_unready_percentage: str
    :param new_pod_scale_up_delay:
    :type new_pod_scale_up_delay: str
    :param ok_total_unready_count:
    :type ok_total_unready_count: str
    :param scan_interval:
    :type scan_interval: str
    :param scale_down_delay_after_add:
    :type scale_down_delay_after_add: str
    :param scale_down_delay_after_delete:
    :type scale_down_delay_after_delete: str
    :param scale_down_delay_after_failure:
    :type scale_down_delay_after_failure: str
    :param scale_down_unneeded_time:
    :type scale_down_unneeded_time: str
    :param scale_down_unready_time:
    :type scale_down_unready_time: str
    :param scale_down_utilization_threshold:
    :type scale_down_utilization_threshold: str
    :param skip_nodes_with_local_storage:
    :type skip_nodes_with_local_storage: str
    :param skip_nodes_with_system_pods:
    :type skip_nodes_with_system_pods: str
    """

    _attribute_map = {
        'balance_similar_node_groups': {'key': 'balance-similar-node-groups', 'type': 'str'},
        'expander': {'key': 'expander', 'type': 'str'},
        'max_empty_bulk_delete': {'key': 'max-empty-bulk-delete', 'type': 'str'},
        'max_graceful_termination_sec': {'key': 'max-graceful-termination-sec', 'type': 'str'},
        'max_total_unready_percentage': {'key': 'max-total-unready-percentage', 'type': 'str'},
        'new_pod_scale_up_delay': {'key': 'new-pod-scale-up-delay', 'type': 'str'},
        'ok_total_unready_count': {'key': 'ok-total-unready-count', 'type': 'str'},
        'scan_interval': {'key': 'scan-interval', 'type': 'str'},
        'scale_down_delay_after_add': {'key': 'scale-down-delay-after-add', 'type': 'str'},
        'scale_down_delay_after_delete': {'key': 'scale-down-delay-after-delete', 'type': 'str'},
        'scale_down_delay_after_failure': {'key': 'scale-down-delay-after-failure', 'type': 'str'},
        'scale_down_unneeded_time': {'key': 'scale-down-unneeded-time', 'type': 'str'},
        'scale_down_unready_time': {'key': 'scale-down-unready-time', 'type': 'str'},
        'scale_down_utilization_threshold': {'key': 'scale-down-utilization-threshold', 'type': 'str'},
        'skip_nodes_with_local_storage': {'key': 'skip-nodes-with-local-storage', 'type': 'str'},
        'skip_nodes_with_system_pods': {'key': 'skip-nodes-with-system-pods', 'type': 'str'},
    }

    def __init__(self, *, balance_similar_node_groups: str=None, expander=None, max_empty_bulk_delete: str=None, max_graceful_termination_sec: str=None, max_total_unready_percentage: str=None, new_pod_scale_up_delay: str=None, ok_total_unready_count: str=None, scan_interval: str=None, scale_down_delay_after_add: str=None, scale_down_delay_after_delete: str=None, scale_down_delay_after_failure: str=None, scale_down_unneeded_time: str=None, scale_down_unready_time: str=None, scale_down_utilization_threshold: str=None, skip_nodes_with_local_storage: str=None, skip_nodes_with_system_pods: str=None, **kwargs) -> None:
        super(ManagedClusterPropertiesAutoScalerProfile, self).__init__(**kwargs)
        self.balance_similar_node_groups = balance_similar_node_groups
        self.expander = expander
        self.max_empty_bulk_delete = max_empty_bulk_delete
        self.max_graceful_termination_sec = max_graceful_termination_sec
        self.max_total_unready_percentage = max_total_unready_percentage
        self.new_pod_scale_up_delay = new_pod_scale_up_delay
        self.ok_total_unready_count = ok_total_unready_count
        self.scan_interval = scan_interval
        self.scale_down_delay_after_add = scale_down_delay_after_add
        self.scale_down_delay_after_delete = scale_down_delay_after_delete
        self.scale_down_delay_after_failure = scale_down_delay_after_failure
        self.scale_down_unneeded_time = scale_down_unneeded_time
        self.scale_down_unready_time = scale_down_unready_time
        self.scale_down_utilization_threshold = scale_down_utilization_threshold
        self.skip_nodes_with_local_storage = skip_nodes_with_local_storage
        self.skip_nodes_with_system_pods = skip_nodes_with_system_pods


class ManagedClusterPropertiesIdentityProfileValue(UserAssignedIdentity):
    """ManagedClusterPropertiesIdentityProfileValue.

    :param resource_id: The resource id of the user assigned identity.
    :type resource_id: str
    :param client_id: The client id of the user assigned identity.
    :type client_id: str
    :param object_id: The object id of the user assigned identity.
    :type object_id: str
    """

    _attribute_map = {
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
        'object_id': {'key': 'objectId', 'type': 'str'},
    }

    def __init__(self, *, resource_id: str=None, client_id: str=None, object_id: str=None, **kwargs) -> None:
        super(ManagedClusterPropertiesIdentityProfileValue, self).__init__(resource_id=resource_id, client_id=client_id, object_id=object_id, **kwargs)


class ManagedClusterServicePrincipalProfile(Model):
    """Information about a service principal identity for the cluster to use for
    manipulating Azure APIs.

    All required parameters must be populated in order to send to Azure.

    :param client_id: Required. The ID for the service principal.
    :type client_id: str
    :param secret: The secret password associated with the service principal
     in plain text.
    :type secret: str
    """

    _validation = {
        'client_id': {'required': True},
    }

    _attribute_map = {
        'client_id': {'key': 'clientId', 'type': 'str'},
        'secret': {'key': 'secret', 'type': 'str'},
    }

    def __init__(self, *, client_id: str, secret: str=None, **kwargs) -> None:
        super(ManagedClusterServicePrincipalProfile, self).__init__(**kwargs)
        self.client_id = client_id
        self.secret = secret


class ManagedClusterSKU(Model):
    """ManagedClusterSKU.

    :param name: Name of a managed cluster SKU. Possible values include:
     'Basic'
    :type name: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterSKUName
    :param tier: Tier of a managed cluster SKU. Possible values include:
     'Paid', 'Free'
    :type tier: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterSKUTier
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'tier': {'key': 'tier', 'type': 'str'},
    }

    def __init__(self, *, name=None, tier=None, **kwargs) -> None:
        super(ManagedClusterSKU, self).__init__(**kwargs)
        self.name = name
        self.tier = tier


class ManagedClusterUpgradeProfile(Model):
    """The list of available upgrades for compute pools.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Id of upgrade profile.
    :vartype id: str
    :ivar name: Name of upgrade profile.
    :vartype name: str
    :ivar type: Type of upgrade profile.
    :vartype type: str
    :param control_plane_profile: Required. The list of available upgrade
     versions for the control plane.
    :type control_plane_profile:
     ~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterPoolUpgradeProfile
    :param agent_pool_profiles: Required. The list of available upgrade
     versions for agent pools.
    :type agent_pool_profiles:
     list[~azure.mgmt.containerservice.v2020_11_01.models.ManagedClusterPoolUpgradeProfile]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'control_plane_profile': {'required': True},
        'agent_pool_profiles': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'control_plane_profile': {'key': 'properties.controlPlaneProfile', 'type': 'ManagedClusterPoolUpgradeProfile'},
        'agent_pool_profiles': {'key': 'properties.agentPoolProfiles', 'type': '[ManagedClusterPoolUpgradeProfile]'},
    }

    def __init__(self, *, control_plane_profile, agent_pool_profiles, **kwargs) -> None:
        super(ManagedClusterUpgradeProfile, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.control_plane_profile = control_plane_profile
        self.agent_pool_profiles = agent_pool_profiles


class ManagedClusterWindowsProfile(Model):
    """Profile for Windows VMs in the container service cluster.

    All required parameters must be populated in order to send to Azure.

    :param admin_username: Required. Specifies the name of the administrator
     account. <br><br> **restriction:** Cannot end in "." <br><br> **Disallowed
     values:** "administrator", "admin", "user", "user1", "test", "user2",
     "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2",
     "aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
     "server", "sql", "support", "support_388945a0", "sys", "test2", "test3",
     "user4", "user5". <br><br> **Minimum-length:** 1 character <br><br>
     **Max-length:** 20 characters
    :type admin_username: str
    :param admin_password: Specifies the password of the administrator
     account. <br><br> **Minimum-length:** 8 characters <br><br>
     **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out
     of 4 conditions below need to be fulfilled <br> Has lower characters
     <br>Has upper characters <br> Has a digit <br> Has a special character
     (Regex match [\\W_]) <br><br> **Disallowed values:** "abc@123",
     "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1",
     "Password!", "Password1", "Password22", "iloveyou!"
    :type admin_password: str
    :param license_type: The licenseType to use for Windows VMs.
     Windows_Server is used to enable Azure Hybrid User Benefits for Windows
     VMs. Possible values include: 'None', 'Windows_Server'
    :type license_type: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.LicenseType
    """

    _validation = {
        'admin_username': {'required': True},
    }

    _attribute_map = {
        'admin_username': {'key': 'adminUsername', 'type': 'str'},
        'admin_password': {'key': 'adminPassword', 'type': 'str'},
        'license_type': {'key': 'licenseType', 'type': 'str'},
    }

    def __init__(self, *, admin_username: str, admin_password: str=None, license_type=None, **kwargs) -> None:
        super(ManagedClusterWindowsProfile, self).__init__(**kwargs)
        self.admin_username = admin_username
        self.admin_password = admin_password
        self.license_type = license_type


class OperationValue(Model):
    """Describes the properties of a Compute Operation value.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar origin: The origin of the compute operation.
    :vartype origin: str
    :ivar name: The name of the compute operation.
    :vartype name: str
    :ivar operation: The display name of the compute operation.
    :vartype operation: str
    :ivar resource: The display name of the resource the operation applies to.
    :vartype resource: str
    :ivar description: The description of the operation.
    :vartype description: str
    :ivar provider: The resource provider for the operation.
    :vartype provider: str
    """

    _validation = {
        'origin': {'readonly': True},
        'name': {'readonly': True},
        'operation': {'readonly': True},
        'resource': {'readonly': True},
        'description': {'readonly': True},
        'provider': {'readonly': True},
    }

    _attribute_map = {
        'origin': {'key': 'origin', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'operation': {'key': 'display.operation', 'type': 'str'},
        'resource': {'key': 'display.resource', 'type': 'str'},
        'description': {'key': 'display.description', 'type': 'str'},
        'provider': {'key': 'display.provider', 'type': 'str'},
    }

    def __init__(self, **kwargs) -> None:
        super(OperationValue, self).__init__(**kwargs)
        self.origin = None
        self.name = None
        self.operation = None
        self.resource = None
        self.description = None
        self.provider = None


class PowerState(Model):
    """Describes the Power State of the cluster.

    :param code: Tells whether the cluster is Running or Stopped. Possible
     values include: 'Running', 'Stopped'
    :type code: str or ~azure.mgmt.containerservice.v2020_11_01.models.Code
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
    }

    def __init__(self, *, code=None, **kwargs) -> None:
        super(PowerState, self).__init__(**kwargs)
        self.code = code


class PrivateEndpoint(Model):
    """Private endpoint which a connection belongs to.

    :param id: The resource Id for private endpoint
    :type id: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(self, *, id: str=None, **kwargs) -> None:
        super(PrivateEndpoint, self).__init__(**kwargs)
        self.id = id


class PrivateEndpointConnection(Model):
    """A private endpoint connection.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The ID of the private endpoint connection.
    :vartype id: str
    :ivar name: The name of the private endpoint connection.
    :vartype name: str
    :ivar type: The resource type.
    :vartype type: str
    :ivar provisioning_state: The current provisioning state. Possible values
     include: 'Succeeded', 'Creating', 'Deleting', 'Failed'
    :vartype provisioning_state: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.PrivateEndpointConnectionProvisioningState
    :param private_endpoint: The resource of private endpoint.
    :type private_endpoint:
     ~azure.mgmt.containerservice.v2020_11_01.models.PrivateEndpoint
    :param private_link_service_connection_state: Required. A collection of
     information about the state of the connection between service consumer and
     provider.
    :type private_link_service_connection_state:
     ~azure.mgmt.containerservice.v2020_11_01.models.PrivateLinkServiceConnectionState
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'private_link_service_connection_state': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'private_endpoint': {'key': 'properties.privateEndpoint', 'type': 'PrivateEndpoint'},
        'private_link_service_connection_state': {'key': 'properties.privateLinkServiceConnectionState', 'type': 'PrivateLinkServiceConnectionState'},
    }

    def __init__(self, *, private_link_service_connection_state, private_endpoint=None, **kwargs) -> None:
        super(PrivateEndpointConnection, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.provisioning_state = None
        self.private_endpoint = private_endpoint
        self.private_link_service_connection_state = private_link_service_connection_state


class PrivateEndpointConnectionListResult(Model):
    """A list of private endpoint connections.

    :param value: The collection value.
    :type value:
     list[~azure.mgmt.containerservice.v2020_11_01.models.PrivateEndpointConnection]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[PrivateEndpointConnection]'},
    }

    def __init__(self, *, value=None, **kwargs) -> None:
        super(PrivateEndpointConnectionListResult, self).__init__(**kwargs)
        self.value = value


class PrivateLinkResource(Model):
    """A private link resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :param id: The ID of the private link resource.
    :type id: str
    :param name: The name of the private link resource.
    :type name: str
    :param type: The resource type.
    :type type: str
    :param group_id: The group ID of the resource.
    :type group_id: str
    :param required_members: RequiredMembers of the resource
    :type required_members: list[str]
    :ivar private_link_service_id: The private link service ID of the
     resource, this field is exposed only to NRP internally.
    :vartype private_link_service_id: str
    """

    _validation = {
        'private_link_service_id': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'group_id': {'key': 'groupId', 'type': 'str'},
        'required_members': {'key': 'requiredMembers', 'type': '[str]'},
        'private_link_service_id': {'key': 'privateLinkServiceID', 'type': 'str'},
    }

    def __init__(self, *, id: str=None, name: str=None, type: str=None, group_id: str=None, required_members=None, **kwargs) -> None:
        super(PrivateLinkResource, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.type = type
        self.group_id = group_id
        self.required_members = required_members
        self.private_link_service_id = None


class PrivateLinkResourcesListResult(Model):
    """A list of private link resources.

    :param value: The collection value.
    :type value:
     list[~azure.mgmt.containerservice.v2020_11_01.models.PrivateLinkResource]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[PrivateLinkResource]'},
    }

    def __init__(self, *, value=None, **kwargs) -> None:
        super(PrivateLinkResourcesListResult, self).__init__(**kwargs)
        self.value = value


class PrivateLinkServiceConnectionState(Model):
    """The state of a private link service connection.

    :param status: The private link service connection status. Possible values
     include: 'Pending', 'Approved', 'Rejected', 'Disconnected'
    :type status: str or
     ~azure.mgmt.containerservice.v2020_11_01.models.ConnectionStatus
    :param description: The private link service connection description.
    :type description: str
    """

    _attribute_map = {
        'status': {'key': 'status', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(self, *, status=None, description: str=None, **kwargs) -> None:
        super(PrivateLinkServiceConnectionState, self).__init__(**kwargs)
        self.status = status
        self.description = description


class ResourceReference(Model):
    """A reference to an Azure resource.

    :param id: The fully qualified Azure resource id.
    :type id: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(self, *, id: str=None, **kwargs) -> None:
        super(ResourceReference, self).__init__(**kwargs)
        self.id = id


class SysctlConfig(Model):
    """Sysctl settings for Linux agent nodes.

    :param net_core_somaxconn: Sysctl setting net.core.somaxconn.
    :type net_core_somaxconn: int
    :param net_core_netdev_max_backlog: Sysctl setting
     net.core.netdev_max_backlog.
    :type net_core_netdev_max_backlog: int
    :param net_core_rmem_max: Sysctl setting net.core.rmem_max.
    :type net_core_rmem_max: int
    :param net_core_wmem_max: Sysctl setting net.core.wmem_max.
    :type net_core_wmem_max: int
    :param net_core_optmem_max: Sysctl setting net.core.optmem_max.
    :type net_core_optmem_max: int
    :param net_ipv4_tcp_max_syn_backlog: Sysctl setting
     net.ipv4.tcp_max_syn_backlog.
    :type net_ipv4_tcp_max_syn_backlog: int
    :param net_ipv4_tcp_max_tw_buckets: Sysctl setting
     net.ipv4.tcp_max_tw_buckets.
    :type net_ipv4_tcp_max_tw_buckets: int
    :param net_ipv4_tcp_fin_timeout: Sysctl setting net.ipv4.tcp_fin_timeout.
    :type net_ipv4_tcp_fin_timeout: int
    :param net_ipv4_tcp_keepalive_time: Sysctl setting
     net.ipv4.tcp_keepalive_time.
    :type net_ipv4_tcp_keepalive_time: int
    :param net_ipv4_tcp_keepalive_probes: Sysctl setting
     net.ipv4.tcp_keepalive_probes.
    :type net_ipv4_tcp_keepalive_probes: int
    :param net_ipv4_tcpkeepalive_intvl: Sysctl setting
     net.ipv4.tcp_keepalive_intvl.
    :type net_ipv4_tcpkeepalive_intvl: int
    :param net_ipv4_tcp_rmem: Sysctl setting net.ipv4.tcp_rmem.
    :type net_ipv4_tcp_rmem: int
    :param net_ipv4_tcp_wmem: Sysctl setting net.ipv4.tcp_wmem.
    :type net_ipv4_tcp_wmem: int
    :param net_ipv4_tcp_tw_reuse: Sysctl setting net.ipv4.tcp_tw_reuse.
    :type net_ipv4_tcp_tw_reuse: bool
    :param net_ipv4_ip_local_port_range: Sysctl setting
     net.ipv4.ip_local_port_range.
    :type net_ipv4_ip_local_port_range: str
    :param net_ipv4_neigh_default_gc_thresh1: Sysctl setting
     net.ipv4.neigh.default.gc_thresh1.
    :type net_ipv4_neigh_default_gc_thresh1: int
    :param net_ipv4_neigh_default_gc_thresh2: Sysctl setting
     net.ipv4.neigh.default.gc_thresh2.
    :type net_ipv4_neigh_default_gc_thresh2: int
    :param net_ipv4_neigh_default_gc_thresh3: Sysctl setting
     net.ipv4.neigh.default.gc_thresh3.
    :type net_ipv4_neigh_default_gc_thresh3: int
    :param net_netfilter_nf_conntrack_max: Sysctl setting
     net.netfilter.nf_conntrack_max.
    :type net_netfilter_nf_conntrack_max: int
    :param net_netfilter_nf_conntrack_buckets: Sysctl setting
     net.netfilter.nf_conntrack_buckets.
    :type net_netfilter_nf_conntrack_buckets: int
    :param fs_inotify_max_user_watches: Sysctl setting
     fs.inotify.max_user_watches.
    :type fs_inotify_max_user_watches: int
    :param fs_file_max: Sysctl setting fs.file-max.
    :type fs_file_max: int
    :param fs_aio_max_nr: Sysctl setting fs.aio-max-nr.
    :type fs_aio_max_nr: int
    :param fs_nr_open: Sysctl setting fs.nr_open.
    :type fs_nr_open: int
    :param kernel_threads_max: Sysctl setting kernel.threads-max.
    :type kernel_threads_max: int
    :param vm_max_map_count: Sysctl setting vm.max_map_count.
    :type vm_max_map_count: int
    :param vm_swappiness: Sysctl setting vm.swappiness.
    :type vm_swappiness: int
    :param vm_vfs_cache_pressure: Sysctl setting vm.vfs_cache_pressure.
    :type vm_vfs_cache_pressure: int
    """

    _attribute_map = {
        'net_core_somaxconn': {'key': 'netCoreSomaxconn', 'type': 'int'},
        'net_core_netdev_max_backlog': {'key': 'netCoreNetdevMaxBacklog', 'type': 'int'},
        'net_core_rmem_max': {'key': 'netCoreRmemMax', 'type': 'int'},
        'net_core_wmem_max': {'key': 'netCoreWmemMax', 'type': 'int'},
        'net_core_optmem_max': {'key': 'netCoreOptmemMax', 'type': 'int'},
        'net_ipv4_tcp_max_syn_backlog': {'key': 'netIpv4TcpMaxSynBacklog', 'type': 'int'},
        'net_ipv4_tcp_max_tw_buckets': {'key': 'netIpv4TcpMaxTwBuckets', 'type': 'int'},
        'net_ipv4_tcp_fin_timeout': {'key': 'netIpv4TcpFinTimeout', 'type': 'int'},
        'net_ipv4_tcp_keepalive_time': {'key': 'netIpv4TcpKeepaliveTime', 'type': 'int'},
        'net_ipv4_tcp_keepalive_probes': {'key': 'netIpv4TcpKeepaliveProbes', 'type': 'int'},
        'net_ipv4_tcpkeepalive_intvl': {'key': 'netIpv4TcpkeepaliveIntvl', 'type': 'int'},
        'net_ipv4_tcp_rmem': {'key': 'netIpv4TcpRmem', 'type': 'int'},
        'net_ipv4_tcp_wmem': {'key': 'netIpv4TcpWmem', 'type': 'int'},
        'net_ipv4_tcp_tw_reuse': {'key': 'netIpv4TcpTwReuse', 'type': 'bool'},
        'net_ipv4_ip_local_port_range': {'key': 'netIpv4IpLocalPortRange', 'type': 'str'},
        'net_ipv4_neigh_default_gc_thresh1': {'key': 'netIpv4NeighDefaultGcThresh1', 'type': 'int'},
        'net_ipv4_neigh_default_gc_thresh2': {'key': 'netIpv4NeighDefaultGcThresh2', 'type': 'int'},
        'net_ipv4_neigh_default_gc_thresh3': {'key': 'netIpv4NeighDefaultGcThresh3', 'type': 'int'},
        'net_netfilter_nf_conntrack_max': {'key': 'netNetfilterNfConntrackMax', 'type': 'int'},
        'net_netfilter_nf_conntrack_buckets': {'key': 'netNetfilterNfConntrackBuckets', 'type': 'int'},
        'fs_inotify_max_user_watches': {'key': 'fsInotifyMaxUserWatches', 'type': 'int'},
        'fs_file_max': {'key': 'fsFileMax', 'type': 'int'},
        'fs_aio_max_nr': {'key': 'fsAioMaxNr', 'type': 'int'},
        'fs_nr_open': {'key': 'fsNrOpen', 'type': 'int'},
        'kernel_threads_max': {'key': 'kernelThreadsMax', 'type': 'int'},
        'vm_max_map_count': {'key': 'vmMaxMapCount', 'type': 'int'},
        'vm_swappiness': {'key': 'vmSwappiness', 'type': 'int'},
        'vm_vfs_cache_pressure': {'key': 'vmVfsCachePressure', 'type': 'int'},
    }

    def __init__(self, *, net_core_somaxconn: int=None, net_core_netdev_max_backlog: int=None, net_core_rmem_max: int=None, net_core_wmem_max: int=None, net_core_optmem_max: int=None, net_ipv4_tcp_max_syn_backlog: int=None, net_ipv4_tcp_max_tw_buckets: int=None, net_ipv4_tcp_fin_timeout: int=None, net_ipv4_tcp_keepalive_time: int=None, net_ipv4_tcp_keepalive_probes: int=None, net_ipv4_tcpkeepalive_intvl: int=None, net_ipv4_tcp_rmem: int=None, net_ipv4_tcp_wmem: int=None, net_ipv4_tcp_tw_reuse: bool=None, net_ipv4_ip_local_port_range: str=None, net_ipv4_neigh_default_gc_thresh1: int=None, net_ipv4_neigh_default_gc_thresh2: int=None, net_ipv4_neigh_default_gc_thresh3: int=None, net_netfilter_nf_conntrack_max: int=None, net_netfilter_nf_conntrack_buckets: int=None, fs_inotify_max_user_watches: int=None, fs_file_max: int=None, fs_aio_max_nr: int=None, fs_nr_open: int=None, kernel_threads_max: int=None, vm_max_map_count: int=None, vm_swappiness: int=None, vm_vfs_cache_pressure: int=None, **kwargs) -> None:
        super(SysctlConfig, self).__init__(**kwargs)
        self.net_core_somaxconn = net_core_somaxconn
        self.net_core_netdev_max_backlog = net_core_netdev_max_backlog
        self.net_core_rmem_max = net_core_rmem_max
        self.net_core_wmem_max = net_core_wmem_max
        self.net_core_optmem_max = net_core_optmem_max
        self.net_ipv4_tcp_max_syn_backlog = net_ipv4_tcp_max_syn_backlog
        self.net_ipv4_tcp_max_tw_buckets = net_ipv4_tcp_max_tw_buckets
        self.net_ipv4_tcp_fin_timeout = net_ipv4_tcp_fin_timeout
        self.net_ipv4_tcp_keepalive_time = net_ipv4_tcp_keepalive_time
        self.net_ipv4_tcp_keepalive_probes = net_ipv4_tcp_keepalive_probes
        self.net_ipv4_tcpkeepalive_intvl = net_ipv4_tcpkeepalive_intvl
        self.net_ipv4_tcp_rmem = net_ipv4_tcp_rmem
        self.net_ipv4_tcp_wmem = net_ipv4_tcp_wmem
        self.net_ipv4_tcp_tw_reuse = net_ipv4_tcp_tw_reuse
        self.net_ipv4_ip_local_port_range = net_ipv4_ip_local_port_range
        self.net_ipv4_neigh_default_gc_thresh1 = net_ipv4_neigh_default_gc_thresh1
        self.net_ipv4_neigh_default_gc_thresh2 = net_ipv4_neigh_default_gc_thresh2
        self.net_ipv4_neigh_default_gc_thresh3 = net_ipv4_neigh_default_gc_thresh3
        self.net_netfilter_nf_conntrack_max = net_netfilter_nf_conntrack_max
        self.net_netfilter_nf_conntrack_buckets = net_netfilter_nf_conntrack_buckets
        self.fs_inotify_max_user_watches = fs_inotify_max_user_watches
        self.fs_file_max = fs_file_max
        self.fs_aio_max_nr = fs_aio_max_nr
        self.fs_nr_open = fs_nr_open
        self.kernel_threads_max = kernel_threads_max
        self.vm_max_map_count = vm_max_map_count
        self.vm_swappiness = vm_swappiness
        self.vm_vfs_cache_pressure = vm_vfs_cache_pressure


class TagsObject(Model):
    """Tags object for patch operations.

    :param tags: Resource tags.
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, *, tags=None, **kwargs) -> None:
        super(TagsObject, self).__init__(**kwargs)
        self.tags = tags
