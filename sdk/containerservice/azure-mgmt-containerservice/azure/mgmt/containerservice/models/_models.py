# pylint: disable=line-too-long,useless-suppression,too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
# pylint: disable=useless-super-delegation

import datetime
from typing import Any, Mapping, Optional, TYPE_CHECKING, Union, overload

from .._utils.model_base import Model as _Model, rest_field

if TYPE_CHECKING:
    from .. import models as _models


class AbsoluteMonthlySchedule(_Model):
    """For schedules like: 'recur every month on the 15th' or 'recur every 3 months on the 20th'.

    :ivar interval_months: Specifies the number of months between each set of occurrences.
     Required.
    :vartype interval_months: int
    :ivar day_of_month: The date of the month. Required.
    :vartype day_of_month: int
    """

    interval_months: int = rest_field(name="intervalMonths", visibility=["read", "create", "update", "delete", "query"])
    """Specifies the number of months between each set of occurrences. Required."""
    day_of_month: int = rest_field(name="dayOfMonth", visibility=["read", "create", "update", "delete", "query"])
    """The date of the month. Required."""

    @overload
    def __init__(
        self,
        *,
        interval_months: int,
        day_of_month: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AccessProfile(_Model):
    """Profile for enabling a user to access a managed cluster.

    :ivar kube_config: Base64-encoded Kubernetes configuration file.
    :vartype kube_config: bytes
    """

    kube_config: Optional[bytes] = rest_field(
        name="kubeConfig", visibility=["read", "create", "update", "delete", "query"], format="base64"
    )
    """Base64-encoded Kubernetes configuration file."""

    @overload
    def __init__(
        self,
        *,
        kube_config: Optional[bytes] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AdvancedNetworking(_Model):
    """Advanced Networking profile for enabling observability and security feature suite on a cluster.
    For more information see aka.ms/aksadvancednetworking.

    :ivar enabled: Indicates the enablement of Advanced Networking functionalities of observability
     and security on AKS clusters. When this is set to true, all observability and security features
     will be set to enabled unless explicitly disabled. If not specified, the default is false.
    :vartype enabled: bool
    :ivar observability: Observability profile to enable advanced network metrics and flow logs
     with historical contexts.
    :vartype observability: ~azure.mgmt.containerservice.models.AdvancedNetworkingObservability
    :ivar security: Security profile to enable security features on cilium based cluster.
    :vartype security: ~azure.mgmt.containerservice.models.AdvancedNetworkingSecurity
    :ivar performance: Profile to enable performance-enhancing features on clusters that use Azure
     CNI powered by Cilium.
    :vartype performance: ~azure.mgmt.containerservice.models.AdvancedNetworkingPerformance
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Indicates the enablement of Advanced Networking functionalities of observability and security
     on AKS clusters. When this is set to true, all observability and security features will be set
     to enabled unless explicitly disabled. If not specified, the default is false."""
    observability: Optional["_models.AdvancedNetworkingObservability"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Observability profile to enable advanced network metrics and flow logs with historical
     contexts."""
    security: Optional["_models.AdvancedNetworkingSecurity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Security profile to enable security features on cilium based cluster."""
    performance: Optional["_models.AdvancedNetworkingPerformance"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Profile to enable performance-enhancing features on clusters that use Azure CNI powered by
     Cilium."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        observability: Optional["_models.AdvancedNetworkingObservability"] = None,
        security: Optional["_models.AdvancedNetworkingSecurity"] = None,
        performance: Optional["_models.AdvancedNetworkingPerformance"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AdvancedNetworkingObservability(_Model):
    """Observability profile to enable advanced network metrics and flow logs with historical
    contexts.

    :ivar enabled: Indicates the enablement of Advanced Networking observability functionalities on
     clusters.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Indicates the enablement of Advanced Networking observability functionalities on clusters."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AdvancedNetworkingPerformance(_Model):
    """Profile to enable performance-enhancing features on clusters that use Azure CNI powered by
    Cilium.

    :ivar acceleration_mode: Enable advanced network acceleration options. This allows users to
     configure acceleration using BPF host routing. This can be enabled only with Cilium dataplane.
     If not specified, the default value is None (no acceleration). The acceleration mode can be
     changed on a pre-existing cluster. See `https://aka.ms/acnsperformance
     <https://aka.ms/acnsperformance>`_ for a detailed explanation. Known values are: "BpfVeth" and
     "None".
    :vartype acceleration_mode: str or ~azure.mgmt.containerservice.models.AccelerationMode
    """

    acceleration_mode: Optional[Union[str, "_models.AccelerationMode"]] = rest_field(
        name="accelerationMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable advanced network acceleration options. This allows users to configure acceleration using
     BPF host routing. This can be enabled only with Cilium dataplane. If not specified, the default
     value is None (no acceleration). The acceleration mode can be changed on a pre-existing
     cluster. See `https://aka.ms/acnsperformance <https://aka.ms/acnsperformance>`_ for a detailed
     explanation. Known values are: \"BpfVeth\" and \"None\"."""

    @overload
    def __init__(
        self,
        *,
        acceleration_mode: Optional[Union[str, "_models.AccelerationMode"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AdvancedNetworkingSecurity(_Model):
    """Security profile to enable security features on cilium based cluster.

    :ivar enabled: This feature allows user to configure network policy based on DNS (FQDN) names.
     It can be enabled only on cilium based clusters. If not specified, the default is false.
    :vartype enabled: bool
    :ivar advanced_network_policies: Enable advanced network policies. This allows users to
     configure Layer 7 network policies (FQDN, HTTP, Kafka). Policies themselves must be configured
     via the Cilium Network Policy resources, see
     `https://docs.cilium.io/en/latest/security/policy/index.html
     <https://docs.cilium.io/en/latest/security/policy/index.html>`_. This can be enabled only on
     cilium-based clusters. If not specified, the default value is FQDN if security.enabled is set
     to true. Known values are: "L7", "FQDN", and "None".
    :vartype advanced_network_policies: str or
     ~azure.mgmt.containerservice.models.AdvancedNetworkPolicies
    :ivar transit_encryption: Encryption configuration for Cilium-based clusters. Once enabled all
     traffic between Cilium managed pods will be encrypted when it leaves the node boundary.
    :vartype transit_encryption:
     ~azure.mgmt.containerservice.models.AdvancedNetworkingSecurityTransitEncryption
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """This feature allows user to configure network policy based on DNS (FQDN) names. It can be
     enabled only on cilium based clusters. If not specified, the default is false."""
    advanced_network_policies: Optional[Union[str, "_models.AdvancedNetworkPolicies"]] = rest_field(
        name="advancedNetworkPolicies", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable advanced network policies. This allows users to configure Layer 7 network policies
     (FQDN, HTTP, Kafka). Policies themselves must be configured via the Cilium Network Policy
     resources, see `https://docs.cilium.io/en/latest/security/policy/index.html
     <https://docs.cilium.io/en/latest/security/policy/index.html>`_. This can be enabled only on
     cilium-based clusters. If not specified, the default value is FQDN if security.enabled is set
     to true. Known values are: \"L7\", \"FQDN\", and \"None\"."""
    transit_encryption: Optional["_models.AdvancedNetworkingSecurityTransitEncryption"] = rest_field(
        name="transitEncryption", visibility=["read", "create", "update", "delete", "query"]
    )
    """Encryption configuration for Cilium-based clusters. Once enabled all traffic between Cilium
     managed pods will be encrypted when it leaves the node boundary."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        advanced_network_policies: Optional[Union[str, "_models.AdvancedNetworkPolicies"]] = None,
        transit_encryption: Optional["_models.AdvancedNetworkingSecurityTransitEncryption"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AdvancedNetworkingSecurityTransitEncryption(_Model):  # pylint: disable=name-too-long
    """Encryption configuration for Cilium-based clusters. Once enabled all traffic between Cilium
    managed pods will be encrypted when it leaves the node boundary.

    :ivar type: Configures pod-to-pod encryption. This can be enabled only on Cilium-based
     clusters. If not specified, the default value is None. Known values are: "WireGuard" and
     "None".
    :vartype type: str or ~azure.mgmt.containerservice.models.TransitEncryptionType
    """

    type: Optional[Union[str, "_models.TransitEncryptionType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Configures pod-to-pod encryption. This can be enabled only on Cilium-based clusters. If not
     specified, the default value is None. Known values are: \"WireGuard\" and \"None\"."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.TransitEncryptionType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Resource(_Model):
    """Resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}."""
    name: Optional[str] = rest_field(visibility=["read"])
    """The name of the resource."""
    type: Optional[str] = rest_field(visibility=["read"])
    """The type of the resource. E.g. \"Microsoft.Compute/virtualMachines\" or
     \"Microsoft.Storage/storageAccounts\"."""
    system_data: Optional["_models.SystemData"] = rest_field(name="systemData", visibility=["read"])
    """Azure Resource Manager metadata containing createdBy and modifiedBy information."""


class ProxyResource(Resource):
    """Proxy Resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    """


class AgentPool(ProxyResource):
    """Agent Pool.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: Properties of an agent pool.
    :vartype properties:
     ~azure.mgmt.containerservice.models.ManagedClusterAgentPoolProfileProperties
    """

    properties: Optional["_models.ManagedClusterAgentPoolProfileProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of an agent pool."""

    __flattened_items = [
        "e_tag",
        "count",
        "vm_size",
        "os_disk_size_gb",
        "os_disk_type",
        "kubelet_disk_type",
        "workload_runtime",
        "message_of_the_day",
        "vnet_subnet_id",
        "pod_subnet_id",
        "pod_ip_allocation_mode",
        "max_pods",
        "os_type",
        "os_sku",
        "max_count",
        "min_count",
        "enable_auto_scaling",
        "scale_down_mode",
        "type",
        "mode",
        "orchestrator_version",
        "current_orchestrator_version",
        "node_image_version",
        "upgrade_strategy",
        "upgrade_settings",
        "upgrade_settings_blue_green",
        "provisioning_state",
        "power_state",
        "availability_zones",
        "enable_node_public_ip",
        "node_public_ip_prefix_id",
        "scale_set_priority",
        "scale_set_eviction_policy",
        "spot_max_price",
        "tags",
        "node_labels",
        "node_taints",
        "node_initialization_taints",
        "proximity_placement_group_id",
        "kubelet_config",
        "linux_os_config",
        "enable_encryption_at_host",
        "enable_ultra_ssd",
        "enable_fips",
        "gpu_instance_profile",
        "creation_data",
        "capacity_reservation_group_id",
        "host_group_id",
        "network_profile",
        "windows_profile",
        "security_profile",
        "gpu_profile",
        "gateway_profile",
        "artifact_streaming_profile",
        "virtual_machines_profile",
        "virtual_machine_nodes_status",
        "status",
        "local_dns_profile",
        "node_customization_profile",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ManagedClusterAgentPoolProfileProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class AgentPoolArtifactStreamingProfile(_Model):
    """AgentPoolArtifactStreamingProfile.

    :ivar enabled: Artifact streaming speeds up the cold-start of containers on a node through
     on-demand image loading. To use this feature, container images must also enable artifact
     streaming on ACR. If not specified, the default is false.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Artifact streaming speeds up the cold-start of containers on a node through on-demand image
     loading. To use this feature, container images must also enable artifact streaming on ACR. If
     not specified, the default is false."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolAvailableVersions(_Model):
    """The list of available versions for an agent pool.

    :ivar id: The ID of the agent pool version list.
    :vartype id: str
    :ivar name: The name of the agent pool version list.
    :vartype name: str
    :ivar type: Type of the agent pool version list.
    :vartype type: str
    :ivar properties: Properties of agent pool available versions. Required.
    :vartype properties: ~azure.mgmt.containerservice.models.AgentPoolAvailableVersionsProperties
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """The ID of the agent pool version list."""
    name: Optional[str] = rest_field(visibility=["read"])
    """The name of the agent pool version list."""
    type: Optional[str] = rest_field(visibility=["read"])
    """Type of the agent pool version list."""
    properties: "_models.AgentPoolAvailableVersionsProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of agent pool available versions. Required."""

    __flattened_items = ["agent_pool_versions"]

    @overload
    def __init__(
        self,
        *,
        properties: "_models.AgentPoolAvailableVersionsProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class AgentPoolAvailableVersionsProperties(_Model):
    """The list of available agent pool versions.

    :ivar agent_pool_versions: List of versions available for agent pool.
    :vartype agent_pool_versions:
     list[~azure.mgmt.containerservice.models.AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem]
    """

    agent_pool_versions: Optional[list["_models.AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem"]] = (
        rest_field(name="agentPoolVersions", visibility=["read", "create", "update", "delete", "query"])
    )
    """List of versions available for agent pool."""

    @overload
    def __init__(
        self,
        *,
        agent_pool_versions: Optional[list["_models.AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem(_Model):  # pylint: disable=name-too-long
    """AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem.

    :ivar default: Whether this version is the default agent pool version.
    :vartype default: bool
    :ivar kubernetes_version: The Kubernetes version (major.minor.patch).
    :vartype kubernetes_version: str
    :ivar is_preview: Whether Kubernetes version is currently in preview.
    :vartype is_preview: bool
    """

    default: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether this version is the default agent pool version."""
    kubernetes_version: Optional[str] = rest_field(
        name="kubernetesVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Kubernetes version (major.minor.patch)."""
    is_preview: Optional[bool] = rest_field(
        name="isPreview", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether Kubernetes version is currently in preview."""

    @overload
    def __init__(
        self,
        *,
        default: Optional[bool] = None,
        kubernetes_version: Optional[str] = None,
        is_preview: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolBlueGreenUpgradeSettings(_Model):
    """Settings for blue-green upgrade on an agentpool.

    :ivar drain_batch_size: The number or percentage of nodes to drain in batch during blue-green
     upgrade. Must be a non-zero number. This can either be set to an integer (e.g. '5') or a
     percentage (e.g. '50%'). If a percentage is specified, it is the percentage of the total number
     of blue nodes of the initial upgrade operation. For percentages, fractional nodes are rounded
     up. If not specified, the default is 10%. For more information, including best practices, see:
     `https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
     <https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster>`_.
    :vartype drain_batch_size: str
    :ivar drain_timeout_in_minutes: The drain timeout for a node, i.e., the amount of time (in
     minutes) to wait on eviction of pods and graceful termination per node. This eviction wait time
     honors waiting on pod disruption budgets. If this time is exceeded, the upgrade fails. If not
     specified, the default is 30 minutes.
    :vartype drain_timeout_in_minutes: int
    :ivar batch_soak_duration_in_minutes: The soak duration after draining a batch of nodes, i.e.,
     the amount of time (in minutes) to wait after draining a batch of nodes before moving on the
     next batch. If not specified, the default is 15 minutes.
    :vartype batch_soak_duration_in_minutes: int
    :ivar final_soak_duration_in_minutes: The soak duration for a node pool, i.e., the amount of
     time (in minutes) to wait after all old nodes are drained before we remove the old nodes. If
     not specified, the default is 60 minutes. Only applicable for blue-green upgrade strategy.
    :vartype final_soak_duration_in_minutes: int
    """

    drain_batch_size: Optional[str] = rest_field(
        name="drainBatchSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The number or percentage of nodes to drain in batch during blue-green upgrade. Must be a
     non-zero number. This can either be set to an integer (e.g. '5') or a percentage (e.g. '50%').
     If a percentage is specified, it is the percentage of the total number of blue nodes of the
     initial upgrade operation. For percentages, fractional nodes are rounded up. If not specified,
     the default is 10%. For more information, including best practices, see:
     `https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
     <https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster>`_."""
    drain_timeout_in_minutes: Optional[int] = rest_field(
        name="drainTimeoutInMinutes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The drain timeout for a node, i.e., the amount of time (in minutes) to wait on eviction of pods
     and graceful termination per node. This eviction wait time honors waiting on pod disruption
     budgets. If this time is exceeded, the upgrade fails. If not specified, the default is 30
     minutes."""
    batch_soak_duration_in_minutes: Optional[int] = rest_field(
        name="batchSoakDurationInMinutes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The soak duration after draining a batch of nodes, i.e., the amount of time (in minutes) to
     wait after draining a batch of nodes before moving on the next batch. If not specified, the
     default is 15 minutes."""
    final_soak_duration_in_minutes: Optional[int] = rest_field(
        name="finalSoakDurationInMinutes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The soak duration for a node pool, i.e., the amount of time (in minutes) to wait after all old
     nodes are drained before we remove the old nodes. If not specified, the default is 60 minutes.
     Only applicable for blue-green upgrade strategy."""

    @overload
    def __init__(
        self,
        *,
        drain_batch_size: Optional[str] = None,
        drain_timeout_in_minutes: Optional[int] = None,
        batch_soak_duration_in_minutes: Optional[int] = None,
        final_soak_duration_in_minutes: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolDeleteMachinesParameter(_Model):
    """Specifies a list of machine names from the agent pool to be deleted.

    :ivar machine_names: The agent pool machine names. Required.
    :vartype machine_names: list[str]
    """

    machine_names: list[str] = rest_field(
        name="machineNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """The agent pool machine names. Required."""

    @overload
    def __init__(
        self,
        *,
        machine_names: list[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolGatewayProfile(_Model):
    """Profile of the managed cluster gateway agent pool.

    :ivar public_ip_prefix_size: The Gateway agent pool associates one public IPPrefix for each
     static egress gateway to provide public egress. The size of Public IPPrefix should be selected
     by the user. Each node in the agent pool is assigned with one IP from the IPPrefix. The
     IPPrefix size thus serves as a cap on the size of the Gateway agent pool. Due to Azure public
     IPPrefix size limitation, the valid value range is [28, 31] (/31 = 2 nodes/IPs, /30 = 4
     nodes/IPs, /29 = 8 nodes/IPs, /28 = 16 nodes/IPs). The default value is 31.
    :vartype public_ip_prefix_size: int
    """

    public_ip_prefix_size: Optional[int] = rest_field(
        name="publicIPPrefixSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Gateway agent pool associates one public IPPrefix for each static egress gateway to provide
     public egress. The size of Public IPPrefix should be selected by the user. Each node in the
     agent pool is assigned with one IP from the IPPrefix. The IPPrefix size thus serves as a cap on
     the size of the Gateway agent pool. Due to Azure public IPPrefix size limitation, the valid
     value range is [28, 31] (/31 = 2 nodes/IPs, /30 = 4 nodes/IPs, /29 = 8 nodes/IPs, /28 = 16
     nodes/IPs). The default value is 31."""

    @overload
    def __init__(
        self,
        *,
        public_ip_prefix_size: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolNetworkProfile(_Model):
    """Network settings of an agent pool.

    :ivar node_public_ip_tags: IPTags of instance-level public IPs.
    :vartype node_public_ip_tags: list[~azure.mgmt.containerservice.models.IPTag]
    :ivar allowed_host_ports: The port ranges that are allowed to access. The specified ranges are
     allowed to overlap.
    :vartype allowed_host_ports: list[~azure.mgmt.containerservice.models.PortRange]
    :ivar application_security_groups: The IDs of the application security groups which agent pool
     will associate when created.
    :vartype application_security_groups: list[str]
    """

    node_public_ip_tags: Optional[list["_models.IPTag"]] = rest_field(
        name="nodePublicIPTags", visibility=["read", "create", "update", "delete", "query"]
    )
    """IPTags of instance-level public IPs."""
    allowed_host_ports: Optional[list["_models.PortRange"]] = rest_field(
        name="allowedHostPorts", visibility=["read", "create", "update", "delete", "query"]
    )
    """The port ranges that are allowed to access. The specified ranges are allowed to overlap."""
    application_security_groups: Optional[list[str]] = rest_field(
        name="applicationSecurityGroups", visibility=["read", "create", "update", "delete", "query"]
    )
    """The IDs of the application security groups which agent pool will associate when created."""

    @overload
    def __init__(
        self,
        *,
        node_public_ip_tags: Optional[list["_models.IPTag"]] = None,
        allowed_host_ports: Optional[list["_models.PortRange"]] = None,
        application_security_groups: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolRecentlyUsedVersion(_Model):
    """A historical version that can be used for rollback operations.

    :ivar orchestrator_version: The Kubernetes version (major.minor.patch) available for rollback.
    :vartype orchestrator_version: str
    :ivar node_image_version: The node image version available for rollback.
    :vartype node_image_version: str
    :ivar timestamp: The timestamp when this version was last used.
    :vartype timestamp: ~datetime.datetime
    """

    orchestrator_version: Optional[str] = rest_field(
        name="orchestratorVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Kubernetes version (major.minor.patch) available for rollback."""
    node_image_version: Optional[str] = rest_field(
        name="nodeImageVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The node image version available for rollback."""
    timestamp: Optional[datetime.datetime] = rest_field(
        visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The timestamp when this version was last used."""

    @overload
    def __init__(
        self,
        *,
        orchestrator_version: Optional[str] = None,
        node_image_version: Optional[str] = None,
        timestamp: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolSecurityProfile(_Model):
    """The security settings of an agent pool.

    :ivar enable_vtpm: vTPM is a Trusted Launch feature for configuring a dedicated secure vault
     for keys and measurements held locally on the node. For more details, see
     aka.ms/aks/trustedlaunch. If not specified, the default is false.
    :vartype enable_vtpm: bool
    :ivar enable_secure_boot: Secure Boot is a feature of Trusted Launch which ensures that only
     signed operating systems and drivers can boot. For more details, see aka.ms/aks/trustedlaunch.
     If not specified, the default is false.
    :vartype enable_secure_boot: bool
    :ivar ssh_access: SSH access method of an agent pool. Known values are: "LocalUser",
     "Disabled", and "EntraId".
    :vartype ssh_access: str or ~azure.mgmt.containerservice.models.AgentPoolSSHAccess
    """

    enable_vtpm: Optional[bool] = rest_field(
        name="enableVTPM", visibility=["read", "create", "update", "delete", "query"]
    )
    """vTPM is a Trusted Launch feature for configuring a dedicated secure vault for keys and
     measurements held locally on the node. For more details, see aka.ms/aks/trustedlaunch. If not
     specified, the default is false."""
    enable_secure_boot: Optional[bool] = rest_field(
        name="enableSecureBoot", visibility=["read", "create", "update", "delete", "query"]
    )
    """Secure Boot is a feature of Trusted Launch which ensures that only signed operating systems and
     drivers can boot. For more details, see aka.ms/aks/trustedlaunch.  If not specified, the
     default is false."""
    ssh_access: Optional[Union[str, "_models.AgentPoolSSHAccess"]] = rest_field(
        name="sshAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """SSH access method of an agent pool. Known values are: \"LocalUser\", \"Disabled\", and
     \"EntraId\"."""

    @overload
    def __init__(
        self,
        *,
        enable_vtpm: Optional[bool] = None,
        enable_secure_boot: Optional[bool] = None,
        ssh_access: Optional[Union[str, "_models.AgentPoolSSHAccess"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolStatus(_Model):
    """Contains read-only information about the Agent Pool.

    :ivar provisioning_error: The error detail information of the agent pool. Preserves the
     detailed info of failure. If there was no error, this field is omitted.
    :vartype provisioning_error: ~azure.mgmt.containerservice.models.ErrorDetail
    """

    provisioning_error: Optional["_models.ErrorDetail"] = rest_field(name="provisioningError", visibility=["read"])
    """The error detail information of the agent pool. Preserves the detailed info of failure. If
     there was no error, this field is omitted."""


class AgentPoolUpgradeProfile(ProxyResource):
    """The list of available upgrades for an agent pool.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: The properties of the agent pool upgrade profile. Required.
    :vartype properties: ~azure.mgmt.containerservice.models.AgentPoolUpgradeProfileProperties
    """

    properties: "_models.AgentPoolUpgradeProfileProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the agent pool upgrade profile. Required."""

    __flattened_items = [
        "kubernetes_version",
        "os_type",
        "upgrades",
        "components_by_releases",
        "recently_used_versions",
        "latest_node_image_version",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: "_models.AgentPoolUpgradeProfileProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class AgentPoolUpgradeProfileProperties(_Model):
    """The list of available upgrade versions.

    :ivar kubernetes_version: The Kubernetes version (major.minor.patch). Required.
    :vartype kubernetes_version: str
    :ivar os_type: The operating system type. The default is Linux. Required. Known values are:
     "Linux" and "Windows".
    :vartype os_type: str or ~azure.mgmt.containerservice.models.OSType
    :ivar upgrades: List of orchestrator types and versions available for upgrade.
    :vartype upgrades:
     list[~azure.mgmt.containerservice.models.AgentPoolUpgradeProfilePropertiesUpgradesItem]
    :ivar components_by_releases: List of components grouped by kubernetes major.minor version.
    :vartype components_by_releases: list[~azure.mgmt.containerservice.models.ComponentsByRelease]
    :ivar recently_used_versions: List of historical good versions for rollback operations.
    :vartype recently_used_versions:
     list[~azure.mgmt.containerservice.models.AgentPoolRecentlyUsedVersion]
    :ivar latest_node_image_version: The latest AKS supported node image version.
    :vartype latest_node_image_version: str
    """

    kubernetes_version: str = rest_field(
        name="kubernetesVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Kubernetes version (major.minor.patch). Required."""
    os_type: Union[str, "_models.OSType"] = rest_field(
        name="osType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The operating system type. The default is Linux. Required. Known values are: \"Linux\" and
     \"Windows\"."""
    upgrades: Optional[list["_models.AgentPoolUpgradeProfilePropertiesUpgradesItem"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """List of orchestrator types and versions available for upgrade."""
    components_by_releases: Optional[list["_models.ComponentsByRelease"]] = rest_field(
        name="componentsByReleases", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of components grouped by kubernetes major.minor version."""
    recently_used_versions: Optional[list["_models.AgentPoolRecentlyUsedVersion"]] = rest_field(
        name="recentlyUsedVersions", visibility=["read"]
    )
    """List of historical good versions for rollback operations."""
    latest_node_image_version: Optional[str] = rest_field(
        name="latestNodeImageVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The latest AKS supported node image version."""

    @overload
    def __init__(
        self,
        *,
        kubernetes_version: str,
        os_type: Union[str, "_models.OSType"],
        upgrades: Optional[list["_models.AgentPoolUpgradeProfilePropertiesUpgradesItem"]] = None,
        components_by_releases: Optional[list["_models.ComponentsByRelease"]] = None,
        latest_node_image_version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolUpgradeProfilePropertiesUpgradesItem(_Model):  # pylint: disable=name-too-long
    """AgentPoolUpgradeProfilePropertiesUpgradesItem.

    :ivar kubernetes_version: The Kubernetes version (major.minor.patch).
    :vartype kubernetes_version: str
    :ivar is_preview: Whether the Kubernetes version is currently in preview.
    :vartype is_preview: bool
    :ivar is_out_of_support: Whether the Kubernetes version is out of support.
    :vartype is_out_of_support: bool
    """

    kubernetes_version: Optional[str] = rest_field(
        name="kubernetesVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Kubernetes version (major.minor.patch)."""
    is_preview: Optional[bool] = rest_field(
        name="isPreview", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether the Kubernetes version is currently in preview."""
    is_out_of_support: Optional[bool] = rest_field(
        name="isOutOfSupport", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether the Kubernetes version is out of support."""

    @overload
    def __init__(
        self,
        *,
        kubernetes_version: Optional[str] = None,
        is_preview: Optional[bool] = None,
        is_out_of_support: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolUpgradeSettings(_Model):
    """Settings for upgrading an agentpool.

    :ivar max_surge: The maximum number or percentage of nodes that are surged during upgrade. This
     can either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is
     specified, it is the percentage of the total agent pool size at the time of the upgrade. For
     percentages, fractional nodes are rounded up. If not specified, the default is 10%. For more
     information, including best practices, see:
     `https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
     <https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster>`_.
    :vartype max_surge: str
    :ivar max_unavailable: The maximum number or percentage of nodes that can be simultaneously
     unavailable during upgrade. This can either be set to an integer (e.g. '1') or a percentage
     (e.g. '5%'). If a percentage is specified, it is the percentage of the total agent pool size at
     the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified,
     the default is 0. For more information, including best practices, see:
     `https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
     <https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster>`_.
    :vartype max_unavailable: str
    :ivar max_blocked_nodes: The maximum number or percentage of extra nodes that are allowed to be
     blocked in the agent pool during an upgrade when undrainable node behavior is Cordon. This can
     either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is
     specified, it is the percentage of the total agent pool size at the time of the upgrade. For
     percentages, fractional nodes are rounded up. If not specified, the default is maxSurge. This
     must always be greater than or equal to maxSurge. For more information, including best
     practices, see: `https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
     <https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster>`_.
    :vartype max_blocked_nodes: str
    :ivar drain_timeout_in_minutes: The drain timeout for a node. The amount of time (in minutes)
     to wait on eviction of pods and graceful termination per node. This eviction wait time honors
     waiting on pod disruption budgets. If this time is exceeded, the upgrade fails. If not
     specified, the default is 30 minutes.
    :vartype drain_timeout_in_minutes: int
    :ivar node_soak_duration_in_minutes: The soak duration for a node. The amount of time (in
     minutes) to wait after draining a node and before reimaging it and moving on to next node. If
     not specified, the default is 0 minutes.
    :vartype node_soak_duration_in_minutes: int
    :ivar undrainable_node_behavior: Defines the behavior for undrainable nodes during upgrade. The
     most common cause of undrainable nodes is Pod Disruption Budgets (PDBs), but other issues, such
     as pod termination grace period is exceeding the remaining per-node drain timeout or pod is
     still being in a running state, can also cause undrainable nodes. Known values are: "Cordon"
     and "Schedule".
    :vartype undrainable_node_behavior: str or
     ~azure.mgmt.containerservice.models.UndrainableNodeBehavior
    """

    max_surge: Optional[str] = rest_field(name="maxSurge", visibility=["read", "create", "update", "delete", "query"])
    """The maximum number or percentage of nodes that are surged during upgrade. This can either be
     set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is
     the percentage of the total agent pool size at the time of the upgrade. For percentages,
     fractional nodes are rounded up. If not specified, the default is 10%. For more information,
     including best practices, see: `https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
     <https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster>`_."""
    max_unavailable: Optional[str] = rest_field(
        name="maxUnavailable", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number or percentage of nodes that can be simultaneously unavailable during
     upgrade. This can either be set to an integer (e.g. '1') or a percentage (e.g. '5%'). If a
     percentage is specified, it is the percentage of the total agent pool size at the time of the
     upgrade. For percentages, fractional nodes are rounded up. If not specified, the default is 0.
     For more information, including best practices, see:
     `https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
     <https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster>`_."""
    max_blocked_nodes: Optional[str] = rest_field(
        name="maxBlockedNodes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number or percentage of extra nodes that are allowed to be blocked in the agent
     pool during an upgrade when undrainable node behavior is Cordon. This can either be set to an
     integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is the
     percentage of the total agent pool size at the time of the upgrade. For percentages, fractional
     nodes are rounded up. If not specified, the default is maxSurge. This must always be greater
     than or equal to maxSurge. For more information, including best practices, see:
     `https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
     <https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster>`_."""
    drain_timeout_in_minutes: Optional[int] = rest_field(
        name="drainTimeoutInMinutes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The drain timeout for a node. The amount of time (in minutes) to wait on eviction of pods and
     graceful termination per node. This eviction wait time honors waiting on pod disruption
     budgets. If this time is exceeded, the upgrade fails. If not specified, the default is 30
     minutes."""
    node_soak_duration_in_minutes: Optional[int] = rest_field(
        name="nodeSoakDurationInMinutes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The soak duration for a node. The amount of time (in minutes) to wait after draining a node and
     before reimaging it and moving on to next node. If not specified, the default is 0 minutes."""
    undrainable_node_behavior: Optional[Union[str, "_models.UndrainableNodeBehavior"]] = rest_field(
        name="undrainableNodeBehavior", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines the behavior for undrainable nodes during upgrade. The most common cause of undrainable
     nodes is Pod Disruption Budgets (PDBs), but other issues, such as pod termination grace period
     is exceeding the remaining per-node drain timeout or pod is still being in a running state, can
     also cause undrainable nodes. Known values are: \"Cordon\" and \"Schedule\"."""

    @overload
    def __init__(
        self,
        *,
        max_surge: Optional[str] = None,
        max_unavailable: Optional[str] = None,
        max_blocked_nodes: Optional[str] = None,
        drain_timeout_in_minutes: Optional[int] = None,
        node_soak_duration_in_minutes: Optional[int] = None,
        undrainable_node_behavior: Optional[Union[str, "_models.UndrainableNodeBehavior"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AgentPoolWindowsProfile(_Model):
    """The Windows agent pool's specific profile.

    :ivar disable_outbound_nat: Whether to disable OutboundNAT in windows nodes. The default value
     is false. Outbound NAT can only be disabled if the cluster outboundType is NAT Gateway and the
     Windows agent pool does not have node public IP enabled.
    :vartype disable_outbound_nat: bool
    """

    disable_outbound_nat: Optional[bool] = rest_field(
        name="disableOutboundNat", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to disable OutboundNAT in windows nodes. The default value is false. Outbound NAT can
     only be disabled if the cluster outboundType is NAT Gateway and the Windows agent pool does not
     have node public IP enabled."""

    @overload
    def __init__(
        self,
        *,
        disable_outbound_nat: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AutoScaleProfile(_Model):
    """Specifications on auto-scaling.

    :ivar size: VM size that AKS will use when creating and scaling e.g. 'Standard_E4s_v3',
     'Standard_E16s_v3' or 'Standard_D16s_v5'.
    :vartype size: str
    :ivar min_count: The minimum number of nodes of the specified sizes.
    :vartype min_count: int
    :ivar max_count: The maximum number of nodes of the specified sizes.
    :vartype max_count: int
    """

    size: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """VM size that AKS will use when creating and scaling e.g. 'Standard_E4s_v3', 'Standard_E16s_v3'
     or 'Standard_D16s_v5'."""
    min_count: Optional[int] = rest_field(name="minCount", visibility=["read", "create", "update", "delete", "query"])
    """The minimum number of nodes of the specified sizes."""
    max_count: Optional[int] = rest_field(name="maxCount", visibility=["read", "create", "update", "delete", "query"])
    """The maximum number of nodes of the specified sizes."""

    @overload
    def __init__(
        self,
        *,
        size: Optional[str] = None,
        min_count: Optional[int] = None,
        max_count: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AzureKeyVaultKms(_Model):
    """Azure Key Vault key management service settings for the security profile.

    :ivar enabled: Whether to enable Azure Key Vault key management service. The default is false.
    :vartype enabled: bool
    :ivar key_id: Identifier of Azure Key Vault key. See `key identifier format
     <https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name>`_
     for more details. When Azure Key Vault key management service is enabled, this field is
     required and must be a valid key identifier. When Azure Key Vault key management service is
     disabled, leave the field empty.
    :vartype key_id: str
    :ivar key_vault_network_access: Network access of the key vault. Network access of key vault.
     The possible values are ``Public`` and ``Private``. ``Public`` means the key vault allows
     public access from all networks. ``Private`` means the key vault disables public access and
     enables private link. The default value is ``Public``. Known values are: "Public" and
     "Private".
    :vartype key_vault_network_access: str or
     ~azure.mgmt.containerservice.models.KeyVaultNetworkAccessTypes
    :ivar key_vault_resource_id: Resource ID of key vault. When keyVaultNetworkAccess is
     ``Private``, this field is required and must be a valid resource ID. When keyVaultNetworkAccess
     is ``Public``, leave the field empty.
    :vartype key_vault_resource_id: str
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable Azure Key Vault key management service. The default is false."""
    key_id: Optional[str] = rest_field(name="keyId", visibility=["read", "create", "update", "delete", "query"])
    """Identifier of Azure Key Vault key. See `key identifier format
     <https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name>`_
     for more details. When Azure Key Vault key management service is enabled, this field is
     required and must be a valid key identifier. When Azure Key Vault key management service is
     disabled, leave the field empty."""
    key_vault_network_access: Optional[Union[str, "_models.KeyVaultNetworkAccessTypes"]] = rest_field(
        name="keyVaultNetworkAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """Network access of the key vault. Network access of key vault. The possible values are
     ``Public`` and ``Private``. ``Public`` means the key vault allows public access from all
     networks. ``Private`` means the key vault disables public access and enables private link. The
     default value is ``Public``. Known values are: \"Public\" and \"Private\"."""
    key_vault_resource_id: Optional[str] = rest_field(
        name="keyVaultResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Resource ID of key vault. When keyVaultNetworkAccess is ``Private``, this field is required and
     must be a valid resource ID. When keyVaultNetworkAccess is ``Public``, leave the field empty."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        key_id: Optional[str] = None,
        key_vault_network_access: Optional[Union[str, "_models.KeyVaultNetworkAccessTypes"]] = None,
        key_vault_resource_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClusterUpgradeSettings(_Model):
    """Settings for upgrading a cluster.

    :ivar override_settings: Settings for overrides.
    :vartype override_settings: ~azure.mgmt.containerservice.models.UpgradeOverrideSettings
    """

    override_settings: Optional["_models.UpgradeOverrideSettings"] = rest_field(
        name="overrideSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for overrides."""

    @overload
    def __init__(
        self,
        *,
        override_settings: Optional["_models.UpgradeOverrideSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommandResultProperties(_Model):
    """The results of a run command.

    :ivar provisioning_state: provisioning State.
    :vartype provisioning_state: str
    :ivar exit_code: The exit code of the command.
    :vartype exit_code: int
    :ivar started_at: The time when the command started.
    :vartype started_at: ~datetime.datetime
    :ivar finished_at: The time when the command finished.
    :vartype finished_at: ~datetime.datetime
    :ivar logs: The command output.
    :vartype logs: str
    :ivar reason: An explanation of why provisioningState is set to failed (if so).
    :vartype reason: str
    """

    provisioning_state: Optional[str] = rest_field(name="provisioningState", visibility=["read"])
    """provisioning State."""
    exit_code: Optional[int] = rest_field(name="exitCode", visibility=["read"])
    """The exit code of the command."""
    started_at: Optional[datetime.datetime] = rest_field(name="startedAt", visibility=["read"], format="rfc3339")
    """The time when the command started."""
    finished_at: Optional[datetime.datetime] = rest_field(name="finishedAt", visibility=["read"], format="rfc3339")
    """The time when the command finished."""
    logs: Optional[str] = rest_field(visibility=["read"])
    """The command output."""
    reason: Optional[str] = rest_field(visibility=["read"])
    """An explanation of why provisioningState is set to failed (if so)."""


class CompatibleVersions(_Model):
    """Version information about a product/service that is compatible with a service mesh revision.

    :ivar name: The product/service name.
    :vartype name: str
    :ivar versions: Product/service versions compatible with a service mesh add-on revision.
    :vartype versions: list[str]
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The product/service name."""
    versions: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Product/service versions compatible with a service mesh add-on revision."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        versions: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Component(_Model):
    """Component.

    :ivar name: Component name.
    :vartype name: str
    :ivar version: Component version.
    :vartype version: str
    :ivar has_breaking_changes: If upgraded component version contains breaking changes from the
     current version. To see a detailed description of what the breaking changes are, visit
     `https://learn.microsoft.com/azure/aks/supported-kubernetes-versions?tabs=azure-cli#aks-components-breaking-changes-by-version
     <https://learn.microsoft.com/azure/aks/supported-kubernetes-versions?tabs=azure-cli#aks-components-breaking-changes-by-version>`_.
    :vartype has_breaking_changes: bool
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Component name."""
    version: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Component version."""
    has_breaking_changes: Optional[bool] = rest_field(
        name="hasBreakingChanges", visibility=["read", "create", "update", "delete", "query"]
    )
    """If upgraded component version contains breaking changes from the current version. To see a
     detailed description of what the breaking changes are, visit
     `https://learn.microsoft.com/azure/aks/supported-kubernetes-versions?tabs=azure-cli#aks-components-breaking-changes-by-version
     <https://learn.microsoft.com/azure/aks/supported-kubernetes-versions?tabs=azure-cli#aks-components-breaking-changes-by-version>`_."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        version: Optional[str] = None,
        has_breaking_changes: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComponentsByRelease(_Model):
    """components of given Kubernetes version.

    :ivar kubernetes_version: The Kubernetes version (major.minor).
    :vartype kubernetes_version: str
    :ivar components: components of current or upgraded Kubernetes version in the cluster.
    :vartype components: list[~azure.mgmt.containerservice.models.Component]
    """

    kubernetes_version: Optional[str] = rest_field(
        name="kubernetesVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Kubernetes version (major.minor)."""
    components: Optional[list["_models.Component"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """components of current or upgraded Kubernetes version in the cluster."""

    @overload
    def __init__(
        self,
        *,
        kubernetes_version: Optional[str] = None,
        components: Optional[list["_models.Component"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ContainerServiceLinuxProfile(_Model):
    """Profile for Linux VMs in the container service cluster.

    :ivar admin_username: The administrator username to use for Linux VMs. Required.
    :vartype admin_username: str
    :ivar ssh: The SSH configuration for Linux-based VMs running on Azure. Required.
    :vartype ssh: ~azure.mgmt.containerservice.models.ContainerServiceSshConfiguration
    """

    admin_username: str = rest_field(name="adminUsername", visibility=["read", "create", "update", "delete", "query"])
    """The administrator username to use for Linux VMs. Required."""
    ssh: "_models.ContainerServiceSshConfiguration" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The SSH configuration for Linux-based VMs running on Azure. Required."""

    @overload
    def __init__(
        self,
        *,
        admin_username: str,
        ssh: "_models.ContainerServiceSshConfiguration",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ContainerServiceNetworkProfile(_Model):
    """Profile of network configuration.

    :ivar network_plugin: Network plugin used for building the Kubernetes network. Known values
     are: "azure", "kubenet", and "none".
    :vartype network_plugin: str or ~azure.mgmt.containerservice.models.NetworkPlugin
    :ivar network_plugin_mode: The mode the network plugin should use. "overlay"
    :vartype network_plugin_mode: str or ~azure.mgmt.containerservice.models.NetworkPluginMode
    :ivar network_policy: Network policy used for building the Kubernetes network. Known values
     are: "none", "calico", "azure", and "cilium".
    :vartype network_policy: str or ~azure.mgmt.containerservice.models.NetworkPolicy
    :ivar network_mode: The network mode Azure CNI is configured with. This cannot be specified if
     networkPlugin is anything other than 'azure'. Known values are: "transparent" and "bridge".
    :vartype network_mode: str or ~azure.mgmt.containerservice.models.NetworkMode
    :ivar network_dataplane: Network dataplane used in the Kubernetes cluster. Known values are:
     "azure" and "cilium".
    :vartype network_dataplane: str or ~azure.mgmt.containerservice.models.NetworkDataplane
    :ivar advanced_networking: Advanced Networking profile for enabling observability and security
     feature suite on a cluster. For more information see aka.ms/aksadvancednetworking.
    :vartype advanced_networking: ~azure.mgmt.containerservice.models.AdvancedNetworking
    :ivar pod_cidr: A CIDR notation IP range from which to assign pod IPs when kubenet is used.
    :vartype pod_cidr: str
    :ivar service_cidr: A CIDR notation IP range from which to assign service cluster IPs. It must
     not overlap with any Subnet IP ranges.
    :vartype service_cidr: str
    :ivar dns_service_ip: An IP address assigned to the Kubernetes DNS service. It must be within
     the Kubernetes service address range specified in serviceCidr.
    :vartype dns_service_ip: str
    :ivar outbound_type: The outbound (egress) routing method. This can only be set at cluster
     creation time and cannot be changed later. For more information see `egress outbound type
     <https://docs.microsoft.com/azure/aks/egress-outboundtype>`_. Known values are: "loadBalancer",
     "userDefinedRouting", "managedNATGateway", "userAssignedNATGateway", and "none".
    :vartype outbound_type: str or ~azure.mgmt.containerservice.models.OutboundType
    :ivar load_balancer_sku: The load balancer sku for the managed cluster. The default is
     'standard'. See `Azure Load Balancer SKUs
     <https://docs.microsoft.com/azure/load-balancer/skus>`_ for more information about the
     differences between load balancer SKUs. Known values are: "standard" and "basic".
    :vartype load_balancer_sku: str or ~azure.mgmt.containerservice.models.LoadBalancerSku
    :ivar load_balancer_profile: Profile of the cluster load balancer.
    :vartype load_balancer_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterLoadBalancerProfile
    :ivar nat_gateway_profile: Profile of the cluster NAT gateway.
    :vartype nat_gateway_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterNATGatewayProfile
    :ivar static_egress_gateway_profile: The profile for Static Egress Gateway addon. For more
     details about Static Egress Gateway, see `https://aka.ms/aks/static-egress-gateway
     <https://aka.ms/aks/static-egress-gateway>`_.
    :vartype static_egress_gateway_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterStaticEgressGatewayProfile
    :ivar pod_cidrs: The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is
     expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is
     expected for dual-stack networking.
    :vartype pod_cidrs: list[str]
    :ivar service_cidrs: The CIDR notation IP ranges from which to assign service cluster IPs. One
     IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family
     (IPv4/IPv6), is expected for dual-stack networking. They must not overlap with any Subnet IP
     ranges.
    :vartype service_cidrs: list[str]
    :ivar ip_families: The IP families used to specify IP versions available to the cluster. IP
     families are used to determine single-stack or dual-stack clusters. For single-stack, the
     expected value is IPv4. For dual-stack, the expected values are IPv4 and IPv6.
    :vartype ip_families: list[str or ~azure.mgmt.containerservice.models.IPFamily]
    :ivar pod_link_local_access: Defines access to special link local addresses (Azure Instance
     Metadata Service, aka IMDS) for pods with hostNetwork=false. if not specified, the default is
     'IMDS'. Known values are: "IMDS" and "None".
    :vartype pod_link_local_access: str or ~azure.mgmt.containerservice.models.PodLinkLocalAccess
    :ivar kube_proxy_config: Holds configuration customizations for kube-proxy. Any values not
     defined will use the kube-proxy defaulting behavior. See `https://v
     <https://v>`_<version>.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
     where <version> is represented by a <major version>-<minor version> string. Kubernetes version
     1.23 would be '1-23'.
    :vartype kube_proxy_config:
     ~azure.mgmt.containerservice.models.ContainerServiceNetworkProfileKubeProxyConfig
    """

    network_plugin: Optional[Union[str, "_models.NetworkPlugin"]] = rest_field(
        name="networkPlugin", visibility=["read", "create", "update", "delete", "query"]
    )
    """Network plugin used for building the Kubernetes network. Known values are: \"azure\",
     \"kubenet\", and \"none\"."""
    network_plugin_mode: Optional[Union[str, "_models.NetworkPluginMode"]] = rest_field(
        name="networkPluginMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The mode the network plugin should use. \"overlay\""""
    network_policy: Optional[Union[str, "_models.NetworkPolicy"]] = rest_field(
        name="networkPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """Network policy used for building the Kubernetes network. Known values are: \"none\",
     \"calico\", \"azure\", and \"cilium\"."""
    network_mode: Optional[Union[str, "_models.NetworkMode"]] = rest_field(
        name="networkMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The network mode Azure CNI is configured with. This cannot be specified if networkPlugin is
     anything other than 'azure'. Known values are: \"transparent\" and \"bridge\"."""
    network_dataplane: Optional[Union[str, "_models.NetworkDataplane"]] = rest_field(
        name="networkDataplane", visibility=["read", "create", "update", "delete", "query"]
    )
    """Network dataplane used in the Kubernetes cluster. Known values are: \"azure\" and \"cilium\"."""
    advanced_networking: Optional["_models.AdvancedNetworking"] = rest_field(
        name="advancedNetworking", visibility=["read", "create", "update", "delete", "query"]
    )
    """Advanced Networking profile for enabling observability and security feature suite on a cluster.
     For more information see aka.ms/aksadvancednetworking."""
    pod_cidr: Optional[str] = rest_field(name="podCidr", visibility=["read", "create", "update", "delete", "query"])
    """A CIDR notation IP range from which to assign pod IPs when kubenet is used."""
    service_cidr: Optional[str] = rest_field(
        name="serviceCidr", visibility=["read", "create", "update", "delete", "query"]
    )
    """A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any
     Subnet IP ranges."""
    dns_service_ip: Optional[str] = rest_field(
        name="dnsServiceIP", visibility=["read", "create", "update", "delete", "query"]
    )
    """An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service
     address range specified in serviceCidr."""
    outbound_type: Optional[Union[str, "_models.OutboundType"]] = rest_field(
        name="outboundType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The outbound (egress) routing method. This can only be set at cluster creation time and cannot
     be changed later. For more information see `egress outbound type
     <https://docs.microsoft.com/azure/aks/egress-outboundtype>`_. Known values are:
     \"loadBalancer\", \"userDefinedRouting\", \"managedNATGateway\", \"userAssignedNATGateway\",
     and \"none\"."""
    load_balancer_sku: Optional[Union[str, "_models.LoadBalancerSku"]] = rest_field(
        name="loadBalancerSku", visibility=["read", "create", "update", "delete", "query"]
    )
    """The load balancer sku for the managed cluster. The default is 'standard'. See `Azure Load
     Balancer SKUs <https://docs.microsoft.com/azure/load-balancer/skus>`_ for more information
     about the differences between load balancer SKUs. Known values are: \"standard\" and \"basic\"."""
    load_balancer_profile: Optional["_models.ManagedClusterLoadBalancerProfile"] = rest_field(
        name="loadBalancerProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Profile of the cluster load balancer."""
    nat_gateway_profile: Optional["_models.ManagedClusterNATGatewayProfile"] = rest_field(
        name="natGatewayProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Profile of the cluster NAT gateway."""
    static_egress_gateway_profile: Optional["_models.ManagedClusterStaticEgressGatewayProfile"] = rest_field(
        name="staticEgressGatewayProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The profile for Static Egress Gateway addon. For more details about Static Egress Gateway, see
     `https://aka.ms/aks/static-egress-gateway <https://aka.ms/aks/static-egress-gateway>`_."""
    pod_cidrs: Optional[list[str]] = rest_field(
        name="podCidrs", visibility=["read", "create", "update", "delete", "query"]
    )
    """The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is expected for
     single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for
     dual-stack networking."""
    service_cidrs: Optional[list[str]] = rest_field(
        name="serviceCidrs", visibility=["read", "create", "update", "delete", "query"]
    )
    """The CIDR notation IP ranges from which to assign service cluster IPs. One IPv4 CIDR is expected
     for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for
     dual-stack networking. They must not overlap with any Subnet IP ranges."""
    ip_families: Optional[list[Union[str, "_models.IPFamily"]]] = rest_field(
        name="ipFamilies", visibility=["read", "create", "update", "delete", "query"]
    )
    """The IP families used to specify IP versions available to the cluster. IP families are used to
     determine single-stack or dual-stack clusters. For single-stack, the expected value is IPv4.
     For dual-stack, the expected values are IPv4 and IPv6."""
    pod_link_local_access: Optional[Union[str, "_models.PodLinkLocalAccess"]] = rest_field(
        name="podLinkLocalAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines access to special link local addresses (Azure Instance Metadata Service, aka IMDS) for
     pods with hostNetwork=false. if not specified, the default is 'IMDS'. Known values are:
     \"IMDS\" and \"None\"."""
    kube_proxy_config: Optional["_models.ContainerServiceNetworkProfileKubeProxyConfig"] = rest_field(
        name="kubeProxyConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """Holds configuration customizations for kube-proxy. Any values not defined will use the
     kube-proxy defaulting behavior. See `https://v
     <https://v>`_<version>.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
     where <version> is represented by a <major version>-<minor version> string. Kubernetes version
     1.23 would be '1-23'."""

    @overload
    def __init__(
        self,
        *,
        network_plugin: Optional[Union[str, "_models.NetworkPlugin"]] = None,
        network_plugin_mode: Optional[Union[str, "_models.NetworkPluginMode"]] = None,
        network_policy: Optional[Union[str, "_models.NetworkPolicy"]] = None,
        network_mode: Optional[Union[str, "_models.NetworkMode"]] = None,
        network_dataplane: Optional[Union[str, "_models.NetworkDataplane"]] = None,
        advanced_networking: Optional["_models.AdvancedNetworking"] = None,
        pod_cidr: Optional[str] = None,
        service_cidr: Optional[str] = None,
        dns_service_ip: Optional[str] = None,
        outbound_type: Optional[Union[str, "_models.OutboundType"]] = None,
        load_balancer_sku: Optional[Union[str, "_models.LoadBalancerSku"]] = None,
        load_balancer_profile: Optional["_models.ManagedClusterLoadBalancerProfile"] = None,
        nat_gateway_profile: Optional["_models.ManagedClusterNATGatewayProfile"] = None,
        static_egress_gateway_profile: Optional["_models.ManagedClusterStaticEgressGatewayProfile"] = None,
        pod_cidrs: Optional[list[str]] = None,
        service_cidrs: Optional[list[str]] = None,
        ip_families: Optional[list[Union[str, "_models.IPFamily"]]] = None,
        pod_link_local_access: Optional[Union[str, "_models.PodLinkLocalAccess"]] = None,
        kube_proxy_config: Optional["_models.ContainerServiceNetworkProfileKubeProxyConfig"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ContainerServiceNetworkProfileKubeProxyConfig(_Model):  # pylint: disable=name-too-long
    """Holds configuration customizations for kube-proxy. Any values not defined will use the
    kube-proxy defaulting behavior. See `https://v
    <https://v>`_<version>.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
    where <version> is represented by a <major version>-<minor version> string. Kubernetes version
    1.23 would be '1-23'.

    :ivar enabled: Whether to enable on kube-proxy on the cluster (if no 'kubeProxyConfig' exists,
     kube-proxy is enabled in AKS by default without these customizations).
    :vartype enabled: bool
    :ivar mode: Specify which proxy mode to use ('IPTABLES', 'IPVS' or 'NFTABLES'). Known values
     are: "IPTABLES", "IPVS", and "NFTABLES".
    :vartype mode: str or ~azure.mgmt.containerservice.models.Mode
    :ivar ipvs_config: Holds configuration customizations for IPVS. May only be specified if 'mode'
     is set to 'IPVS'.
    :vartype ipvs_config:
     ~azure.mgmt.containerservice.models.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable on kube-proxy on the cluster (if no 'kubeProxyConfig' exists, kube-proxy is
     enabled in AKS by default without these customizations)."""
    mode: Optional[Union[str, "_models.Mode"]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specify which proxy mode to use ('IPTABLES', 'IPVS' or 'NFTABLES'). Known values are:
     \"IPTABLES\", \"IPVS\", and \"NFTABLES\"."""
    ipvs_config: Optional["_models.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig"] = rest_field(
        name="ipvsConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """Holds configuration customizations for IPVS. May only be specified if 'mode' is set to 'IPVS'."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        mode: Optional[Union[str, "_models.Mode"]] = None,
        ipvs_config: Optional["_models.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig(_Model):  # pylint: disable=name-too-long
    """Holds configuration customizations for IPVS. May only be specified if 'mode' is set to 'IPVS'.

    :ivar scheduler: IPVS scheduler, for more information please see
     `http://www.linuxvirtualserver.org/docs/scheduling.html
     <http://www.linuxvirtualserver.org/docs/scheduling.html>`_. Known values are: "RoundRobin" and
     "LeastConnection".
    :vartype scheduler: str or ~azure.mgmt.containerservice.models.IpvsScheduler
    :ivar tcp_timeout_seconds: The timeout value used for idle IPVS TCP sessions in seconds. Must
     be a positive integer value.
    :vartype tcp_timeout_seconds: int
    :ivar tcp_fin_timeout_seconds: The timeout value used for IPVS TCP sessions after receiving a
     FIN in seconds. Must be a positive integer value.
    :vartype tcp_fin_timeout_seconds: int
    :ivar udp_timeout_seconds: The timeout value used for IPVS UDP packets in seconds. Must be a
     positive integer value.
    :vartype udp_timeout_seconds: int
    """

    scheduler: Optional[Union[str, "_models.IpvsScheduler"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """IPVS scheduler, for more information please see
     `http://www.linuxvirtualserver.org/docs/scheduling.html
     <http://www.linuxvirtualserver.org/docs/scheduling.html>`_. Known values are: \"RoundRobin\"
     and \"LeastConnection\"."""
    tcp_timeout_seconds: Optional[int] = rest_field(
        name="tcpTimeoutSeconds", visibility=["read", "create", "update", "delete", "query"]
    )
    """The timeout value used for idle IPVS TCP sessions in seconds. Must be a positive integer value."""
    tcp_fin_timeout_seconds: Optional[int] = rest_field(
        name="tcpFinTimeoutSeconds", visibility=["read", "create", "update", "delete", "query"]
    )
    """The timeout value used for IPVS TCP sessions after receiving a FIN in seconds. Must be a
     positive integer value."""
    udp_timeout_seconds: Optional[int] = rest_field(
        name="udpTimeoutSeconds", visibility=["read", "create", "update", "delete", "query"]
    )
    """The timeout value used for IPVS UDP packets in seconds. Must be a positive integer value."""

    @overload
    def __init__(
        self,
        *,
        scheduler: Optional[Union[str, "_models.IpvsScheduler"]] = None,
        tcp_timeout_seconds: Optional[int] = None,
        tcp_fin_timeout_seconds: Optional[int] = None,
        udp_timeout_seconds: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ContainerServiceSshConfiguration(_Model):
    """SSH configuration for Linux-based VMs running on Azure.

    :ivar public_keys: The list of SSH public keys used to authenticate with Linux-based VMs. A
     maximum of 1 key may be specified. Required.
    :vartype public_keys: list[~azure.mgmt.containerservice.models.ContainerServiceSshPublicKey]
    """

    public_keys: list["_models.ContainerServiceSshPublicKey"] = rest_field(
        name="publicKeys", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may
     be specified. Required."""

    @overload
    def __init__(
        self,
        *,
        public_keys: list["_models.ContainerServiceSshPublicKey"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ContainerServiceSshPublicKey(_Model):
    """Contains information about SSH certificate public key data.

    :ivar key_data: Certificate public key used to authenticate with VMs through SSH. The
     certificate must be in PEM format with or without headers. Required.
    :vartype key_data: str
    """

    key_data: str = rest_field(name="keyData", visibility=["read", "create", "update", "delete", "query"])
    """Certificate public key used to authenticate with VMs through SSH. The certificate must be in
     PEM format with or without headers. Required."""

    @overload
    def __init__(
        self,
        *,
        key_data: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreationData(_Model):
    """Data used when creating a target resource from a source resource.

    :ivar source_resource_id: This is the ARM ID of the source object to be used to create the
     target object.
    :vartype source_resource_id: str
    """

    source_resource_id: Optional[str] = rest_field(
        name="sourceResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """This is the ARM ID of the source object to be used to create the target object."""

    @overload
    def __init__(
        self,
        *,
        source_resource_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CredentialResult(_Model):
    """The credential result response.

    :ivar name: The name of the credential.
    :vartype name: str
    :ivar value: Base64-encoded Kubernetes configuration file.
    :vartype value: bytes
    """

    name: Optional[str] = rest_field(visibility=["read"])
    """The name of the credential."""
    value: Optional[bytes] = rest_field(visibility=["read"], format="base64")
    """Base64-encoded Kubernetes configuration file."""


class CredentialResults(_Model):
    """The list credential result response.

    :ivar kubeconfigs: Base64-encoded Kubernetes configuration file.
    :vartype kubeconfigs: list[~azure.mgmt.containerservice.models.CredentialResult]
    """

    kubeconfigs: Optional[list["_models.CredentialResult"]] = rest_field(visibility=["read"])
    """Base64-encoded Kubernetes configuration file."""


class DailySchedule(_Model):
    """For schedules like: 'recur every day' or 'recur every 3 days'.

    :ivar interval_days: Specifies the number of days between each set of occurrences. Required.
    :vartype interval_days: int
    """

    interval_days: int = rest_field(name="intervalDays", visibility=["read", "create", "update", "delete", "query"])
    """Specifies the number of days between each set of occurrences. Required."""

    @overload
    def __init__(
        self,
        *,
        interval_days: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DateSpan(_Model):
    """A date range. For example, between '2022-12-23' and '2023-01-05'.

    :ivar start: The start date of the date span. Required.
    :vartype start: ~datetime.date
    :ivar end: The end date of the date span. Required.
    :vartype end: ~datetime.date
    """

    start: datetime.date = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The start date of the date span. Required."""
    end: datetime.date = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The end date of the date span. Required."""

    @overload
    def __init__(
        self,
        *,
        start: datetime.date,
        end: datetime.date,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DelegatedResource(_Model):
    """Delegated resource properties - internal use only.

    :ivar resource_id: The ARM resource id of the delegated resource - internal use only.
    :vartype resource_id: str
    :ivar tenant_id: The tenant id of the delegated resource - internal use only.
    :vartype tenant_id: str
    :ivar referral_resource: The delegation id of the referral delegation (optional) - internal use
     only.
    :vartype referral_resource: str
    :ivar location: The source resource location - internal use only.
    :vartype location: str
    """

    resource_id: Optional[str] = rest_field(
        name="resourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The ARM resource id of the delegated resource - internal use only."""
    tenant_id: Optional[str] = rest_field(name="tenantId", visibility=["read", "create", "update", "delete", "query"])
    """The tenant id of the delegated resource - internal use only."""
    referral_resource: Optional[str] = rest_field(
        name="referralResource", visibility=["read", "create", "update", "delete", "query"]
    )
    """The delegation id of the referral delegation (optional) - internal use only."""
    location: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The source resource location - internal use only."""

    @overload
    def __init__(
        self,
        *,
        resource_id: Optional[str] = None,
        tenant_id: Optional[str] = None,
        referral_resource: Optional[str] = None,
        location: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointDependency(_Model):
    """A domain name that AKS agent nodes are reaching at.

    :ivar domain_name: The domain name of the dependency.
    :vartype domain_name: str
    :ivar endpoint_details: The Ports and Protocols used when connecting to domainName.
    :vartype endpoint_details: list[~azure.mgmt.containerservice.models.EndpointDetail]
    """

    domain_name: Optional[str] = rest_field(
        name="domainName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The domain name of the dependency."""
    endpoint_details: Optional[list["_models.EndpointDetail"]] = rest_field(
        name="endpointDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Ports and Protocols used when connecting to domainName."""

    @overload
    def __init__(
        self,
        *,
        domain_name: Optional[str] = None,
        endpoint_details: Optional[list["_models.EndpointDetail"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointDetail(_Model):
    """connect information from the AKS agent nodes to a single endpoint.

    :ivar ip_address: An IP Address that Domain Name currently resolves to.
    :vartype ip_address: str
    :ivar port: The port an endpoint is connected to.
    :vartype port: int
    :ivar protocol: The protocol used for connection.
    :vartype protocol: str
    :ivar description: Description of the detail.
    :vartype description: str
    """

    ip_address: Optional[str] = rest_field(name="ipAddress", visibility=["read", "create", "update", "delete", "query"])
    """An IP Address that Domain Name currently resolves to."""
    port: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The port an endpoint is connected to."""
    protocol: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The protocol used for connection."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Description of the detail."""

    @overload
    def __init__(
        self,
        *,
        ip_address: Optional[str] = None,
        port: Optional[int] = None,
        protocol: Optional[str] = None,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ErrorAdditionalInfo(_Model):
    """The resource management error additional info.

    :ivar type: The additional info type.
    :vartype type: str
    :ivar info: The additional info.
    :vartype info: any
    """

    type: Optional[str] = rest_field(visibility=["read"])
    """The additional info type."""
    info: Optional[Any] = rest_field(visibility=["read"])
    """The additional info."""


class ErrorDetail(_Model):
    """The error detail.

    :ivar code: The error code.
    :vartype code: str
    :ivar message: The error message.
    :vartype message: str
    :ivar target: The error target.
    :vartype target: str
    :ivar details: The error details.
    :vartype details: list[~azure.mgmt.containerservice.models.ErrorDetail]
    :ivar additional_info: The error additional info.
    :vartype additional_info: list[~azure.mgmt.containerservice.models.ErrorAdditionalInfo]
    """

    code: Optional[str] = rest_field(visibility=["read"])
    """The error code."""
    message: Optional[str] = rest_field(visibility=["read"])
    """The error message."""
    target: Optional[str] = rest_field(visibility=["read"])
    """The error target."""
    details: Optional[list["_models.ErrorDetail"]] = rest_field(visibility=["read"])
    """The error details."""
    additional_info: Optional[list["_models.ErrorAdditionalInfo"]] = rest_field(
        name="additionalInfo", visibility=["read"]
    )
    """The error additional info."""


class ErrorResponse(_Model):
    """Error response.

    :ivar error: The error object.
    :vartype error: ~azure.mgmt.containerservice.models.ErrorDetail
    """

    error: Optional["_models.ErrorDetail"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The error object."""

    @overload
    def __init__(
        self,
        *,
        error: Optional["_models.ErrorDetail"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExtendedLocation(_Model):
    """The complex type of the extended location.

    :ivar name: The name of the extended location.
    :vartype name: str
    :ivar type: The type of the extended location. "EdgeZone"
    :vartype type: str or ~azure.mgmt.containerservice.models.ExtendedLocationTypes
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the extended location."""
    type: Optional[Union[str, "_models.ExtendedLocationTypes"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of the extended location. \"EdgeZone\""""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        type: Optional[Union[str, "_models.ExtendedLocationTypes"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GPUProfile(_Model):
    """GPU settings for the Agent Pool.

    :ivar driver: Whether to install GPU drivers. When it's not specified, default is Install.
     Known values are: "Install" and "None".
    :vartype driver: str or ~azure.mgmt.containerservice.models.GPUDriver
    :ivar driver_type: Specify the type of GPU driver to install when creating Windows agent pools.
     If not provided, AKS selects the driver based on system compatibility. This cannot be changed
     once the AgentPool has been created. This cannot be set on Linux AgentPools. For Linux
     AgentPools, the driver is selected based on system compatibility. Known values are: "GRID" and
     "CUDA".
    :vartype driver_type: str or ~azure.mgmt.containerservice.models.DriverType
    """

    driver: Optional[Union[str, "_models.GPUDriver"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to install GPU drivers. When it's not specified, default is Install. Known values are:
     \"Install\" and \"None\"."""
    driver_type: Optional[Union[str, "_models.DriverType"]] = rest_field(
        name="driverType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specify the type of GPU driver to install when creating Windows agent pools. If not provided,
     AKS selects the driver based on system compatibility. This cannot be changed once the AgentPool
     has been created. This cannot be set on Linux AgentPools. For Linux AgentPools, the driver is
     selected based on system compatibility. Known values are: \"GRID\" and \"CUDA\"."""

    @overload
    def __init__(
        self,
        *,
        driver: Optional[Union[str, "_models.GPUDriver"]] = None,
        driver_type: Optional[Union[str, "_models.DriverType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GuardrailsAvailableVersion(ProxyResource):
    """Available Guardrails Version.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: Whether the version is default or not and support info. Required.
    :vartype properties: ~azure.mgmt.containerservice.models.GuardrailsAvailableVersionsProperties
    """

    properties: "_models.GuardrailsAvailableVersionsProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether the version is default or not and support info. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.GuardrailsAvailableVersionsProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GuardrailsAvailableVersionsProperties(_Model):
    """Whether the version is default or not and support info.

    :ivar is_default_version:
    :vartype is_default_version: bool
    :ivar support: Whether the version is preview or stable. Known values are: "Preview" and
     "Stable".
    :vartype support: str or ~azure.mgmt.containerservice.models.GuardrailsSupport
    """

    is_default_version: Optional[bool] = rest_field(name="isDefaultVersion", visibility=["read"])
    support: Optional[Union[str, "_models.GuardrailsSupport"]] = rest_field(visibility=["read"])
    """Whether the version is preview or stable. Known values are: \"Preview\" and \"Stable\"."""


class IdentityBinding(ProxyResource):
    """The IdentityBinding resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: The resource-specific properties for this resource.
    :vartype properties: ~azure.mgmt.containerservice.models.IdentityBindingProperties
    :ivar e_tag: If eTag is provided in the response body, it may also be provided as a header per
     the normal etag convention.  Entity tags are used for comparing two or more entities from the
     same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match
     (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.
    :vartype e_tag: str
    """

    properties: Optional["_models.IdentityBindingProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource-specific properties for this resource."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read"])
    """If eTag is provided in the response body, it may also be provided as a header per the normal
     etag convention.  Entity tags are used for comparing two or more entities from the same
     requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section
     14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.IdentityBindingProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IdentityBindingManagedIdentityProfile(_Model):
    """Managed identity profile for the identity binding.

    :ivar resource_id: The resource ID of the managed identity. Required.
    :vartype resource_id: str
    :ivar object_id: The object ID of the managed identity.
    :vartype object_id: str
    :ivar client_id: The client ID of the managed identity.
    :vartype client_id: str
    :ivar tenant_id: The tenant ID of the managed identity.
    :vartype tenant_id: str
    """

    resource_id: str = rest_field(name="resourceId", visibility=["read", "create"])
    """The resource ID of the managed identity. Required."""
    object_id: Optional[str] = rest_field(name="objectId", visibility=["read"])
    """The object ID of the managed identity."""
    client_id: Optional[str] = rest_field(name="clientId", visibility=["read"])
    """The client ID of the managed identity."""
    tenant_id: Optional[str] = rest_field(name="tenantId", visibility=["read"])
    """The tenant ID of the managed identity."""

    @overload
    def __init__(
        self,
        *,
        resource_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IdentityBindingOidcIssuerProfile(_Model):
    """IdentityBinding OIDC issuer profile.

    :ivar oidc_issuer_url: The OIDC issuer URL of the IdentityBinding.
    :vartype oidc_issuer_url: str
    """

    oidc_issuer_url: Optional[str] = rest_field(name="oidcIssuerUrl", visibility=["read"])
    """The OIDC issuer URL of the IdentityBinding."""


class IdentityBindingProperties(_Model):
    """IdentityBinding properties.

    :ivar managed_identity: Managed identity profile for the identity binding. Required.
    :vartype managed_identity:
     ~azure.mgmt.containerservice.models.IdentityBindingManagedIdentityProfile
    :ivar oidc_issuer: The OIDC issuer URL of the IdentityBinding.
    :vartype oidc_issuer: ~azure.mgmt.containerservice.models.IdentityBindingOidcIssuerProfile
    :ivar provisioning_state: The status of the last operation. Known values are: "Succeeded",
     "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.containerservice.models.IdentityBindingProvisioningState
    """

    managed_identity: "_models.IdentityBindingManagedIdentityProfile" = rest_field(
        name="managedIdentity", visibility=["read", "create"]
    )
    """Managed identity profile for the identity binding. Required."""
    oidc_issuer: Optional["_models.IdentityBindingOidcIssuerProfile"] = rest_field(
        name="oidcIssuer", visibility=["read"]
    )
    """The OIDC issuer URL of the IdentityBinding."""
    provisioning_state: Optional[Union[str, "_models.IdentityBindingProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The status of the last operation. Known values are: \"Succeeded\", \"Failed\", \"Canceled\",
     \"Creating\", \"Updating\", and \"Deleting\"."""

    @overload
    def __init__(
        self,
        *,
        managed_identity: "_models.IdentityBindingManagedIdentityProfile",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IPTag(_Model):
    """Contains the IPTag associated with the object.

    :ivar ip_tag_type: The IP tag type. Example: RoutingPreference.
    :vartype ip_tag_type: str
    :ivar tag: The value of the IP tag associated with the public IP. Example: Internet.
    :vartype tag: str
    """

    ip_tag_type: Optional[str] = rest_field(
        name="ipTagType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The IP tag type. Example: RoutingPreference."""
    tag: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The value of the IP tag associated with the public IP. Example: Internet."""

    @overload
    def __init__(
        self,
        *,
        ip_tag_type: Optional[str] = None,
        tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IstioCertificateAuthority(_Model):
    """Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin
    certificates as described here `https://aka.ms/asm-plugin-ca <https://aka.ms/asm-plugin-ca>`_.

    :ivar plugin: Plugin certificates information for Service Mesh.
    :vartype plugin: ~azure.mgmt.containerservice.models.IstioPluginCertificateAuthority
    """

    plugin: Optional["_models.IstioPluginCertificateAuthority"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Plugin certificates information for Service Mesh."""

    @overload
    def __init__(
        self,
        *,
        plugin: Optional["_models.IstioPluginCertificateAuthority"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IstioComponents(_Model):
    """Istio components configuration.

    :ivar ingress_gateways: Istio ingress gateways.
    :vartype ingress_gateways: list[~azure.mgmt.containerservice.models.IstioIngressGateway]
    :ivar egress_gateways: Istio egress gateways.
    :vartype egress_gateways: list[~azure.mgmt.containerservice.models.IstioEgressGateway]
    :ivar proxy_redirection_mechanism: Mode of traffic redirection. Known values are:
     "InitContainers" and "CNIChaining".
    :vartype proxy_redirection_mechanism: str or
     ~azure.mgmt.containerservice.models.ProxyRedirectionMechanism
    """

    ingress_gateways: Optional[list["_models.IstioIngressGateway"]] = rest_field(
        name="ingressGateways", visibility=["read", "create", "update", "delete", "query"]
    )
    """Istio ingress gateways."""
    egress_gateways: Optional[list["_models.IstioEgressGateway"]] = rest_field(
        name="egressGateways", visibility=["read", "create", "update", "delete", "query"]
    )
    """Istio egress gateways."""
    proxy_redirection_mechanism: Optional[Union[str, "_models.ProxyRedirectionMechanism"]] = rest_field(
        name="proxyRedirectionMechanism", visibility=["read", "create", "update", "delete", "query"]
    )
    """Mode of traffic redirection. Known values are: \"InitContainers\" and \"CNIChaining\"."""

    @overload
    def __init__(
        self,
        *,
        ingress_gateways: Optional[list["_models.IstioIngressGateway"]] = None,
        egress_gateways: Optional[list["_models.IstioEgressGateway"]] = None,
        proxy_redirection_mechanism: Optional[Union[str, "_models.ProxyRedirectionMechanism"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IstioEgressGateway(_Model):
    """Istio egress gateway configuration.

    :ivar enabled: Whether to enable the egress gateway. Required.
    :vartype enabled: bool
    :ivar name: Name of the Istio add-on egress gateway. Required.
    :vartype name: str
    :ivar namespace: Namespace that the Istio add-on egress gateway should be deployed in. If
     unspecified, the default is aks-istio-egress.
    :vartype namespace: str
    :ivar gateway_configuration_name: Name of the gateway configuration custom resource for the
     Istio add-on egress gateway. Must be specified when enabling the Istio egress gateway. Must be
     deployed in the same namespace that the Istio egress gateway will be deployed in.
    :vartype gateway_configuration_name: str
    """

    enabled: bool = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable the egress gateway. Required."""
    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Name of the Istio add-on egress gateway. Required."""
    namespace: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Namespace that the Istio add-on egress gateway should be deployed in. If unspecified, the
     default is aks-istio-egress."""
    gateway_configuration_name: Optional[str] = rest_field(
        name="gatewayConfigurationName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of the gateway configuration custom resource for the Istio add-on egress gateway. Must be
     specified when enabling the Istio egress gateway. Must be deployed in the same namespace that
     the Istio egress gateway will be deployed in."""

    @overload
    def __init__(
        self,
        *,
        enabled: bool,
        name: str,
        namespace: Optional[str] = None,
        gateway_configuration_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IstioIngressGateway(_Model):
    """Istio ingress gateway configuration. For now, we support up to one external ingress gateway
    named ``aks-istio-ingressgateway-external`` and one internal ingress gateway named
    ``aks-istio-ingressgateway-internal``.

    :ivar mode: Mode of an ingress gateway. Required. Known values are: "External" and "Internal".
    :vartype mode: str or ~azure.mgmt.containerservice.models.IstioIngressGatewayMode
    :ivar enabled: Whether to enable the ingress gateway. Required.
    :vartype enabled: bool
    """

    mode: Union[str, "_models.IstioIngressGatewayMode"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Mode of an ingress gateway. Required. Known values are: \"External\" and \"Internal\"."""
    enabled: bool = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable the ingress gateway. Required."""

    @overload
    def __init__(
        self,
        *,
        mode: Union[str, "_models.IstioIngressGatewayMode"],
        enabled: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IstioPluginCertificateAuthority(_Model):
    """Plugin certificates information for Service Mesh.

    :ivar key_vault_id: The resource ID of the Key Vault.
    :vartype key_vault_id: str
    :ivar cert_object_name: Intermediate certificate object name in Azure Key Vault.
    :vartype cert_object_name: str
    :ivar key_object_name: Intermediate certificate private key object name in Azure Key Vault.
    :vartype key_object_name: str
    :ivar root_cert_object_name: Root certificate object name in Azure Key Vault.
    :vartype root_cert_object_name: str
    :ivar cert_chain_object_name: Certificate chain object name in Azure Key Vault.
    :vartype cert_chain_object_name: str
    """

    key_vault_id: Optional[str] = rest_field(
        name="keyVaultId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource ID of the Key Vault."""
    cert_object_name: Optional[str] = rest_field(
        name="certObjectName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Intermediate certificate object name in Azure Key Vault."""
    key_object_name: Optional[str] = rest_field(
        name="keyObjectName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Intermediate certificate private key object name in Azure Key Vault."""
    root_cert_object_name: Optional[str] = rest_field(
        name="rootCertObjectName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Root certificate object name in Azure Key Vault."""
    cert_chain_object_name: Optional[str] = rest_field(
        name="certChainObjectName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Certificate chain object name in Azure Key Vault."""

    @overload
    def __init__(
        self,
        *,
        key_vault_id: Optional[str] = None,
        cert_object_name: Optional[str] = None,
        key_object_name: Optional[str] = None,
        root_cert_object_name: Optional[str] = None,
        cert_chain_object_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IstioServiceMesh(_Model):
    """Istio service mesh configuration.

    :ivar components: Istio components configuration.
    :vartype components: ~azure.mgmt.containerservice.models.IstioComponents
    :ivar certificate_authority: Istio Service Mesh Certificate Authority (CA) configuration. For
     now, we only support plugin certificates as described here `https://aka.ms/asm-plugin-ca
     <https://aka.ms/asm-plugin-ca>`_.
    :vartype certificate_authority: ~azure.mgmt.containerservice.models.IstioCertificateAuthority
    :ivar revisions: The list of revisions of the Istio control plane. When an upgrade is not in
     progress, this holds one value. When canary upgrade is in progress, this can only hold two
     consecutive values. For more information, see:
     `https://learn.microsoft.com/en-us/azure/aks/istio-upgrade
     <https://learn.microsoft.com/en-us/azure/aks/istio-upgrade>`_.
    :vartype revisions: list[str]
    """

    components: Optional["_models.IstioComponents"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Istio components configuration."""
    certificate_authority: Optional["_models.IstioCertificateAuthority"] = rest_field(
        name="certificateAuthority", visibility=["read", "create", "update", "delete", "query"]
    )
    """Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin
     certificates as described here `https://aka.ms/asm-plugin-ca <https://aka.ms/asm-plugin-ca>`_."""
    revisions: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The list of revisions of the Istio control plane. When an upgrade is not in progress, this
     holds one value. When canary upgrade is in progress, this can only hold two consecutive values.
     For more information, see: `https://learn.microsoft.com/en-us/azure/aks/istio-upgrade
     <https://learn.microsoft.com/en-us/azure/aks/istio-upgrade>`_."""

    @overload
    def __init__(
        self,
        *,
        components: Optional["_models.IstioComponents"] = None,
        certificate_authority: Optional["_models.IstioCertificateAuthority"] = None,
        revisions: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JWTAuthenticator(ProxyResource):
    """Configuration for JWT authenticator in the managed cluster.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: The properties of JWTAuthenticator. For details on how to configure the
     properties of a JWT authenticator, please refer to the Kubernetes documentation:
     `https://kubernetes.io/docs/reference/access-authn-authz/authentication/#using-authentication-configuration
     <https://kubernetes.io/docs/reference/access-authn-authz/authentication/#using-authentication-configuration>`_.
     Please note that not all fields available in the Kubernetes documentation are supported by AKS.
     For troubleshooting, please see `https://aka.ms/aks-external-issuers-docs
     <https://aka.ms/aks-external-issuers-docs>`_. Required.
    :vartype properties: ~azure.mgmt.containerservice.models.JWTAuthenticatorProperties
    """

    properties: "_models.JWTAuthenticatorProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of JWTAuthenticator. For details on how to configure the properties of a JWT
     authenticator, please refer to the Kubernetes documentation:
     `https://kubernetes.io/docs/reference/access-authn-authz/authentication/#using-authentication-configuration
     <https://kubernetes.io/docs/reference/access-authn-authz/authentication/#using-authentication-configuration>`_.
     Please note that not all fields available in the Kubernetes documentation are supported by AKS.
     For troubleshooting, please see `https://aka.ms/aks-external-issuers-docs
     <https://aka.ms/aks-external-issuers-docs>`_. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.JWTAuthenticatorProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JWTAuthenticatorClaimMappingExpression(_Model):
    """The claim mapping expression for JWTAuthenticator.

    :ivar expression: The CEL expression used to access token claims. Required.
    :vartype expression: str
    """

    expression: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The CEL expression used to access token claims. Required."""

    @overload
    def __init__(
        self,
        *,
        expression: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JWTAuthenticatorClaimMappings(_Model):
    """The claim mappings for JWTAuthenticator.

    :ivar username: The expression to extract username attribute from the token claims. Required.
    :vartype username: ~azure.mgmt.containerservice.models.JWTAuthenticatorClaimMappingExpression
    :ivar groups: The expression to extract groups attribute from the token claims. When not
     provided, no groups are extracted from the token claims.
    :vartype groups: ~azure.mgmt.containerservice.models.JWTAuthenticatorClaimMappingExpression
    :ivar uid: The expression to extract uid attribute from the token claims. When not provided, no
     uid is extracted from the token claims.
    :vartype uid: ~azure.mgmt.containerservice.models.JWTAuthenticatorClaimMappingExpression
    :ivar extra: The expression to extract extra attribute from the token claims. When not
     provided, no extra attributes are extracted from the token claims.
    :vartype extra:
     list[~azure.mgmt.containerservice.models.JWTAuthenticatorExtraClaimMappingExpression]
    """

    username: "_models.JWTAuthenticatorClaimMappingExpression" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The expression to extract username attribute from the token claims. Required."""
    groups: Optional["_models.JWTAuthenticatorClaimMappingExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The expression to extract groups attribute from the token claims. When not provided, no groups
     are extracted from the token claims."""
    uid: Optional["_models.JWTAuthenticatorClaimMappingExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The expression to extract uid attribute from the token claims. When not provided, no uid is
     extracted from the token claims."""
    extra: Optional[list["_models.JWTAuthenticatorExtraClaimMappingExpression"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The expression to extract extra attribute from the token claims. When not provided, no extra
     attributes are extracted from the token claims."""

    @overload
    def __init__(
        self,
        *,
        username: "_models.JWTAuthenticatorClaimMappingExpression",
        groups: Optional["_models.JWTAuthenticatorClaimMappingExpression"] = None,
        uid: Optional["_models.JWTAuthenticatorClaimMappingExpression"] = None,
        extra: Optional[list["_models.JWTAuthenticatorExtraClaimMappingExpression"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JWTAuthenticatorExtraClaimMappingExpression(_Model):  # pylint: disable=name-too-long
    """The extra claim mapping expression for JWTAuthenticator.

    :ivar key: The key of the extra attribute. Required.
    :vartype key: str
    :ivar value_expression: The CEL expression used to extract the value of the extra attribute.
     Required.
    :vartype value_expression: str
    """

    key: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The key of the extra attribute. Required."""
    value_expression: str = rest_field(
        name="valueExpression", visibility=["read", "create", "update", "delete", "query"]
    )
    """The CEL expression used to extract the value of the extra attribute. Required."""

    @overload
    def __init__(
        self,
        *,
        key: str,
        value_expression: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JWTAuthenticatorIssuer(_Model):
    """The OIDC issuer details for JWTAuthenticator.

    :ivar url: The issuer URL. The URL must begin with the scheme https and cannot contain a query
     string or fragment. This must match the "iss" claim in the presented JWT, and the issuer
     returned from discovery. Required.
    :vartype url: str
    :ivar audiences: The set of acceptable audiences the JWT must be issued to. At least one is
     required. When multiple is set, AudienceMatchPolicy is used in API Server configuration.
     Required.
    :vartype audiences: list[str]
    """

    url: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The issuer URL. The URL must begin with the scheme https and cannot contain a query string or
     fragment. This must match the \"iss\" claim in the presented JWT, and the issuer returned from
     discovery. Required."""
    audiences: list[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The set of acceptable audiences the JWT must be issued to. At least one is required. When
     multiple is set, AudienceMatchPolicy is used in API Server configuration. Required."""

    @overload
    def __init__(
        self,
        *,
        url: str,
        audiences: list[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JWTAuthenticatorProperties(_Model):
    """The properties of JWTAuthenticator. For details on how to configure the properties of a JWT
    authenticator, please refer to the Kubernetes documentation:
    `https://kubernetes.io/docs/reference/access-authn-authz/authentication/#using-authentication-configuration
    <https://kubernetes.io/docs/reference/access-authn-authz/authentication/#using-authentication-configuration>`_.
    Please note that not all fields available in the Kubernetes documentation are supported by AKS.
    For troubleshooting, please see `https://aka.ms/aks-external-issuers-docs
    <https://aka.ms/aks-external-issuers-docs>`_.

    :ivar provisioning_state: The current provisioning state of the JWT authenticator. Known values
     are: "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.containerservice.models.JWTAuthenticatorProvisioningState
    :ivar issuer: The JWT OIDC issuer details. Required.
    :vartype issuer: ~azure.mgmt.containerservice.models.JWTAuthenticatorIssuer
    :ivar claim_validation_rules: The rules that are applied to validate token claims to
     authenticate users. All the expressions must evaluate to true for validation to succeed.
    :vartype claim_validation_rules:
     list[~azure.mgmt.containerservice.models.JWTAuthenticatorValidationRule]
    :ivar claim_mappings: The mappings that define how user attributes are extracted from the token
     claims. Required.
    :vartype claim_mappings: ~azure.mgmt.containerservice.models.JWTAuthenticatorClaimMappings
    :ivar user_validation_rules: The rules that are applied to the mapped user before completing
     authentication. All the expressions must evaluate to true for validation to succeed.
    :vartype user_validation_rules:
     list[~azure.mgmt.containerservice.models.JWTAuthenticatorValidationRule]
    """

    provisioning_state: Optional[Union[str, "_models.JWTAuthenticatorProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The current provisioning state of the JWT authenticator. Known values are: \"Succeeded\",
     \"Failed\", \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""
    issuer: "_models.JWTAuthenticatorIssuer" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The JWT OIDC issuer details. Required."""
    claim_validation_rules: Optional[list["_models.JWTAuthenticatorValidationRule"]] = rest_field(
        name="claimValidationRules", visibility=["read", "create", "update", "delete", "query"]
    )
    """The rules that are applied to validate token claims to authenticate users. All the expressions
     must evaluate to true for validation to succeed."""
    claim_mappings: "_models.JWTAuthenticatorClaimMappings" = rest_field(
        name="claimMappings", visibility=["read", "create", "update", "delete", "query"]
    )
    """The mappings that define how user attributes are extracted from the token claims. Required."""
    user_validation_rules: Optional[list["_models.JWTAuthenticatorValidationRule"]] = rest_field(
        name="userValidationRules", visibility=["read", "create", "update", "delete", "query"]
    )
    """The rules that are applied to the mapped user before completing authentication. All the
     expressions must evaluate to true for validation to succeed."""

    @overload
    def __init__(
        self,
        *,
        issuer: "_models.JWTAuthenticatorIssuer",
        claim_mappings: "_models.JWTAuthenticatorClaimMappings",
        claim_validation_rules: Optional[list["_models.JWTAuthenticatorValidationRule"]] = None,
        user_validation_rules: Optional[list["_models.JWTAuthenticatorValidationRule"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JWTAuthenticatorValidationRule(_Model):
    """The validation rule for JWTAuthenticator.

    :ivar expression: The CEL expression used to validate the claim or attribute. Required.
    :vartype expression: str
    :ivar message: The validation error message.
    :vartype message: str
    """

    expression: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The CEL expression used to validate the claim or attribute. Required."""
    message: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The validation error message."""

    @overload
    def __init__(
        self,
        *,
        expression: str,
        message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class KubeletConfig(_Model):
    """Kubelet configurations of agent nodes. See `AKS custom node configuration
    <https://docs.microsoft.com/azure/aks/custom-node-configuration>`_ for more details.

    :ivar cpu_manager_policy: The CPU Manager policy to use. The default is 'none'. See `Kubernetes
     CPU management policies
     <https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#cpu-management-policies>`_
     for more information. Allowed values are 'none' and 'static'.
    :vartype cpu_manager_policy: str
    :ivar cpu_cfs_quota: If CPU CFS quota enforcement is enabled for containers that specify CPU
     limits. The default is true.
    :vartype cpu_cfs_quota: bool
    :ivar cpu_cfs_quota_period: The CPU CFS quota period value. The default is '100ms.' Valid
     values are a sequence of decimal numbers with an optional fraction and a unit suffix. For
     example: '300ms', '2h45m'. Supported units are 'ns', 'us', 'ms', 's', 'm', and 'h'.
    :vartype cpu_cfs_quota_period: str
    :ivar image_gc_high_threshold: The percent of disk usage after which image garbage collection
     is always run. To disable image garbage collection, set to 100. The default is 85%.
    :vartype image_gc_high_threshold: int
    :ivar image_gc_low_threshold: The percent of disk usage before which image garbage collection
     is never run. This cannot be set higher than imageGcHighThreshold. The default is 80%.
    :vartype image_gc_low_threshold: int
    :ivar topology_manager_policy: The Topology Manager policy to use. For more information see
     `Kubernetes Topology Manager
     <https://kubernetes.io/docs/tasks/administer-cluster/topology-manager>`_. The default is
     'none'. Allowed values are 'none', 'best-effort', 'restricted', and 'single-numa-node'.
    :vartype topology_manager_policy: str
    :ivar allowed_unsafe_sysctls: Allowed list of unsafe sysctls or unsafe sysctl patterns (ending
     in ``*``).
    :vartype allowed_unsafe_sysctls: list[str]
    :ivar fail_swap_on: If set to true it will make the Kubelet fail to start if swap is enabled on
     the node.
    :vartype fail_swap_on: bool
    :ivar container_log_max_size_mb: The maximum size (e.g. 10Mi) of container log file before it
     is rotated.
    :vartype container_log_max_size_mb: int
    :ivar container_log_max_files: The maximum number of container log files that can be present
     for a container. The number must be  2.
    :vartype container_log_max_files: int
    :ivar pod_max_pids: The maximum number of processes per pod.
    :vartype pod_max_pids: int
    :ivar seccomp_default: Specifies the default seccomp profile applied to all workloads. If not
     specified, 'Unconfined' will be used by default. Known values are: "Unconfined" and
     "RuntimeDefault".
    :vartype seccomp_default: str or ~azure.mgmt.containerservice.models.SeccompDefault
    """

    cpu_manager_policy: Optional[str] = rest_field(
        name="cpuManagerPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The CPU Manager policy to use. The default is 'none'. See `Kubernetes CPU management policies
     <https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#cpu-management-policies>`_
     for more information. Allowed values are 'none' and 'static'."""
    cpu_cfs_quota: Optional[bool] = rest_field(
        name="cpuCfsQuota", visibility=["read", "create", "update", "delete", "query"]
    )
    """If CPU CFS quota enforcement is enabled for containers that specify CPU limits. The default is
     true."""
    cpu_cfs_quota_period: Optional[str] = rest_field(
        name="cpuCfsQuotaPeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """The CPU CFS quota period value. The default is '100ms.' Valid values are a sequence of decimal
     numbers with an optional fraction and a unit suffix. For example: '300ms', '2h45m'. Supported
     units are 'ns', 'us', 'ms', 's', 'm', and 'h'."""
    image_gc_high_threshold: Optional[int] = rest_field(
        name="imageGcHighThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """The percent of disk usage after which image garbage collection is always run. To disable image
     garbage collection, set to 100. The default is 85%."""
    image_gc_low_threshold: Optional[int] = rest_field(
        name="imageGcLowThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """The percent of disk usage before which image garbage collection is never run. This cannot be
     set higher than imageGcHighThreshold. The default is 80%."""
    topology_manager_policy: Optional[str] = rest_field(
        name="topologyManagerPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Topology Manager policy to use. For more information see `Kubernetes Topology Manager
     <https://kubernetes.io/docs/tasks/administer-cluster/topology-manager>`_. The default is
     'none'. Allowed values are 'none', 'best-effort', 'restricted', and 'single-numa-node'."""
    allowed_unsafe_sysctls: Optional[list[str]] = rest_field(
        name="allowedUnsafeSysctls", visibility=["read", "create", "update", "delete", "query"]
    )
    """Allowed list of unsafe sysctls or unsafe sysctl patterns (ending in ``*``)."""
    fail_swap_on: Optional[bool] = rest_field(
        name="failSwapOn", visibility=["read", "create", "update", "delete", "query"]
    )
    """If set to true it will make the Kubelet fail to start if swap is enabled on the node."""
    container_log_max_size_mb: Optional[int] = rest_field(
        name="containerLogMaxSizeMB", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum size (e.g. 10Mi) of container log file before it is rotated."""
    container_log_max_files: Optional[int] = rest_field(
        name="containerLogMaxFiles", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of container log files that can be present for a container. The number must
     be  2."""
    pod_max_pids: Optional[int] = rest_field(
        name="podMaxPids", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of processes per pod."""
    seccomp_default: Optional[Union[str, "_models.SeccompDefault"]] = rest_field(
        name="seccompDefault", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the default seccomp profile applied to all workloads. If not specified, 'Unconfined'
     will be used by default. Known values are: \"Unconfined\" and \"RuntimeDefault\"."""

    @overload
    def __init__(
        self,
        *,
        cpu_manager_policy: Optional[str] = None,
        cpu_cfs_quota: Optional[bool] = None,
        cpu_cfs_quota_period: Optional[str] = None,
        image_gc_high_threshold: Optional[int] = None,
        image_gc_low_threshold: Optional[int] = None,
        topology_manager_policy: Optional[str] = None,
        allowed_unsafe_sysctls: Optional[list[str]] = None,
        fail_swap_on: Optional[bool] = None,
        container_log_max_size_mb: Optional[int] = None,
        container_log_max_files: Optional[int] = None,
        pod_max_pids: Optional[int] = None,
        seccomp_default: Optional[Union[str, "_models.SeccompDefault"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class KubernetesPatchVersion(_Model):
    """Kubernetes patch version profile.

    :ivar upgrades: Possible upgrade path for given patch version.
    :vartype upgrades: list[str]
    """

    upgrades: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Possible upgrade path for given patch version."""

    @overload
    def __init__(
        self,
        *,
        upgrades: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class KubernetesResourceObjectEncryptionProfile(_Model):  # pylint: disable=name-too-long
    """Encryption at rest of Kubernetes resource objects using service-managed keys. More information
    on this can be found under `https://aka.ms/aks/kubernetesResourceObjectEncryption
    <https://aka.ms/aks/kubernetesResourceObjectEncryption>`_.

    :ivar infrastructure_encryption: Whether to enable encryption at rest of Kubernetes resource
     objects using service-managed keys. More information on this can be found under
     `https://aka.ms/aks/kubernetesResourceObjectEncryption
     <https://aka.ms/aks/kubernetesResourceObjectEncryption>`_. Known values are: "Enabled" and
     "Disabled".
    :vartype infrastructure_encryption: str or
     ~azure.mgmt.containerservice.models.InfrastructureEncryption
    """

    infrastructure_encryption: Optional[Union[str, "_models.InfrastructureEncryption"]] = rest_field(
        name="infrastructureEncryption", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to enable encryption at rest of Kubernetes resource objects using service-managed keys.
     More information on this can be found under
     `https://aka.ms/aks/kubernetesResourceObjectEncryption
     <https://aka.ms/aks/kubernetesResourceObjectEncryption>`_. Known values are: \"Enabled\" and
     \"Disabled\"."""

    @overload
    def __init__(
        self,
        *,
        infrastructure_encryption: Optional[Union[str, "_models.InfrastructureEncryption"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class KubernetesVersion(_Model):
    """Kubernetes version profile for given major.minor release.

    :ivar version: major.minor version of Kubernetes release.
    :vartype version: str
    :ivar capabilities: Capabilities on this Kubernetes version.
    :vartype capabilities: ~azure.mgmt.containerservice.models.KubernetesVersionCapabilities
    :ivar is_default: Whether this version is default.
    :vartype is_default: bool
    :ivar is_preview: Whether this version is in preview mode.
    :vartype is_preview: bool
    :ivar patch_versions: Patch versions of Kubernetes release.
    :vartype patch_versions: dict[str, ~azure.mgmt.containerservice.models.KubernetesPatchVersion]
    """

    version: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """major.minor version of Kubernetes release."""
    capabilities: Optional["_models.KubernetesVersionCapabilities"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Capabilities on this Kubernetes version."""
    is_default: Optional[bool] = rest_field(
        name="isDefault", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether this version is default."""
    is_preview: Optional[bool] = rest_field(
        name="isPreview", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether this version is in preview mode."""
    patch_versions: Optional[dict[str, "_models.KubernetesPatchVersion"]] = rest_field(
        name="patchVersions", visibility=["read", "create", "update", "delete", "query"]
    )
    """Patch versions of Kubernetes release."""

    @overload
    def __init__(
        self,
        *,
        version: Optional[str] = None,
        capabilities: Optional["_models.KubernetesVersionCapabilities"] = None,
        is_default: Optional[bool] = None,
        is_preview: Optional[bool] = None,
        patch_versions: Optional[dict[str, "_models.KubernetesPatchVersion"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class KubernetesVersionCapabilities(_Model):
    """Capabilities on this Kubernetes version.

    :ivar support_plan:
    :vartype support_plan: list[str or ~azure.mgmt.containerservice.models.KubernetesSupportPlan]
    """

    support_plan: Optional[list[Union[str, "_models.KubernetesSupportPlan"]]] = rest_field(
        name="supportPlan", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        support_plan: Optional[list[Union[str, "_models.KubernetesSupportPlan"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class KubernetesVersionListResult(_Model):
    """Hold values properties, which is array of KubernetesVersion.

    :ivar values_property: Array of AKS supported Kubernetes versions.
    :vartype values_property: list[~azure.mgmt.containerservice.models.KubernetesVersion]
    """

    values_property: Optional[list["_models.KubernetesVersion"]] = rest_field(
        name="values", visibility=["read", "create", "update", "delete", "query"], original_tsp_name="values"
    )
    """Array of AKS supported Kubernetes versions."""

    @overload
    def __init__(
        self,
        *,
        values_property: Optional[list["_models.KubernetesVersion"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LabelSelector(_Model):
    """A label selector is a label query over a set of resources. The result of matchLabels and
    matchExpressions are ANDed. An empty label selector matches all objects. A null label selector
    matches no objects.

    :ivar match_labels: matchLabels is an array of {key=value} pairs. A single {key=value} in the
     matchLabels map is equivalent to an element of matchExpressions, whose key field is ``key``,
     the operator is ``In``, and the values array contains only ``value``. The requirements are
     ANDed.
    :vartype match_labels: list[str]
    :ivar match_expressions: matchExpressions is a list of label selector requirements. The
     requirements are ANDed.
    :vartype match_expressions: list[~azure.mgmt.containerservice.models.LabelSelectorRequirement]
    """

    match_labels: Optional[list[str]] = rest_field(
        name="matchLabels", visibility=["read", "create", "update", "delete", "query"]
    )
    """matchLabels is an array of {key=value} pairs. A single {key=value} in the matchLabels map is
     equivalent to an element of matchExpressions, whose key field is ``key``, the operator is
     ``In``, and the values array contains only ``value``. The requirements are ANDed."""
    match_expressions: Optional[list["_models.LabelSelectorRequirement"]] = rest_field(
        name="matchExpressions", visibility=["read", "create", "update", "delete", "query"]
    )
    """matchExpressions is a list of label selector requirements. The requirements are ANDed."""

    @overload
    def __init__(
        self,
        *,
        match_labels: Optional[list[str]] = None,
        match_expressions: Optional[list["_models.LabelSelectorRequirement"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LabelSelectorRequirement(_Model):
    """A label selector requirement is a selector that contains values, a key, and an operator that
    relates the key and values.

    :ivar key: key is the label key that the selector applies to.
    :vartype key: str
    :ivar operator: operator represents a key's relationship to a set of values. Valid operators
     are In and NotIn. Known values are: "In", "NotIn", "Exists", and "DoesNotExist".
    :vartype operator: str or ~azure.mgmt.containerservice.models.Operator
    :ivar values_property: values is an array of string values, the values array must be non-empty.
    :vartype values_property: list[str]
    """

    key: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """key is the label key that the selector applies to."""
    operator: Optional[Union[str, "_models.Operator"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """operator represents a key's relationship to a set of values. Valid operators are In and NotIn.
     Known values are: \"In\", \"NotIn\", \"Exists\", and \"DoesNotExist\"."""
    values_property: Optional[list[str]] = rest_field(
        name="values", visibility=["read", "create", "update", "delete", "query"], original_tsp_name="values"
    )
    """values is an array of string values, the values array must be non-empty."""

    @overload
    def __init__(
        self,
        *,
        key: Optional[str] = None,
        operator: Optional[Union[str, "_models.Operator"]] = None,
        values_property: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LinuxOSConfig(_Model):
    """OS configurations of Linux agent nodes. See `AKS custom node configuration
    <https://docs.microsoft.com/azure/aks/custom-node-configuration>`_ for more details.

    :ivar sysctls: Sysctl settings for Linux agent nodes.
    :vartype sysctls: ~azure.mgmt.containerservice.models.SysctlConfig
    :ivar transparent_huge_page_enabled: Whether transparent hugepages are enabled. Valid values
     are 'always', 'madvise', and 'never'. The default is 'always'. For more information see
     `Transparent Hugepages
     <https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge>`_.
    :vartype transparent_huge_page_enabled: str
    :ivar transparent_huge_page_defrag: Whether the kernel should make aggressive use of memory
     compaction to make more hugepages available. Valid values are 'always', 'defer',
     'defer+madvise', 'madvise' and 'never'. The default is 'madvise'. For more information see
     `Transparent Hugepages
     <https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge>`_.
    :vartype transparent_huge_page_defrag: str
    :ivar swap_file_size_mb: The size in MB of a swap file that will be created on each node.
    :vartype swap_file_size_mb: int
    """

    sysctls: Optional["_models.SysctlConfig"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sysctl settings for Linux agent nodes."""
    transparent_huge_page_enabled: Optional[str] = rest_field(
        name="transparentHugePageEnabled", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether transparent hugepages are enabled. Valid values are 'always', 'madvise', and 'never'.
     The default is 'always'. For more information see `Transparent Hugepages
     <https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge>`_."""
    transparent_huge_page_defrag: Optional[str] = rest_field(
        name="transparentHugePageDefrag", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether the kernel should make aggressive use of memory compaction to make more hugepages
     available. Valid values are 'always', 'defer', 'defer+madvise', 'madvise' and 'never'. The
     default is 'madvise'. For more information see `Transparent Hugepages
     <https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge>`_."""
    swap_file_size_mb: Optional[int] = rest_field(
        name="swapFileSizeMB", visibility=["read", "create", "update", "delete", "query"]
    )
    """The size in MB of a swap file that will be created on each node."""

    @overload
    def __init__(
        self,
        *,
        sysctls: Optional["_models.SysctlConfig"] = None,
        transparent_huge_page_enabled: Optional[str] = None,
        transparent_huge_page_defrag: Optional[str] = None,
        swap_file_size_mb: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoadBalancer(ProxyResource):
    """The configurations regarding multiple standard load balancers. If not supplied, single load
    balancer mode will be used. Multiple standard load balancers mode will be used if at lease one
    configuration is supplied. There has to be a configuration named ``kubernetes``. The name field
    will be the name of the corresponding public load balancer. There will be an internal load
    balancer created if needed, and the name will be ``<name>-internal``. The internal lb shares
    the same configurations as the external one. The internal lbs are not needed to be included in
    LoadBalancer list.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: The properties of the load balancer.
    :vartype properties: ~azure.mgmt.containerservice.models.LoadBalancerProperties
    """

    properties: Optional["_models.LoadBalancerProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the load balancer."""

    __flattened_items = [
        "primary_agent_pool_name",
        "allow_service_placement",
        "service_label_selector",
        "service_namespace_selector",
        "node_selector",
        "provisioning_state",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.LoadBalancerProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class LoadBalancerProperties(_Model):
    """LoadBalancerProperties.

    :ivar primary_agent_pool_name: Required field. A string value that must specify the ID of an
     existing agent pool. All nodes in the given pool will always be added to this load balancer.
     This agent pool must have at least one node and minCount>=1 for autoscaling operations. An
     agent pool can only be the primary pool for a single load balancer. Required.
    :vartype primary_agent_pool_name: str
    :ivar allow_service_placement: Whether to automatically place services on the load balancer. If
     not supplied, the default value is true. If set to false manually, both of the external and the
     internal load balancer will not be selected for services unless they explicitly target it.
    :vartype allow_service_placement: bool
    :ivar service_label_selector: Only services that must match this selector can be placed on this
     load balancer.
    :vartype service_label_selector: ~azure.mgmt.containerservice.models.LabelSelector
    :ivar service_namespace_selector: Services created in namespaces that match the selector can be
     placed on this load balancer.
    :vartype service_namespace_selector: ~azure.mgmt.containerservice.models.LabelSelector
    :ivar node_selector: Nodes that match this selector will be possible members of this load
     balancer.
    :vartype node_selector: ~azure.mgmt.containerservice.models.LabelSelector
    :ivar provisioning_state: The current provisioning state.
    :vartype provisioning_state: str
    """

    primary_agent_pool_name: str = rest_field(
        name="primaryAgentPoolName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Required field. A string value that must specify the ID of an existing agent pool. All nodes in
     the given pool will always be added to this load balancer. This agent pool must have at least
     one node and minCount>=1 for autoscaling operations. An agent pool can only be the primary pool
     for a single load balancer. Required."""
    allow_service_placement: Optional[bool] = rest_field(
        name="allowServicePlacement", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to automatically place services on the load balancer. If not supplied, the default
     value is true. If set to false manually, both of the external and the internal load balancer
     will not be selected for services unless they explicitly target it."""
    service_label_selector: Optional["_models.LabelSelector"] = rest_field(
        name="serviceLabelSelector", visibility=["read", "create", "update", "delete", "query"]
    )
    """Only services that must match this selector can be placed on this load balancer."""
    service_namespace_selector: Optional["_models.LabelSelector"] = rest_field(
        name="serviceNamespaceSelector", visibility=["read", "create", "update", "delete", "query"]
    )
    """Services created in namespaces that match the selector can be placed on this load balancer."""
    node_selector: Optional["_models.LabelSelector"] = rest_field(
        name="nodeSelector", visibility=["read", "create", "update", "delete", "query"]
    )
    """Nodes that match this selector will be possible members of this load balancer."""
    provisioning_state: Optional[str] = rest_field(name="provisioningState", visibility=["read"])
    """The current provisioning state."""

    @overload
    def __init__(
        self,
        *,
        primary_agent_pool_name: str,
        allow_service_placement: Optional[bool] = None,
        service_label_selector: Optional["_models.LabelSelector"] = None,
        service_namespace_selector: Optional["_models.LabelSelector"] = None,
        node_selector: Optional["_models.LabelSelector"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LocalDNSOverride(_Model):
    """Overrides for localDNS profile.

    :ivar query_logging: Log level for DNS queries in localDNS. Known values are: "Error" and
     "Log".
    :vartype query_logging: str or ~azure.mgmt.containerservice.models.LocalDNSQueryLogging
    :ivar protocol: Enforce TCP or prefer UDP protocol for connections from localDNS to upstream
     DNS server. Known values are: "PreferUDP" and "ForceTCP".
    :vartype protocol: str or ~azure.mgmt.containerservice.models.LocalDNSProtocol
    :ivar forward_destination: Destination server for DNS queries to be forwarded from localDNS.
     Known values are: "ClusterCoreDNS" and "VnetDNS".
    :vartype forward_destination: str or
     ~azure.mgmt.containerservice.models.LocalDNSForwardDestination
    :ivar forward_policy: Forward policy for selecting upstream DNS server. See `forward plugin
     <https://coredns.io/plugins/forward>`_ for more information. Known values are: "Sequential",
     "RoundRobin", and "Random".
    :vartype forward_policy: str or ~azure.mgmt.containerservice.models.LocalDNSForwardPolicy
    :ivar max_concurrent: Maximum number of concurrent queries. See `forward plugin
     <https://coredns.io/plugins/forward>`_ for more information.
    :vartype max_concurrent: int
    :ivar cache_duration_in_seconds: Cache max TTL in seconds. See `cache plugin
     <https://coredns.io/plugins/cache>`_ for more information.
    :vartype cache_duration_in_seconds: int
    :ivar serve_stale_duration_in_seconds: Serve stale duration in seconds. See `cache plugin
     <https://coredns.io/plugins/cache>`_ for more information.
    :vartype serve_stale_duration_in_seconds: int
    :ivar serve_stale: Policy for serving stale data. See `cache plugin
     <https://coredns.io/plugins/cache>`_ for more information. Known values are: "Verify",
     "Immediate", and "Disable".
    :vartype serve_stale: str or ~azure.mgmt.containerservice.models.LocalDNSServeStale
    """

    query_logging: Optional[Union[str, "_models.LocalDNSQueryLogging"]] = rest_field(
        name="queryLogging", visibility=["read", "create", "update", "delete", "query"]
    )
    """Log level for DNS queries in localDNS. Known values are: \"Error\" and \"Log\"."""
    protocol: Optional[Union[str, "_models.LocalDNSProtocol"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Enforce TCP or prefer UDP protocol for connections from localDNS to upstream DNS server. Known
     values are: \"PreferUDP\" and \"ForceTCP\"."""
    forward_destination: Optional[Union[str, "_models.LocalDNSForwardDestination"]] = rest_field(
        name="forwardDestination", visibility=["read", "create", "update", "delete", "query"]
    )
    """Destination server for DNS queries to be forwarded from localDNS. Known values are:
     \"ClusterCoreDNS\" and \"VnetDNS\"."""
    forward_policy: Optional[Union[str, "_models.LocalDNSForwardPolicy"]] = rest_field(
        name="forwardPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """Forward policy for selecting upstream DNS server. See `forward plugin
     <https://coredns.io/plugins/forward>`_ for more information. Known values are: \"Sequential\",
     \"RoundRobin\", and \"Random\"."""
    max_concurrent: Optional[int] = rest_field(
        name="maxConcurrent", visibility=["read", "create", "update", "delete", "query"]
    )
    """Maximum number of concurrent queries. See `forward plugin
     <https://coredns.io/plugins/forward>`_ for more information."""
    cache_duration_in_seconds: Optional[int] = rest_field(
        name="cacheDurationInSeconds", visibility=["read", "create", "update", "delete", "query"]
    )
    """Cache max TTL in seconds. See `cache plugin <https://coredns.io/plugins/cache>`_ for more
     information."""
    serve_stale_duration_in_seconds: Optional[int] = rest_field(
        name="serveStaleDurationInSeconds", visibility=["read", "create", "update", "delete", "query"]
    )
    """Serve stale duration in seconds. See `cache plugin <https://coredns.io/plugins/cache>`_ for
     more information."""
    serve_stale: Optional[Union[str, "_models.LocalDNSServeStale"]] = rest_field(
        name="serveStale", visibility=["read", "create", "update", "delete", "query"]
    )
    """Policy for serving stale data. See `cache plugin <https://coredns.io/plugins/cache>`_ for more
     information. Known values are: \"Verify\", \"Immediate\", and \"Disable\"."""

    @overload
    def __init__(
        self,
        *,
        query_logging: Optional[Union[str, "_models.LocalDNSQueryLogging"]] = None,
        protocol: Optional[Union[str, "_models.LocalDNSProtocol"]] = None,
        forward_destination: Optional[Union[str, "_models.LocalDNSForwardDestination"]] = None,
        forward_policy: Optional[Union[str, "_models.LocalDNSForwardPolicy"]] = None,
        max_concurrent: Optional[int] = None,
        cache_duration_in_seconds: Optional[int] = None,
        serve_stale_duration_in_seconds: Optional[int] = None,
        serve_stale: Optional[Union[str, "_models.LocalDNSServeStale"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LocalDNSProfile(_Model):
    """Configures the per-node local DNS, with VnetDNS and KubeDNS overrides. LocalDNS helps improve
    performance and reliability of DNS resolution in an AKS cluster. For more details see
    aka.ms/aks/localdns.

    :ivar mode: Mode of enablement for localDNS. Known values are: "Preferred", "Required", and
     "Disabled".
    :vartype mode: str or ~azure.mgmt.containerservice.models.LocalDNSMode
    :ivar state: System-generated state of localDNS. Known values are: "Enabled" and "Disabled".
    :vartype state: str or ~azure.mgmt.containerservice.models.LocalDNSState
    :ivar vnet_dns_overrides: VnetDNS overrides apply to DNS traffic from pods with
     dnsPolicy:default or kubelet (referred to as VnetDNS traffic).
    :vartype vnet_dns_overrides: dict[str, ~azure.mgmt.containerservice.models.LocalDNSOverride]
    :ivar kube_dns_overrides: KubeDNS overrides apply to DNS traffic from pods with
     dnsPolicy:ClusterFirst (referred to as KubeDNS traffic).
    :vartype kube_dns_overrides: dict[str, ~azure.mgmt.containerservice.models.LocalDNSOverride]
    """

    mode: Optional[Union[str, "_models.LocalDNSMode"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Mode of enablement for localDNS. Known values are: \"Preferred\", \"Required\", and
     \"Disabled\"."""
    state: Optional[Union[str, "_models.LocalDNSState"]] = rest_field(visibility=["read"])
    """System-generated state of localDNS. Known values are: \"Enabled\" and \"Disabled\"."""
    vnet_dns_overrides: Optional[dict[str, "_models.LocalDNSOverride"]] = rest_field(
        name="vnetDNSOverrides", visibility=["read", "create", "update", "delete", "query"]
    )
    """VnetDNS overrides apply to DNS traffic from pods with dnsPolicy:default or kubelet (referred to
     as VnetDNS traffic)."""
    kube_dns_overrides: Optional[dict[str, "_models.LocalDNSOverride"]] = rest_field(
        name="kubeDNSOverrides", visibility=["read", "create", "update", "delete", "query"]
    )
    """KubeDNS overrides apply to DNS traffic from pods with dnsPolicy:ClusterFirst (referred to as
     KubeDNS traffic)."""

    @overload
    def __init__(
        self,
        *,
        mode: Optional[Union[str, "_models.LocalDNSMode"]] = None,
        vnet_dns_overrides: Optional[dict[str, "_models.LocalDNSOverride"]] = None,
        kube_dns_overrides: Optional[dict[str, "_models.LocalDNSOverride"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Machine(ProxyResource):
    """A machine. Contains details about the underlying virtual machine. A machine may be visible here
    but not in kubectl get nodes; if so it may be because the machine has not been registered with
    the Kubernetes API Server yet.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: The properties of the machine.
    :vartype properties: ~azure.mgmt.containerservice.models.MachineProperties
    :ivar zones: The Availability zone in which machine is located.
    :vartype zones: list[str]
    """

    properties: Optional["_models.MachineProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the machine."""
    zones: Optional[list[str]] = rest_field(visibility=["read"])
    """The Availability zone in which machine is located."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.MachineProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MachineHardwareProfile(_Model):
    """The hardware and GPU settings of the machine.

    :ivar vm_size: The size of the VM. VM size availability varies by region. If a node contains
     insufficient compute resources (memory, cpu, etc) pods might fail to run correctly. For more
     details on restricted VM sizes, see: `https://docs.microsoft.com/azure/aks/quotas-skus-regions
     <https://docs.microsoft.com/azure/aks/quotas-skus-regions>`_.
    :vartype vm_size: str
    :ivar gpu_instance_profile: GPUInstanceProfile to be used to specify GPU MIG instance profile
     for supported GPU VM SKU. Known values are: "MIG1g", "MIG2g", "MIG3g", "MIG4g", and "MIG7g".
    :vartype gpu_instance_profile: str or ~azure.mgmt.containerservice.models.GPUInstanceProfile
    :ivar gpu_profile: The GPU settings of the machine.
    :vartype gpu_profile: ~azure.mgmt.containerservice.models.GPUProfile
    """

    vm_size: Optional[str] = rest_field(name="vmSize", visibility=["read", "create", "update", "delete", "query"])
    """The size of the VM. VM size availability varies by region. If a node contains insufficient
     compute resources (memory, cpu, etc) pods might fail to run correctly. For more details on
     restricted VM sizes, see: `https://docs.microsoft.com/azure/aks/quotas-skus-regions
     <https://docs.microsoft.com/azure/aks/quotas-skus-regions>`_."""
    gpu_instance_profile: Optional[Union[str, "_models.GPUInstanceProfile"]] = rest_field(
        name="gpuInstanceProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
     Known values are: \"MIG1g\", \"MIG2g\", \"MIG3g\", \"MIG4g\", and \"MIG7g\"."""
    gpu_profile: Optional["_models.GPUProfile"] = rest_field(
        name="gpuProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The GPU settings of the machine."""

    @overload
    def __init__(
        self,
        *,
        vm_size: Optional[str] = None,
        gpu_instance_profile: Optional[Union[str, "_models.GPUInstanceProfile"]] = None,
        gpu_profile: Optional["_models.GPUProfile"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MachineIpAddress(_Model):
    """The machine IP address details.

    :ivar family: To determine if address belongs IPv4 or IPv6 family. Known values are: "IPv4" and
     "IPv6".
    :vartype family: str or ~azure.mgmt.containerservice.models.IPFamily
    :ivar ip: IPv4 or IPv6 address of the machine.
    :vartype ip: str
    """

    family: Optional[Union[str, "_models.IPFamily"]] = rest_field(visibility=["read"])
    """To determine if address belongs IPv4 or IPv6 family. Known values are: \"IPv4\" and \"IPv6\"."""
    ip: Optional[str] = rest_field(visibility=["read"])
    """IPv4 or IPv6 address of the machine."""


class MachineKubernetesProfile(_Model):
    """The Kubernetes configurations used by the machine.

    :ivar node_labels: The node labels on the machine.
    :vartype node_labels: dict[str, str]
    :ivar orchestrator_version: The version of Kubernetes specified by the user. Both patch version
     <major.minor.patch> and <major.minor> are supported. When <major.minor> is specified, the
     latest supported patch version is chosen automatically.
    :vartype orchestrator_version: str
    :ivar current_orchestrator_version: The version of Kubernetes running on the machine. If
     orchestratorVersion was a fully specified version <major.minor.patch>, this field will be
     exactly equal to it. If orchestratorVersion was <major.minor>, this field will contain the full
     <major.minor.patch> version being used.
    :vartype current_orchestrator_version: str
    :ivar kubelet_disk_type: Determines the placement of emptyDir volumes, container runtime data
     root, and Kubelet ephemeral storage. Known values are: "OS" and "Temporary".
    :vartype kubelet_disk_type: str or ~azure.mgmt.containerservice.models.KubeletDiskType
    :ivar kubelet_config: The Kubelet configuration on the machine.
    :vartype kubelet_config: ~azure.mgmt.containerservice.models.KubeletConfig
    :ivar node_initialization_taints: Taints added on the node during creation that will not be
     reconciled by AKS. These taints will not be reconciled by AKS and can be removed with a kubectl
     call. These taints allow for required configuration to run before the node is ready to accept
     workloads, for example 'key1=value1:NoSchedule' that then can be removed with ``kubectl taint
     nodes node1 key1=value1:NoSchedule-``.
    :vartype node_initialization_taints: list[str]
    :ivar node_taints: The taints added to new node during machine create. For example,
     key=value:NoSchedule.
    :vartype node_taints: list[str]
    :ivar max_pods: The maximum number of pods that can run on a node.
    :vartype max_pods: int
    :ivar node_name: The node name in the Kubernetes cluster.
    :vartype node_name: str
    :ivar workload_runtime: Determines the type of workload a node can run. Known values are:
     "OCIContainer", "WasmWasi", "KataMshvVmIsolation", and "KataVmIsolation".
    :vartype workload_runtime: str or ~azure.mgmt.containerservice.models.WorkloadRuntime
    :ivar artifact_streaming_profile: Configuration for using artifact streaming on AKS.
    :vartype artifact_streaming_profile:
     ~azure.mgmt.containerservice.models.AgentPoolArtifactStreamingProfile
    """

    node_labels: Optional[dict[str, str]] = rest_field(
        name="nodeLabels", visibility=["read", "create", "update", "delete", "query"]
    )
    """The node labels on the machine."""
    orchestrator_version: Optional[str] = rest_field(
        name="orchestratorVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The version of Kubernetes specified by the user. Both patch version <major.minor.patch> and
     <major.minor> are supported. When <major.minor> is specified, the latest supported patch
     version is chosen automatically."""
    current_orchestrator_version: Optional[str] = rest_field(name="currentOrchestratorVersion", visibility=["read"])
    """The version of Kubernetes running on the machine. If orchestratorVersion was a fully specified
     version <major.minor.patch>, this field will be exactly equal to it. If orchestratorVersion was
     <major.minor>, this field will contain the full <major.minor.patch> version being used."""
    kubelet_disk_type: Optional[Union[str, "_models.KubeletDiskType"]] = rest_field(
        name="kubeletDiskType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines the placement of emptyDir volumes, container runtime data root, and Kubelet
     ephemeral storage. Known values are: \"OS\" and \"Temporary\"."""
    kubelet_config: Optional["_models.KubeletConfig"] = rest_field(
        name="kubeletConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Kubelet configuration on the machine."""
    node_initialization_taints: Optional[list[str]] = rest_field(
        name="nodeInitializationTaints", visibility=["read", "create", "update", "delete", "query"]
    )
    """Taints added on the node during creation that will not be reconciled by AKS. These taints will
     not be reconciled by AKS and can be removed with a kubectl call. These taints allow for
     required configuration to run before the node is ready to accept workloads, for example
     'key1=value1:NoSchedule' that then can be removed with ``kubectl taint nodes node1
     key1=value1:NoSchedule-``."""
    node_taints: Optional[list[str]] = rest_field(
        name="nodeTaints", visibility=["read", "create", "update", "delete", "query"]
    )
    """The taints added to new node during machine create. For example, key=value:NoSchedule."""
    max_pods: Optional[int] = rest_field(name="maxPods", visibility=["read", "create", "update", "delete", "query"])
    """The maximum number of pods that can run on a node."""
    node_name: Optional[str] = rest_field(name="nodeName", visibility=["read"])
    """The node name in the Kubernetes cluster."""
    workload_runtime: Optional[Union[str, "_models.WorkloadRuntime"]] = rest_field(
        name="workloadRuntime", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines the type of workload a node can run. Known values are: \"OCIContainer\",
     \"WasmWasi\", \"KataMshvVmIsolation\", and \"KataVmIsolation\"."""
    artifact_streaming_profile: Optional["_models.AgentPoolArtifactStreamingProfile"] = rest_field(
        name="artifactStreamingProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Configuration for using artifact streaming on AKS."""

    @overload
    def __init__(
        self,
        *,
        node_labels: Optional[dict[str, str]] = None,
        orchestrator_version: Optional[str] = None,
        kubelet_disk_type: Optional[Union[str, "_models.KubeletDiskType"]] = None,
        kubelet_config: Optional["_models.KubeletConfig"] = None,
        node_initialization_taints: Optional[list[str]] = None,
        node_taints: Optional[list[str]] = None,
        max_pods: Optional[int] = None,
        workload_runtime: Optional[Union[str, "_models.WorkloadRuntime"]] = None,
        artifact_streaming_profile: Optional["_models.AgentPoolArtifactStreamingProfile"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MachineNetworkProperties(_Model):
    """network properties of the machine.

    :ivar ip_addresses: IPv4, IPv6 addresses of the machine.
    :vartype ip_addresses: list[~azure.mgmt.containerservice.models.MachineIpAddress]
    :ivar vnet_subnet_id: The ID of the subnet which node and optionally pods will join on startup.
     If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is
     specified, this applies to nodes and pods, otherwise it applies to just nodes. This is of the
     form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
    :vartype vnet_subnet_id: str
    :ivar pod_subnet_id: The ID of the subnet which pods will join when launched. If omitted, pod
     IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of
     the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
    :vartype pod_subnet_id: str
    :ivar enable_node_public_ip: Whether the machine is allocated its own public IP. Some scenarios
     may require the machine to receive their own dedicated public IP addresses. A common scenario
     is for gaming workloads, where a console needs to make a direct connection to a cloud virtual
     machine to minimize hops. The default is false.
    :vartype enable_node_public_ip: bool
    :ivar node_public_ip_prefix_id: The public IP prefix ID which VM node should use IPs from. This
     is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}.
    :vartype node_public_ip_prefix_id: str
    :ivar node_public_ip_tags: IPTags of instance-level public IPs.
    :vartype node_public_ip_tags: list[~azure.mgmt.containerservice.models.IPTag]
    """

    ip_addresses: Optional[list["_models.MachineIpAddress"]] = rest_field(name="ipAddresses", visibility=["read"])
    """IPv4, IPv6 addresses of the machine."""
    vnet_subnet_id: Optional[str] = rest_field(
        name="vnetSubnetID", visibility=["read", "create", "update", "delete", "query"]
    )
    """The ID of the subnet which node and optionally pods will join on startup. If this is not
     specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this
     applies to nodes and pods, otherwise it applies to just nodes. This is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}."""
    pod_subnet_id: Optional[str] = rest_field(
        name="podSubnetID", visibility=["read", "create", "update", "delete", "query"]
    )
    """The ID of the subnet which pods will join when launched. If omitted, pod IPs are statically
     assigned on the node subnet (see vnetSubnetID for more details). This is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}."""
    enable_node_public_ip: Optional[bool] = rest_field(
        name="enableNodePublicIP", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether the machine is allocated its own public IP. Some scenarios may require the machine to
     receive their own dedicated public IP addresses. A common scenario is for gaming workloads,
     where a console needs to make a direct connection to a cloud virtual machine to minimize hops.
     The default is false."""
    node_public_ip_prefix_id: Optional[str] = rest_field(
        name="nodePublicIPPrefixID", visibility=["read", "create", "update", "delete", "query"]
    )
    """The public IP prefix ID which VM node should use IPs from. This is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}."""
    node_public_ip_tags: Optional[list["_models.IPTag"]] = rest_field(
        name="nodePublicIPTags", visibility=["read", "create", "update", "delete", "query"]
    )
    """IPTags of instance-level public IPs."""

    @overload
    def __init__(
        self,
        *,
        vnet_subnet_id: Optional[str] = None,
        pod_subnet_id: Optional[str] = None,
        enable_node_public_ip: Optional[bool] = None,
        node_public_ip_prefix_id: Optional[str] = None,
        node_public_ip_tags: Optional[list["_models.IPTag"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MachineOSProfile(_Model):
    """The operating system and disk used by the machine.

    :ivar os_type: The operating system type. The default is Linux. Known values are: "Linux" and
     "Windows".
    :vartype os_type: str or ~azure.mgmt.containerservice.models.OSType
    :ivar os_sku: Specifies the OS SKU used by the agent pool. If not specified, the default is
     Ubuntu if OSType=Linux or Windows2019 if OSType=Windows. And the default Windows OSSKU will be
     changed to Windows2022 after Windows2019 is deprecated. Known values are: "Ubuntu",
     "AzureLinux", "AzureLinux3", "Mariner", "Flatcar", "CBLMariner", "Windows2019", "Windows2022",
     "Ubuntu2204", "Windows2025", "WindowsAnnual", and "Ubuntu2404".
    :vartype os_sku: str or ~azure.mgmt.containerservice.models.OSSKU
    :ivar os_disk_size_gb: OS Disk Size in GB to be used to specify the disk size for every machine
     in the master/agent pool. If you specify 0, it will apply the default osDisk size according to
     the vmSize specified.
    :vartype os_disk_size_gb: int
    :ivar os_disk_type: The OS disk type to be used for machines in the agent pool. The default is
     'Ephemeral' if the VM supports it and has a cache disk larger than the requested OSDiskSizeGB.
     Otherwise, defaults to 'Managed'. May not be changed after creation. For more information see
     `Ephemeral OS <https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os>`_.
     Known values are: "Managed" and "Ephemeral".
    :vartype os_disk_type: str or ~azure.mgmt.containerservice.models.OSDiskType
    :ivar enable_fips: Whether to use a FIPS-enabled OS.
    :vartype enable_fips: bool
    :ivar linux_profile: The Linux machine's specific profile.
    :vartype linux_profile: ~azure.mgmt.containerservice.models.MachineOSProfileLinuxProfile
    :ivar windows_profile: The Windows machine's specific profile.
    :vartype windows_profile: ~azure.mgmt.containerservice.models.AgentPoolWindowsProfile
    """

    os_type: Optional[Union[str, "_models.OSType"]] = rest_field(
        name="osType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The operating system type. The default is Linux. Known values are: \"Linux\" and \"Windows\"."""
    os_sku: Optional[Union[str, "_models.OSSKU"]] = rest_field(
        name="osSKU", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the OS SKU used by the agent pool. If not specified, the default is Ubuntu if
     OSType=Linux or Windows2019 if OSType=Windows. And the default Windows OSSKU will be changed to
     Windows2022 after Windows2019 is deprecated. Known values are: \"Ubuntu\", \"AzureLinux\",
     \"AzureLinux3\", \"Mariner\", \"Flatcar\", \"CBLMariner\", \"Windows2019\", \"Windows2022\",
     \"Ubuntu2204\", \"Windows2025\", \"WindowsAnnual\", and \"Ubuntu2404\"."""
    os_disk_size_gb: Optional[int] = rest_field(
        name="osDiskSizeGB", visibility=["read", "create", "update", "delete", "query"]
    )
    """OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent
     pool. If you specify 0, it will apply the default osDisk size according to the vmSize
     specified."""
    os_disk_type: Optional[Union[str, "_models.OSDiskType"]] = rest_field(
        name="osDiskType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The OS disk type to be used for machines in the agent pool. The default is 'Ephemeral' if the
     VM supports it and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults
     to 'Managed'. May not be changed after creation. For more information see `Ephemeral OS
     <https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os>`_. Known values are:
     \"Managed\" and \"Ephemeral\"."""
    enable_fips: Optional[bool] = rest_field(
        name="enableFIPS", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to use a FIPS-enabled OS."""
    linux_profile: Optional["_models.MachineOSProfileLinuxProfile"] = rest_field(
        name="linuxProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Linux machine's specific profile."""
    windows_profile: Optional["_models.AgentPoolWindowsProfile"] = rest_field(
        name="windowsProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Windows machine's specific profile."""

    @overload
    def __init__(
        self,
        *,
        os_type: Optional[Union[str, "_models.OSType"]] = None,
        os_sku: Optional[Union[str, "_models.OSSKU"]] = None,
        os_disk_size_gb: Optional[int] = None,
        os_disk_type: Optional[Union[str, "_models.OSDiskType"]] = None,
        enable_fips: Optional[bool] = None,
        linux_profile: Optional["_models.MachineOSProfileLinuxProfile"] = None,
        windows_profile: Optional["_models.AgentPoolWindowsProfile"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MachineOSProfileLinuxProfile(_Model):
    """The Linux machine's specific profile.

    :ivar linux_os_config: The OS configuration of Linux machine.
    :vartype linux_os_config: ~azure.mgmt.containerservice.models.LinuxOSConfig
    :ivar message_of_the_day: Message of the day for Linux nodes, base64-encoded. A base64-encoded
     string which will be written to /etc/motd after decoding. This allows customization of the
     message of the day for Linux nodes. It must not be specified for Windows nodes. It must be a
     static string (i.e., will be printed raw and not be executed as a script).
    :vartype message_of_the_day: str
    """

    linux_os_config: Optional["_models.LinuxOSConfig"] = rest_field(
        name="linuxOSConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """The OS configuration of Linux machine."""
    message_of_the_day: Optional[str] = rest_field(
        name="messageOfTheDay", visibility=["read", "create", "update", "delete", "query"]
    )
    """Message of the day for Linux nodes, base64-encoded. A base64-encoded string which will be
     written to /etc/motd after decoding. This allows customization of the message of the day for
     Linux nodes. It must not be specified for Windows nodes. It must be a static string (i.e., will
     be printed raw and not be executed as a script)."""

    @overload
    def __init__(
        self,
        *,
        linux_os_config: Optional["_models.LinuxOSConfig"] = None,
        message_of_the_day: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MachineProperties(_Model):
    """The properties of the machine.

    :ivar network: network properties of the machine.
    :vartype network: ~azure.mgmt.containerservice.models.MachineNetworkProperties
    :ivar resource_id: Azure resource id of the machine. It can be used to GET underlying VM
     Instance.
    :vartype resource_id: str
    :ivar hardware: The hardware and GPU settings of the machine.
    :vartype hardware: ~azure.mgmt.containerservice.models.MachineHardwareProfile
    :ivar operating_system: The operating system and disk used by the machine.
    :vartype operating_system: ~azure.mgmt.containerservice.models.MachineOSProfile
    :ivar kubernetes: The Kubernetes configurations used by the machine.
    :vartype kubernetes: ~azure.mgmt.containerservice.models.MachineKubernetesProfile
    :ivar mode: Machine only allows 'System' and 'User' mode. Known values are: "System", "User",
     "Gateway", "ManagedSystem", and "Machines".
    :vartype mode: str or ~azure.mgmt.containerservice.models.AgentPoolMode
    :ivar security: The security settings of the machine.
    :vartype security: ~azure.mgmt.containerservice.models.MachineSecurityProfile
    :ivar priority: The priority for the machine. If not specified, the default is 'Regular'. Known
     values are: "Spot" and "Regular".
    :vartype priority: str or ~azure.mgmt.containerservice.models.ScaleSetPriority
    :ivar node_image_version: The version of node image.
    :vartype node_image_version: str
    :ivar provisioning_state: The current deployment or provisioning state.
    :vartype provisioning_state: str
    :ivar tags: The tags to be persisted on the machine.
    :vartype tags: dict[str, str]
    :ivar e_tag: Unique read-only string used to implement optimistic concurrency. The eTag value
     will change when the resource is updated. Specify an if-match or if-none-match header with the
     eTag value for a subsequent request to enable optimistic concurrency per the normal eTag
     convention.
    :vartype e_tag: str
    :ivar status: Contains read-only information about the machine.
    :vartype status: ~azure.mgmt.containerservice.models.MachineStatus
    """

    network: Optional["_models.MachineNetworkProperties"] = rest_field(visibility=["read"])
    """network properties of the machine."""
    resource_id: Optional[str] = rest_field(name="resourceId", visibility=["read"])
    """Azure resource id of the machine. It can be used to GET underlying VM Instance."""
    hardware: Optional["_models.MachineHardwareProfile"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The hardware and GPU settings of the machine."""
    operating_system: Optional["_models.MachineOSProfile"] = rest_field(
        name="operatingSystem", visibility=["read", "create", "update", "delete", "query"]
    )
    """The operating system and disk used by the machine."""
    kubernetes: Optional["_models.MachineKubernetesProfile"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The Kubernetes configurations used by the machine."""
    mode: Optional[Union[str, "_models.AgentPoolMode"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Machine only allows 'System' and 'User' mode. Known values are: \"System\", \"User\",
     \"Gateway\", \"ManagedSystem\", and \"Machines\"."""
    security: Optional["_models.MachineSecurityProfile"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The security settings of the machine."""
    priority: Optional[Union[str, "_models.ScaleSetPriority"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The priority for the machine. If not specified, the default is 'Regular'. Known values are:
     \"Spot\" and \"Regular\"."""
    node_image_version: Optional[str] = rest_field(name="nodeImageVersion", visibility=["read"])
    """The version of node image."""
    provisioning_state: Optional[str] = rest_field(name="provisioningState", visibility=["read"])
    """The current deployment or provisioning state."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The tags to be persisted on the machine."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read"])
    """Unique read-only string used to implement optimistic concurrency. The eTag value will change
     when the resource is updated. Specify an if-match or if-none-match header with the eTag value
     for a subsequent request to enable optimistic concurrency per the normal eTag convention."""
    status: Optional["_models.MachineStatus"] = rest_field(visibility=["read"])
    """Contains read-only information about the machine."""

    @overload
    def __init__(
        self,
        *,
        hardware: Optional["_models.MachineHardwareProfile"] = None,
        operating_system: Optional["_models.MachineOSProfile"] = None,
        kubernetes: Optional["_models.MachineKubernetesProfile"] = None,
        mode: Optional[Union[str, "_models.AgentPoolMode"]] = None,
        security: Optional["_models.MachineSecurityProfile"] = None,
        priority: Optional[Union[str, "_models.ScaleSetPriority"]] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MachineSecurityProfile(_Model):
    """The security settings of the machine.

    :ivar enable_vtpm: vTPM is a Trusted Launch feature for configuring a dedicated secure vault
     for keys and measurements held locally on the node. For more details, see
     aka.ms/aks/trustedlaunch. If not specified, the default is false.
    :vartype enable_vtpm: bool
    :ivar enable_secure_boot: Secure Boot is a feature of Trusted Launch which ensures that only
     signed operating systems and drivers can boot. For more details, see aka.ms/aks/trustedlaunch.
     If not specified, the default is false.
    :vartype enable_secure_boot: bool
    :ivar ssh_access: SSH access method of an agent pool. Known values are: "LocalUser",
     "Disabled", and "EntraId".
    :vartype ssh_access: str or ~azure.mgmt.containerservice.models.AgentPoolSSHAccess
    :ivar enable_encryption_at_host: Whether to enable host based OS and data drive encryption.
     This is only supported on certain VM sizes and in certain Azure regions. For more information,
     see: `https://docs.microsoft.com/azure/aks/enable-host-encryption
     <https://docs.microsoft.com/azure/aks/enable-host-encryption>`_.
    :vartype enable_encryption_at_host: bool
    """

    enable_vtpm: Optional[bool] = rest_field(
        name="enableVTPM", visibility=["read", "create", "update", "delete", "query"]
    )
    """vTPM is a Trusted Launch feature for configuring a dedicated secure vault for keys and
     measurements held locally on the node. For more details, see aka.ms/aks/trustedlaunch. If not
     specified, the default is false."""
    enable_secure_boot: Optional[bool] = rest_field(
        name="enableSecureBoot", visibility=["read", "create", "update", "delete", "query"]
    )
    """Secure Boot is a feature of Trusted Launch which ensures that only signed operating systems and
     drivers can boot. For more details, see aka.ms/aks/trustedlaunch.  If not specified, the
     default is false."""
    ssh_access: Optional[Union[str, "_models.AgentPoolSSHAccess"]] = rest_field(
        name="sshAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """SSH access method of an agent pool. Known values are: \"LocalUser\", \"Disabled\", and
     \"EntraId\"."""
    enable_encryption_at_host: Optional[bool] = rest_field(
        name="enableEncryptionAtHost", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to enable host based OS and data drive encryption. This is only supported on certain VM
     sizes and in certain Azure regions. For more information, see:
     `https://docs.microsoft.com/azure/aks/enable-host-encryption
     <https://docs.microsoft.com/azure/aks/enable-host-encryption>`_."""

    @overload
    def __init__(
        self,
        *,
        enable_vtpm: Optional[bool] = None,
        enable_secure_boot: Optional[bool] = None,
        ssh_access: Optional[Union[str, "_models.AgentPoolSSHAccess"]] = None,
        enable_encryption_at_host: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MachineStatus(_Model):
    """Contains read-only information about the machine.

    :ivar provisioning_error: The error details information of the machine. Preserves the detailed
     info of failure. If there was no error, this field is omitted.
    :vartype provisioning_error: ~azure.mgmt.containerservice.models.ErrorDetail
    :ivar creation_timestamp: Specifies the time at which the machine was created.
    :vartype creation_timestamp: ~datetime.datetime
    :ivar drift_action: The drift action of the machine. Indicates whether a machine has deviated
     from its expected state due to changes in managed cluster properties, requiring corrective
     action. Known values are: "Synced" and "Recreate".
    :vartype drift_action: str or ~azure.mgmt.containerservice.models.DriftAction
    :ivar drift_reason: Reason for machine drift. Provides detailed information on why the machine
     has drifted. This field is omitted if the machine is up to date.
    :vartype drift_reason: str
    :ivar vm_state: Virtual machine state. Indicates the current state of the underlying virtual
     machine. Known values are: "Running" and "Deleted".
    :vartype vm_state: str or ~azure.mgmt.containerservice.models.VmState
    """

    provisioning_error: Optional["_models.ErrorDetail"] = rest_field(name="provisioningError", visibility=["read"])
    """The error details information of the machine. Preserves the detailed info of failure. If there
     was no error, this field is omitted."""
    creation_timestamp: Optional[datetime.datetime] = rest_field(
        name="creationTimestamp", visibility=["read"], format="rfc3339"
    )
    """Specifies the time at which the machine was created."""
    drift_action: Optional[Union[str, "_models.DriftAction"]] = rest_field(name="driftAction", visibility=["read"])
    """The drift action of the machine. Indicates whether a machine has deviated from its expected
     state due to changes in managed cluster properties, requiring corrective action. Known values
     are: \"Synced\" and \"Recreate\"."""
    drift_reason: Optional[str] = rest_field(name="driftReason", visibility=["read"])
    """Reason for machine drift. Provides detailed information on why the machine has drifted. This
     field is omitted if the machine is up to date."""
    vm_state: Optional[Union[str, "_models.VmState"]] = rest_field(name="vmState", visibility=["read"])
    """Virtual machine state. Indicates the current state of the underlying virtual machine. Known
     values are: \"Running\" and \"Deleted\"."""


class MaintenanceConfiguration(ProxyResource):
    """Planned maintenance configuration, used to configure when updates can be deployed to a Managed
    Cluster. See `planned maintenance <https://docs.microsoft.com/azure/aks/planned-maintenance>`_
    for more information about planned maintenance.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: Properties of a default maintenance configuration.
    :vartype properties: ~azure.mgmt.containerservice.models.MaintenanceConfigurationProperties
    """

    properties: Optional["_models.MaintenanceConfigurationProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of a default maintenance configuration."""

    __flattened_items = ["time_in_week", "not_allowed_time", "maintenance_window"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.MaintenanceConfigurationProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class MaintenanceConfigurationProperties(_Model):
    """Properties used to configure planned maintenance for a Managed Cluster.

    :ivar time_in_week: Time slots during the week when planned maintenance is allowed to proceed.
     If two array entries specify the same day of the week, the applied configuration is the union
     of times in both entries.
    :vartype time_in_week: list[~azure.mgmt.containerservice.models.TimeInWeek]
    :ivar not_allowed_time: Time slots on which upgrade is not allowed.
    :vartype not_allowed_time: list[~azure.mgmt.containerservice.models.TimeSpan]
    :ivar maintenance_window: Maintenance window for the maintenance configuration.
    :vartype maintenance_window: ~azure.mgmt.containerservice.models.MaintenanceWindow
    """

    time_in_week: Optional[list["_models.TimeInWeek"]] = rest_field(
        name="timeInWeek", visibility=["read", "create", "update", "delete", "query"]
    )
    """Time slots during the week when planned maintenance is allowed to proceed. If two array entries
     specify the same day of the week, the applied configuration is the union of times in both
     entries."""
    not_allowed_time: Optional[list["_models.TimeSpan"]] = rest_field(
        name="notAllowedTime", visibility=["read", "create", "update", "delete", "query"]
    )
    """Time slots on which upgrade is not allowed."""
    maintenance_window: Optional["_models.MaintenanceWindow"] = rest_field(
        name="maintenanceWindow", visibility=["read", "create", "update", "delete", "query"]
    )
    """Maintenance window for the maintenance configuration."""

    @overload
    def __init__(
        self,
        *,
        time_in_week: Optional[list["_models.TimeInWeek"]] = None,
        not_allowed_time: Optional[list["_models.TimeSpan"]] = None,
        maintenance_window: Optional["_models.MaintenanceWindow"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MaintenanceWindow(_Model):
    """Maintenance window used to configure scheduled auto-upgrade for a Managed Cluster.

    :ivar schedule: Recurrence schedule for the maintenance window. Required.
    :vartype schedule: ~azure.mgmt.containerservice.models.Schedule
    :ivar duration_hours: Length of maintenance window range from 4 to 24 hours. Required.
    :vartype duration_hours: int
    :ivar utc_offset: The UTC offset in format +/-HH:mm. For example, '+05:30' for IST and '-07:00'
     for PST. If not specified, the default is '+00:00'.
    :vartype utc_offset: str
    :ivar start_date: The date the maintenance window activates. If the current date is before this
     date, the maintenance window is inactive and will not be used for upgrades. If not specified,
     the maintenance window will be active right away.
    :vartype start_date: ~datetime.date
    :ivar start_time: The start time of the maintenance window. Accepted values are from '00:00' to
     '23:59'. 'utcOffset' applies to this field. For example: '02:00' with 'utcOffset: +02:00' means
     UTC time '00:00'. Required.
    :vartype start_time: str
    :ivar not_allowed_dates: Date ranges on which upgrade is not allowed. 'utcOffset' applies to
     this field. For example, with 'utcOffset: +02:00' and 'dateSpan' being '2022-12-23' to
     '2023-01-03', maintenance will be blocked from '2022-12-22 22:00' to '2023-01-03 22:00' in UTC
     time.
    :vartype not_allowed_dates: list[~azure.mgmt.containerservice.models.DateSpan]
    """

    schedule: "_models.Schedule" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Recurrence schedule for the maintenance window. Required."""
    duration_hours: int = rest_field(name="durationHours", visibility=["read", "create", "update", "delete", "query"])
    """Length of maintenance window range from 4 to 24 hours. Required."""
    utc_offset: Optional[str] = rest_field(name="utcOffset", visibility=["read", "create", "update", "delete", "query"])
    """The UTC offset in format +/-HH:mm. For example, '+05:30' for IST and '-07:00' for PST. If not
     specified, the default is '+00:00'."""
    start_date: Optional[datetime.date] = rest_field(
        name="startDate", visibility=["read", "create", "update", "delete", "query"]
    )
    """The date the maintenance window activates. If the current date is before this date, the
     maintenance window is inactive and will not be used for upgrades. If not specified, the
     maintenance window will be active right away."""
    start_time: str = rest_field(name="startTime", visibility=["read", "create", "update", "delete", "query"])
    """The start time of the maintenance window. Accepted values are from '00:00' to '23:59'.
     'utcOffset' applies to this field. For example: '02:00' with 'utcOffset: +02:00' means UTC time
     '00:00'. Required."""
    not_allowed_dates: Optional[list["_models.DateSpan"]] = rest_field(
        name="notAllowedDates", visibility=["read", "create", "update", "delete", "query"]
    )
    """Date ranges on which upgrade is not allowed. 'utcOffset' applies to this field. For example,
     with 'utcOffset: +02:00' and 'dateSpan' being '2022-12-23' to '2023-01-03', maintenance will be
     blocked from '2022-12-22 22:00' to '2023-01-03 22:00' in UTC time."""

    @overload
    def __init__(
        self,
        *,
        schedule: "_models.Schedule",
        duration_hours: int,
        start_time: str,
        utc_offset: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        not_allowed_dates: Optional[list["_models.DateSpan"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TrackedResource(Resource):
    """Tracked Resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    """

    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""
    location: str = rest_field(visibility=["read", "create"])
    """The geo-location where the resource lives. Required."""

    @overload
    def __init__(
        self,
        *,
        location: str,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedCluster(TrackedResource):
    """Managed cluster.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: Properties of a managed cluster.
    :vartype properties: ~azure.mgmt.containerservice.models.ManagedClusterProperties
    :ivar e_tag: If eTag is provided in the response body, it may also be provided as a header per
     the normal etag convention.  Entity tags are used for comparing two or more entities from the
     same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match
     (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.
    :vartype e_tag: str
    :ivar sku: The managed cluster SKU.
    :vartype sku: ~azure.mgmt.containerservice.models.ManagedClusterSKU
    :ivar extended_location: The extended location of the Virtual Machine.
    :vartype extended_location: ~azure.mgmt.containerservice.models.ExtendedLocation
    :ivar identity: The identity of the managed cluster, if configured.
    :vartype identity: ~azure.mgmt.containerservice.models.ManagedClusterIdentity
    :ivar kind: This is primarily used to expose different UI experiences in the portal for
     different kinds.
    :vartype kind: str
    """

    properties: Optional["_models.ManagedClusterProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of a managed cluster."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read"])
    """If eTag is provided in the response body, it may also be provided as a header per the normal
     etag convention.  Entity tags are used for comparing two or more entities from the same
     requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section
     14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."""
    sku: Optional["_models.ManagedClusterSKU"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The managed cluster SKU."""
    extended_location: Optional["_models.ExtendedLocation"] = rest_field(
        name="extendedLocation", visibility=["read", "create", "update", "delete", "query"]
    )
    """The extended location of the Virtual Machine."""
    identity: Optional["_models.ManagedClusterIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The identity of the managed cluster, if configured."""
    kind: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """This is primarily used to expose different UI experiences in the portal for different kinds."""

    __flattened_items = [
        "provisioning_state",
        "power_state",
        "creation_data",
        "max_agent_pools",
        "kubernetes_version",
        "current_kubernetes_version",
        "dns_prefix",
        "fqdn_subdomain",
        "fqdn",
        "private_fqdn",
        "azure_portal_fqdn",
        "agent_pool_profiles",
        "linux_profile",
        "windows_profile",
        "service_principal_profile",
        "addon_profiles",
        "pod_identity_profile",
        "oidc_issuer_profile",
        "node_resource_group",
        "node_resource_group_profile",
        "enable_rbac",
        "support_plan",
        "enable_namespace_resources",
        "network_profile",
        "aad_profile",
        "auto_upgrade_profile",
        "upgrade_settings",
        "auto_scaler_profile",
        "api_server_access_profile",
        "disk_encryption_set_id",
        "identity_profile",
        "private_link_resources",
        "disable_local_accounts",
        "http_proxy_config",
        "security_profile",
        "storage_profile",
        "ingress_profile",
        "public_network_access",
        "workload_auto_scaler_profile",
        "azure_monitor_profile",
        "service_mesh_profile",
        "resource_uid",
        "metrics_profile",
        "node_provisioning_profile",
        "bootstrap_profile",
        "ai_toolchain_operator_profile",
        "scheduler_profile",
        "hosted_system_profile",
        "status",
    ]

    @overload
    def __init__(
        self,
        *,
        location: str,
        tags: Optional[dict[str, str]] = None,
        properties: Optional["_models.ManagedClusterProperties"] = None,
        sku: Optional["_models.ManagedClusterSKU"] = None,
        extended_location: Optional["_models.ExtendedLocation"] = None,
        identity: Optional["_models.ManagedClusterIdentity"] = None,
        kind: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ManagedClusterAADProfile(_Model):
    """AADProfile specifies attributes for Azure Active Directory integration. For more details see
    `managed AAD on AKS <https://docs.microsoft.com/azure/aks/managed-aad>`_.

    :ivar managed: Whether to enable managed AAD.
    :vartype managed: bool
    :ivar enable_azure_rbac: Whether to enable Azure RBAC for Kubernetes authorization.
    :vartype enable_azure_rbac: bool
    :ivar admin_group_object_i_ds: The list of AAD group object IDs that will have admin role of
     the cluster.
    :vartype admin_group_object_i_ds: list[str]
    :ivar client_app_id: (DEPRECATED) The client AAD application ID. Learn more at
     `https://aka.ms/aks/aad-legacy <https://aka.ms/aks/aad-legacy>`_.
    :vartype client_app_id: str
    :ivar server_app_id: (DEPRECATED) The server AAD application ID. Learn more at
     `https://aka.ms/aks/aad-legacy <https://aka.ms/aks/aad-legacy>`_.
    :vartype server_app_id: str
    :ivar server_app_secret: (DEPRECATED) The server AAD application secret. Learn more at
     `https://aka.ms/aks/aad-legacy <https://aka.ms/aks/aad-legacy>`_.
    :vartype server_app_secret: str
    :ivar tenant_id: The AAD tenant ID to use for authentication. If not specified, will use the
     tenant of the deployment subscription.
    :vartype tenant_id: str
    """

    managed: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable managed AAD."""
    enable_azure_rbac: Optional[bool] = rest_field(
        name="enableAzureRBAC", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to enable Azure RBAC for Kubernetes authorization."""
    admin_group_object_i_ds: Optional[list[str]] = rest_field(
        name="adminGroupObjectIDs", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of AAD group object IDs that will have admin role of the cluster."""
    client_app_id: Optional[str] = rest_field(
        name="clientAppID", visibility=["read", "create", "update", "delete", "query"]
    )
    """(DEPRECATED) The client AAD application ID. Learn more at `https://aka.ms/aks/aad-legacy
     <https://aka.ms/aks/aad-legacy>`_."""
    server_app_id: Optional[str] = rest_field(
        name="serverAppID", visibility=["read", "create", "update", "delete", "query"]
    )
    """(DEPRECATED) The server AAD application ID. Learn more at `https://aka.ms/aks/aad-legacy
     <https://aka.ms/aks/aad-legacy>`_."""
    server_app_secret: Optional[str] = rest_field(
        name="serverAppSecret", visibility=["read", "create", "update", "delete", "query"]
    )
    """(DEPRECATED) The server AAD application secret. Learn more at `https://aka.ms/aks/aad-legacy
     <https://aka.ms/aks/aad-legacy>`_."""
    tenant_id: Optional[str] = rest_field(name="tenantID", visibility=["read", "create", "update", "delete", "query"])
    """The AAD tenant ID to use for authentication. If not specified, will use the tenant of the
     deployment subscription."""

    @overload
    def __init__(
        self,
        *,
        managed: Optional[bool] = None,
        enable_azure_rbac: Optional[bool] = None,
        admin_group_object_i_ds: Optional[list[str]] = None,
        client_app_id: Optional[str] = None,
        server_app_id: Optional[str] = None,
        server_app_secret: Optional[str] = None,
        tenant_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAccessProfile(TrackedResource):
    """Managed cluster Access Profile.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: AccessProfile of a managed cluster.
    :vartype properties: ~azure.mgmt.containerservice.models.AccessProfile
    """

    properties: Optional["_models.AccessProfile"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """AccessProfile of a managed cluster."""

    __flattened_items = ["kube_config"]

    @overload
    def __init__(
        self,
        *,
        location: str,
        tags: Optional[dict[str, str]] = None,
        properties: Optional["_models.AccessProfile"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ManagedClusterAddonProfile(_Model):
    """A Kubernetes add-on profile for a managed cluster.

    :ivar enabled: Whether the add-on is enabled or not. Required.
    :vartype enabled: bool
    :ivar config: Key-value pairs for configuring an add-on.
    :vartype config: dict[str, str]
    :ivar identity: Information of user assigned identity used by this add-on.
    :vartype identity: ~azure.mgmt.containerservice.models.ManagedClusterAddonProfileIdentity
    """

    enabled: bool = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether the add-on is enabled or not. Required."""
    config: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Key-value pairs for configuring an add-on."""
    identity: Optional["_models.ManagedClusterAddonProfileIdentity"] = rest_field(visibility=["read"])
    """Information of user assigned identity used by this add-on."""

    @overload
    def __init__(
        self,
        *,
        enabled: bool,
        config: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UserAssignedIdentity(_Model):
    """Details about a user assigned identity.

    :ivar resource_id: The resource ID of the user assigned identity.
    :vartype resource_id: str
    :ivar client_id: The client ID of the user assigned identity.
    :vartype client_id: str
    :ivar object_id: The object ID of the user assigned identity.
    :vartype object_id: str
    """

    resource_id: Optional[str] = rest_field(
        name="resourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource ID of the user assigned identity."""
    client_id: Optional[str] = rest_field(name="clientId", visibility=["read", "create", "update", "delete", "query"])
    """The client ID of the user assigned identity."""
    object_id: Optional[str] = rest_field(name="objectId", visibility=["read", "create", "update", "delete", "query"])
    """The object ID of the user assigned identity."""

    @overload
    def __init__(
        self,
        *,
        resource_id: Optional[str] = None,
        client_id: Optional[str] = None,
        object_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAddonProfileIdentity(UserAssignedIdentity):
    """Information of user assigned identity used by this add-on.

    :ivar resource_id: The resource ID of the user assigned identity.
    :vartype resource_id: str
    :ivar client_id: The client ID of the user assigned identity.
    :vartype client_id: str
    :ivar object_id: The object ID of the user assigned identity.
    :vartype object_id: str
    """

    @overload
    def __init__(
        self,
        *,
        resource_id: Optional[str] = None,
        client_id: Optional[str] = None,
        object_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAgentPoolProfileProperties(_Model):
    """Properties for the container service agent pool profile.

    :ivar e_tag: Unique read-only string used to implement optimistic concurrency. The eTag value
     will change when the resource is updated. Specify an if-match or if-none-match header with the
     eTag value for a subsequent request to enable optimistic concurrency per the normal eTag
     convention.
    :vartype e_tag: str
    :ivar count: Number of agents (VMs) to host docker containers. Allowed values must be in the
     range of 0 to 1000 (inclusive) for user pools and in the range of 1 to 1000 (inclusive) for
     system pools. The default value is 1.
    :vartype count: int
    :ivar vm_size: The size of the agent pool VMs. VM size availability varies by region. If a node
     contains insufficient compute resources (memory, cpu, etc) pods might fail to run correctly.
     For more details on restricted VM sizes, see:
     `https://docs.microsoft.com/azure/aks/quotas-skus-regions
     <https://docs.microsoft.com/azure/aks/quotas-skus-regions>`_.
    :vartype vm_size: str
    :ivar os_disk_size_gb: OS Disk Size in GB to be used to specify the disk size for every machine
     in the master/agent pool. If you specify 0, it will apply the default osDisk size according to
     the vmSize specified.
    :vartype os_disk_size_gb: int
    :ivar os_disk_type: The OS disk type to be used for machines in the agent pool. The default is
     'Ephemeral' if the VM supports it and has a cache disk larger than the requested OSDiskSizeGB.
     Otherwise, defaults to 'Managed'. May not be changed after creation. For more information see
     `Ephemeral OS <https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os>`_.
     Known values are: "Managed" and "Ephemeral".
    :vartype os_disk_type: str or ~azure.mgmt.containerservice.models.OSDiskType
    :ivar kubelet_disk_type: Determines the placement of emptyDir volumes, container runtime data
     root, and Kubelet ephemeral storage. Known values are: "OS" and "Temporary".
    :vartype kubelet_disk_type: str or ~azure.mgmt.containerservice.models.KubeletDiskType
    :ivar workload_runtime: Determines the type of workload a node can run. Known values are:
     "OCIContainer", "WasmWasi", "KataMshvVmIsolation", and "KataVmIsolation".
    :vartype workload_runtime: str or ~azure.mgmt.containerservice.models.WorkloadRuntime
    :ivar message_of_the_day: Message of the day for Linux nodes, base64-encoded. A base64-encoded
     string which will be written to /etc/motd after decoding. This allows customization of the
     message of the day for Linux nodes. It must not be specified for Windows nodes. It must be a
     static string (i.e., will be printed raw and not be executed as a script).
    :vartype message_of_the_day: str
    :ivar vnet_subnet_id: The ID of the subnet which agent pool nodes and optionally pods will join
     on startup. If this is not specified, a VNET and subnet will be generated and used. If no
     podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes.
     This is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
    :vartype vnet_subnet_id: str
    :ivar pod_subnet_id: The ID of the subnet which pods will join when launched. If omitted, pod
     IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of
     the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
    :vartype pod_subnet_id: str
    :ivar pod_ip_allocation_mode: Pod IP Allocation Mode. The IP allocation mode for pods in the
     agent pool. Must be used with podSubnetId. The default is 'DynamicIndividual'. Known values
     are: "DynamicIndividual" and "StaticBlock".
    :vartype pod_ip_allocation_mode: str or ~azure.mgmt.containerservice.models.PodIPAllocationMode
    :ivar max_pods: The maximum number of pods that can run on a node.
    :vartype max_pods: int
    :ivar os_type: The operating system type. The default is Linux. Known values are: "Linux" and
     "Windows".
    :vartype os_type: str or ~azure.mgmt.containerservice.models.OSType
    :ivar os_sku: Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is
     Linux. The default is Windows2019 when Kubernetes <= 1.24 or Windows2022 when Kubernetes >=
     1.25 if OSType is Windows. Known values are: "Ubuntu", "AzureLinux", "AzureLinux3", "Mariner",
     "Flatcar", "CBLMariner", "Windows2019", "Windows2022", "Ubuntu2204", "Windows2025",
     "WindowsAnnual", and "Ubuntu2404".
    :vartype os_sku: str or ~azure.mgmt.containerservice.models.OSSKU
    :ivar max_count: The maximum number of nodes for auto-scaling.
    :vartype max_count: int
    :ivar min_count: The minimum number of nodes for auto-scaling.
    :vartype min_count: int
    :ivar enable_auto_scaling: Whether to enable auto-scaler.
    :vartype enable_auto_scaling: bool
    :ivar scale_down_mode: The scale down mode to use when scaling the Agent Pool. This also
     effects the cluster autoscaler behavior. If not specified, it defaults to Delete. Known values
     are: "Delete" and "Deallocate".
    :vartype scale_down_mode: str or ~azure.mgmt.containerservice.models.ScaleDownMode
    :ivar type: The type of Agent Pool. Known values are: "VirtualMachineScaleSets",
     "AvailabilitySet", and "VirtualMachines".
    :vartype type: str or ~azure.mgmt.containerservice.models.AgentPoolType
    :ivar mode: The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at
     all times. For additional information on agent pool restrictions and best practices, see:
     `https://docs.microsoft.com/azure/aks/use-system-pools
     <https://docs.microsoft.com/azure/aks/use-system-pools>`_. Known values are: "System", "User",
     "Gateway", "ManagedSystem", and "Machines".
    :vartype mode: str or ~azure.mgmt.containerservice.models.AgentPoolMode
    :ivar orchestrator_version: The version of Kubernetes specified by the user. Both patch version
     <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When
     <major.minor> is specified, the latest supported GA patch version is chosen automatically.
     Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x -> 1.14)
     will not trigger an upgrade, even if a newer patch version is available. As a best practice,
     you should upgrade all node pools in an AKS cluster to the same Kubernetes version. The node
     pool version must have the same major version as the control plane. The node pool minor version
     must be within two minor versions of the control plane version. The node pool version cannot be
     greater than the control plane version. For more information see `upgrading a node pool
     <https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool>`_.
    :vartype orchestrator_version: str
    :ivar current_orchestrator_version: The version of Kubernetes the Agent Pool is running. If
     orchestratorVersion is a fully specified version <major.minor.patch>, this field will be
     exactly equal to it. If orchestratorVersion is <major.minor>, this field will contain the full
     <major.minor.patch> version being used.
    :vartype current_orchestrator_version: str
    :ivar node_image_version: The version of node image.
    :vartype node_image_version: str
    :ivar upgrade_strategy: Defines the upgrade strategy for the agent pool. The default is
     Rolling. Known values are: "Rolling" and "BlueGreen".
    :vartype upgrade_strategy: str or ~azure.mgmt.containerservice.models.UpgradeStrategy
    :ivar upgrade_settings: Settings for upgrading the agentpool.
    :vartype upgrade_settings: ~azure.mgmt.containerservice.models.AgentPoolUpgradeSettings
    :ivar upgrade_settings_blue_green: Settings for Blue-Green upgrade on the agentpool. Applies
     when upgrade strategy is set to BlueGreen.
    :vartype upgrade_settings_blue_green:
     ~azure.mgmt.containerservice.models.AgentPoolBlueGreenUpgradeSettings
    :ivar provisioning_state: The current deployment or provisioning state.
    :vartype provisioning_state: str
    :ivar power_state: Whether the Agent Pool is running or stopped. When an Agent Pool is first
     created it is initially Running. The Agent Pool can be stopped by setting this field to
     Stopped. A stopped Agent Pool stops all of its VMs and does not accrue billing charges. An
     Agent Pool can only be stopped if it is Running and provisioning state is Succeeded.
    :vartype power_state: ~azure.mgmt.containerservice.models.PowerState
    :ivar availability_zones: The list of Availability zones to use for nodes. This can only be
     specified if the AgentPoolType property is 'VirtualMachineScaleSets'.
    :vartype availability_zones: list[str]
    :ivar enable_node_public_ip: Whether each node is allocated its own public IP. Some scenarios
     may require nodes in a node pool to receive their own dedicated public IP addresses. A common
     scenario is for gaming workloads, where a console needs to make a direct connection to a cloud
     virtual machine to minimize hops. For more information see `assigning a public IP per node
     <https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools>`_.
     The default is false.
    :vartype enable_node_public_ip: bool
    :ivar node_public_ip_prefix_id: The public IP prefix ID which VM nodes should use IPs from.
     This is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}.
    :vartype node_public_ip_prefix_id: str
    :ivar scale_set_priority: The Virtual Machine Scale Set priority. Known values are: "Spot" and
     "Regular".
    :vartype scale_set_priority: str or ~azure.mgmt.containerservice.models.ScaleSetPriority
    :ivar scale_set_eviction_policy: The Virtual Machine Scale Set eviction policy. The eviction
     policy specifies what to do with the VM when it is evicted. The default is Delete. For more
     information about eviction see `spot VMs
     <https://docs.microsoft.com/azure/virtual-machines/spot-vms>`_. Known values are: "Delete" and
     "Deallocate".
    :vartype scale_set_eviction_policy: str or
     ~azure.mgmt.containerservice.models.ScaleSetEvictionPolicy
    :ivar spot_max_price: The max price (in US Dollars) you are willing to pay for spot instances.
     Possible values are any decimal value greater than zero or -1 which indicates default price to
     be up-to on-demand. Possible values are any decimal value greater than zero or -1 which
     indicates the willingness to pay any on-demand price. For more details on spot pricing, see
     `spot VMs pricing <https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing>`_.
    :vartype spot_max_price: float
    :ivar tags: The tags to be persisted on the agent pool virtual machine scale set.
    :vartype tags: dict[str, str]
    :ivar node_labels: The node labels to be persisted across all nodes in agent pool.
    :vartype node_labels: dict[str, str]
    :ivar node_taints: The taints added to new nodes during node pool create and scale. For
     example, key=value:NoSchedule.
    :vartype node_taints: list[str]
    :ivar node_initialization_taints: Taints added on the nodes during creation that will not be
     reconciled by AKS. These taints will not be reconciled by AKS and can be removed with a kubectl
     call. This field can be modified after node pool is created, but nodes will not be recreated
     with new taints until another operation that requires recreation (e.g. node image upgrade)
     happens. These taints allow for required configuration to run before the node is ready to
     accept workloads, for example 'key1=value1:NoSchedule' that then can be removed with ``kubectl
     taint nodes node1 key1=value1:NoSchedule-``.
    :vartype node_initialization_taints: list[str]
    :ivar proximity_placement_group_id: The ID for Proximity Placement Group.
    :vartype proximity_placement_group_id: str
    :ivar kubelet_config: The Kubelet configuration on the agent pool nodes.
    :vartype kubelet_config: ~azure.mgmt.containerservice.models.KubeletConfig
    :ivar linux_os_config: The OS configuration of Linux agent nodes.
    :vartype linux_os_config: ~azure.mgmt.containerservice.models.LinuxOSConfig
    :ivar enable_encryption_at_host: Whether to enable host based OS and data drive encryption.
     This is only supported on certain VM sizes and in certain Azure regions. For more information,
     see: `https://docs.microsoft.com/azure/aks/enable-host-encryption
     <https://docs.microsoft.com/azure/aks/enable-host-encryption>`_.
    :vartype enable_encryption_at_host: bool
    :ivar enable_ultra_ssd: Whether to enable UltraSSD.
    :vartype enable_ultra_ssd: bool
    :ivar enable_fips: Whether to use a FIPS-enabled OS. See `Add a FIPS-enabled node pool
     <https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview>`_
     for more details.
    :vartype enable_fips: bool
    :ivar gpu_instance_profile: GPUInstanceProfile to be used to specify GPU MIG instance profile
     for supported GPU VM SKU. Known values are: "MIG1g", "MIG2g", "MIG3g", "MIG4g", and "MIG7g".
    :vartype gpu_instance_profile: str or ~azure.mgmt.containerservice.models.GPUInstanceProfile
    :ivar creation_data: CreationData to be used to specify the source Snapshot ID if the node pool
     will be created/upgraded using a snapshot.
    :vartype creation_data: ~azure.mgmt.containerservice.models.CreationData
    :ivar capacity_reservation_group_id: The fully qualified resource ID of the Capacity
     Reservation Group to provide virtual machines from a reserved group of Virtual Machines. This
     is of the form:
     '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Compute/capacityreservationgroups/{capacityReservationGroupName}'
     Customers use it to create an agentpool with a specified CRG. For more information see
     `Capacity Reservation
     <https://learn.microsoft.com/en-us/azure/virtual-machines/capacity-reservation-overview>`_.
    :vartype capacity_reservation_group_id: str
    :ivar host_group_id: The fully qualified resource ID of the Dedicated Host Group to provision
     virtual machines from, used only in creation scenario and not allowed to changed once set. This
     is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}.
     For more information see `Azure dedicated hosts
     <https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts>`_.
    :vartype host_group_id: str
    :ivar network_profile: Network-related settings of an agent pool.
    :vartype network_profile: ~azure.mgmt.containerservice.models.AgentPoolNetworkProfile
    :ivar windows_profile: The Windows agent pool's specific profile.
    :vartype windows_profile: ~azure.mgmt.containerservice.models.AgentPoolWindowsProfile
    :ivar security_profile: The security settings of an agent pool.
    :vartype security_profile: ~azure.mgmt.containerservice.models.AgentPoolSecurityProfile
    :ivar gpu_profile: GPU settings for the Agent Pool.
    :vartype gpu_profile: ~azure.mgmt.containerservice.models.GPUProfile
    :ivar gateway_profile: Profile specific to a managed agent pool in Gateway mode. This field
     cannot be set if agent pool mode is not Gateway.
    :vartype gateway_profile: ~azure.mgmt.containerservice.models.AgentPoolGatewayProfile
    :ivar artifact_streaming_profile: Configuration for using artifact streaming on AKS.
    :vartype artifact_streaming_profile:
     ~azure.mgmt.containerservice.models.AgentPoolArtifactStreamingProfile
    :ivar virtual_machines_profile: Specifications on VirtualMachines agent pool.
    :vartype virtual_machines_profile: ~azure.mgmt.containerservice.models.VirtualMachinesProfile
    :ivar virtual_machine_nodes_status: The status of nodes in a VirtualMachines agent pool.
    :vartype virtual_machine_nodes_status:
     list[~azure.mgmt.containerservice.models.VirtualMachineNodes]
    :ivar status: Contains read-only information about the Agent Pool.
    :vartype status: ~azure.mgmt.containerservice.models.AgentPoolStatus
    :ivar local_dns_profile: Configures the per-node local DNS, with VnetDNS and KubeDNS overrides.
     LocalDNS helps improve performance and reliability of DNS resolution in an AKS cluster. For
     more details see aka.ms/aks/localdns.
    :vartype local_dns_profile: ~azure.mgmt.containerservice.models.LocalDNSProfile
    :ivar node_customization_profile: Settings to determine the node customization used to
     provision nodes in a pool.
    :vartype node_customization_profile:
     ~azure.mgmt.containerservice.models.NodeCustomizationProfile
    """

    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read"])
    """Unique read-only string used to implement optimistic concurrency. The eTag value will change
     when the resource is updated. Specify an if-match or if-none-match header with the eTag value
     for a subsequent request to enable optimistic concurrency per the normal eTag convention."""
    count: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to
     1000 (inclusive) for user pools and in the range of 1 to 1000 (inclusive) for system pools. The
     default value is 1."""
    vm_size: Optional[str] = rest_field(name="vmSize", visibility=["read", "create", "update", "delete", "query"])
    """The size of the agent pool VMs. VM size availability varies by region. If a node contains
     insufficient compute resources (memory, cpu, etc) pods might fail to run correctly. For more
     details on restricted VM sizes, see: `https://docs.microsoft.com/azure/aks/quotas-skus-regions
     <https://docs.microsoft.com/azure/aks/quotas-skus-regions>`_."""
    os_disk_size_gb: Optional[int] = rest_field(
        name="osDiskSizeGB", visibility=["read", "create", "update", "delete", "query"]
    )
    """OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent
     pool. If you specify 0, it will apply the default osDisk size according to the vmSize
     specified."""
    os_disk_type: Optional[Union[str, "_models.OSDiskType"]] = rest_field(
        name="osDiskType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The OS disk type to be used for machines in the agent pool. The default is 'Ephemeral' if the
     VM supports it and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults
     to 'Managed'. May not be changed after creation. For more information see `Ephemeral OS
     <https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os>`_. Known values are:
     \"Managed\" and \"Ephemeral\"."""
    kubelet_disk_type: Optional[Union[str, "_models.KubeletDiskType"]] = rest_field(
        name="kubeletDiskType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines the placement of emptyDir volumes, container runtime data root, and Kubelet
     ephemeral storage. Known values are: \"OS\" and \"Temporary\"."""
    workload_runtime: Optional[Union[str, "_models.WorkloadRuntime"]] = rest_field(
        name="workloadRuntime", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines the type of workload a node can run. Known values are: \"OCIContainer\",
     \"WasmWasi\", \"KataMshvVmIsolation\", and \"KataVmIsolation\"."""
    message_of_the_day: Optional[str] = rest_field(
        name="messageOfTheDay", visibility=["read", "create", "update", "delete", "query"]
    )
    """Message of the day for Linux nodes, base64-encoded. A base64-encoded string which will be
     written to /etc/motd after decoding. This allows customization of the message of the day for
     Linux nodes. It must not be specified for Windows nodes. It must be a static string (i.e., will
     be printed raw and not be executed as a script)."""
    vnet_subnet_id: Optional[str] = rest_field(
        name="vnetSubnetID", visibility=["read", "create", "update", "delete", "query"]
    )
    """The ID of the subnet which agent pool nodes and optionally pods will join on startup. If this
     is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified,
     this applies to nodes and pods, otherwise it applies to just nodes. This is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}."""
    pod_subnet_id: Optional[str] = rest_field(
        name="podSubnetID", visibility=["read", "create", "update", "delete", "query"]
    )
    """The ID of the subnet which pods will join when launched. If omitted, pod IPs are statically
     assigned on the node subnet (see vnetSubnetID for more details). This is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}."""
    pod_ip_allocation_mode: Optional[Union[str, "_models.PodIPAllocationMode"]] = rest_field(
        name="podIPAllocationMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Pod IP Allocation Mode. The IP allocation mode for pods in the agent pool. Must be used with
     podSubnetId. The default is 'DynamicIndividual'. Known values are: \"DynamicIndividual\" and
     \"StaticBlock\"."""
    max_pods: Optional[int] = rest_field(name="maxPods", visibility=["read", "create", "update", "delete", "query"])
    """The maximum number of pods that can run on a node."""
    os_type: Optional[Union[str, "_models.OSType"]] = rest_field(
        name="osType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The operating system type. The default is Linux. Known values are: \"Linux\" and \"Windows\"."""
    os_sku: Optional[Union[str, "_models.OSSKU"]] = rest_field(
        name="osSKU", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The
     default is Windows2019 when Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType
     is Windows. Known values are: \"Ubuntu\", \"AzureLinux\", \"AzureLinux3\", \"Mariner\",
     \"Flatcar\", \"CBLMariner\", \"Windows2019\", \"Windows2022\", \"Ubuntu2204\", \"Windows2025\",
     \"WindowsAnnual\", and \"Ubuntu2404\"."""
    max_count: Optional[int] = rest_field(name="maxCount", visibility=["read", "create", "update", "delete", "query"])
    """The maximum number of nodes for auto-scaling."""
    min_count: Optional[int] = rest_field(name="minCount", visibility=["read", "create", "update", "delete", "query"])
    """The minimum number of nodes for auto-scaling."""
    enable_auto_scaling: Optional[bool] = rest_field(
        name="enableAutoScaling", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to enable auto-scaler."""
    scale_down_mode: Optional[Union[str, "_models.ScaleDownMode"]] = rest_field(
        name="scaleDownMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The scale down mode to use when scaling the Agent Pool. This also effects the cluster
     autoscaler behavior. If not specified, it defaults to Delete. Known values are: \"Delete\" and
     \"Deallocate\"."""
    type: Optional[Union[str, "_models.AgentPoolType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of Agent Pool. Known values are: \"VirtualMachineScaleSets\", \"AvailabilitySet\", and
     \"VirtualMachines\"."""
    mode: Optional[Union[str, "_models.AgentPoolMode"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at all times.
     For additional information on agent pool restrictions and best practices, see:
     `https://docs.microsoft.com/azure/aks/use-system-pools
     <https://docs.microsoft.com/azure/aks/use-system-pools>`_. Known values are: \"System\",
     \"User\", \"Gateway\", \"ManagedSystem\", and \"Machines\"."""
    orchestrator_version: Optional[str] = rest_field(
        name="orchestratorVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The version of Kubernetes specified by the user. Both patch version <major.minor.patch> (e.g.
     1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the
     latest supported GA patch version is chosen automatically. Updating the cluster with the same
     <major.minor> once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even
     if a newer patch version is available. As a best practice, you should upgrade all node pools in
     an AKS cluster to the same Kubernetes version. The node pool version must have the same major
     version as the control plane. The node pool minor version must be within two minor versions of
     the control plane version. The node pool version cannot be greater than the control plane
     version. For more information see `upgrading a node pool
     <https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool>`_."""
    current_orchestrator_version: Optional[str] = rest_field(name="currentOrchestratorVersion", visibility=["read"])
    """The version of Kubernetes the Agent Pool is running. If orchestratorVersion is a fully
     specified version <major.minor.patch>, this field will be exactly equal to it. If
     orchestratorVersion is <major.minor>, this field will contain the full <major.minor.patch>
     version being used."""
    node_image_version: Optional[str] = rest_field(name="nodeImageVersion", visibility=["read"])
    """The version of node image."""
    upgrade_strategy: Optional[Union[str, "_models.UpgradeStrategy"]] = rest_field(
        name="upgradeStrategy", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines the upgrade strategy for the agent pool. The default is Rolling. Known values are:
     \"Rolling\" and \"BlueGreen\"."""
    upgrade_settings: Optional["_models.AgentPoolUpgradeSettings"] = rest_field(
        name="upgradeSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for upgrading the agentpool."""
    upgrade_settings_blue_green: Optional["_models.AgentPoolBlueGreenUpgradeSettings"] = rest_field(
        name="upgradeSettingsBlueGreen", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for Blue-Green upgrade on the agentpool. Applies when upgrade strategy is set to
     BlueGreen."""
    provisioning_state: Optional[str] = rest_field(name="provisioningState", visibility=["read"])
    """The current deployment or provisioning state."""
    power_state: Optional["_models.PowerState"] = rest_field(
        name="powerState", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether the Agent Pool is running or stopped. When an Agent Pool is first created it is
     initially Running. The Agent Pool can be stopped by setting this field to Stopped. A stopped
     Agent Pool stops all of its VMs and does not accrue billing charges. An Agent Pool can only be
     stopped if it is Running and provisioning state is Succeeded."""
    availability_zones: Optional[list[str]] = rest_field(
        name="availabilityZones", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of Availability zones to use for nodes. This can only be specified if the
     AgentPoolType property is 'VirtualMachineScaleSets'."""
    enable_node_public_ip: Optional[bool] = rest_field(
        name="enableNodePublicIP", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether each node is allocated its own public IP. Some scenarios may require nodes in a node
     pool to receive their own dedicated public IP addresses. A common scenario is for gaming
     workloads, where a console needs to make a direct connection to a cloud virtual machine to
     minimize hops. For more information see `assigning a public IP per node
     <https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools>`_.
     The default is false."""
    node_public_ip_prefix_id: Optional[str] = rest_field(
        name="nodePublicIPPrefixID", visibility=["read", "create", "update", "delete", "query"]
    )
    """The public IP prefix ID which VM nodes should use IPs from. This is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}."""
    scale_set_priority: Optional[Union[str, "_models.ScaleSetPriority"]] = rest_field(
        name="scaleSetPriority", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Virtual Machine Scale Set priority. Known values are: \"Spot\" and \"Regular\"."""
    scale_set_eviction_policy: Optional[Union[str, "_models.ScaleSetEvictionPolicy"]] = rest_field(
        name="scaleSetEvictionPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Virtual Machine Scale Set eviction policy. The eviction policy specifies what to do with
     the VM when it is evicted. The default is Delete. For more information about eviction see `spot
     VMs <https://docs.microsoft.com/azure/virtual-machines/spot-vms>`_. Known values are:
     \"Delete\" and \"Deallocate\"."""
    spot_max_price: Optional[float] = rest_field(
        name="spotMaxPrice", visibility=["read", "create", "update", "delete", "query"]
    )
    """The max price (in US Dollars) you are willing to pay for spot instances. Possible values are
     any decimal value greater than zero or -1 which indicates default price to be up-to on-demand.
     Possible values are any decimal value greater than zero or -1 which indicates the willingness
     to pay any on-demand price. For more details on spot pricing, see `spot VMs pricing
     <https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing>`_."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The tags to be persisted on the agent pool virtual machine scale set."""
    node_labels: Optional[dict[str, str]] = rest_field(
        name="nodeLabels", visibility=["read", "create", "update", "delete", "query"]
    )
    """The node labels to be persisted across all nodes in agent pool."""
    node_taints: Optional[list[str]] = rest_field(
        name="nodeTaints", visibility=["read", "create", "update", "delete", "query"]
    )
    """The taints added to new nodes during node pool create and scale. For example,
     key=value:NoSchedule."""
    node_initialization_taints: Optional[list[str]] = rest_field(
        name="nodeInitializationTaints", visibility=["read", "create", "update", "delete", "query"]
    )
    """Taints added on the nodes during creation that will not be reconciled by AKS. These taints will
     not be reconciled by AKS and can be removed with a kubectl call. This field can be modified
     after node pool is created, but nodes will not be recreated with new taints until another
     operation that requires recreation (e.g. node image upgrade) happens. These taints allow for
     required configuration to run before the node is ready to accept workloads, for example
     'key1=value1:NoSchedule' that then can be removed with ``kubectl taint nodes node1
     key1=value1:NoSchedule-``."""
    proximity_placement_group_id: Optional[str] = rest_field(
        name="proximityPlacementGroupID", visibility=["read", "create", "update", "delete", "query"]
    )
    """The ID for Proximity Placement Group."""
    kubelet_config: Optional["_models.KubeletConfig"] = rest_field(
        name="kubeletConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Kubelet configuration on the agent pool nodes."""
    linux_os_config: Optional["_models.LinuxOSConfig"] = rest_field(
        name="linuxOSConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """The OS configuration of Linux agent nodes."""
    enable_encryption_at_host: Optional[bool] = rest_field(
        name="enableEncryptionAtHost", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to enable host based OS and data drive encryption. This is only supported on certain VM
     sizes and in certain Azure regions. For more information, see:
     `https://docs.microsoft.com/azure/aks/enable-host-encryption
     <https://docs.microsoft.com/azure/aks/enable-host-encryption>`_."""
    enable_ultra_ssd: Optional[bool] = rest_field(
        name="enableUltraSSD", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to enable UltraSSD."""
    enable_fips: Optional[bool] = rest_field(
        name="enableFIPS", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to use a FIPS-enabled OS. See `Add a FIPS-enabled node pool
     <https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview>`_
     for more details."""
    gpu_instance_profile: Optional[Union[str, "_models.GPUInstanceProfile"]] = rest_field(
        name="gpuInstanceProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
     Known values are: \"MIG1g\", \"MIG2g\", \"MIG3g\", \"MIG4g\", and \"MIG7g\"."""
    creation_data: Optional["_models.CreationData"] = rest_field(
        name="creationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """CreationData to be used to specify the source Snapshot ID if the node pool will be
     created/upgraded using a snapshot."""
    capacity_reservation_group_id: Optional[str] = rest_field(
        name="capacityReservationGroupID", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fully qualified resource ID of the Capacity Reservation Group to provide virtual machines
     from a reserved group of Virtual Machines. This is of the form:
     '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Compute/capacityreservationgroups/{capacityReservationGroupName}'
     Customers use it to create an agentpool with a specified CRG. For more information see
     `Capacity Reservation
     <https://learn.microsoft.com/en-us/azure/virtual-machines/capacity-reservation-overview>`_."""
    host_group_id: Optional[str] = rest_field(
        name="hostGroupID", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fully qualified resource ID of the Dedicated Host Group to provision virtual machines from,
     used only in creation scenario and not allowed to changed once set. This is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}.
     For more information see `Azure dedicated hosts
     <https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts>`_."""
    network_profile: Optional["_models.AgentPoolNetworkProfile"] = rest_field(
        name="networkProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Network-related settings of an agent pool."""
    windows_profile: Optional["_models.AgentPoolWindowsProfile"] = rest_field(
        name="windowsProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Windows agent pool's specific profile."""
    security_profile: Optional["_models.AgentPoolSecurityProfile"] = rest_field(
        name="securityProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The security settings of an agent pool."""
    gpu_profile: Optional["_models.GPUProfile"] = rest_field(
        name="gpuProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """GPU settings for the Agent Pool."""
    gateway_profile: Optional["_models.AgentPoolGatewayProfile"] = rest_field(
        name="gatewayProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Profile specific to a managed agent pool in Gateway mode. This field cannot be set if agent
     pool mode is not Gateway."""
    artifact_streaming_profile: Optional["_models.AgentPoolArtifactStreamingProfile"] = rest_field(
        name="artifactStreamingProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Configuration for using artifact streaming on AKS."""
    virtual_machines_profile: Optional["_models.VirtualMachinesProfile"] = rest_field(
        name="virtualMachinesProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifications on VirtualMachines agent pool."""
    virtual_machine_nodes_status: Optional[list["_models.VirtualMachineNodes"]] = rest_field(
        name="virtualMachineNodesStatus", visibility=["read", "create", "update", "delete", "query"]
    )
    """The status of nodes in a VirtualMachines agent pool."""
    status: Optional["_models.AgentPoolStatus"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Contains read-only information about the Agent Pool."""
    local_dns_profile: Optional["_models.LocalDNSProfile"] = rest_field(
        name="localDNSProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Configures the per-node local DNS, with VnetDNS and KubeDNS overrides. LocalDNS helps improve
     performance and reliability of DNS resolution in an AKS cluster. For more details see
     aka.ms/aks/localdns."""
    node_customization_profile: Optional["_models.NodeCustomizationProfile"] = rest_field(
        name="nodeCustomizationProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings to determine the node customization used to provision nodes in a pool."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        count: Optional[int] = None,
        vm_size: Optional[str] = None,
        os_disk_size_gb: Optional[int] = None,
        os_disk_type: Optional[Union[str, "_models.OSDiskType"]] = None,
        kubelet_disk_type: Optional[Union[str, "_models.KubeletDiskType"]] = None,
        workload_runtime: Optional[Union[str, "_models.WorkloadRuntime"]] = None,
        message_of_the_day: Optional[str] = None,
        vnet_subnet_id: Optional[str] = None,
        pod_subnet_id: Optional[str] = None,
        pod_ip_allocation_mode: Optional[Union[str, "_models.PodIPAllocationMode"]] = None,
        max_pods: Optional[int] = None,
        os_type: Optional[Union[str, "_models.OSType"]] = None,
        os_sku: Optional[Union[str, "_models.OSSKU"]] = None,
        max_count: Optional[int] = None,
        min_count: Optional[int] = None,
        enable_auto_scaling: Optional[bool] = None,
        scale_down_mode: Optional[Union[str, "_models.ScaleDownMode"]] = None,
        type: Optional[Union[str, "_models.AgentPoolType"]] = None,
        mode: Optional[Union[str, "_models.AgentPoolMode"]] = None,
        orchestrator_version: Optional[str] = None,
        upgrade_strategy: Optional[Union[str, "_models.UpgradeStrategy"]] = None,
        upgrade_settings: Optional["_models.AgentPoolUpgradeSettings"] = None,
        upgrade_settings_blue_green: Optional["_models.AgentPoolBlueGreenUpgradeSettings"] = None,
        power_state: Optional["_models.PowerState"] = None,
        availability_zones: Optional[list[str]] = None,
        enable_node_public_ip: Optional[bool] = None,
        node_public_ip_prefix_id: Optional[str] = None,
        scale_set_priority: Optional[Union[str, "_models.ScaleSetPriority"]] = None,
        scale_set_eviction_policy: Optional[Union[str, "_models.ScaleSetEvictionPolicy"]] = None,
        spot_max_price: Optional[float] = None,
        tags: Optional[dict[str, str]] = None,
        node_labels: Optional[dict[str, str]] = None,
        node_taints: Optional[list[str]] = None,
        node_initialization_taints: Optional[list[str]] = None,
        proximity_placement_group_id: Optional[str] = None,
        kubelet_config: Optional["_models.KubeletConfig"] = None,
        linux_os_config: Optional["_models.LinuxOSConfig"] = None,
        enable_encryption_at_host: Optional[bool] = None,
        enable_ultra_ssd: Optional[bool] = None,
        enable_fips: Optional[bool] = None,
        gpu_instance_profile: Optional[Union[str, "_models.GPUInstanceProfile"]] = None,
        creation_data: Optional["_models.CreationData"] = None,
        capacity_reservation_group_id: Optional[str] = None,
        host_group_id: Optional[str] = None,
        network_profile: Optional["_models.AgentPoolNetworkProfile"] = None,
        windows_profile: Optional["_models.AgentPoolWindowsProfile"] = None,
        security_profile: Optional["_models.AgentPoolSecurityProfile"] = None,
        gpu_profile: Optional["_models.GPUProfile"] = None,
        gateway_profile: Optional["_models.AgentPoolGatewayProfile"] = None,
        artifact_streaming_profile: Optional["_models.AgentPoolArtifactStreamingProfile"] = None,
        virtual_machines_profile: Optional["_models.VirtualMachinesProfile"] = None,
        virtual_machine_nodes_status: Optional[list["_models.VirtualMachineNodes"]] = None,
        status: Optional["_models.AgentPoolStatus"] = None,
        local_dns_profile: Optional["_models.LocalDNSProfile"] = None,
        node_customization_profile: Optional["_models.NodeCustomizationProfile"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAgentPoolProfile(ManagedClusterAgentPoolProfileProperties):
    """Profile for the container service agent pool.

    :ivar e_tag: Unique read-only string used to implement optimistic concurrency. The eTag value
     will change when the resource is updated. Specify an if-match or if-none-match header with the
     eTag value for a subsequent request to enable optimistic concurrency per the normal eTag
     convention.
    :vartype e_tag: str
    :ivar count: Number of agents (VMs) to host docker containers. Allowed values must be in the
     range of 0 to 1000 (inclusive) for user pools and in the range of 1 to 1000 (inclusive) for
     system pools. The default value is 1.
    :vartype count: int
    :ivar vm_size: The size of the agent pool VMs. VM size availability varies by region. If a node
     contains insufficient compute resources (memory, cpu, etc) pods might fail to run correctly.
     For more details on restricted VM sizes, see:
     `https://docs.microsoft.com/azure/aks/quotas-skus-regions
     <https://docs.microsoft.com/azure/aks/quotas-skus-regions>`_.
    :vartype vm_size: str
    :ivar os_disk_size_gb: OS Disk Size in GB to be used to specify the disk size for every machine
     in the master/agent pool. If you specify 0, it will apply the default osDisk size according to
     the vmSize specified.
    :vartype os_disk_size_gb: int
    :ivar os_disk_type: The OS disk type to be used for machines in the agent pool. The default is
     'Ephemeral' if the VM supports it and has a cache disk larger than the requested OSDiskSizeGB.
     Otherwise, defaults to 'Managed'. May not be changed after creation. For more information see
     `Ephemeral OS <https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os>`_.
     Known values are: "Managed" and "Ephemeral".
    :vartype os_disk_type: str or ~azure.mgmt.containerservice.models.OSDiskType
    :ivar kubelet_disk_type: Determines the placement of emptyDir volumes, container runtime data
     root, and Kubelet ephemeral storage. Known values are: "OS" and "Temporary".
    :vartype kubelet_disk_type: str or ~azure.mgmt.containerservice.models.KubeletDiskType
    :ivar workload_runtime: Determines the type of workload a node can run. Known values are:
     "OCIContainer", "WasmWasi", "KataMshvVmIsolation", and "KataVmIsolation".
    :vartype workload_runtime: str or ~azure.mgmt.containerservice.models.WorkloadRuntime
    :ivar message_of_the_day: Message of the day for Linux nodes, base64-encoded. A base64-encoded
     string which will be written to /etc/motd after decoding. This allows customization of the
     message of the day for Linux nodes. It must not be specified for Windows nodes. It must be a
     static string (i.e., will be printed raw and not be executed as a script).
    :vartype message_of_the_day: str
    :ivar vnet_subnet_id: The ID of the subnet which agent pool nodes and optionally pods will join
     on startup. If this is not specified, a VNET and subnet will be generated and used. If no
     podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes.
     This is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
    :vartype vnet_subnet_id: str
    :ivar pod_subnet_id: The ID of the subnet which pods will join when launched. If omitted, pod
     IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of
     the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
    :vartype pod_subnet_id: str
    :ivar pod_ip_allocation_mode: Pod IP Allocation Mode. The IP allocation mode for pods in the
     agent pool. Must be used with podSubnetId. The default is 'DynamicIndividual'. Known values
     are: "DynamicIndividual" and "StaticBlock".
    :vartype pod_ip_allocation_mode: str or ~azure.mgmt.containerservice.models.PodIPAllocationMode
    :ivar max_pods: The maximum number of pods that can run on a node.
    :vartype max_pods: int
    :ivar os_type: The operating system type. The default is Linux. Known values are: "Linux" and
     "Windows".
    :vartype os_type: str or ~azure.mgmt.containerservice.models.OSType
    :ivar os_sku: Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is
     Linux. The default is Windows2019 when Kubernetes <= 1.24 or Windows2022 when Kubernetes >=
     1.25 if OSType is Windows. Known values are: "Ubuntu", "AzureLinux", "AzureLinux3", "Mariner",
     "Flatcar", "CBLMariner", "Windows2019", "Windows2022", "Ubuntu2204", "Windows2025",
     "WindowsAnnual", and "Ubuntu2404".
    :vartype os_sku: str or ~azure.mgmt.containerservice.models.OSSKU
    :ivar max_count: The maximum number of nodes for auto-scaling.
    :vartype max_count: int
    :ivar min_count: The minimum number of nodes for auto-scaling.
    :vartype min_count: int
    :ivar enable_auto_scaling: Whether to enable auto-scaler.
    :vartype enable_auto_scaling: bool
    :ivar scale_down_mode: The scale down mode to use when scaling the Agent Pool. This also
     effects the cluster autoscaler behavior. If not specified, it defaults to Delete. Known values
     are: "Delete" and "Deallocate".
    :vartype scale_down_mode: str or ~azure.mgmt.containerservice.models.ScaleDownMode
    :ivar type: The type of Agent Pool. Known values are: "VirtualMachineScaleSets",
     "AvailabilitySet", and "VirtualMachines".
    :vartype type: str or ~azure.mgmt.containerservice.models.AgentPoolType
    :ivar mode: The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at
     all times. For additional information on agent pool restrictions and best practices, see:
     `https://docs.microsoft.com/azure/aks/use-system-pools
     <https://docs.microsoft.com/azure/aks/use-system-pools>`_. Known values are: "System", "User",
     "Gateway", "ManagedSystem", and "Machines".
    :vartype mode: str or ~azure.mgmt.containerservice.models.AgentPoolMode
    :ivar orchestrator_version: The version of Kubernetes specified by the user. Both patch version
     <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When
     <major.minor> is specified, the latest supported GA patch version is chosen automatically.
     Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x -> 1.14)
     will not trigger an upgrade, even if a newer patch version is available. As a best practice,
     you should upgrade all node pools in an AKS cluster to the same Kubernetes version. The node
     pool version must have the same major version as the control plane. The node pool minor version
     must be within two minor versions of the control plane version. The node pool version cannot be
     greater than the control plane version. For more information see `upgrading a node pool
     <https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool>`_.
    :vartype orchestrator_version: str
    :ivar current_orchestrator_version: The version of Kubernetes the Agent Pool is running. If
     orchestratorVersion is a fully specified version <major.minor.patch>, this field will be
     exactly equal to it. If orchestratorVersion is <major.minor>, this field will contain the full
     <major.minor.patch> version being used.
    :vartype current_orchestrator_version: str
    :ivar node_image_version: The version of node image.
    :vartype node_image_version: str
    :ivar upgrade_strategy: Defines the upgrade strategy for the agent pool. The default is
     Rolling. Known values are: "Rolling" and "BlueGreen".
    :vartype upgrade_strategy: str or ~azure.mgmt.containerservice.models.UpgradeStrategy
    :ivar upgrade_settings: Settings for upgrading the agentpool.
    :vartype upgrade_settings: ~azure.mgmt.containerservice.models.AgentPoolUpgradeSettings
    :ivar upgrade_settings_blue_green: Settings for Blue-Green upgrade on the agentpool. Applies
     when upgrade strategy is set to BlueGreen.
    :vartype upgrade_settings_blue_green:
     ~azure.mgmt.containerservice.models.AgentPoolBlueGreenUpgradeSettings
    :ivar provisioning_state: The current deployment or provisioning state.
    :vartype provisioning_state: str
    :ivar power_state: Whether the Agent Pool is running or stopped. When an Agent Pool is first
     created it is initially Running. The Agent Pool can be stopped by setting this field to
     Stopped. A stopped Agent Pool stops all of its VMs and does not accrue billing charges. An
     Agent Pool can only be stopped if it is Running and provisioning state is Succeeded.
    :vartype power_state: ~azure.mgmt.containerservice.models.PowerState
    :ivar availability_zones: The list of Availability zones to use for nodes. This can only be
     specified if the AgentPoolType property is 'VirtualMachineScaleSets'.
    :vartype availability_zones: list[str]
    :ivar enable_node_public_ip: Whether each node is allocated its own public IP. Some scenarios
     may require nodes in a node pool to receive their own dedicated public IP addresses. A common
     scenario is for gaming workloads, where a console needs to make a direct connection to a cloud
     virtual machine to minimize hops. For more information see `assigning a public IP per node
     <https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools>`_.
     The default is false.
    :vartype enable_node_public_ip: bool
    :ivar node_public_ip_prefix_id: The public IP prefix ID which VM nodes should use IPs from.
     This is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}.
    :vartype node_public_ip_prefix_id: str
    :ivar scale_set_priority: The Virtual Machine Scale Set priority. Known values are: "Spot" and
     "Regular".
    :vartype scale_set_priority: str or ~azure.mgmt.containerservice.models.ScaleSetPriority
    :ivar scale_set_eviction_policy: The Virtual Machine Scale Set eviction policy. The eviction
     policy specifies what to do with the VM when it is evicted. The default is Delete. For more
     information about eviction see `spot VMs
     <https://docs.microsoft.com/azure/virtual-machines/spot-vms>`_. Known values are: "Delete" and
     "Deallocate".
    :vartype scale_set_eviction_policy: str or
     ~azure.mgmt.containerservice.models.ScaleSetEvictionPolicy
    :ivar spot_max_price: The max price (in US Dollars) you are willing to pay for spot instances.
     Possible values are any decimal value greater than zero or -1 which indicates default price to
     be up-to on-demand. Possible values are any decimal value greater than zero or -1 which
     indicates the willingness to pay any on-demand price. For more details on spot pricing, see
     `spot VMs pricing <https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing>`_.
    :vartype spot_max_price: float
    :ivar tags: The tags to be persisted on the agent pool virtual machine scale set.
    :vartype tags: dict[str, str]
    :ivar node_labels: The node labels to be persisted across all nodes in agent pool.
    :vartype node_labels: dict[str, str]
    :ivar node_taints: The taints added to new nodes during node pool create and scale. For
     example, key=value:NoSchedule.
    :vartype node_taints: list[str]
    :ivar node_initialization_taints: Taints added on the nodes during creation that will not be
     reconciled by AKS. These taints will not be reconciled by AKS and can be removed with a kubectl
     call. This field can be modified after node pool is created, but nodes will not be recreated
     with new taints until another operation that requires recreation (e.g. node image upgrade)
     happens. These taints allow for required configuration to run before the node is ready to
     accept workloads, for example 'key1=value1:NoSchedule' that then can be removed with ``kubectl
     taint nodes node1 key1=value1:NoSchedule-``.
    :vartype node_initialization_taints: list[str]
    :ivar proximity_placement_group_id: The ID for Proximity Placement Group.
    :vartype proximity_placement_group_id: str
    :ivar kubelet_config: The Kubelet configuration on the agent pool nodes.
    :vartype kubelet_config: ~azure.mgmt.containerservice.models.KubeletConfig
    :ivar linux_os_config: The OS configuration of Linux agent nodes.
    :vartype linux_os_config: ~azure.mgmt.containerservice.models.LinuxOSConfig
    :ivar enable_encryption_at_host: Whether to enable host based OS and data drive encryption.
     This is only supported on certain VM sizes and in certain Azure regions. For more information,
     see: `https://docs.microsoft.com/azure/aks/enable-host-encryption
     <https://docs.microsoft.com/azure/aks/enable-host-encryption>`_.
    :vartype enable_encryption_at_host: bool
    :ivar enable_ultra_ssd: Whether to enable UltraSSD.
    :vartype enable_ultra_ssd: bool
    :ivar enable_fips: Whether to use a FIPS-enabled OS. See `Add a FIPS-enabled node pool
     <https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview>`_
     for more details.
    :vartype enable_fips: bool
    :ivar gpu_instance_profile: GPUInstanceProfile to be used to specify GPU MIG instance profile
     for supported GPU VM SKU. Known values are: "MIG1g", "MIG2g", "MIG3g", "MIG4g", and "MIG7g".
    :vartype gpu_instance_profile: str or ~azure.mgmt.containerservice.models.GPUInstanceProfile
    :ivar creation_data: CreationData to be used to specify the source Snapshot ID if the node pool
     will be created/upgraded using a snapshot.
    :vartype creation_data: ~azure.mgmt.containerservice.models.CreationData
    :ivar capacity_reservation_group_id: The fully qualified resource ID of the Capacity
     Reservation Group to provide virtual machines from a reserved group of Virtual Machines. This
     is of the form:
     '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Compute/capacityreservationgroups/{capacityReservationGroupName}'
     Customers use it to create an agentpool with a specified CRG. For more information see
     `Capacity Reservation
     <https://learn.microsoft.com/en-us/azure/virtual-machines/capacity-reservation-overview>`_.
    :vartype capacity_reservation_group_id: str
    :ivar host_group_id: The fully qualified resource ID of the Dedicated Host Group to provision
     virtual machines from, used only in creation scenario and not allowed to changed once set. This
     is of the form:
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}.
     For more information see `Azure dedicated hosts
     <https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts>`_.
    :vartype host_group_id: str
    :ivar network_profile: Network-related settings of an agent pool.
    :vartype network_profile: ~azure.mgmt.containerservice.models.AgentPoolNetworkProfile
    :ivar windows_profile: The Windows agent pool's specific profile.
    :vartype windows_profile: ~azure.mgmt.containerservice.models.AgentPoolWindowsProfile
    :ivar security_profile: The security settings of an agent pool.
    :vartype security_profile: ~azure.mgmt.containerservice.models.AgentPoolSecurityProfile
    :ivar gpu_profile: GPU settings for the Agent Pool.
    :vartype gpu_profile: ~azure.mgmt.containerservice.models.GPUProfile
    :ivar gateway_profile: Profile specific to a managed agent pool in Gateway mode. This field
     cannot be set if agent pool mode is not Gateway.
    :vartype gateway_profile: ~azure.mgmt.containerservice.models.AgentPoolGatewayProfile
    :ivar artifact_streaming_profile: Configuration for using artifact streaming on AKS.
    :vartype artifact_streaming_profile:
     ~azure.mgmt.containerservice.models.AgentPoolArtifactStreamingProfile
    :ivar virtual_machines_profile: Specifications on VirtualMachines agent pool.
    :vartype virtual_machines_profile: ~azure.mgmt.containerservice.models.VirtualMachinesProfile
    :ivar virtual_machine_nodes_status: The status of nodes in a VirtualMachines agent pool.
    :vartype virtual_machine_nodes_status:
     list[~azure.mgmt.containerservice.models.VirtualMachineNodes]
    :ivar status: Contains read-only information about the Agent Pool.
    :vartype status: ~azure.mgmt.containerservice.models.AgentPoolStatus
    :ivar local_dns_profile: Configures the per-node local DNS, with VnetDNS and KubeDNS overrides.
     LocalDNS helps improve performance and reliability of DNS resolution in an AKS cluster. For
     more details see aka.ms/aks/localdns.
    :vartype local_dns_profile: ~azure.mgmt.containerservice.models.LocalDNSProfile
    :ivar node_customization_profile: Settings to determine the node customization used to
     provision nodes in a pool.
    :vartype node_customization_profile:
     ~azure.mgmt.containerservice.models.NodeCustomizationProfile
    :ivar name: Unique name of the agent pool profile in the context of the subscription and
     resource group. Windows agent pool names must be 6 characters or less. Required.
    :vartype name: str
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Unique name of the agent pool profile in the context of the subscription and resource group.
     Windows agent pool names must be 6 characters or less. Required."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        name: str,
        count: Optional[int] = None,
        vm_size: Optional[str] = None,
        os_disk_size_gb: Optional[int] = None,
        os_disk_type: Optional[Union[str, "_models.OSDiskType"]] = None,
        kubelet_disk_type: Optional[Union[str, "_models.KubeletDiskType"]] = None,
        workload_runtime: Optional[Union[str, "_models.WorkloadRuntime"]] = None,
        message_of_the_day: Optional[str] = None,
        vnet_subnet_id: Optional[str] = None,
        pod_subnet_id: Optional[str] = None,
        pod_ip_allocation_mode: Optional[Union[str, "_models.PodIPAllocationMode"]] = None,
        max_pods: Optional[int] = None,
        os_type: Optional[Union[str, "_models.OSType"]] = None,
        os_sku: Optional[Union[str, "_models.OSSKU"]] = None,
        max_count: Optional[int] = None,
        min_count: Optional[int] = None,
        enable_auto_scaling: Optional[bool] = None,
        scale_down_mode: Optional[Union[str, "_models.ScaleDownMode"]] = None,
        type: Optional[Union[str, "_models.AgentPoolType"]] = None,
        mode: Optional[Union[str, "_models.AgentPoolMode"]] = None,
        orchestrator_version: Optional[str] = None,
        upgrade_strategy: Optional[Union[str, "_models.UpgradeStrategy"]] = None,
        upgrade_settings: Optional["_models.AgentPoolUpgradeSettings"] = None,
        upgrade_settings_blue_green: Optional["_models.AgentPoolBlueGreenUpgradeSettings"] = None,
        power_state: Optional["_models.PowerState"] = None,
        availability_zones: Optional[list[str]] = None,
        enable_node_public_ip: Optional[bool] = None,
        node_public_ip_prefix_id: Optional[str] = None,
        scale_set_priority: Optional[Union[str, "_models.ScaleSetPriority"]] = None,
        scale_set_eviction_policy: Optional[Union[str, "_models.ScaleSetEvictionPolicy"]] = None,
        spot_max_price: Optional[float] = None,
        tags: Optional[dict[str, str]] = None,
        node_labels: Optional[dict[str, str]] = None,
        node_taints: Optional[list[str]] = None,
        node_initialization_taints: Optional[list[str]] = None,
        proximity_placement_group_id: Optional[str] = None,
        kubelet_config: Optional["_models.KubeletConfig"] = None,
        linux_os_config: Optional["_models.LinuxOSConfig"] = None,
        enable_encryption_at_host: Optional[bool] = None,
        enable_ultra_ssd: Optional[bool] = None,
        enable_fips: Optional[bool] = None,
        gpu_instance_profile: Optional[Union[str, "_models.GPUInstanceProfile"]] = None,
        creation_data: Optional["_models.CreationData"] = None,
        capacity_reservation_group_id: Optional[str] = None,
        host_group_id: Optional[str] = None,
        network_profile: Optional["_models.AgentPoolNetworkProfile"] = None,
        windows_profile: Optional["_models.AgentPoolWindowsProfile"] = None,
        security_profile: Optional["_models.AgentPoolSecurityProfile"] = None,
        gpu_profile: Optional["_models.GPUProfile"] = None,
        gateway_profile: Optional["_models.AgentPoolGatewayProfile"] = None,
        artifact_streaming_profile: Optional["_models.AgentPoolArtifactStreamingProfile"] = None,
        virtual_machines_profile: Optional["_models.VirtualMachinesProfile"] = None,
        virtual_machine_nodes_status: Optional[list["_models.VirtualMachineNodes"]] = None,
        status: Optional["_models.AgentPoolStatus"] = None,
        local_dns_profile: Optional["_models.LocalDNSProfile"] = None,
        node_customization_profile: Optional["_models.NodeCustomizationProfile"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAIToolchainOperatorProfile(_Model):
    """When enabling the operator, a set of AKS managed CRDs and controllers will be installed in the
    cluster. The operator automates the deployment of OSS models for inference and/or training
    purposes. It provides a set of preset models and enables distributed inference against them.

    :ivar enabled: Whether to enable AI toolchain operator to the cluster. Indicates if AI
     toolchain operator  enabled or not.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable AI toolchain operator to the cluster. Indicates if AI toolchain operator
     enabled or not."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAPIServerAccessProfile(_Model):
    """Access profile for managed cluster API server.

    :ivar authorized_ip_ranges: The IP ranges authorized to access the Kubernetes API server. IP
     ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible
     with clusters that use Public IP Per Node, or clusters that are using a Basic Load Balancer.
     For more information see `API server authorized IP ranges
     <https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges>`_.
    :vartype authorized_ip_ranges: list[str]
    :ivar enable_private_cluster: Whether to create the cluster as a private cluster or not. For
     more details, see `Creating a private AKS cluster
     <https://docs.microsoft.com/azure/aks/private-clusters>`_.
    :vartype enable_private_cluster: bool
    :ivar private_dns_zone: The private DNS zone mode for the cluster. The default is System. For
     more details see `configure private DNS zone
     <https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone>`_. Allowed
     values are 'system' and 'none'.
    :vartype private_dns_zone: str
    :ivar enable_private_cluster_public_fqdn: Whether to create additional public FQDN for private
     cluster or not.
    :vartype enable_private_cluster_public_fqdn: bool
    :ivar disable_run_command: Whether to disable run command for the cluster or not.
    :vartype disable_run_command: bool
    :ivar enable_vnet_integration: Whether to enable apiserver vnet integration for the cluster or
     not. See aka.ms/AksVnetIntegration for more details.
    :vartype enable_vnet_integration: bool
    :ivar subnet_id: The subnet to be used when apiserver vnet integration is enabled. It is
     required when creating a new cluster with BYO Vnet, or when updating an existing cluster to
     enable apiserver vnet integration.
    :vartype subnet_id: str
    """

    authorized_ip_ranges: Optional[list[str]] = rest_field(
        name="authorizedIPRanges", visibility=["read", "create", "update", "delete", "query"]
    )
    """The IP ranges authorized to access the Kubernetes API server. IP ranges are specified in CIDR
     format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP
     Per Node, or clusters that are using a Basic Load Balancer. For more information see `API
     server authorized IP ranges
     <https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges>`_."""
    enable_private_cluster: Optional[bool] = rest_field(
        name="enablePrivateCluster", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to create the cluster as a private cluster or not. For more details, see `Creating a
     private AKS cluster <https://docs.microsoft.com/azure/aks/private-clusters>`_."""
    private_dns_zone: Optional[str] = rest_field(
        name="privateDNSZone", visibility=["read", "create", "update", "delete", "query"]
    )
    """The private DNS zone mode for the cluster. The default is System. For more details see
     `configure private DNS zone
     <https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone>`_. Allowed
     values are 'system' and 'none'."""
    enable_private_cluster_public_fqdn: Optional[bool] = rest_field(
        name="enablePrivateClusterPublicFQDN", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to create additional public FQDN for private cluster or not."""
    disable_run_command: Optional[bool] = rest_field(
        name="disableRunCommand", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to disable run command for the cluster or not."""
    enable_vnet_integration: Optional[bool] = rest_field(
        name="enableVnetIntegration", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to enable apiserver vnet integration for the cluster or not. See
     aka.ms/AksVnetIntegration for more details."""
    subnet_id: Optional[str] = rest_field(name="subnetId", visibility=["read", "create", "update", "delete", "query"])
    """The subnet to be used when apiserver vnet integration is enabled. It is required when creating
     a new cluster with BYO Vnet, or when updating an existing cluster to enable apiserver vnet
     integration."""

    @overload
    def __init__(
        self,
        *,
        authorized_ip_ranges: Optional[list[str]] = None,
        enable_private_cluster: Optional[bool] = None,
        private_dns_zone: Optional[str] = None,
        enable_private_cluster_public_fqdn: Optional[bool] = None,
        disable_run_command: Optional[bool] = None,
        enable_vnet_integration: Optional[bool] = None,
        subnet_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAutoUpgradeProfile(_Model):
    """Auto upgrade profile for a managed cluster.

    :ivar upgrade_channel: The upgrade channel for auto upgrade. The default is 'none'. For more
     information see `setting the AKS cluster auto-upgrade channel
     <https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel>`_. Known values
     are: "rapid", "stable", "patch", "node-image", and "none".
    :vartype upgrade_channel: str or ~azure.mgmt.containerservice.models.UpgradeChannel
    :ivar node_os_upgrade_channel: Node OS Upgrade Channel. Manner in which the OS on your nodes is
     updated. The default is NodeImage. Known values are: "None", "Unmanaged", "NodeImage", and
     "SecurityPatch".
    :vartype node_os_upgrade_channel: str or
     ~azure.mgmt.containerservice.models.NodeOSUpgradeChannel
    """

    upgrade_channel: Optional[Union[str, "_models.UpgradeChannel"]] = rest_field(
        name="upgradeChannel", visibility=["read", "create", "update", "delete", "query"]
    )
    """The upgrade channel for auto upgrade. The default is 'none'. For more information see `setting
     the AKS cluster auto-upgrade channel
     <https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel>`_. Known values
     are: \"rapid\", \"stable\", \"patch\", \"node-image\", and \"none\"."""
    node_os_upgrade_channel: Optional[Union[str, "_models.NodeOSUpgradeChannel"]] = rest_field(
        name="nodeOSUpgradeChannel", visibility=["read", "create", "update", "delete", "query"]
    )
    """Node OS Upgrade Channel. Manner in which the OS on your nodes is updated. The default is
     NodeImage. Known values are: \"None\", \"Unmanaged\", \"NodeImage\", and \"SecurityPatch\"."""

    @overload
    def __init__(
        self,
        *,
        upgrade_channel: Optional[Union[str, "_models.UpgradeChannel"]] = None,
        node_os_upgrade_channel: Optional[Union[str, "_models.NodeOSUpgradeChannel"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAzureMonitorProfile(_Model):
    """Azure Monitor addon profiles for monitoring the managed cluster.

    :ivar metrics: Metrics profile for the Azure Monitor managed service for Prometheus addon.
     Collect out-of-the-box Kubernetes infrastructure metrics to send to an Azure Monitor Workspace
     and configure additional scraping for custom targets. See aka.ms/AzureManagedPrometheus for an
     overview.
    :vartype metrics: ~azure.mgmt.containerservice.models.ManagedClusterAzureMonitorProfileMetrics
    :ivar container_insights: Azure Monitor Container Insights Profile for Kubernetes Events,
     Inventory and Container stdout & stderr logs etc. See aka.ms/AzureMonitorContainerInsights for
     an overview.
    :vartype container_insights:
     ~azure.mgmt.containerservice.models.ManagedClusterAzureMonitorProfileContainerInsights
    :ivar app_monitoring: Application Monitoring Profile for Kubernetes Application Container.
     Collects application logs, metrics and traces through auto-instrumentation of the application
     using Azure Monitor OpenTelemetry based SDKs. See aka.ms/AzureMonitorApplicationMonitoring for
     an overview.
    :vartype app_monitoring:
     ~azure.mgmt.containerservice.models.ManagedClusterAzureMonitorProfileAppMonitoring
    """

    metrics: Optional["_models.ManagedClusterAzureMonitorProfileMetrics"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect
     out-of-the-box Kubernetes infrastructure metrics to send to an Azure Monitor Workspace and
     configure additional scraping for custom targets. See aka.ms/AzureManagedPrometheus for an
     overview."""
    container_insights: Optional["_models.ManagedClusterAzureMonitorProfileContainerInsights"] = rest_field(
        name="containerInsights", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure Monitor Container Insights Profile for Kubernetes Events, Inventory and Container stdout
     & stderr logs etc. See aka.ms/AzureMonitorContainerInsights for an overview."""
    app_monitoring: Optional["_models.ManagedClusterAzureMonitorProfileAppMonitoring"] = rest_field(
        name="appMonitoring", visibility=["read", "create", "update", "delete", "query"]
    )
    """Application Monitoring Profile for Kubernetes Application Container. Collects application logs,
     metrics and traces through auto-instrumentation of the application using Azure Monitor
     OpenTelemetry based SDKs. See aka.ms/AzureMonitorApplicationMonitoring for an overview."""

    @overload
    def __init__(
        self,
        *,
        metrics: Optional["_models.ManagedClusterAzureMonitorProfileMetrics"] = None,
        container_insights: Optional["_models.ManagedClusterAzureMonitorProfileContainerInsights"] = None,
        app_monitoring: Optional["_models.ManagedClusterAzureMonitorProfileAppMonitoring"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAzureMonitorProfileAppMonitoring(_Model):  # pylint: disable=name-too-long
    """Application Monitoring Profile for Kubernetes Application Container. Collects application logs,
    metrics and traces through auto-instrumentation of the application using Azure Monitor
    OpenTelemetry based SDKs. See aka.ms/AzureMonitorApplicationMonitoring for an overview.

    :ivar auto_instrumentation: Application Monitoring Auto Instrumentation for Kubernetes
     Application Container. Deploys web hook to auto-instrument Azure Monitor OpenTelemetry based
     SDKs to collect OpenTelemetry metrics, logs and traces of the application. See
     aka.ms/AzureMonitorApplicationMonitoring for an overview.
    :vartype auto_instrumentation:
     ~azure.mgmt.containerservice.models.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation
    :ivar open_telemetry_metrics: Application Monitoring Open Telemetry Metrics Profile for
     Kubernetes Application Container Metrics. Collects OpenTelemetry metrics of the application
     using Azure Monitor OpenTelemetry based SDKs. See aka.ms/AzureMonitorApplicationMonitoring for
     an overview.
    :vartype open_telemetry_metrics:
     ~azure.mgmt.containerservice.models.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics
    :ivar open_telemetry_logs: Application Monitoring Open Telemetry Metrics Profile for Kubernetes
     Application Container Logs and Traces. Collects OpenTelemetry logs and traces of the
     application using Azure Monitor OpenTelemetry based SDKs. See
     aka.ms/AzureMonitorApplicationMonitoring for an overview.
    :vartype open_telemetry_logs:
     ~azure.mgmt.containerservice.models.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs
    """

    auto_instrumentation: Optional["_models.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation"] = (
        rest_field(name="autoInstrumentation", visibility=["read", "create", "update", "delete", "query"])
    )
    """Application Monitoring Auto Instrumentation for Kubernetes Application Container. Deploys web
     hook to auto-instrument Azure Monitor OpenTelemetry based SDKs to collect OpenTelemetry
     metrics, logs and traces of the application. See aka.ms/AzureMonitorApplicationMonitoring for
     an overview."""
    open_telemetry_metrics: Optional["_models.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics"] = (
        rest_field(name="openTelemetryMetrics", visibility=["read", "create", "update", "delete", "query"])
    )
    """Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container
     Metrics. Collects OpenTelemetry metrics of the application using Azure Monitor OpenTelemetry
     based SDKs. See aka.ms/AzureMonitorApplicationMonitoring for an overview."""
    open_telemetry_logs: Optional["_models.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs"] = (
        rest_field(name="openTelemetryLogs", visibility=["read", "create", "update", "delete", "query"])
    )
    """Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Logs
     and Traces. Collects OpenTelemetry logs and traces of the application using Azure Monitor
     OpenTelemetry based SDKs. See aka.ms/AzureMonitorApplicationMonitoring for an overview."""

    @overload
    def __init__(
        self,
        *,
        auto_instrumentation: Optional[
            "_models.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation"
        ] = None,
        open_telemetry_metrics: Optional[
            "_models.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics"
        ] = None,
        open_telemetry_logs: Optional["_models.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation(_Model):  # pylint: disable=name-too-long
    """Application Monitoring Auto Instrumentation for Kubernetes Application Container. Deploys web
    hook to auto-instrument Azure Monitor OpenTelemetry based SDKs to collect OpenTelemetry
    metrics, logs and traces of the application. See aka.ms/AzureMonitorApplicationMonitoring for
    an overview.

    :ivar enabled: Indicates if Application Monitoring Auto Instrumentation is enabled or not.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Indicates if Application Monitoring Auto Instrumentation is enabled or not."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs(_Model):  # pylint: disable=name-too-long
    """Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Logs
    and Traces. Collects OpenTelemetry logs and traces of the application using Azure Monitor
    OpenTelemetry based SDKs. See aka.ms/AzureMonitorApplicationMonitoring for an overview.

    :ivar enabled: Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or
     not.
    :vartype enabled: bool
    :ivar port: The Open Telemetry host port for Open Telemetry logs and traces. If not specified,
     the default port is 28331.
    :vartype port: int
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or not."""
    port: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The Open Telemetry host port for Open Telemetry logs and traces. If not specified, the default
     port is 28331."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        port: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics(_Model):  # pylint: disable=name-too-long
    """Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container
    Metrics. Collects OpenTelemetry metrics of the application using Azure Monitor OpenTelemetry
    based SDKs. See aka.ms/AzureMonitorApplicationMonitoring for an overview.

    :ivar enabled: Indicates if Application Monitoring Open Telemetry Metrics is enabled or not.
    :vartype enabled: bool
    :ivar port: The Open Telemetry host port for Open Telemetry metrics. If not specified, the
     default port is 28333.
    :vartype port: int
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Indicates if Application Monitoring Open Telemetry Metrics is enabled or not."""
    port: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The Open Telemetry host port for Open Telemetry metrics. If not specified, the default port is
     28333."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        port: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAzureMonitorProfileContainerInsights(_Model):  # pylint: disable=name-too-long
    """Azure Monitor Container Insights Profile for Kubernetes Events, Inventory and Container stdout
    & stderr logs etc. See aka.ms/AzureMonitorContainerInsights for an overview.

    :ivar enabled: Indicates if Azure Monitor Container Insights Logs Addon is enabled or not.
    :vartype enabled: bool
    :ivar log_analytics_workspace_resource_id: Fully Qualified ARM Resource Id of Azure Log
     Analytics Workspace for storing Azure Monitor Container Insights Logs.
    :vartype log_analytics_workspace_resource_id: str
    :ivar syslog_port: The syslog host port. If not specified, the default port is 28330.
    :vartype syslog_port: int
    :ivar disable_custom_metrics: Indicates whether custom metrics collection has to be disabled or
     not. If not specified the default is false. No custom metrics will be emitted if this field is
     false but the container insights enabled field is false.
    :vartype disable_custom_metrics: bool
    :ivar disable_prometheus_metrics_scraping: Indicates whether prometheus metrics scraping is
     disabled or not. If not specified the default is false. No prometheus metrics will be emitted
     if this field is false but the container insights enabled field is false.
    :vartype disable_prometheus_metrics_scraping: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Indicates if Azure Monitor Container Insights Logs Addon is enabled or not."""
    log_analytics_workspace_resource_id: Optional[str] = rest_field(
        name="logAnalyticsWorkspaceResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Fully Qualified ARM Resource Id of Azure Log Analytics Workspace for storing Azure Monitor
     Container Insights Logs."""
    syslog_port: Optional[int] = rest_field(
        name="syslogPort", visibility=["read", "create", "update", "delete", "query"]
    )
    """The syslog host port. If not specified, the default port is 28330."""
    disable_custom_metrics: Optional[bool] = rest_field(
        name="disableCustomMetrics", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates whether custom metrics collection has to be disabled or not. If not specified the
     default is false. No custom metrics will be emitted if this field is false but the container
     insights enabled field is false."""
    disable_prometheus_metrics_scraping: Optional[bool] = rest_field(
        name="disablePrometheusMetricsScraping", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates whether prometheus metrics scraping is disabled or not. If not specified the default
     is false. No prometheus metrics will be emitted if this field is false but the container
     insights enabled field is false."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        log_analytics_workspace_resource_id: Optional[str] = None,
        syslog_port: Optional[int] = None,
        disable_custom_metrics: Optional[bool] = None,
        disable_prometheus_metrics_scraping: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAzureMonitorProfileKubeStateMetrics(_Model):  # pylint: disable=name-too-long
    """Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are
    for the kube-state-metrics pod that is deployed with the addon. See
    aka.ms/AzureManagedPrometheus-optional-parameters for details.

    :ivar metric_labels_allowlist: Comma-separated list of additional Kubernetes label keys that
     will be used in the resource's labels metric (Example:
     'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...'). By default the metric contains only
     resource name and namespace labels.
    :vartype metric_labels_allowlist: str
    :ivar metric_annotations_allow_list: Comma-separated list of Kubernetes annotation keys that
     will be used in the resource's labels metric (Example:
     'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...'). By default the metric
     contains only resource name and namespace labels.
    :vartype metric_annotations_allow_list: str
    """

    metric_labels_allowlist: Optional[str] = rest_field(
        name="metricLabelsAllowlist", visibility=["read", "create", "update", "delete", "query"]
    )
    """Comma-separated list of additional Kubernetes label keys that will be used in the resource's
     labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...'). By default
     the metric contains only resource name and namespace labels."""
    metric_annotations_allow_list: Optional[str] = rest_field(
        name="metricAnnotationsAllowList", visibility=["read", "create", "update", "delete", "query"]
    )
    """Comma-separated list of Kubernetes annotation keys that will be used in the resource's labels
     metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...'). By
     default the metric contains only resource name and namespace labels."""

    @overload
    def __init__(
        self,
        *,
        metric_labels_allowlist: Optional[str] = None,
        metric_annotations_allow_list: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterAzureMonitorProfileMetrics(_Model):
    """Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect
    out-of-the-box Kubernetes infrastructure metrics to send to an Azure Monitor Workspace and
    configure additional scraping for custom targets. See aka.ms/AzureManagedPrometheus for an
    overview.

    :ivar enabled: Whether to enable or disable the Azure Managed Prometheus addon for Prometheus
     monitoring. See aka.ms/AzureManagedPrometheus-aks-enable for details on enabling and disabling.
     Required.
    :vartype enabled: bool
    :ivar kube_state_metrics: Kube State Metrics profile for the Azure Managed Prometheus addon.
     These optional settings are for the kube-state-metrics pod that is deployed with the addon. See
     aka.ms/AzureManagedPrometheus-optional-parameters for details.
    :vartype kube_state_metrics:
     ~azure.mgmt.containerservice.models.ManagedClusterAzureMonitorProfileKubeStateMetrics
    """

    enabled: bool = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See
     aka.ms/AzureManagedPrometheus-aks-enable for details on enabling and disabling. Required."""
    kube_state_metrics: Optional["_models.ManagedClusterAzureMonitorProfileKubeStateMetrics"] = rest_field(
        name="kubeStateMetrics", visibility=["read", "create", "update", "delete", "query"]
    )
    """Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are
     for the kube-state-metrics pod that is deployed with the addon. See
     aka.ms/AzureManagedPrometheus-optional-parameters for details."""

    @overload
    def __init__(
        self,
        *,
        enabled: bool,
        kube_state_metrics: Optional["_models.ManagedClusterAzureMonitorProfileKubeStateMetrics"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterBootstrapProfile(_Model):
    """The bootstrap profile.

    :ivar artifact_source: The artifact source. The source where the artifacts are downloaded from.
     Known values are: "Cache" and "Direct".
    :vartype artifact_source: str or ~azure.mgmt.containerservice.models.ArtifactSource
    :ivar container_registry_id: The resource Id of Azure Container Registry. The registry must
     have private network access, premium SKU and zone redundancy.
    :vartype container_registry_id: str
    """

    artifact_source: Optional[Union[str, "_models.ArtifactSource"]] = rest_field(
        name="artifactSource", visibility=["read", "create", "update", "delete", "query"]
    )
    """The artifact source. The source where the artifacts are downloaded from. Known values are:
     \"Cache\" and \"Direct\"."""
    container_registry_id: Optional[str] = rest_field(
        name="containerRegistryId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource Id of Azure Container Registry. The registry must have private network access,
     premium SKU and zone redundancy."""

    @overload
    def __init__(
        self,
        *,
        artifact_source: Optional[Union[str, "_models.ArtifactSource"]] = None,
        container_registry_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterCostAnalysis(_Model):
    """The cost analysis configuration for the cluster.

    :ivar enabled: Whether to enable cost analysis. The Managed Cluster sku.tier must be set to
     'Standard' or 'Premium' to enable this feature. Enabling this will add Kubernetes Namespace and
     Deployment details to the Cost Analysis views in the Azure portal. If not specified, the
     default is false. For more information see aka.ms/aks/docs/cost-analysis.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable cost analysis. The Managed Cluster sku.tier must be set to 'Standard' or
     'Premium' to enable this feature. Enabling this will add Kubernetes Namespace and Deployment
     details to the Cost Analysis views in the Azure portal. If not specified, the default is false.
     For more information see aka.ms/aks/docs/cost-analysis."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterHostedSystemProfile(_Model):
    """Settings for hosted system addons.

    :ivar enabled: Whether to enable hosted system addons for the cluster.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable hosted system addons for the cluster."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterHTTPProxyConfig(_Model):
    """Cluster HTTP proxy configuration.

    :ivar http_proxy: The HTTP proxy server endpoint to use.
    :vartype http_proxy: str
    :ivar https_proxy: The HTTPS proxy server endpoint to use.
    :vartype https_proxy: str
    :ivar no_proxy: The endpoints that should not go through proxy.
    :vartype no_proxy: list[str]
    :ivar effective_no_proxy: A read-only list of all endpoints for which traffic should not be
     sent to the proxy. This list is a superset of noProxy and values injected by AKS.
    :vartype effective_no_proxy: list[str]
    :ivar trusted_ca: Alternative CA cert to use for connecting to proxy servers.
    :vartype trusted_ca: str
    :ivar enabled: Whether to enable HTTP proxy. When disabled, the specified proxy configuration
     will be not be set on pods and nodes.
    :vartype enabled: bool
    """

    http_proxy: Optional[str] = rest_field(name="httpProxy", visibility=["read", "create", "update", "delete", "query"])
    """The HTTP proxy server endpoint to use."""
    https_proxy: Optional[str] = rest_field(
        name="httpsProxy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The HTTPS proxy server endpoint to use."""
    no_proxy: Optional[list[str]] = rest_field(
        name="noProxy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The endpoints that should not go through proxy."""
    effective_no_proxy: Optional[list[str]] = rest_field(name="effectiveNoProxy", visibility=["read"])
    """A read-only list of all endpoints for which traffic should not be sent to the proxy. This list
     is a superset of noProxy and values injected by AKS."""
    trusted_ca: Optional[str] = rest_field(name="trustedCa", visibility=["read", "create", "update", "delete", "query"])
    """Alternative CA cert to use for connecting to proxy servers."""
    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable HTTP proxy. When disabled, the specified proxy configuration will be not be
     set on pods and nodes."""

    @overload
    def __init__(
        self,
        *,
        http_proxy: Optional[str] = None,
        https_proxy: Optional[str] = None,
        no_proxy: Optional[list[str]] = None,
        trusted_ca: Optional[str] = None,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterIdentity(_Model):
    """Identity for the managed cluster.

    :ivar principal_id: The principal id of the system assigned identity which is used by master
     components.
    :vartype principal_id: str
    :ivar tenant_id: The tenant id of the system assigned identity which is used by master
     components.
    :vartype tenant_id: str
    :ivar type: The type of identity used for the managed cluster. For more information see `use
     managed identities in AKS <https://docs.microsoft.com/azure/aks/use-managed-identity>`_. Known
     values are: "SystemAssigned", "UserAssigned", and "None".
    :vartype type: str or ~azure.mgmt.containerservice.models.ResourceIdentityType
    :ivar delegated_resources: The delegated identity resources assigned to this managed cluster.
     This can only be set by another Azure Resource Provider, and managed cluster only accept one
     delegated identity resource. Internal use only.
    :vartype delegated_resources: dict[str, ~azure.mgmt.containerservice.models.DelegatedResource]
    :ivar user_assigned_identities: The user identity associated with the managed cluster. This
     identity will be used in control plane. Only one user assigned identity is allowed. The keys
     must be ARM resource IDs in the form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
    :vartype user_assigned_identities: dict[str,
     ~azure.mgmt.containerservice.models.ManagedServiceIdentityUserAssignedIdentitiesValue]
    """

    principal_id: Optional[str] = rest_field(name="principalId", visibility=["read"])
    """The principal id of the system assigned identity which is used by master components."""
    tenant_id: Optional[str] = rest_field(name="tenantId", visibility=["read"])
    """The tenant id of the system assigned identity which is used by master components."""
    type: Optional[Union[str, "_models.ResourceIdentityType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of identity used for the managed cluster. For more information see `use managed
     identities in AKS <https://docs.microsoft.com/azure/aks/use-managed-identity>`_. Known values
     are: \"SystemAssigned\", \"UserAssigned\", and \"None\"."""
    delegated_resources: Optional[dict[str, "_models.DelegatedResource"]] = rest_field(
        name="delegatedResources", visibility=["read", "create", "update", "delete", "query"]
    )
    """The delegated identity resources assigned to this managed cluster. This can only be set by
     another Azure Resource Provider, and managed cluster only accept one delegated identity
     resource. Internal use only."""
    user_assigned_identities: Optional[dict[str, "_models.ManagedServiceIdentityUserAssignedIdentitiesValue"]] = (
        rest_field(name="userAssignedIdentities", visibility=["read", "create", "update", "delete", "query"])
    )
    """The user identity associated with the managed cluster. This identity will be used in control
     plane. Only one user assigned identity is allowed. The keys must be ARM resource IDs in the
     form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.ResourceIdentityType"]] = None,
        delegated_resources: Optional[dict[str, "_models.DelegatedResource"]] = None,
        user_assigned_identities: Optional[
            dict[str, "_models.ManagedServiceIdentityUserAssignedIdentitiesValue"]
        ] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterIngressDefaultDomainProfile(_Model):  # pylint: disable=name-too-long
    """ManagedClusterIngressDefaultDomainProfile.

    :ivar enabled: Whether to enable Default Domain.
    :vartype enabled: bool
    :ivar domain_name: The unique fully qualified domain name assigned to the cluster. This will
     not change even if disabled then reenabled.
    :vartype domain_name: str
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable Default Domain."""
    domain_name: Optional[str] = rest_field(name="domainName", visibility=["read"])
    """The unique fully qualified domain name assigned to the cluster. This will not change even if
     disabled then reenabled."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterIngressProfile(_Model):
    """Ingress profile for the container service cluster.

    :ivar web_app_routing: App Routing settings for the ingress profile. You can find an overview
     and onboarding guide for this feature at
     `https://learn.microsoft.com/en-us/azure/aks/app-routing?tabs=default%2Cdeploy-app-default
     <https://learn.microsoft.com/en-us/azure/aks/app-routing?tabs=default%2Cdeploy-app-default>`_.
    :vartype web_app_routing:
     ~azure.mgmt.containerservice.models.ManagedClusterIngressProfileWebAppRouting
    :ivar gateway_api: Settings for the managed Gateway API installation.
    :vartype gateway_api:
     ~azure.mgmt.containerservice.models.ManagedClusterIngressProfileGatewayConfiguration
    :ivar application_load_balancer: Settings for the managed Application Load Balancer
     installation.
    :vartype application_load_balancer:
     ~azure.mgmt.containerservice.models.ManagedClusterIngressProfileApplicationLoadBalancer
    """

    web_app_routing: Optional["_models.ManagedClusterIngressProfileWebAppRouting"] = rest_field(
        name="webAppRouting", visibility=["read", "create", "update", "delete", "query"]
    )
    """App Routing settings for the ingress profile. You can find an overview and onboarding guide for
     this feature at
     `https://learn.microsoft.com/en-us/azure/aks/app-routing?tabs=default%2Cdeploy-app-default
     <https://learn.microsoft.com/en-us/azure/aks/app-routing?tabs=default%2Cdeploy-app-default>`_."""
    gateway_api: Optional["_models.ManagedClusterIngressProfileGatewayConfiguration"] = rest_field(
        name="gatewayAPI", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for the managed Gateway API installation."""
    application_load_balancer: Optional["_models.ManagedClusterIngressProfileApplicationLoadBalancer"] = rest_field(
        name="applicationLoadBalancer", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for the managed Application Load Balancer installation."""

    @overload
    def __init__(
        self,
        *,
        web_app_routing: Optional["_models.ManagedClusterIngressProfileWebAppRouting"] = None,
        gateway_api: Optional["_models.ManagedClusterIngressProfileGatewayConfiguration"] = None,
        application_load_balancer: Optional["_models.ManagedClusterIngressProfileApplicationLoadBalancer"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterIngressProfileApplicationLoadBalancer(_Model):  # pylint: disable=name-too-long
    """Application Load Balancer settings for the ingress profile.

    :ivar enabled: Whether to enable Application Load Balancer.
    :vartype enabled: bool
    :ivar identity: Managed identity of the Application Load Balancer add-on. This is the identity
     that should be granted permissions to manage the associated Application Gateway for Containers
     resource.
    :vartype identity: ~azure.mgmt.containerservice.models.UserAssignedIdentity
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable Application Load Balancer."""
    identity: Optional["_models.UserAssignedIdentity"] = rest_field(visibility=["read"])
    """Managed identity of the Application Load Balancer add-on. This is the identity that should be
     granted permissions to manage the associated Application Gateway for Containers resource."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterIngressProfileGatewayConfiguration(_Model):  # pylint: disable=name-too-long
    """ManagedClusterIngressProfileGatewayConfiguration.

    :ivar installation: Configuration for the managed Gateway API installation. If not specified,
     the default is 'Disabled'. See `https://aka.ms/k8s-gateway-api
     <https://aka.ms/k8s-gateway-api>`_ for more details. Known values are: "Disabled" and
     "Standard".
    :vartype installation: str or ~azure.mgmt.containerservice.models.ManagedGatewayType
    """

    installation: Optional[Union[str, "_models.ManagedGatewayType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Configuration for the managed Gateway API installation. If not specified, the default is
     'Disabled'. See `https://aka.ms/k8s-gateway-api <https://aka.ms/k8s-gateway-api>`_ for more
     details. Known values are: \"Disabled\" and \"Standard\"."""

    @overload
    def __init__(
        self,
        *,
        installation: Optional[Union[str, "_models.ManagedGatewayType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterIngressProfileNginx(_Model):
    """ManagedClusterIngressProfileNginx.

    :ivar default_ingress_controller_type: Ingress type for the default NginxIngressController
     custom resource. Known values are: "AnnotationControlled", "External", "Internal", and "None".
    :vartype default_ingress_controller_type: str or
     ~azure.mgmt.containerservice.models.NginxIngressControllerType
    """

    default_ingress_controller_type: Optional[Union[str, "_models.NginxIngressControllerType"]] = rest_field(
        name="defaultIngressControllerType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Ingress type for the default NginxIngressController custom resource. Known values are:
     \"AnnotationControlled\", \"External\", \"Internal\", and \"None\"."""

    @overload
    def __init__(
        self,
        *,
        default_ingress_controller_type: Optional[Union[str, "_models.NginxIngressControllerType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterIngressProfileWebAppRouting(_Model):  # pylint: disable=name-too-long
    """Application Routing add-on settings for the ingress profile.

    :ivar enabled: Whether to enable the Application Routing add-on.
    :vartype enabled: bool
    :ivar dns_zone_resource_ids: Resource IDs of the DNS zones to be associated with the
     Application Routing add-on. Used only when Application Routing add-on is enabled. Public and
     private DNS zones can be in different resource groups, but all public DNS zones must be in the
     same resource group and all private DNS zones must be in the same resource group.
    :vartype dns_zone_resource_ids: list[str]
    :ivar nginx: Configuration for the default NginxIngressController. See more at
     `https://learn.microsoft.com/en-us/azure/aks/app-routing-nginx-configuration#the-default-nginx-ingress-controller
     <https://learn.microsoft.com/en-us/azure/aks/app-routing-nginx-configuration#the-default-nginx-ingress-controller>`_.
    :vartype nginx: ~azure.mgmt.containerservice.models.ManagedClusterIngressProfileNginx
    :ivar identity: Managed identity of the Application Routing add-on. This is the identity that
     should be granted permissions, for example, to manage the associated Azure DNS resource and get
     certificates from Azure Key Vault. See `this overview of the add-on
     <https://learn.microsoft.com/en-us/azure/aks/web-app-routing?tabs=with-osm>`_ for more
     instructions.
    :vartype identity: ~azure.mgmt.containerservice.models.UserAssignedIdentity
    :ivar default_domain: Configuration for the Default Domain. This is a unique, autogenerated
     domain that comes with a signed TLS Certificate allowing for secure HTTPS. See `the Default
     Domain documentation <https://aka.ms/aks/defaultdomain>`_ for more instructions.
    :vartype default_domain:
     ~azure.mgmt.containerservice.models.ManagedClusterIngressDefaultDomainProfile
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable the Application Routing add-on."""
    dns_zone_resource_ids: Optional[list[str]] = rest_field(
        name="dnsZoneResourceIds", visibility=["read", "create", "update", "delete", "query"]
    )
    """Resource IDs of the DNS zones to be associated with the Application Routing add-on. Used only
     when Application Routing add-on is enabled. Public and private DNS zones can be in different
     resource groups, but all public DNS zones must be in the same resource group and all private
     DNS zones must be in the same resource group."""
    nginx: Optional["_models.ManagedClusterIngressProfileNginx"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Configuration for the default NginxIngressController. See more at
     `https://learn.microsoft.com/en-us/azure/aks/app-routing-nginx-configuration#the-default-nginx-ingress-controller
     <https://learn.microsoft.com/en-us/azure/aks/app-routing-nginx-configuration#the-default-nginx-ingress-controller>`_."""
    identity: Optional["_models.UserAssignedIdentity"] = rest_field(visibility=["read"])
    """Managed identity of the Application Routing add-on. This is the identity that should be granted
     permissions, for example, to manage the associated Azure DNS resource and get certificates from
     Azure Key Vault. See `this overview of the add-on
     <https://learn.microsoft.com/en-us/azure/aks/web-app-routing?tabs=with-osm>`_ for more
     instructions."""
    default_domain: Optional["_models.ManagedClusterIngressDefaultDomainProfile"] = rest_field(
        name="defaultDomain", visibility=["read", "create", "update", "delete", "query"]
    )
    """Configuration for the Default Domain. This is a unique, autogenerated domain that comes with a
     signed TLS Certificate allowing for secure HTTPS. See `the Default Domain documentation
     <https://aka.ms/aks/defaultdomain>`_ for more instructions."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        dns_zone_resource_ids: Optional[list[str]] = None,
        nginx: Optional["_models.ManagedClusterIngressProfileNginx"] = None,
        default_domain: Optional["_models.ManagedClusterIngressDefaultDomainProfile"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterLoadBalancerProfile(_Model):
    """Profile of the managed cluster load balancer.

    :ivar managed_outbound_i_ps: Desired managed outbound IPs for the cluster load balancer.
    :vartype managed_outbound_i_ps:
     ~azure.mgmt.containerservice.models.ManagedClusterLoadBalancerProfileManagedOutboundIPs
    :ivar outbound_ip_prefixes: Desired outbound IP Prefix resources for the cluster load balancer.
    :vartype outbound_ip_prefixes:
     ~azure.mgmt.containerservice.models.ManagedClusterLoadBalancerProfileOutboundIPPrefixes
    :ivar outbound_i_ps: Desired outbound IP resources for the cluster load balancer.
    :vartype outbound_i_ps:
     ~azure.mgmt.containerservice.models.ManagedClusterLoadBalancerProfileOutboundIPs
    :ivar effective_outbound_i_ps: The effective outbound IP resources of the cluster load
     balancer.
    :vartype effective_outbound_i_ps: list[~azure.mgmt.containerservice.models.ResourceReference]
    :ivar allocated_outbound_ports: The desired number of allocated SNAT ports per VM. Allowed
     values are in the range of 0 to 64000 (inclusive). The default value is 0 which results in
     Azure dynamically allocating ports.
    :vartype allocated_outbound_ports: int
    :ivar idle_timeout_in_minutes: Desired outbound flow idle timeout in minutes. Allowed values
     are in the range of 4 to 120 (inclusive). The default value is 30 minutes.
    :vartype idle_timeout_in_minutes: int
    :ivar enable_multiple_standard_load_balancers: Enable multiple standard load balancers per AKS
     cluster or not.
    :vartype enable_multiple_standard_load_balancers: bool
    :ivar backend_pool_type: The type of the managed inbound Load Balancer BackendPool. Known
     values are: "NodeIPConfiguration" and "NodeIP".
    :vartype backend_pool_type: str or ~azure.mgmt.containerservice.models.BackendPoolType
    :ivar cluster_service_load_balancer_health_probe_mode: The health probing behavior for External
     Traffic Policy Cluster services. Known values are: "ServiceNodePort" and "Shared".
    :vartype cluster_service_load_balancer_health_probe_mode: str or
     ~azure.mgmt.containerservice.models.ClusterServiceLoadBalancerHealthProbeMode
    """

    managed_outbound_i_ps: Optional["_models.ManagedClusterLoadBalancerProfileManagedOutboundIPs"] = rest_field(
        name="managedOutboundIPs", visibility=["read", "create", "update", "delete", "query"]
    )
    """Desired managed outbound IPs for the cluster load balancer."""
    outbound_ip_prefixes: Optional["_models.ManagedClusterLoadBalancerProfileOutboundIPPrefixes"] = rest_field(
        name="outboundIPPrefixes", visibility=["read", "create", "update", "delete", "query"]
    )
    """Desired outbound IP Prefix resources for the cluster load balancer."""
    outbound_i_ps: Optional["_models.ManagedClusterLoadBalancerProfileOutboundIPs"] = rest_field(
        name="outboundIPs", visibility=["read", "create", "update", "delete", "query"]
    )
    """Desired outbound IP resources for the cluster load balancer."""
    effective_outbound_i_ps: Optional[list["_models.ResourceReference"]] = rest_field(
        name="effectiveOutboundIPs", visibility=["read"]
    )
    """The effective outbound IP resources of the cluster load balancer."""
    allocated_outbound_ports: Optional[int] = rest_field(
        name="allocatedOutboundPorts", visibility=["read", "create", "update", "delete", "query"]
    )
    """The desired number of allocated SNAT ports per VM. Allowed values are in the range of 0 to
     64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports."""
    idle_timeout_in_minutes: Optional[int] = rest_field(
        name="idleTimeoutInMinutes", visibility=["read", "create", "update", "delete", "query"]
    )
    """Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120
     (inclusive). The default value is 30 minutes."""
    enable_multiple_standard_load_balancers: Optional[bool] = rest_field(
        name="enableMultipleStandardLoadBalancers", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable multiple standard load balancers per AKS cluster or not."""
    backend_pool_type: Optional[Union[str, "_models.BackendPoolType"]] = rest_field(
        name="backendPoolType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of the managed inbound Load Balancer BackendPool. Known values are:
     \"NodeIPConfiguration\" and \"NodeIP\"."""
    cluster_service_load_balancer_health_probe_mode: Optional[
        Union[str, "_models.ClusterServiceLoadBalancerHealthProbeMode"]
    ] = rest_field(
        name="clusterServiceLoadBalancerHealthProbeMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The health probing behavior for External Traffic Policy Cluster services. Known values are:
     \"ServiceNodePort\" and \"Shared\"."""

    @overload
    def __init__(
        self,
        *,
        managed_outbound_i_ps: Optional["_models.ManagedClusterLoadBalancerProfileManagedOutboundIPs"] = None,
        outbound_ip_prefixes: Optional["_models.ManagedClusterLoadBalancerProfileOutboundIPPrefixes"] = None,
        outbound_i_ps: Optional["_models.ManagedClusterLoadBalancerProfileOutboundIPs"] = None,
        allocated_outbound_ports: Optional[int] = None,
        idle_timeout_in_minutes: Optional[int] = None,
        enable_multiple_standard_load_balancers: Optional[bool] = None,
        backend_pool_type: Optional[Union[str, "_models.BackendPoolType"]] = None,
        cluster_service_load_balancer_health_probe_mode: Optional[
            Union[str, "_models.ClusterServiceLoadBalancerHealthProbeMode"]
        ] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterLoadBalancerProfileManagedOutboundIPs(_Model):  # pylint: disable=name-too-long
    """Desired managed outbound IPs for the cluster load balancer.

    :ivar count: The desired number of IPv4 outbound IPs created/managed by Azure for the cluster
     load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value
     is 1.
    :vartype count: int
    :ivar count_ipv6: The desired number of IPv6 outbound IPs created/managed by Azure for the
     cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default
     value is 0 for single-stack and 1 for dual-stack.
    :vartype count_ipv6: int
    """

    count: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The desired number of IPv4 outbound IPs created/managed by Azure for the cluster load balancer.
     Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1."""
    count_ipv6: Optional[int] = rest_field(name="countIPv6", visibility=["read", "create", "update", "delete", "query"])
    """The desired number of IPv6 outbound IPs created/managed by Azure for the cluster load balancer.
     Allowed values must be in the range of 1 to 100 (inclusive). The default value is 0 for
     single-stack and 1 for dual-stack."""

    @overload
    def __init__(
        self,
        *,
        count: Optional[int] = None,
        count_ipv6: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterLoadBalancerProfileOutboundIPPrefixes(_Model):  # pylint: disable=name-too-long
    """Desired outbound IP Prefix resources for the cluster load balancer.

    :ivar public_ip_prefixes: A list of public IP prefix resources.
    :vartype public_ip_prefixes: list[~azure.mgmt.containerservice.models.ResourceReference]
    """

    public_ip_prefixes: Optional[list["_models.ResourceReference"]] = rest_field(
        name="publicIPPrefixes", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of public IP prefix resources."""

    @overload
    def __init__(
        self,
        *,
        public_ip_prefixes: Optional[list["_models.ResourceReference"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterLoadBalancerProfileOutboundIPs(_Model):  # pylint: disable=name-too-long
    """Desired outbound IP resources for the cluster load balancer.

    :ivar public_i_ps: A list of public IP resources.
    :vartype public_i_ps: list[~azure.mgmt.containerservice.models.ResourceReference]
    """

    public_i_ps: Optional[list["_models.ResourceReference"]] = rest_field(
        name="publicIPs", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of public IP resources."""

    @overload
    def __init__(
        self,
        *,
        public_i_ps: Optional[list["_models.ResourceReference"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterManagedOutboundIPProfile(_Model):
    """Profile of the managed outbound IP resources of the managed cluster.

    :ivar count: The desired number of outbound IPs created/managed by Azure. Allowed values must
     be in the range of 1 to 16 (inclusive). The default value is 1.
    :vartype count: int
    """

    count: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The desired number of outbound IPs created/managed by Azure. Allowed values must be in the
     range of 1 to 16 (inclusive). The default value is 1."""

    @overload
    def __init__(
        self,
        *,
        count: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterMetricsProfile(_Model):
    """The metrics profile for the ManagedCluster.

    :ivar cost_analysis: The configuration for detailed per-Kubernetes resource cost analysis.
    :vartype cost_analysis: ~azure.mgmt.containerservice.models.ManagedClusterCostAnalysis
    """

    cost_analysis: Optional["_models.ManagedClusterCostAnalysis"] = rest_field(
        name="costAnalysis", visibility=["read", "create", "update", "delete", "query"]
    )
    """The configuration for detailed per-Kubernetes resource cost analysis."""

    @overload
    def __init__(
        self,
        *,
        cost_analysis: Optional["_models.ManagedClusterCostAnalysis"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterNATGatewayProfile(_Model):
    """Profile of the managed cluster NAT gateway.

    :ivar managed_outbound_ip_profile: Profile of the managed outbound IP resources of the cluster
     NAT gateway.
    :vartype managed_outbound_ip_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterManagedOutboundIPProfile
    :ivar effective_outbound_i_ps: The effective outbound IP resources of the cluster NAT gateway.
    :vartype effective_outbound_i_ps: list[~azure.mgmt.containerservice.models.ResourceReference]
    :ivar idle_timeout_in_minutes: Desired outbound flow idle timeout in minutes. Allowed values
     are in the range of 4 to 120 (inclusive). The default value is 4 minutes.
    :vartype idle_timeout_in_minutes: int
    """

    managed_outbound_ip_profile: Optional["_models.ManagedClusterManagedOutboundIPProfile"] = rest_field(
        name="managedOutboundIPProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Profile of the managed outbound IP resources of the cluster NAT gateway."""
    effective_outbound_i_ps: Optional[list["_models.ResourceReference"]] = rest_field(
        name="effectiveOutboundIPs", visibility=["read"]
    )
    """The effective outbound IP resources of the cluster NAT gateway."""
    idle_timeout_in_minutes: Optional[int] = rest_field(
        name="idleTimeoutInMinutes", visibility=["read", "create", "update", "delete", "query"]
    )
    """Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120
     (inclusive). The default value is 4 minutes."""

    @overload
    def __init__(
        self,
        *,
        managed_outbound_ip_profile: Optional["_models.ManagedClusterManagedOutboundIPProfile"] = None,
        idle_timeout_in_minutes: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterNodeProvisioningProfile(_Model):
    """ManagedClusterNodeProvisioningProfile.

    :ivar mode: The node provisioning mode. If not specified, the default is Manual. Known values
     are: "Manual" and "Auto".
    :vartype mode: str or ~azure.mgmt.containerservice.models.NodeProvisioningMode
    :ivar default_node_pools: The set of default Karpenter NodePools (CRDs) configured for node
     provisioning. This field has no effect unless mode is 'Auto'. Warning: Changing this from Auto
     to None on an existing cluster will cause the default Karpenter NodePools to be deleted, which
     will drain and delete the nodes associated with those pools. It is strongly recommended to not
     do this unless there are idle nodes ready to take the pods evicted by that action. If not
     specified, the default is Auto. For more information see aka.ms/aks/nap#node-pools. Known
     values are: "None" and "Auto".
    :vartype default_node_pools: str or
     ~azure.mgmt.containerservice.models.NodeProvisioningDefaultNodePools
    """

    mode: Optional[Union[str, "_models.NodeProvisioningMode"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The node provisioning mode. If not specified, the default is Manual. Known values are:
     \"Manual\" and \"Auto\"."""
    default_node_pools: Optional[Union[str, "_models.NodeProvisioningDefaultNodePools"]] = rest_field(
        name="defaultNodePools", visibility=["read", "create", "update", "delete", "query"]
    )
    """The set of default Karpenter NodePools (CRDs) configured for node provisioning. This field has
     no effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing
     cluster will cause the default Karpenter NodePools to be deleted, which will drain and delete
     the nodes associated with those pools. It is strongly recommended to not do this unless there
     are idle nodes ready to take the pods evicted by that action. If not specified, the default is
     Auto. For more information see aka.ms/aks/nap#node-pools. Known values are: \"None\" and
     \"Auto\"."""

    @overload
    def __init__(
        self,
        *,
        mode: Optional[Union[str, "_models.NodeProvisioningMode"]] = None,
        default_node_pools: Optional[Union[str, "_models.NodeProvisioningDefaultNodePools"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterNodeResourceGroupProfile(_Model):
    """Node resource group lockdown profile for a managed cluster.

    :ivar restriction_level: The restriction level applied to the cluster's node resource group. If
     not specified, the default is 'Unrestricted'. Known values are: "Unrestricted" and "ReadOnly".
    :vartype restriction_level: str or ~azure.mgmt.containerservice.models.RestrictionLevel
    """

    restriction_level: Optional[Union[str, "_models.RestrictionLevel"]] = rest_field(
        name="restrictionLevel", visibility=["read", "create", "update", "delete", "query"]
    )
    """The restriction level applied to the cluster's node resource group. If not specified, the
     default is 'Unrestricted'. Known values are: \"Unrestricted\" and \"ReadOnly\"."""

    @overload
    def __init__(
        self,
        *,
        restriction_level: Optional[Union[str, "_models.RestrictionLevel"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterOIDCIssuerProfile(_Model):
    """The OIDC issuer profile of the Managed Cluster.

    :ivar issuer_url: The OIDC issuer url of the Managed Cluster.
    :vartype issuer_url: str
    :ivar enabled: Whether the OIDC issuer is enabled.
    :vartype enabled: bool
    """

    issuer_url: Optional[str] = rest_field(name="issuerURL", visibility=["read"])
    """The OIDC issuer url of the Managed Cluster."""
    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether the OIDC issuer is enabled."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterPodIdentity(_Model):
    """Details about the pod identity assigned to the Managed Cluster.

    :ivar name: The name of the pod identity. Required.
    :vartype name: str
    :ivar namespace: The namespace of the pod identity. Required.
    :vartype namespace: str
    :ivar binding_selector: The binding selector to use for the AzureIdentityBinding resource.
    :vartype binding_selector: str
    :ivar identity: The user assigned identity details. Required.
    :vartype identity: ~azure.mgmt.containerservice.models.UserAssignedIdentity
    :ivar provisioning_state: The current provisioning state of the pod identity. Known values are:
     "Assigned", "Canceled", "Deleting", "Failed", "Succeeded", and "Updating".
    :vartype provisioning_state: str or
     ~azure.mgmt.containerservice.models.ManagedClusterPodIdentityProvisioningState
    :ivar provisioning_info:
    :vartype provisioning_info:
     ~azure.mgmt.containerservice.models.ManagedClusterPodIdentityProvisioningInfo
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the pod identity. Required."""
    namespace: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The namespace of the pod identity. Required."""
    binding_selector: Optional[str] = rest_field(
        name="bindingSelector", visibility=["read", "create", "update", "delete", "query"]
    )
    """The binding selector to use for the AzureIdentityBinding resource."""
    identity: "_models.UserAssignedIdentity" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The user assigned identity details. Required."""
    provisioning_state: Optional[Union[str, "_models.ManagedClusterPodIdentityProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The current provisioning state of the pod identity. Known values are: \"Assigned\",
     \"Canceled\", \"Deleting\", \"Failed\", \"Succeeded\", and \"Updating\"."""
    provisioning_info: Optional["_models.ManagedClusterPodIdentityProvisioningInfo"] = rest_field(
        name="provisioningInfo", visibility=["read"]
    )

    @overload
    def __init__(
        self,
        *,
        name: str,
        namespace: str,
        identity: "_models.UserAssignedIdentity",
        binding_selector: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterPodIdentityException(_Model):
    """A pod identity exception, which allows pods with certain labels to access the Azure Instance
    Metadata Service (IMDS) endpoint without being intercepted by the node-managed identity (NMI)
    server. See `disable AAD Pod Identity for a specific Pod/Application
    <https://azure.github.io/aad-pod-identity/docs/configure/application_exception/>`_ for more
    details.

    :ivar name: The name of the pod identity exception. Required.
    :vartype name: str
    :ivar namespace: The namespace of the pod identity exception. Required.
    :vartype namespace: str
    :ivar pod_labels: The pod labels to match. Required.
    :vartype pod_labels: dict[str, str]
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the pod identity exception. Required."""
    namespace: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The namespace of the pod identity exception. Required."""
    pod_labels: dict[str, str] = rest_field(
        name="podLabels", visibility=["read", "create", "update", "delete", "query"]
    )
    """The pod labels to match. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        namespace: str,
        pod_labels: dict[str, str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterPodIdentityProfile(_Model):
    """The pod identity profile of the Managed Cluster. See `use AAD pod identity
    <https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity>`_ for more details on pod
    identity integration.

    :ivar enabled: Whether the pod identity addon is enabled.
    :vartype enabled: bool
    :ivar allow_network_plugin_kubenet: Whether pod identity is allowed to run on clusters with
     Kubenet networking. Running in Kubenet is disabled by default due to the security related
     nature of AAD Pod Identity and the risks of IP spoofing. See `using Kubenet network plugin with
     AAD Pod Identity
     <https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities>`_
     for more information.
    :vartype allow_network_plugin_kubenet: bool
    :ivar user_assigned_identities: The pod identities to use in the cluster.
    :vartype user_assigned_identities:
     list[~azure.mgmt.containerservice.models.ManagedClusterPodIdentity]
    :ivar user_assigned_identity_exceptions: The pod identity exceptions to allow.
    :vartype user_assigned_identity_exceptions:
     list[~azure.mgmt.containerservice.models.ManagedClusterPodIdentityException]
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether the pod identity addon is enabled."""
    allow_network_plugin_kubenet: Optional[bool] = rest_field(
        name="allowNetworkPluginKubenet", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether pod identity is allowed to run on clusters with Kubenet networking. Running in Kubenet
     is disabled by default due to the security related nature of AAD Pod Identity and the risks of
     IP spoofing. See `using Kubenet network plugin with AAD Pod Identity
     <https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities>`_
     for more information."""
    user_assigned_identities: Optional[list["_models.ManagedClusterPodIdentity"]] = rest_field(
        name="userAssignedIdentities", visibility=["read", "create", "update", "delete", "query"]
    )
    """The pod identities to use in the cluster."""
    user_assigned_identity_exceptions: Optional[list["_models.ManagedClusterPodIdentityException"]] = rest_field(
        name="userAssignedIdentityExceptions", visibility=["read", "create", "update", "delete", "query"]
    )
    """The pod identity exceptions to allow."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        allow_network_plugin_kubenet: Optional[bool] = None,
        user_assigned_identities: Optional[list["_models.ManagedClusterPodIdentity"]] = None,
        user_assigned_identity_exceptions: Optional[list["_models.ManagedClusterPodIdentityException"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterPodIdentityProvisioningError(_Model):  # pylint: disable=name-too-long
    """An error response from the pod identity provisioning.

    :ivar error: Details about the error.
    :vartype error:
     ~azure.mgmt.containerservice.models.ManagedClusterPodIdentityProvisioningErrorBody
    """

    error: Optional["_models.ManagedClusterPodIdentityProvisioningErrorBody"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Details about the error."""

    @overload
    def __init__(
        self,
        *,
        error: Optional["_models.ManagedClusterPodIdentityProvisioningErrorBody"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterPodIdentityProvisioningErrorBody(_Model):  # pylint: disable=name-too-long
    """An error response from the pod identity provisioning.

    :ivar code: An identifier for the error. Codes are invariant and are intended to be consumed
     programmatically.
    :vartype code: str
    :ivar message: A message describing the error, intended to be suitable for display in a user
     interface.
    :vartype message: str
    :ivar target: The target of the particular error. For example, the name of the property in
     error.
    :vartype target: str
    :ivar details: A list of additional details about the error.
    :vartype details:
     list[~azure.mgmt.containerservice.models.ManagedClusterPodIdentityProvisioningErrorBody]
    """

    code: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """An identifier for the error. Codes are invariant and are intended to be consumed
     programmatically."""
    message: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A message describing the error, intended to be suitable for display in a user interface."""
    target: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The target of the particular error. For example, the name of the property in error."""
    details: Optional[list["_models.ManagedClusterPodIdentityProvisioningErrorBody"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of additional details about the error."""

    @overload
    def __init__(
        self,
        *,
        code: Optional[str] = None,
        message: Optional[str] = None,
        target: Optional[str] = None,
        details: Optional[list["_models.ManagedClusterPodIdentityProvisioningErrorBody"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterPodIdentityProvisioningInfo(_Model):  # pylint: disable=name-too-long
    """ManagedClusterPodIdentityProvisioningInfo.

    :ivar error: Pod identity assignment error (if any).
    :vartype error: ~azure.mgmt.containerservice.models.ManagedClusterPodIdentityProvisioningError
    """

    error: Optional["_models.ManagedClusterPodIdentityProvisioningError"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Pod identity assignment error (if any)."""

    @overload
    def __init__(
        self,
        *,
        error: Optional["_models.ManagedClusterPodIdentityProvisioningError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterPoolUpgradeProfile(_Model):
    """The list of available upgrade versions.

    :ivar kubernetes_version: The Kubernetes version (major.minor.patch). Required.
    :vartype kubernetes_version: str
    :ivar name: The Agent Pool name.
    :vartype name: str
    :ivar os_type: The operating system type. The default is Linux. Required. Known values are:
     "Linux" and "Windows".
    :vartype os_type: str or ~azure.mgmt.containerservice.models.OSType
    :ivar upgrades: List of orchestrator types and versions available for upgrade.
    :vartype upgrades:
     list[~azure.mgmt.containerservice.models.ManagedClusterPoolUpgradeProfileUpgradesItem]
    :ivar components_by_releases: List of components grouped by kubernetes major.minor version.
    :vartype components_by_releases: list[~azure.mgmt.containerservice.models.ComponentsByRelease]
    """

    kubernetes_version: str = rest_field(
        name="kubernetesVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Kubernetes version (major.minor.patch). Required."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The Agent Pool name."""
    os_type: Union[str, "_models.OSType"] = rest_field(
        name="osType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The operating system type. The default is Linux. Required. Known values are: \"Linux\" and
     \"Windows\"."""
    upgrades: Optional[list["_models.ManagedClusterPoolUpgradeProfileUpgradesItem"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """List of orchestrator types and versions available for upgrade."""
    components_by_releases: Optional[list["_models.ComponentsByRelease"]] = rest_field(
        name="componentsByReleases", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of components grouped by kubernetes major.minor version."""

    @overload
    def __init__(
        self,
        *,
        kubernetes_version: str,
        os_type: Union[str, "_models.OSType"],
        name: Optional[str] = None,
        upgrades: Optional[list["_models.ManagedClusterPoolUpgradeProfileUpgradesItem"]] = None,
        components_by_releases: Optional[list["_models.ComponentsByRelease"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterPoolUpgradeProfileUpgradesItem(_Model):  # pylint: disable=name-too-long
    """ManagedClusterPoolUpgradeProfileUpgradesItem.

    :ivar kubernetes_version: The Kubernetes version (major.minor.patch).
    :vartype kubernetes_version: str
    :ivar is_preview: Whether the Kubernetes version is currently in preview.
    :vartype is_preview: bool
    :ivar is_out_of_support: Whether the Kubernetes version is out of support.
    :vartype is_out_of_support: bool
    """

    kubernetes_version: Optional[str] = rest_field(
        name="kubernetesVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Kubernetes version (major.minor.patch)."""
    is_preview: Optional[bool] = rest_field(
        name="isPreview", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether the Kubernetes version is currently in preview."""
    is_out_of_support: Optional[bool] = rest_field(
        name="isOutOfSupport", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether the Kubernetes version is out of support."""

    @overload
    def __init__(
        self,
        *,
        kubernetes_version: Optional[str] = None,
        is_preview: Optional[bool] = None,
        is_out_of_support: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterProperties(_Model):
    """Properties of the managed cluster.

    :ivar provisioning_state: The current provisioning state.
    :vartype provisioning_state: str
    :ivar power_state: The Power State of the cluster.
    :vartype power_state: ~azure.mgmt.containerservice.models.PowerState
    :ivar creation_data: CreationData to be used to specify the source Snapshot ID if the cluster
     will be created/upgraded using a snapshot.
    :vartype creation_data: ~azure.mgmt.containerservice.models.CreationData
    :ivar max_agent_pools: The max number of agent pools for the managed cluster.
    :vartype max_agent_pools: int
    :ivar kubernetes_version: The version of Kubernetes specified by the user. Both patch version
     <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When
     <major.minor> is specified, the latest supported GA patch version is chosen automatically.
     Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x -> 1.14)
     will not trigger an upgrade, even if a newer patch version is available. When you upgrade a
     supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be
     performed sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x
     or 1.15.x -> 1.16.x are allowed, however 1.14.x -> 1.16.x is not allowed. See `upgrading an AKS
     cluster <https://docs.microsoft.com/azure/aks/upgrade-cluster>`_ for more details.
    :vartype kubernetes_version: str
    :ivar current_kubernetes_version: The version of Kubernetes the Managed Cluster is running. If
     kubernetesVersion was a fully specified version <major.minor.patch>, this field will be exactly
     equal to it. If kubernetesVersion was <major.minor>, this field will contain the full
     <major.minor.patch> version being used.
    :vartype current_kubernetes_version: str
    :ivar dns_prefix: The DNS prefix of the Managed Cluster. This cannot be updated once the
     Managed Cluster has been created.
    :vartype dns_prefix: str
    :ivar fqdn_subdomain: The FQDN subdomain of the private cluster with custom private dns zone.
     This cannot be updated once the Managed Cluster has been created.
    :vartype fqdn_subdomain: str
    :ivar fqdn: The FQDN of the master pool.
    :vartype fqdn: str
    :ivar private_fqdn: The FQDN of private cluster.
    :vartype private_fqdn: str
    :ivar azure_portal_fqdn: The special FQDN used by the Azure Portal to access the Managed
     Cluster. This FQDN is for use only by the Azure Portal and should not be used by other clients.
     The Azure Portal requires certain Cross-Origin Resource Sharing (CORS) headers to be sent in
     some responses, which Kubernetes APIServer doesn't handle by default. This special FQDN
     supports CORS, allowing the Azure Portal to function properly.
    :vartype azure_portal_fqdn: str
    :ivar agent_pool_profiles: The agent pool properties.
    :vartype agent_pool_profiles:
     list[~azure.mgmt.containerservice.models.ManagedClusterAgentPoolProfile]
    :ivar linux_profile: The profile for Linux VMs in the Managed Cluster.
    :vartype linux_profile: ~azure.mgmt.containerservice.models.ContainerServiceLinuxProfile
    :ivar windows_profile: The profile for Windows VMs in the Managed Cluster.
    :vartype windows_profile: ~azure.mgmt.containerservice.models.ManagedClusterWindowsProfile
    :ivar service_principal_profile: Information about a service principal identity for the cluster
     to use for manipulating Azure APIs.
    :vartype service_principal_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterServicePrincipalProfile
    :ivar addon_profiles: The profile of managed cluster add-on.
    :vartype addon_profiles: dict[str,
     ~azure.mgmt.containerservice.models.ManagedClusterAddonProfile]
    :ivar pod_identity_profile: The pod identity profile of the Managed Cluster. See `use AAD pod
     identity <https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity>`_ for more details on
     AAD pod identity integration.
    :vartype pod_identity_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterPodIdentityProfile
    :ivar oidc_issuer_profile: The OIDC issuer profile of the Managed Cluster.
    :vartype oidc_issuer_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterOIDCIssuerProfile
    :ivar node_resource_group: The name of the resource group containing agent pool nodes.
    :vartype node_resource_group: str
    :ivar node_resource_group_profile: Profile of the node resource group configuration.
    :vartype node_resource_group_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterNodeResourceGroupProfile
    :ivar enable_rbac: Whether to enable Kubernetes Role-Based Access Control.
    :vartype enable_rbac: bool
    :ivar support_plan: The support plan for the Managed Cluster. If unspecified, the default is
     'KubernetesOfficial'. Known values are: "KubernetesOfficial" and "AKSLongTermSupport".
    :vartype support_plan: str or ~azure.mgmt.containerservice.models.KubernetesSupportPlan
    :ivar enable_namespace_resources: Enable namespace as Azure resource. The default value is
     false. It can be enabled/disabled on creation and updating of the managed cluster. See
     `https://aka.ms/NamespaceARMResource <https://aka.ms/NamespaceARMResource>`_ for more details
     on Namespace as a ARM Resource.
    :vartype enable_namespace_resources: bool
    :ivar network_profile: The network configuration profile.
    :vartype network_profile: ~azure.mgmt.containerservice.models.ContainerServiceNetworkProfile
    :ivar aad_profile: The Azure Active Directory configuration.
    :vartype aad_profile: ~azure.mgmt.containerservice.models.ManagedClusterAADProfile
    :ivar auto_upgrade_profile: The auto upgrade configuration.
    :vartype auto_upgrade_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterAutoUpgradeProfile
    :ivar upgrade_settings: Settings for upgrading a cluster.
    :vartype upgrade_settings: ~azure.mgmt.containerservice.models.ClusterUpgradeSettings
    :ivar auto_scaler_profile: Parameters to be applied to the cluster-autoscaler when enabled.
    :vartype auto_scaler_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterPropertiesAutoScalerProfile
    :ivar api_server_access_profile: The access profile for managed cluster API server.
    :vartype api_server_access_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterAPIServerAccessProfile
    :ivar disk_encryption_set_id: The Resource ID of the disk encryption set to use for enabling
     encryption at rest. This is of the form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'.
    :vartype disk_encryption_set_id: str
    :ivar identity_profile: The user identity associated with the managed cluster. This identity
     will be used by the kubelet. Only one user assigned identity is allowed. The only accepted key
     is "kubeletidentity", with value of "resourceId":
     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}".
    :vartype identity_profile: dict[str, ~azure.mgmt.containerservice.models.UserAssignedIdentity]
    :ivar private_link_resources: Private link resources associated with the cluster.
    :vartype private_link_resources: list[~azure.mgmt.containerservice.models.PrivateLinkResource]
    :ivar disable_local_accounts: If local accounts should be disabled on the Managed Cluster. If
     set to true, getting static credentials will be disabled for this cluster. This must only be
     used on Managed Clusters that are AAD enabled. For more details see `disable local accounts
     <https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview>`_.
    :vartype disable_local_accounts: bool
    :ivar http_proxy_config: Configurations for provisioning the cluster with HTTP proxy servers.
    :vartype http_proxy_config: ~azure.mgmt.containerservice.models.ManagedClusterHTTPProxyConfig
    :ivar security_profile: Security profile for the managed cluster.
    :vartype security_profile: ~azure.mgmt.containerservice.models.ManagedClusterSecurityProfile
    :ivar storage_profile: Storage profile for the managed cluster.
    :vartype storage_profile: ~azure.mgmt.containerservice.models.ManagedClusterStorageProfile
    :ivar ingress_profile: Ingress profile for the managed cluster.
    :vartype ingress_profile: ~azure.mgmt.containerservice.models.ManagedClusterIngressProfile
    :ivar public_network_access: PublicNetworkAccess of the managedCluster. Allow or deny public
     network access for AKS. Known values are: "Enabled", "Disabled", and "SecuredByPerimeter".
    :vartype public_network_access: str or ~azure.mgmt.containerservice.models.PublicNetworkAccess
    :ivar workload_auto_scaler_profile: Workload Auto-scaler profile for the managed cluster.
    :vartype workload_auto_scaler_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterWorkloadAutoScalerProfile
    :ivar azure_monitor_profile: Azure Monitor addon profiles for monitoring the managed cluster.
    :vartype azure_monitor_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterAzureMonitorProfile
    :ivar service_mesh_profile: Service mesh profile for a managed cluster.
    :vartype service_mesh_profile: ~azure.mgmt.containerservice.models.ServiceMeshProfile
    :ivar resource_uid: The resourceUID uniquely identifies ManagedClusters that reuse ARM
     ResourceIds (i.e: create, delete, create sequence).
    :vartype resource_uid: str
    :ivar metrics_profile: Optional cluster metrics configuration.
    :vartype metrics_profile: ~azure.mgmt.containerservice.models.ManagedClusterMetricsProfile
    :ivar node_provisioning_profile: Node provisioning settings that apply to the whole cluster.
    :vartype node_provisioning_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterNodeProvisioningProfile
    :ivar bootstrap_profile: Profile of the cluster bootstrap configuration.
    :vartype bootstrap_profile: ~azure.mgmt.containerservice.models.ManagedClusterBootstrapProfile
    :ivar ai_toolchain_operator_profile: AI toolchain operator settings that apply to the whole
     cluster.
    :vartype ai_toolchain_operator_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterAIToolchainOperatorProfile
    :ivar scheduler_profile: Profile of the pod scheduler configuration.
    :vartype scheduler_profile: ~azure.mgmt.containerservice.models.SchedulerProfile
    :ivar hosted_system_profile: Settings for hosted system addons. For more information, see
     `https://aka.ms/aks/automatic/systemcomponents
     <https://aka.ms/aks/automatic/systemcomponents>`_.
    :vartype hosted_system_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterHostedSystemProfile
    :ivar status: Contains read-only information about the Managed Cluster.
    :vartype status: ~azure.mgmt.containerservice.models.ManagedClusterStatus
    """

    provisioning_state: Optional[str] = rest_field(name="provisioningState", visibility=["read"])
    """The current provisioning state."""
    power_state: Optional["_models.PowerState"] = rest_field(name="powerState", visibility=["read"])
    """The Power State of the cluster."""
    creation_data: Optional["_models.CreationData"] = rest_field(
        name="creationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """CreationData to be used to specify the source Snapshot ID if the cluster will be
     created/upgraded using a snapshot."""
    max_agent_pools: Optional[int] = rest_field(name="maxAgentPools", visibility=["read"])
    """The max number of agent pools for the managed cluster."""
    kubernetes_version: Optional[str] = rest_field(
        name="kubernetesVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The version of Kubernetes specified by the user. Both patch version <major.minor.patch> (e.g.
     1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the
     latest supported GA patch version is chosen automatically. Updating the cluster with the same
     <major.minor> once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even
     if a newer patch version is available. When you upgrade a supported AKS cluster, Kubernetes
     minor versions cannot be skipped. All upgrades must be performed sequentially by major version
     number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed, however
     1.14.x -> 1.16.x is not allowed. See `upgrading an AKS cluster
     <https://docs.microsoft.com/azure/aks/upgrade-cluster>`_ for more details."""
    current_kubernetes_version: Optional[str] = rest_field(name="currentKubernetesVersion", visibility=["read"])
    """The version of Kubernetes the Managed Cluster is running. If kubernetesVersion was a fully
     specified version <major.minor.patch>, this field will be exactly equal to it. If
     kubernetesVersion was <major.minor>, this field will contain the full <major.minor.patch>
     version being used."""
    dns_prefix: Optional[str] = rest_field(name="dnsPrefix", visibility=["read", "create", "update", "delete", "query"])
    """The DNS prefix of the Managed Cluster. This cannot be updated once the Managed Cluster has been
     created."""
    fqdn_subdomain: Optional[str] = rest_field(
        name="fqdnSubdomain", visibility=["read", "create", "update", "delete", "query"]
    )
    """The FQDN subdomain of the private cluster with custom private dns zone. This cannot be updated
     once the Managed Cluster has been created."""
    fqdn: Optional[str] = rest_field(visibility=["read"])
    """The FQDN of the master pool."""
    private_fqdn: Optional[str] = rest_field(name="privateFQDN", visibility=["read"])
    """The FQDN of private cluster."""
    azure_portal_fqdn: Optional[str] = rest_field(name="azurePortalFQDN", visibility=["read"])
    """The special FQDN used by the Azure Portal to access the Managed Cluster. This FQDN is for use
     only by the Azure Portal and should not be used by other clients. The Azure Portal requires
     certain Cross-Origin Resource Sharing (CORS) headers to be sent in some responses, which
     Kubernetes APIServer doesn't handle by default. This special FQDN supports CORS, allowing the
     Azure Portal to function properly."""
    agent_pool_profiles: Optional[list["_models.ManagedClusterAgentPoolProfile"]] = rest_field(
        name="agentPoolProfiles", visibility=["read", "create", "update", "delete", "query"]
    )
    """The agent pool properties."""
    linux_profile: Optional["_models.ContainerServiceLinuxProfile"] = rest_field(
        name="linuxProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The profile for Linux VMs in the Managed Cluster."""
    windows_profile: Optional["_models.ManagedClusterWindowsProfile"] = rest_field(
        name="windowsProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The profile for Windows VMs in the Managed Cluster."""
    service_principal_profile: Optional["_models.ManagedClusterServicePrincipalProfile"] = rest_field(
        name="servicePrincipalProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Information about a service principal identity for the cluster to use for manipulating Azure
     APIs."""
    addon_profiles: Optional[dict[str, "_models.ManagedClusterAddonProfile"]] = rest_field(
        name="addonProfiles", visibility=["read", "create", "update", "delete", "query"]
    )
    """The profile of managed cluster add-on."""
    pod_identity_profile: Optional["_models.ManagedClusterPodIdentityProfile"] = rest_field(
        name="podIdentityProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The pod identity profile of the Managed Cluster. See `use AAD pod identity
     <https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity>`_ for more details on AAD pod
     identity integration."""
    oidc_issuer_profile: Optional["_models.ManagedClusterOIDCIssuerProfile"] = rest_field(
        name="oidcIssuerProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The OIDC issuer profile of the Managed Cluster."""
    node_resource_group: Optional[str] = rest_field(
        name="nodeResourceGroup", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the resource group containing agent pool nodes."""
    node_resource_group_profile: Optional["_models.ManagedClusterNodeResourceGroupProfile"] = rest_field(
        name="nodeResourceGroupProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Profile of the node resource group configuration."""
    enable_rbac: Optional[bool] = rest_field(
        name="enableRBAC", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to enable Kubernetes Role-Based Access Control."""
    support_plan: Optional[Union[str, "_models.KubernetesSupportPlan"]] = rest_field(
        name="supportPlan", visibility=["read", "create", "update", "delete", "query"]
    )
    """The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.
     Known values are: \"KubernetesOfficial\" and \"AKSLongTermSupport\"."""
    enable_namespace_resources: Optional[bool] = rest_field(
        name="enableNamespaceResources", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable namespace as Azure resource. The default value is false. It can be enabled/disabled on
     creation and updating of the managed cluster. See `https://aka.ms/NamespaceARMResource
     <https://aka.ms/NamespaceARMResource>`_ for more details on Namespace as a ARM Resource."""
    network_profile: Optional["_models.ContainerServiceNetworkProfile"] = rest_field(
        name="networkProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The network configuration profile."""
    aad_profile: Optional["_models.ManagedClusterAADProfile"] = rest_field(
        name="aadProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Azure Active Directory configuration."""
    auto_upgrade_profile: Optional["_models.ManagedClusterAutoUpgradeProfile"] = rest_field(
        name="autoUpgradeProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The auto upgrade configuration."""
    upgrade_settings: Optional["_models.ClusterUpgradeSettings"] = rest_field(
        name="upgradeSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for upgrading a cluster."""
    auto_scaler_profile: Optional["_models.ManagedClusterPropertiesAutoScalerProfile"] = rest_field(
        name="autoScalerProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Parameters to be applied to the cluster-autoscaler when enabled."""
    api_server_access_profile: Optional["_models.ManagedClusterAPIServerAccessProfile"] = rest_field(
        name="apiServerAccessProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The access profile for managed cluster API server."""
    disk_encryption_set_id: Optional[str] = rest_field(
        name="diskEncryptionSetID", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Resource ID of the disk encryption set to use for enabling encryption at rest. This is of
     the form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'."""
    identity_profile: Optional[dict[str, "_models.UserAssignedIdentity"]] = rest_field(
        name="identityProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The user identity associated with the managed cluster. This identity will be used by the
     kubelet. Only one user assigned identity is allowed. The only accepted key is
     \"kubeletidentity\", with value of \"resourceId\":
     \"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}\"."""
    private_link_resources: Optional[list["_models.PrivateLinkResource"]] = rest_field(
        name="privateLinkResources", visibility=["read", "create", "update", "delete", "query"]
    )
    """Private link resources associated with the cluster."""
    disable_local_accounts: Optional[bool] = rest_field(
        name="disableLocalAccounts", visibility=["read", "create", "update", "delete", "query"]
    )
    """If local accounts should be disabled on the Managed Cluster. If set to true, getting static
     credentials will be disabled for this cluster. This must only be used on Managed Clusters that
     are AAD enabled. For more details see `disable local accounts
     <https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview>`_."""
    http_proxy_config: Optional["_models.ManagedClusterHTTPProxyConfig"] = rest_field(
        name="httpProxyConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """Configurations for provisioning the cluster with HTTP proxy servers."""
    security_profile: Optional["_models.ManagedClusterSecurityProfile"] = rest_field(
        name="securityProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Security profile for the managed cluster."""
    storage_profile: Optional["_models.ManagedClusterStorageProfile"] = rest_field(
        name="storageProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Storage profile for the managed cluster."""
    ingress_profile: Optional["_models.ManagedClusterIngressProfile"] = rest_field(
        name="ingressProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Ingress profile for the managed cluster."""
    public_network_access: Optional[Union[str, "_models.PublicNetworkAccess"]] = rest_field(
        name="publicNetworkAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """PublicNetworkAccess of the managedCluster. Allow or deny public network access for AKS. Known
     values are: \"Enabled\", \"Disabled\", and \"SecuredByPerimeter\"."""
    workload_auto_scaler_profile: Optional["_models.ManagedClusterWorkloadAutoScalerProfile"] = rest_field(
        name="workloadAutoScalerProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Workload Auto-scaler profile for the managed cluster."""
    azure_monitor_profile: Optional["_models.ManagedClusterAzureMonitorProfile"] = rest_field(
        name="azureMonitorProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure Monitor addon profiles for monitoring the managed cluster."""
    service_mesh_profile: Optional["_models.ServiceMeshProfile"] = rest_field(
        name="serviceMeshProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Service mesh profile for a managed cluster."""
    resource_uid: Optional[str] = rest_field(name="resourceUID", visibility=["read"])
    """The resourceUID uniquely identifies ManagedClusters that reuse ARM ResourceIds (i.e: create,
     delete, create sequence)."""
    metrics_profile: Optional["_models.ManagedClusterMetricsProfile"] = rest_field(
        name="metricsProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Optional cluster metrics configuration."""
    node_provisioning_profile: Optional["_models.ManagedClusterNodeProvisioningProfile"] = rest_field(
        name="nodeProvisioningProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Node provisioning settings that apply to the whole cluster."""
    bootstrap_profile: Optional["_models.ManagedClusterBootstrapProfile"] = rest_field(
        name="bootstrapProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Profile of the cluster bootstrap configuration."""
    ai_toolchain_operator_profile: Optional["_models.ManagedClusterAIToolchainOperatorProfile"] = rest_field(
        name="aiToolchainOperatorProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """AI toolchain operator settings that apply to the whole cluster."""
    scheduler_profile: Optional["_models.SchedulerProfile"] = rest_field(
        name="schedulerProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Profile of the pod scheduler configuration."""
    hosted_system_profile: Optional["_models.ManagedClusterHostedSystemProfile"] = rest_field(
        name="hostedSystemProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for hosted system addons. For more information, see
     `https://aka.ms/aks/automatic/systemcomponents
     <https://aka.ms/aks/automatic/systemcomponents>`_."""
    status: Optional["_models.ManagedClusterStatus"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains read-only information about the Managed Cluster."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        creation_data: Optional["_models.CreationData"] = None,
        kubernetes_version: Optional[str] = None,
        dns_prefix: Optional[str] = None,
        fqdn_subdomain: Optional[str] = None,
        agent_pool_profiles: Optional[list["_models.ManagedClusterAgentPoolProfile"]] = None,
        linux_profile: Optional["_models.ContainerServiceLinuxProfile"] = None,
        windows_profile: Optional["_models.ManagedClusterWindowsProfile"] = None,
        service_principal_profile: Optional["_models.ManagedClusterServicePrincipalProfile"] = None,
        addon_profiles: Optional[dict[str, "_models.ManagedClusterAddonProfile"]] = None,
        pod_identity_profile: Optional["_models.ManagedClusterPodIdentityProfile"] = None,
        oidc_issuer_profile: Optional["_models.ManagedClusterOIDCIssuerProfile"] = None,
        node_resource_group: Optional[str] = None,
        node_resource_group_profile: Optional["_models.ManagedClusterNodeResourceGroupProfile"] = None,
        enable_rbac: Optional[bool] = None,
        support_plan: Optional[Union[str, "_models.KubernetesSupportPlan"]] = None,
        enable_namespace_resources: Optional[bool] = None,
        network_profile: Optional["_models.ContainerServiceNetworkProfile"] = None,
        aad_profile: Optional["_models.ManagedClusterAADProfile"] = None,
        auto_upgrade_profile: Optional["_models.ManagedClusterAutoUpgradeProfile"] = None,
        upgrade_settings: Optional["_models.ClusterUpgradeSettings"] = None,
        auto_scaler_profile: Optional["_models.ManagedClusterPropertiesAutoScalerProfile"] = None,
        api_server_access_profile: Optional["_models.ManagedClusterAPIServerAccessProfile"] = None,
        disk_encryption_set_id: Optional[str] = None,
        identity_profile: Optional[dict[str, "_models.UserAssignedIdentity"]] = None,
        private_link_resources: Optional[list["_models.PrivateLinkResource"]] = None,
        disable_local_accounts: Optional[bool] = None,
        http_proxy_config: Optional["_models.ManagedClusterHTTPProxyConfig"] = None,
        security_profile: Optional["_models.ManagedClusterSecurityProfile"] = None,
        storage_profile: Optional["_models.ManagedClusterStorageProfile"] = None,
        ingress_profile: Optional["_models.ManagedClusterIngressProfile"] = None,
        public_network_access: Optional[Union[str, "_models.PublicNetworkAccess"]] = None,
        workload_auto_scaler_profile: Optional["_models.ManagedClusterWorkloadAutoScalerProfile"] = None,
        azure_monitor_profile: Optional["_models.ManagedClusterAzureMonitorProfile"] = None,
        service_mesh_profile: Optional["_models.ServiceMeshProfile"] = None,
        metrics_profile: Optional["_models.ManagedClusterMetricsProfile"] = None,
        node_provisioning_profile: Optional["_models.ManagedClusterNodeProvisioningProfile"] = None,
        bootstrap_profile: Optional["_models.ManagedClusterBootstrapProfile"] = None,
        ai_toolchain_operator_profile: Optional["_models.ManagedClusterAIToolchainOperatorProfile"] = None,
        scheduler_profile: Optional["_models.SchedulerProfile"] = None,
        hosted_system_profile: Optional["_models.ManagedClusterHostedSystemProfile"] = None,
        status: Optional["_models.ManagedClusterStatus"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterPropertiesAutoScalerProfile(_Model):  # pylint: disable=name-too-long
    """Parameters to be applied to the cluster-autoscaler when enabled.

    :ivar balance_similar_node_groups: Detects similar node pools and balances the number of nodes
     between them. Valid values are 'true' and 'false'.
    :vartype balance_similar_node_groups: str
    :ivar daemonset_eviction_for_empty_nodes: DaemonSet pods will be gracefully terminated from
     empty nodes. If set to true, all daemonset pods on empty nodes will be evicted before deletion
     of the node. If the daemonset pod cannot be evicted another node will be chosen for scaling. If
     set to false, the node will be deleted without ensuring that daemonset pods are deleted or
     evicted.
    :vartype daemonset_eviction_for_empty_nodes: bool
    :ivar daemonset_eviction_for_occupied_nodes: DaemonSet pods will be gracefully terminated from
     non-empty nodes. If set to true, all daemonset pods on occupied nodes will be evicted before
     deletion of the node. If the daemonset pod cannot be evicted another node will be chosen for
     scaling. If set to false, the node will be deleted without ensuring that daemonset pods are
     deleted or evicted.
    :vartype daemonset_eviction_for_occupied_nodes: bool
    :ivar ignore_daemonsets_utilization: Should CA ignore DaemonSet pods when calculating resource
     utilization for scaling down. If set to true, the resources used by daemonset will be taken
     into account when making scaling down decisions.
    :vartype ignore_daemonsets_utilization: bool
    :ivar expander: The expander to use when scaling up. If not specified, the default is 'random'.
     See `expanders
     <https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders>`_
     for more information. Known values are: "least-waste", "most-pods", "priority", and "random".
    :vartype expander: str or ~azure.mgmt.containerservice.models.Expander
    :ivar max_empty_bulk_delete: The maximum number of empty nodes that can be deleted at the same
     time. This must be a positive integer. The default is 10.
    :vartype max_empty_bulk_delete: str
    :ivar max_graceful_termination_sec: The maximum number of seconds the cluster autoscaler waits
     for pod termination when trying to scale down a node. The default is 600.
    :vartype max_graceful_termination_sec: str
    :ivar max_node_provision_time: The maximum time the autoscaler waits for a node to be
     provisioned. The default is '15m'. Values must be an integer followed by an 'm'. No unit of
     time other than minutes (m) is supported.
    :vartype max_node_provision_time: str
    :ivar max_total_unready_percentage: The maximum percentage of unready nodes in the cluster.
     After this percentage is exceeded, cluster autoscaler halts operations. The default is 45. The
     maximum is 100 and the minimum is 0.
    :vartype max_total_unready_percentage: str
    :ivar new_pod_scale_up_delay: Ignore unscheduled pods before they're a certain age. For
     scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler
     could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a
     certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for
     seconds, 'm' for minutes, 'h' for hours, etc).
    :vartype new_pod_scale_up_delay: str
    :ivar ok_total_unready_count: The number of allowed unready nodes, irrespective of
     max-total-unready-percentage. This must be an integer. The default is 3.
    :vartype ok_total_unready_count: str
    :ivar scan_interval: How often cluster is reevaluated for scale up or down. The default is
     '10'. Values must be an integer number of seconds.
    :vartype scan_interval: str
    :ivar scale_down_delay_after_add: How long after scale up that scale down evaluation resumes.
     The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than
     minutes (m) is supported.
    :vartype scale_down_delay_after_add: str
    :ivar scale_down_delay_after_delete: How long after node deletion that scale down evaluation
     resumes. The default is the scan-interval. Values must be an integer followed by an 'm'. No
     unit of time other than minutes (m) is supported.
    :vartype scale_down_delay_after_delete: str
    :ivar scale_down_delay_after_failure: How long after scale down failure that scale down
     evaluation resumes. The default is '3m'. Values must be an integer followed by an 'm'. No unit
     of time other than minutes (m) is supported.
    :vartype scale_down_delay_after_failure: str
    :ivar scale_down_unneeded_time: How long a node should be unneeded before it is eligible for
     scale down. The default is '10m'. Values must be an integer followed by an 'm'. No unit of time
     other than minutes (m) is supported.
    :vartype scale_down_unneeded_time: str
    :ivar scale_down_unready_time: How long an unready node should be unneeded before it is
     eligible for scale down. The default is '20m'. Values must be an integer followed by an 'm'. No
     unit of time other than minutes (m) is supported.
    :vartype scale_down_unready_time: str
    :ivar scale_down_utilization_threshold: Node utilization level, defined as sum of requested
     resources divided by capacity, below which a node can be considered for scale down. The default
     is '0.5'.
    :vartype scale_down_utilization_threshold: str
    :ivar skip_nodes_with_local_storage: If cluster autoscaler will skip deleting nodes with pods
     with local storage, for example, EmptyDir or HostPath. The default is true.
    :vartype skip_nodes_with_local_storage: str
    :ivar skip_nodes_with_system_pods: If cluster autoscaler will skip deleting nodes with pods
     from kube-system (except for DaemonSet or mirror pods). The default is true.
    :vartype skip_nodes_with_system_pods: str
    """

    balance_similar_node_groups: Optional[str] = rest_field(
        name="balance-similar-node-groups", visibility=["read", "create", "update", "delete", "query"]
    )
    """Detects similar node pools and balances the number of nodes between them. Valid values are
     'true' and 'false'."""
    daemonset_eviction_for_empty_nodes: Optional[bool] = rest_field(
        name="daemonset-eviction-for-empty-nodes", visibility=["read", "create", "update", "delete", "query"]
    )
    """DaemonSet pods will be gracefully terminated from empty nodes. If set to true, all daemonset
     pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot be
     evicted another node will be chosen for scaling. If set to false, the node will be deleted
     without ensuring that daemonset pods are deleted or evicted."""
    daemonset_eviction_for_occupied_nodes: Optional[bool] = rest_field(
        name="daemonset-eviction-for-occupied-nodes", visibility=["read", "create", "update", "delete", "query"]
    )
    """DaemonSet pods will be gracefully terminated from non-empty nodes. If set to true, all
     daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset
     pod cannot be evicted another node will be chosen for scaling. If set to false, the node will
     be deleted without ensuring that daemonset pods are deleted or evicted."""
    ignore_daemonsets_utilization: Optional[bool] = rest_field(
        name="ignore-daemonsets-utilization", visibility=["read", "create", "update", "delete", "query"]
    )
    """Should CA ignore DaemonSet pods when calculating resource utilization for scaling down. If set
     to true, the resources used by daemonset will be taken into account when making scaling down
     decisions."""
    expander: Optional[Union[str, "_models.Expander"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The expander to use when scaling up. If not specified, the default is 'random'. See `expanders
     <https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders>`_
     for more information. Known values are: \"least-waste\", \"most-pods\", \"priority\", and
     \"random\"."""
    max_empty_bulk_delete: Optional[str] = rest_field(
        name="max-empty-bulk-delete", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of empty nodes that can be deleted at the same time. This must be a positive
     integer. The default is 10."""
    max_graceful_termination_sec: Optional[str] = rest_field(
        name="max-graceful-termination-sec", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of seconds the cluster autoscaler waits for pod termination when trying to
     scale down a node. The default is 600."""
    max_node_provision_time: Optional[str] = rest_field(
        name="max-node-provision-time", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum time the autoscaler waits for a node to be provisioned. The default is '15m'.
     Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is
     supported."""
    max_total_unready_percentage: Optional[str] = rest_field(
        name="max-total-unready-percentage", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum percentage of unready nodes in the cluster. After this percentage is exceeded,
     cluster autoscaler halts operations. The default is 45. The maximum is 100 and the minimum is
     0."""
    new_pod_scale_up_delay: Optional[str] = rest_field(
        name="new-pod-scale-up-delay", visibility=["read", "create", "update", "delete", "query"]
    )
    """Ignore unscheduled pods before they're a certain age. For scenarios like burst/batch scale
     where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you
     can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'.
     Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours,
     etc)."""
    ok_total_unready_count: Optional[str] = rest_field(
        name="ok-total-unready-count", visibility=["read", "create", "update", "delete", "query"]
    )
    """The number of allowed unready nodes, irrespective of max-total-unready-percentage. This must be
     an integer. The default is 3."""
    scan_interval: Optional[str] = rest_field(
        name="scan-interval", visibility=["read", "create", "update", "delete", "query"]
    )
    """How often cluster is reevaluated for scale up or down. The default is '10'. Values must be an
     integer number of seconds."""
    scale_down_delay_after_add: Optional[str] = rest_field(
        name="scale-down-delay-after-add", visibility=["read", "create", "update", "delete", "query"]
    )
    """How long after scale up that scale down evaluation resumes. The default is '10m'. Values must
     be an integer followed by an 'm'. No unit of time other than minutes (m) is supported."""
    scale_down_delay_after_delete: Optional[str] = rest_field(
        name="scale-down-delay-after-delete", visibility=["read", "create", "update", "delete", "query"]
    )
    """How long after node deletion that scale down evaluation resumes. The default is the
     scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes
     (m) is supported."""
    scale_down_delay_after_failure: Optional[str] = rest_field(
        name="scale-down-delay-after-failure", visibility=["read", "create", "update", "delete", "query"]
    )
    """How long after scale down failure that scale down evaluation resumes. The default is '3m'.
     Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is
     supported."""
    scale_down_unneeded_time: Optional[str] = rest_field(
        name="scale-down-unneeded-time", visibility=["read", "create", "update", "delete", "query"]
    )
    """How long a node should be unneeded before it is eligible for scale down. The default is '10m'.
     Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is
     supported."""
    scale_down_unready_time: Optional[str] = rest_field(
        name="scale-down-unready-time", visibility=["read", "create", "update", "delete", "query"]
    )
    """How long an unready node should be unneeded before it is eligible for scale down. The default
     is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m)
     is supported."""
    scale_down_utilization_threshold: Optional[str] = rest_field(
        name="scale-down-utilization-threshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """Node utilization level, defined as sum of requested resources divided by capacity, below which
     a node can be considered for scale down. The default is '0.5'."""
    skip_nodes_with_local_storage: Optional[str] = rest_field(
        name="skip-nodes-with-local-storage", visibility=["read", "create", "update", "delete", "query"]
    )
    """If cluster autoscaler will skip deleting nodes with pods with local storage, for example,
     EmptyDir or HostPath. The default is true."""
    skip_nodes_with_system_pods: Optional[str] = rest_field(
        name="skip-nodes-with-system-pods", visibility=["read", "create", "update", "delete", "query"]
    )
    """If cluster autoscaler will skip deleting nodes with pods from kube-system (except for DaemonSet
     or mirror pods). The default is true."""

    @overload
    def __init__(
        self,
        *,
        balance_similar_node_groups: Optional[str] = None,
        daemonset_eviction_for_empty_nodes: Optional[bool] = None,
        daemonset_eviction_for_occupied_nodes: Optional[bool] = None,
        ignore_daemonsets_utilization: Optional[bool] = None,
        expander: Optional[Union[str, "_models.Expander"]] = None,
        max_empty_bulk_delete: Optional[str] = None,
        max_graceful_termination_sec: Optional[str] = None,
        max_node_provision_time: Optional[str] = None,
        max_total_unready_percentage: Optional[str] = None,
        new_pod_scale_up_delay: Optional[str] = None,
        ok_total_unready_count: Optional[str] = None,
        scan_interval: Optional[str] = None,
        scale_down_delay_after_add: Optional[str] = None,
        scale_down_delay_after_delete: Optional[str] = None,
        scale_down_delay_after_failure: Optional[str] = None,
        scale_down_unneeded_time: Optional[str] = None,
        scale_down_unready_time: Optional[str] = None,
        scale_down_utilization_threshold: Optional[str] = None,
        skip_nodes_with_local_storage: Optional[str] = None,
        skip_nodes_with_system_pods: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterPropertiesForSnapshot(_Model):
    """managed cluster properties for snapshot, these properties are read only.

    :ivar kubernetes_version: The current kubernetes version.
    :vartype kubernetes_version: str
    :ivar sku: The current managed cluster sku.
    :vartype sku: ~azure.mgmt.containerservice.models.ManagedClusterSKU
    :ivar enable_rbac: Whether the cluster has enabled Kubernetes Role-Based Access Control or not.
    :vartype enable_rbac: bool
    :ivar network_profile: The current network profile.
    :vartype network_profile: ~azure.mgmt.containerservice.models.NetworkProfileForSnapshot
    """

    kubernetes_version: Optional[str] = rest_field(
        name="kubernetesVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The current kubernetes version."""
    sku: Optional["_models.ManagedClusterSKU"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The current managed cluster sku."""
    enable_rbac: Optional[bool] = rest_field(
        name="enableRbac", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether the cluster has enabled Kubernetes Role-Based Access Control or not."""
    network_profile: Optional["_models.NetworkProfileForSnapshot"] = rest_field(
        name="networkProfile", visibility=["read"]
    )
    """The current network profile."""

    @overload
    def __init__(
        self,
        *,
        kubernetes_version: Optional[str] = None,
        sku: Optional["_models.ManagedClusterSKU"] = None,
        enable_rbac: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterSecurityProfile(_Model):
    """Security profile for the container service cluster.

    :ivar defender: Microsoft Defender settings for the security profile.
    :vartype defender: ~azure.mgmt.containerservice.models.ManagedClusterSecurityProfileDefender
    :ivar azure_key_vault_kms: Azure Key Vault `key management service
     <https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/>`_ settings for the security
     profile.
    :vartype azure_key_vault_kms: ~azure.mgmt.containerservice.models.AzureKeyVaultKms
    :ivar kubernetes_resource_object_encryption_profile: Encryption at rest of Kubernetes resource
     objects. More information on this can be found under
     `https://aka.ms/aks/kubernetesResourceObjectEncryption
     <https://aka.ms/aks/kubernetesResourceObjectEncryption>`_.
    :vartype kubernetes_resource_object_encryption_profile:
     ~azure.mgmt.containerservice.models.KubernetesResourceObjectEncryptionProfile
    :ivar workload_identity: Workload identity settings for the security profile. Workload identity
     enables Kubernetes applications to access Azure cloud resources securely with Azure AD. See
     `https://aka.ms/aks/wi <https://aka.ms/aks/wi>`_ for more details.
    :vartype workload_identity:
     ~azure.mgmt.containerservice.models.ManagedClusterSecurityProfileWorkloadIdentity
    :ivar image_cleaner: Image Cleaner settings for the security profile.
    :vartype image_cleaner:
     ~azure.mgmt.containerservice.models.ManagedClusterSecurityProfileImageCleaner
    :ivar image_integrity: Image integrity is a feature that works with Azure Policy to verify
     image integrity by signature. This will not have any effect unless Azure Policy is applied to
     enforce image signatures. See `https://aka.ms/aks/image-integrity
     <https://aka.ms/aks/image-integrity>`_ for how to use this feature via policy.
    :vartype image_integrity:
     ~azure.mgmt.containerservice.models.ManagedClusterSecurityProfileImageIntegrity
    :ivar node_restriction: `Node Restriction
     <https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction>`_
     settings for the security profile.
    :vartype node_restriction:
     ~azure.mgmt.containerservice.models.ManagedClusterSecurityProfileNodeRestriction
    :ivar custom_ca_trust_certificates: A list of up to 10 base64 encoded CAs that will be added to
     the trust store on all nodes in the cluster. For more information see `Custom CA Trust
     Certificates <https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority>`_.
    :vartype custom_ca_trust_certificates: list[bytes]
    """

    defender: Optional["_models.ManagedClusterSecurityProfileDefender"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Microsoft Defender settings for the security profile."""
    azure_key_vault_kms: Optional["_models.AzureKeyVaultKms"] = rest_field(
        name="azureKeyVaultKms", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure Key Vault `key management service
     <https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/>`_ settings for the security
     profile."""
    kubernetes_resource_object_encryption_profile: Optional["_models.KubernetesResourceObjectEncryptionProfile"] = (
        rest_field(
            name="kubernetesResourceObjectEncryptionProfile", visibility=["read", "create", "update", "delete", "query"]
        )
    )
    """Encryption at rest of Kubernetes resource objects. More information on this can be found under
     `https://aka.ms/aks/kubernetesResourceObjectEncryption
     <https://aka.ms/aks/kubernetesResourceObjectEncryption>`_."""
    workload_identity: Optional["_models.ManagedClusterSecurityProfileWorkloadIdentity"] = rest_field(
        name="workloadIdentity", visibility=["read", "create", "update", "delete", "query"]
    )
    """Workload identity settings for the security profile. Workload identity enables Kubernetes
     applications to access Azure cloud resources securely with Azure AD. See `https://aka.ms/aks/wi
     <https://aka.ms/aks/wi>`_ for more details."""
    image_cleaner: Optional["_models.ManagedClusterSecurityProfileImageCleaner"] = rest_field(
        name="imageCleaner", visibility=["read", "create", "update", "delete", "query"]
    )
    """Image Cleaner settings for the security profile."""
    image_integrity: Optional["_models.ManagedClusterSecurityProfileImageIntegrity"] = rest_field(
        name="imageIntegrity", visibility=["read", "create", "update", "delete", "query"]
    )
    """Image integrity is a feature that works with Azure Policy to verify image integrity by
     signature. This will not have any effect unless Azure Policy is applied to enforce image
     signatures. See `https://aka.ms/aks/image-integrity <https://aka.ms/aks/image-integrity>`_ for
     how to use this feature via policy."""
    node_restriction: Optional["_models.ManagedClusterSecurityProfileNodeRestriction"] = rest_field(
        name="nodeRestriction", visibility=["read", "create", "update", "delete", "query"]
    )
    """`Node Restriction
     <https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction>`_
     settings for the security profile."""
    custom_ca_trust_certificates: Optional[list[bytes]] = rest_field(
        name="customCATrustCertificates", visibility=["read", "create", "update", "delete", "query"], format="base64"
    )
    """A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in the
     cluster. For more information see `Custom CA Trust Certificates
     <https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority>`_."""

    @overload
    def __init__(
        self,
        *,
        defender: Optional["_models.ManagedClusterSecurityProfileDefender"] = None,
        azure_key_vault_kms: Optional["_models.AzureKeyVaultKms"] = None,
        kubernetes_resource_object_encryption_profile: Optional[
            "_models.KubernetesResourceObjectEncryptionProfile"
        ] = None,
        workload_identity: Optional["_models.ManagedClusterSecurityProfileWorkloadIdentity"] = None,
        image_cleaner: Optional["_models.ManagedClusterSecurityProfileImageCleaner"] = None,
        image_integrity: Optional["_models.ManagedClusterSecurityProfileImageIntegrity"] = None,
        node_restriction: Optional["_models.ManagedClusterSecurityProfileNodeRestriction"] = None,
        custom_ca_trust_certificates: Optional[list[bytes]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterSecurityProfileDefender(_Model):
    """Microsoft Defender settings for the security profile.

    :ivar log_analytics_workspace_resource_id: Resource ID of the Log Analytics workspace to be
     associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required
     and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
     empty.
    :vartype log_analytics_workspace_resource_id: str
    :ivar security_monitoring: Microsoft Defender threat detection for Cloud settings for the
     security profile.
    :vartype security_monitoring:
     ~azure.mgmt.containerservice.models.ManagedClusterSecurityProfileDefenderSecurityMonitoring
    :ivar security_gating: Microsoft Defender settings for security gating, validates container
     images eligibility for deployment based on Defender for Containers security findings. Using
     Admission Controller, it either audits or prevents the deployment of images that do not meet
     security standards.
    :vartype security_gating:
     ~azure.mgmt.containerservice.models.ManagedClusterSecurityProfileDefenderSecurityGating
    """

    log_analytics_workspace_resource_id: Optional[str] = rest_field(
        name="logAnalyticsWorkspaceResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When
     Microsoft Defender is enabled, this field is required and must be a valid workspace resource
     ID. When Microsoft Defender is disabled, leave the field empty."""
    security_monitoring: Optional["_models.ManagedClusterSecurityProfileDefenderSecurityMonitoring"] = rest_field(
        name="securityMonitoring", visibility=["read", "create", "update", "delete", "query"]
    )
    """Microsoft Defender threat detection for Cloud settings for the security profile."""
    security_gating: Optional["_models.ManagedClusterSecurityProfileDefenderSecurityGating"] = rest_field(
        name="securityGating", visibility=["read", "create", "update", "delete", "query"]
    )
    """Microsoft Defender settings for security gating, validates container images eligibility for
     deployment based on Defender for Containers security findings. Using Admission Controller, it
     either audits or prevents the deployment of images that do not meet security standards."""

    @overload
    def __init__(
        self,
        *,
        log_analytics_workspace_resource_id: Optional[str] = None,
        security_monitoring: Optional["_models.ManagedClusterSecurityProfileDefenderSecurityMonitoring"] = None,
        security_gating: Optional["_models.ManagedClusterSecurityProfileDefenderSecurityGating"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterSecurityProfileDefenderSecurityGating(_Model):  # pylint: disable=name-too-long
    """Microsoft Defender settings for security gating, validates container images eligibility for
    deployment based on Defender for Containers security findings. Using Admission Controller, it
    either audits or prevents the deployment of images that do not meet security standards.

    :ivar enabled: Whether to enable Defender security gating. When enabled, the gating feature
     will scan container images and audit or block the deployment of images that do not meet
     security standards according to the configured security rules.
    :vartype enabled: bool
    :ivar identities: List of identities that the admission controller will make use of in order to
     pull security artifacts from the registry. These are the same identities used by the cluster to
     pull container images. Each identity provided should have federated identity credential
     attached to it.
    :vartype identities:
     list[~azure.mgmt.containerservice.models.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem]
    :ivar allow_secret_access: In use only while registry access granted by secret rather than
     managed identity. Set whether to grant the Defender gating agent access to the cluster's
     secrets for pulling images from registries. If secret access is denied and the registry
     requires pull secrets, the add-on will not perform any image validation. Default value is
     false.
    :vartype allow_secret_access: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable Defender security gating. When enabled, the gating feature will scan
     container images and audit or block the deployment of images that do not meet security
     standards according to the configured security rules."""
    identities: Optional[list["_models.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem"]] = (
        rest_field(visibility=["read", "create", "update", "delete", "query"])
    )
    """List of identities that the admission controller will make use of in order to pull security
     artifacts from the registry. These are the same identities used by the cluster to pull
     container images. Each identity provided should have federated identity credential attached to
     it."""
    allow_secret_access: Optional[bool] = rest_field(
        name="allowSecretAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """In use only while registry access granted by secret rather than managed identity. Set whether
     to grant the Defender gating agent access to the cluster's secrets for pulling images from
     registries. If secret access is denied and the registry requires pull secrets, the add-on will
     not perform any image validation. Default value is false."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        identities: Optional[list["_models.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem"]] = None,
        allow_secret_access: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem(_Model):  # pylint: disable=name-too-long
    """ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem.

    :ivar azure_container_registry: The container registry for which the identity will be used; the
     identity specified here should have a federated identity credential attached to it.
    :vartype azure_container_registry: str
    :ivar identity: The identity object used to access the registry.
    :vartype identity: ~azure.mgmt.containerservice.models.UserAssignedIdentity
    """

    azure_container_registry: Optional[str] = rest_field(
        name="azureContainerRegistry", visibility=["read", "create", "update", "delete", "query"]
    )
    """The container registry for which the identity will be used; the identity specified here should
     have a federated identity credential attached to it."""
    identity: Optional["_models.UserAssignedIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The identity object used to access the registry."""

    @overload
    def __init__(
        self,
        *,
        azure_container_registry: Optional[str] = None,
        identity: Optional["_models.UserAssignedIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterSecurityProfileDefenderSecurityMonitoring(_Model):  # pylint: disable=name-too-long
    """Microsoft Defender settings for the security profile threat detection.

    :ivar enabled: Whether to enable Defender threat detection.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable Defender threat detection."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterSecurityProfileImageCleaner(_Model):  # pylint: disable=name-too-long
    """Image Cleaner removes unused images from nodes, freeing up disk space and helping to reduce
    attack surface area. Here are settings for the security profile.

    :ivar enabled: Whether to enable Image Cleaner on AKS cluster.
    :vartype enabled: bool
    :ivar interval_hours: Image Cleaner scanning interval in hours.
    :vartype interval_hours: int
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable Image Cleaner on AKS cluster."""
    interval_hours: Optional[int] = rest_field(
        name="intervalHours", visibility=["read", "create", "update", "delete", "query"]
    )
    """Image Cleaner scanning interval in hours."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        interval_hours: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterSecurityProfileImageIntegrity(_Model):  # pylint: disable=name-too-long
    """Image integrity related settings for the security profile.

    :ivar enabled: Whether to enable image integrity. The default value is false.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable image integrity. The default value is false."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterSecurityProfileNodeRestriction(_Model):  # pylint: disable=name-too-long
    """Node Restriction settings for the security profile.

    :ivar enabled: Whether to enable Node Restriction.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable Node Restriction."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterSecurityProfileWorkloadIdentity(_Model):  # pylint: disable=name-too-long
    """Workload identity settings for the security profile.

    :ivar enabled: Whether to enable workload identity.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable workload identity."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterServicePrincipalProfile(_Model):
    """Information about a service principal identity for the cluster to use for manipulating Azure
    APIs.

    :ivar client_id: The ID for the service principal. Required.
    :vartype client_id: str
    :ivar secret: The secret password associated with the service principal in plain text.
    :vartype secret: str
    """

    client_id: str = rest_field(name="clientId", visibility=["read", "create", "update", "delete", "query"])
    """The ID for the service principal. Required."""
    secret: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The secret password associated with the service principal in plain text."""

    @overload
    def __init__(
        self,
        *,
        client_id: str,
        secret: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterSKU(_Model):
    """The SKU of a Managed Cluster.

    :ivar name: The name of a managed cluster SKU. Known values are: "Base" and "Automatic".
    :vartype name: str or ~azure.mgmt.containerservice.models.ManagedClusterSKUName
    :ivar tier: The tier of a managed cluster SKU. If not specified, the default is 'Free'. See
     `AKS Pricing Tier <https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers>`_ for
     more details. Known values are: "Premium", "Standard", and "Free".
    :vartype tier: str or ~azure.mgmt.containerservice.models.ManagedClusterSKUTier
    """

    name: Optional[Union[str, "_models.ManagedClusterSKUName"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of a managed cluster SKU. Known values are: \"Base\" and \"Automatic\"."""
    tier: Optional[Union[str, "_models.ManagedClusterSKUTier"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The tier of a managed cluster SKU. If not specified, the default is 'Free'. See `AKS Pricing
     Tier <https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers>`_ for more details.
     Known values are: \"Premium\", \"Standard\", and \"Free\"."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[Union[str, "_models.ManagedClusterSKUName"]] = None,
        tier: Optional[Union[str, "_models.ManagedClusterSKUTier"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterSnapshot(TrackedResource):
    """A managed cluster snapshot resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: Properties of a managed cluster snapshot.
    :vartype properties: ~azure.mgmt.containerservice.models.ManagedClusterSnapshotProperties
    """

    properties: Optional["_models.ManagedClusterSnapshotProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of a managed cluster snapshot."""

    __flattened_items = ["creation_data", "snapshot_type", "managed_cluster_properties_read_only"]

    @overload
    def __init__(
        self,
        *,
        location: str,
        tags: Optional[dict[str, str]] = None,
        properties: Optional["_models.ManagedClusterSnapshotProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ManagedClusterSnapshotProperties(_Model):
    """Properties for a managed cluster snapshot.

    :ivar creation_data: CreationData to be used to specify the source resource ID to create this
     snapshot.
    :vartype creation_data: ~azure.mgmt.containerservice.models.CreationData
    :ivar snapshot_type: The type of a snapshot. The default is NodePool. Known values are:
     "NodePool" and "ManagedCluster".
    :vartype snapshot_type: str or ~azure.mgmt.containerservice.models.SnapshotType
    :ivar managed_cluster_properties_read_only: What the properties will be showed when getting
     managed cluster snapshot. Those properties are read-only.
    :vartype managed_cluster_properties_read_only:
     ~azure.mgmt.containerservice.models.ManagedClusterPropertiesForSnapshot
    """

    creation_data: Optional["_models.CreationData"] = rest_field(
        name="creationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """CreationData to be used to specify the source resource ID to create this snapshot."""
    snapshot_type: Optional[Union[str, "_models.SnapshotType"]] = rest_field(
        name="snapshotType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of a snapshot. The default is NodePool. Known values are: \"NodePool\" and
     \"ManagedCluster\"."""
    managed_cluster_properties_read_only: Optional["_models.ManagedClusterPropertiesForSnapshot"] = rest_field(
        name="managedClusterPropertiesReadOnly", visibility=["read"]
    )
    """What the properties will be showed when getting managed cluster snapshot. Those properties are
     read-only."""

    @overload
    def __init__(
        self,
        *,
        creation_data: Optional["_models.CreationData"] = None,
        snapshot_type: Optional[Union[str, "_models.SnapshotType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterStaticEgressGatewayProfile(_Model):
    """The Static Egress Gateway addon configuration for the cluster.

    :ivar enabled: Enable Static Egress Gateway addon. Indicates if Static Egress Gateway addon is
     enabled or not.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Enable Static Egress Gateway addon. Indicates if Static Egress Gateway addon is enabled or not."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterStatus(_Model):
    """Contains read-only information about the Managed Cluster.

    :ivar provisioning_error: The error details information of the managed cluster. Preserves the
     detailed info of failure. If there was no error, this field is omitted.
    :vartype provisioning_error: ~azure.mgmt.containerservice.models.ErrorDetail
    """

    provisioning_error: Optional["_models.ErrorDetail"] = rest_field(name="provisioningError", visibility=["read"])
    """The error details information of the managed cluster. Preserves the detailed info of failure.
     If there was no error, this field is omitted."""


class ManagedClusterStorageProfile(_Model):
    """Storage profile for the container service cluster.

    :ivar disk_csi_driver: AzureDisk CSI Driver settings for the storage profile.
    :vartype disk_csi_driver:
     ~azure.mgmt.containerservice.models.ManagedClusterStorageProfileDiskCSIDriver
    :ivar file_csi_driver: AzureFile CSI Driver settings for the storage profile.
    :vartype file_csi_driver:
     ~azure.mgmt.containerservice.models.ManagedClusterStorageProfileFileCSIDriver
    :ivar snapshot_controller: Snapshot Controller settings for the storage profile.
    :vartype snapshot_controller:
     ~azure.mgmt.containerservice.models.ManagedClusterStorageProfileSnapshotController
    :ivar blob_csi_driver: AzureBlob CSI Driver settings for the storage profile.
    :vartype blob_csi_driver:
     ~azure.mgmt.containerservice.models.ManagedClusterStorageProfileBlobCSIDriver
    """

    disk_csi_driver: Optional["_models.ManagedClusterStorageProfileDiskCSIDriver"] = rest_field(
        name="diskCSIDriver", visibility=["read", "create", "update", "delete", "query"]
    )
    """AzureDisk CSI Driver settings for the storage profile."""
    file_csi_driver: Optional["_models.ManagedClusterStorageProfileFileCSIDriver"] = rest_field(
        name="fileCSIDriver", visibility=["read", "create", "update", "delete", "query"]
    )
    """AzureFile CSI Driver settings for the storage profile."""
    snapshot_controller: Optional["_models.ManagedClusterStorageProfileSnapshotController"] = rest_field(
        name="snapshotController", visibility=["read", "create", "update", "delete", "query"]
    )
    """Snapshot Controller settings for the storage profile."""
    blob_csi_driver: Optional["_models.ManagedClusterStorageProfileBlobCSIDriver"] = rest_field(
        name="blobCSIDriver", visibility=["read", "create", "update", "delete", "query"]
    )
    """AzureBlob CSI Driver settings for the storage profile."""

    @overload
    def __init__(
        self,
        *,
        disk_csi_driver: Optional["_models.ManagedClusterStorageProfileDiskCSIDriver"] = None,
        file_csi_driver: Optional["_models.ManagedClusterStorageProfileFileCSIDriver"] = None,
        snapshot_controller: Optional["_models.ManagedClusterStorageProfileSnapshotController"] = None,
        blob_csi_driver: Optional["_models.ManagedClusterStorageProfileBlobCSIDriver"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterStorageProfileBlobCSIDriver(_Model):  # pylint: disable=name-too-long
    """AzureBlob CSI Driver settings for the storage profile.

    :ivar enabled: Whether to enable AzureBlob CSI Driver. The default value is false.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable AzureBlob CSI Driver. The default value is false."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterStorageProfileDiskCSIDriver(_Model):  # pylint: disable=name-too-long
    """AzureDisk CSI Driver settings for the storage profile.

    :ivar enabled: Whether to enable AzureDisk CSI Driver. The default value is true.
    :vartype enabled: bool
    :ivar version: The version of AzureDisk CSI Driver. The default value is v1.
    :vartype version: str
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable AzureDisk CSI Driver. The default value is true."""
    version: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The version of AzureDisk CSI Driver. The default value is v1."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterStorageProfileFileCSIDriver(_Model):  # pylint: disable=name-too-long
    """AzureFile CSI Driver settings for the storage profile.

    :ivar enabled: Whether to enable AzureFile CSI Driver. The default value is true.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable AzureFile CSI Driver. The default value is true."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterStorageProfileSnapshotController(_Model):  # pylint: disable=name-too-long
    """Snapshot Controller settings for the storage profile.

    :ivar enabled: Whether to enable Snapshot Controller. The default value is true.
    :vartype enabled: bool
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable Snapshot Controller. The default value is true."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterUpgradeProfile(ProxyResource):
    """The list of available upgrades for compute pools.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: The properties of the upgrade profile. Required.
    :vartype properties: ~azure.mgmt.containerservice.models.ManagedClusterUpgradeProfileProperties
    """

    properties: "_models.ManagedClusterUpgradeProfileProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the upgrade profile. Required."""

    __flattened_items = ["control_plane_profile", "agent_pool_profiles"]

    @overload
    def __init__(
        self,
        *,
        properties: "_models.ManagedClusterUpgradeProfileProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ManagedClusterUpgradeProfileProperties(_Model):
    """Control plane and agent pool upgrade profiles.

    :ivar control_plane_profile: The list of available upgrade versions for the control plane.
     Required.
    :vartype control_plane_profile:
     ~azure.mgmt.containerservice.models.ManagedClusterPoolUpgradeProfile
    :ivar agent_pool_profiles: The list of available upgrade versions for agent pools. Required.
    :vartype agent_pool_profiles:
     list[~azure.mgmt.containerservice.models.ManagedClusterPoolUpgradeProfile]
    """

    control_plane_profile: "_models.ManagedClusterPoolUpgradeProfile" = rest_field(
        name="controlPlaneProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of available upgrade versions for the control plane. Required."""
    agent_pool_profiles: list["_models.ManagedClusterPoolUpgradeProfile"] = rest_field(
        name="agentPoolProfiles", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of available upgrade versions for agent pools. Required."""

    @overload
    def __init__(
        self,
        *,
        control_plane_profile: "_models.ManagedClusterPoolUpgradeProfile",
        agent_pool_profiles: list["_models.ManagedClusterPoolUpgradeProfile"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterWindowsProfile(_Model):
    """Profile for Windows VMs in the managed cluster.

    :ivar admin_username: Specifies the name of the administrator account. <br><br>
     **Restriction:** Cannot end in "." <br><br> **Disallowed values:** "administrator", "admin",
     "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser",
     "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
     "server", "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
     <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters. Required.
    :vartype admin_username: str
    :ivar admin_password: Specifies the password of the administrator account. <br><br>
     **Minimum-length:** 8 characters <br><br> **Max-length:** 123 characters <br><br> **Complexity
     requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters
     <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\\W_])
     <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word",
     "pass@word1", "Password!", "Password1", "Password22", "iloveyou!".
    :vartype admin_password: str
    :ivar license_type: The license type to use for Windows VMs. See `Azure Hybrid User Benefits
     <https://azure.microsoft.com/pricing/hybrid-benefit/faq/>`_ for more details. Known values are:
     "None" and "Windows_Server".
    :vartype license_type: str or ~azure.mgmt.containerservice.models.LicenseType
    :ivar enable_csi_proxy: Whether to enable CSI proxy. For more details on CSI proxy, see the
     `CSI proxy GitHub repo <https://github.com/kubernetes-csi/csi-proxy>`_.
    :vartype enable_csi_proxy: bool
    :ivar gmsa_profile: The Windows gMSA Profile in the Managed Cluster.
    :vartype gmsa_profile: ~azure.mgmt.containerservice.models.WindowsGmsaProfile
    """

    admin_username: str = rest_field(name="adminUsername", visibility=["read", "create", "update", "delete", "query"])
    """Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in \".\"
     <br><br> **Disallowed values:** \"administrator\", \"admin\", \"user\", \"user1\", \"test\",
     \"user2\", \"test1\", \"user3\", \"admin1\", \"1\", \"123\", \"a\", \"actuser\", \"adm\",
     \"admin2\", \"aspnet\", \"backup\", \"console\", \"david\", \"guest\", \"john\", \"owner\",
     \"root\", \"server\", \"sql\", \"support\", \"support_388945a0\", \"sys\", \"test2\",
     \"test3\", \"user4\", \"user5\". <br><br> **Minimum-length:** 1 character <br><br>
     **Max-length:** 20 characters. Required."""
    admin_password: Optional[str] = rest_field(
        name="adminPassword", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters
     <br><br> **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out of 4
     conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br>
     Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:**
     \"abc@123\", \"P@$$w0rd\", \"P@ssw0rd\", \"P@ssword123\", \"Pa$$word\", \"pass@word1\",
     \"Password!\", \"Password1\", \"Password22\", \"iloveyou!\"."""
    license_type: Optional[Union[str, "_models.LicenseType"]] = rest_field(
        name="licenseType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The license type to use for Windows VMs. See `Azure Hybrid User Benefits
     <https://azure.microsoft.com/pricing/hybrid-benefit/faq/>`_ for more details. Known values are:
     \"None\" and \"Windows_Server\"."""
    enable_csi_proxy: Optional[bool] = rest_field(
        name="enableCSIProxy", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to enable CSI proxy. For more details on CSI proxy, see the `CSI proxy GitHub repo
     <https://github.com/kubernetes-csi/csi-proxy>`_."""
    gmsa_profile: Optional["_models.WindowsGmsaProfile"] = rest_field(
        name="gmsaProfile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Windows gMSA Profile in the Managed Cluster."""

    @overload
    def __init__(
        self,
        *,
        admin_username: str,
        admin_password: Optional[str] = None,
        license_type: Optional[Union[str, "_models.LicenseType"]] = None,
        enable_csi_proxy: Optional[bool] = None,
        gmsa_profile: Optional["_models.WindowsGmsaProfile"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterWorkloadAutoScalerProfile(_Model):
    """Workload Auto-scaler profile for the managed cluster.

    :ivar keda: KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler
     profile.
    :vartype keda: ~azure.mgmt.containerservice.models.ManagedClusterWorkloadAutoScalerProfileKeda
    :ivar vertical_pod_autoscaler: VPA (Vertical Pod Autoscaler) settings for the workload
     auto-scaler profile.
    :vartype vertical_pod_autoscaler:
     ~azure.mgmt.containerservice.models.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler
    """

    keda: Optional["_models.ManagedClusterWorkloadAutoScalerProfileKeda"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile."""
    vertical_pod_autoscaler: Optional["_models.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler"] = (
        rest_field(name="verticalPodAutoscaler", visibility=["read", "create", "update", "delete", "query"])
    )
    """VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile."""

    @overload
    def __init__(
        self,
        *,
        keda: Optional["_models.ManagedClusterWorkloadAutoScalerProfileKeda"] = None,
        vertical_pod_autoscaler: Optional[
            "_models.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler"
        ] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterWorkloadAutoScalerProfileKeda(_Model):  # pylint: disable=name-too-long
    """KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.

    :ivar enabled: Whether to enable KEDA. Required.
    :vartype enabled: bool
    """

    enabled: bool = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable KEDA. Required."""

    @overload
    def __init__(
        self,
        *,
        enabled: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler(_Model):  # pylint: disable=name-too-long
    """VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile.

    :ivar enabled: Whether to enable VPA. Default value is false. Required.
    :vartype enabled: bool
    :ivar addon_autoscaling: Whether VPA add-on is enabled and configured to scale AKS-managed
     add-ons. Known values are: "Enabled" and "Disabled".
    :vartype addon_autoscaling: str or ~azure.mgmt.containerservice.models.AddonAutoscaling
    """

    enabled: bool = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable VPA. Default value is false. Required."""
    addon_autoscaling: Optional[Union[str, "_models.AddonAutoscaling"]] = rest_field(
        name="addonAutoscaling", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether VPA add-on is enabled and configured to scale AKS-managed add-ons. Known values are:
     \"Enabled\" and \"Disabled\"."""

    @overload
    def __init__(
        self,
        *,
        enabled: bool,
        addon_autoscaling: Optional[Union[str, "_models.AddonAutoscaling"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedNamespace(Resource):
    """Namespace managed by ARM.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: Properties of a namespace.
    :vartype properties: ~azure.mgmt.containerservice.models.NamespaceProperties
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives.
    :vartype location: str
    :ivar e_tag: If eTag is provided in the response body, it may also be provided as a header per
     the normal etag convention.  Entity tags are used for comparing two or more entities from the
     same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match
     (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.
    :vartype e_tag: str
    """

    properties: Optional["_models.NamespaceProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of a namespace."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""
    location: Optional[str] = rest_field(visibility=["read", "create"])
    """The geo-location where the resource lives."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read"])
    """If eTag is provided in the response body, it may also be provided as a header per the normal
     etag convention.  Entity tags are used for comparing two or more entities from the same
     requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section
     14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.NamespaceProperties"] = None,
        tags: Optional[dict[str, str]] = None,
        location: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedServiceIdentityUserAssignedIdentitiesValue(_Model):  # pylint: disable=name-too-long
    """ManagedServiceIdentityUserAssignedIdentitiesValue.

    :ivar principal_id: The principal id of user assigned identity.
    :vartype principal_id: str
    :ivar client_id: The client id of user assigned identity.
    :vartype client_id: str
    """

    principal_id: Optional[str] = rest_field(name="principalId", visibility=["read"])
    """The principal id of user assigned identity."""
    client_id: Optional[str] = rest_field(name="clientId", visibility=["read"])
    """The client id of user assigned identity."""


class ManualScaleProfile(_Model):
    """Specifications on number of machines.

    :ivar size: VM size that AKS will use when creating and scaling e.g. 'Standard_E4s_v3',
     'Standard_E16s_v3' or 'Standard_D16s_v5'.
    :vartype size: str
    :ivar count: Number of nodes.
    :vartype count: int
    """

    size: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """VM size that AKS will use when creating and scaling e.g. 'Standard_E4s_v3', 'Standard_E16s_v3'
     or 'Standard_D16s_v5'."""
    count: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Number of nodes."""

    @overload
    def __init__(
        self,
        *,
        size: Optional[str] = None,
        count: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MeshMembership(ProxyResource):
    """Mesh membership of a managed cluster.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: Mesh membership properties of a managed cluster.
    :vartype properties: ~azure.mgmt.containerservice.models.MeshMembershipProperties
    :ivar managed_by: The fully qualified resource ID of the resource that manages this resource.
     Indicates if this resource is managed by another Azure resource. If this is present, complete
     mode deployment will not delete the resource if it is removed from the template since it is
     managed by another resource.
    :vartype managed_by: str
    :ivar e_tag: If eTag is provided in the response body, it may also be provided as a header per
     the normal etag convention.  Entity tags are used for comparing two or more entities from the
     same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match
     (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.
    :vartype e_tag: str
    """

    properties: Optional["_models.MeshMembershipProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Mesh membership properties of a managed cluster."""
    managed_by: Optional[str] = rest_field(name="managedBy", visibility=["read", "create", "update"])
    """The fully qualified resource ID of the resource that manages this resource. Indicates if this
     resource is managed by another Azure resource. If this is present, complete mode deployment
     will not delete the resource if it is removed from the template since it is managed by another
     resource."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read"])
    """If eTag is provided in the response body, it may also be provided as a header per the normal
     etag convention.  Entity tags are used for comparing two or more entities from the same
     requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section
     14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.MeshMembershipProperties"] = None,
        managed_by: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MeshMembershipProperties(_Model):
    """Mesh membership properties of a managed cluster.

    :ivar provisioning_state: The current provisioning state of the Mesh Membership. Known values
     are: "Canceled", "Creating", "Deleting", "Failed", "Succeeded", and "Updating".
    :vartype provisioning_state: str or
     ~azure.mgmt.containerservice.models.MeshMembershipProvisioningState
    :ivar managed_mesh_id: The ARM resource id for the managed mesh member. This is of the form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AppLink/applinks/{appLinkName}/appLinkMembers/{appLinkMemberName}'.
     Visit `https://aka.ms/applink <https://aka.ms/applink>`_ for more information. Required.
    :vartype managed_mesh_id: str
    """

    provisioning_state: Optional[Union[str, "_models.MeshMembershipProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The current provisioning state of the Mesh Membership. Known values are: \"Canceled\",
     \"Creating\", \"Deleting\", \"Failed\", \"Succeeded\", and \"Updating\"."""
    managed_mesh_id: str = rest_field(name="managedMeshID", visibility=["read", "create", "update", "delete", "query"])
    """The ARM resource id for the managed mesh member. This is of the form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AppLink/applinks/{appLinkName}/appLinkMembers/{appLinkMemberName}'.
     Visit `https://aka.ms/applink <https://aka.ms/applink>`_ for more information. Required."""

    @overload
    def __init__(
        self,
        *,
        managed_mesh_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MeshRevision(_Model):
    """Holds information on upgrades and compatibility for given major.minor mesh release.

    :ivar revision: The revision of the mesh release.
    :vartype revision: str
    :ivar upgrades: List of revisions available for upgrade of a specific mesh revision.
    :vartype upgrades: list[str]
    :ivar compatible_with: List of items this revision of service mesh is compatible with, and
     their associated versions.
    :vartype compatible_with: list[~azure.mgmt.containerservice.models.CompatibleVersions]
    """

    revision: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The revision of the mesh release."""
    upgrades: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """List of revisions available for upgrade of a specific mesh revision."""
    compatible_with: Optional[list["_models.CompatibleVersions"]] = rest_field(
        name="compatibleWith", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of items this revision of service mesh is compatible with, and their associated versions."""

    @overload
    def __init__(
        self,
        *,
        revision: Optional[str] = None,
        upgrades: Optional[list[str]] = None,
        compatible_with: Optional[list["_models.CompatibleVersions"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MeshRevisionProfile(ProxyResource):
    """Mesh revision profile for a mesh.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: Mesh revision profile properties for a mesh.
    :vartype properties: ~azure.mgmt.containerservice.models.MeshRevisionProfileProperties
    """

    properties: Optional["_models.MeshRevisionProfileProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Mesh revision profile properties for a mesh."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.MeshRevisionProfileProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MeshRevisionProfileProperties(_Model):
    """Mesh revision profile properties for a mesh.

    :ivar mesh_revisions:
    :vartype mesh_revisions: list[~azure.mgmt.containerservice.models.MeshRevision]
    """

    mesh_revisions: Optional[list["_models.MeshRevision"]] = rest_field(
        name="meshRevisions", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        mesh_revisions: Optional[list["_models.MeshRevision"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MeshUpgradeProfile(ProxyResource):
    """Upgrade profile for given mesh.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: Mesh upgrade profile properties for a major.minor release.
    :vartype properties: ~azure.mgmt.containerservice.models.MeshUpgradeProfileProperties
    """

    properties: Optional["_models.MeshUpgradeProfileProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Mesh upgrade profile properties for a major.minor release."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.MeshUpgradeProfileProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MeshUpgradeProfileProperties(MeshRevision):
    """Mesh upgrade profile properties for a major.minor release.

    :ivar revision: The revision of the mesh release.
    :vartype revision: str
    :ivar upgrades: List of revisions available for upgrade of a specific mesh revision.
    :vartype upgrades: list[str]
    :ivar compatible_with: List of items this revision of service mesh is compatible with, and
     their associated versions.
    :vartype compatible_with: list[~azure.mgmt.containerservice.models.CompatibleVersions]
    """

    @overload
    def __init__(
        self,
        *,
        revision: Optional[str] = None,
        upgrades: Optional[list[str]] = None,
        compatible_with: Optional[list["_models.CompatibleVersions"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NamespaceProperties(_Model):
    """Properties of a namespace managed by ARM.

    :ivar provisioning_state: The current provisioning state of the namespace. Known values are:
     "Updating", "Deleting", "Creating", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.containerservice.models.NamespaceProvisioningState
    :ivar labels: The labels of managed namespace.
    :vartype labels: dict[str, str]
    :ivar annotations: The annotations of managed namespace.
    :vartype annotations: dict[str, str]
    :ivar portal_fqdn: The special FQDN used by the Azure Portal to access the Managed Cluster.
     This FQDN is for use only by the Azure Portal and should not be used by other clients. The
     Azure Portal requires certain Cross-Origin Resource Sharing (CORS) headers to be sent in some
     responses, which Kubernetes APIServer doesn't handle by default. This special FQDN supports
     CORS, allowing the Azure Portal to function properly.
    :vartype portal_fqdn: str
    :ivar default_resource_quota: The default resource quota enforced upon the namespace. Customers
     can have other Kubernetes resource quota objects under the namespace. Resource quotas are
     additive; if multiple resource quotas are applied to a given namespace, then the effective
     limit will be one such that all quotas on the namespace can be satisfied.
    :vartype default_resource_quota: ~azure.mgmt.containerservice.models.ResourceQuota
    :ivar default_network_policy: The default network policy enforced upon the namespace. Customers
     can have other Kubernetes network policy objects under the namespace. Network policies are
     additive; if a policy or policies apply to a given pod for a given direction, the connections
     allowed in that direction for the pod is the union of what all applicable policies allow.
    :vartype default_network_policy: ~azure.mgmt.containerservice.models.NetworkPolicies
    :ivar adoption_policy: Action if Kubernetes namespace with same name already exists. Known
     values are: "Never", "IfIdentical", and "Always".
    :vartype adoption_policy: str or ~azure.mgmt.containerservice.models.AdoptionPolicy
    :ivar delete_policy: Delete options of a namespace. Known values are: "Keep" and "Delete".
    :vartype delete_policy: str or ~azure.mgmt.containerservice.models.DeletePolicy
    """

    provisioning_state: Optional[Union[str, "_models.NamespaceProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The current provisioning state of the namespace. Known values are: \"Updating\", \"Deleting\",
     \"Creating\", \"Succeeded\", \"Failed\", and \"Canceled\"."""
    labels: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The labels of managed namespace."""
    annotations: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The annotations of managed namespace."""
    portal_fqdn: Optional[str] = rest_field(name="portalFqdn", visibility=["read"])
    """The special FQDN used by the Azure Portal to access the Managed Cluster. This FQDN is for use
     only by the Azure Portal and should not be used by other clients. The Azure Portal requires
     certain Cross-Origin Resource Sharing (CORS) headers to be sent in some responses, which
     Kubernetes APIServer doesn't handle by default. This special FQDN supports CORS, allowing the
     Azure Portal to function properly."""
    default_resource_quota: Optional["_models.ResourceQuota"] = rest_field(
        name="defaultResourceQuota", visibility=["read", "create", "update", "delete", "query"]
    )
    """The default resource quota enforced upon the namespace. Customers can have other Kubernetes
     resource quota objects under the namespace. Resource quotas are additive; if multiple resource
     quotas are applied to a given namespace, then the effective limit will be one such that all
     quotas on the namespace can be satisfied."""
    default_network_policy: Optional["_models.NetworkPolicies"] = rest_field(
        name="defaultNetworkPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The default network policy enforced upon the namespace. Customers can have other Kubernetes
     network policy objects under the namespace. Network policies are additive; if a policy or
     policies apply to a given pod for a given direction, the connections allowed in that direction
     for the pod is the union of what all applicable policies allow."""
    adoption_policy: Optional[Union[str, "_models.AdoptionPolicy"]] = rest_field(
        name="adoptionPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """Action if Kubernetes namespace with same name already exists. Known values are: \"Never\",
     \"IfIdentical\", and \"Always\"."""
    delete_policy: Optional[Union[str, "_models.DeletePolicy"]] = rest_field(
        name="deletePolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """Delete options of a namespace. Known values are: \"Keep\" and \"Delete\"."""

    @overload
    def __init__(
        self,
        *,
        labels: Optional[dict[str, str]] = None,
        annotations: Optional[dict[str, str]] = None,
        default_resource_quota: Optional["_models.ResourceQuota"] = None,
        default_network_policy: Optional["_models.NetworkPolicies"] = None,
        adoption_policy: Optional[Union[str, "_models.AdoptionPolicy"]] = None,
        delete_policy: Optional[Union[str, "_models.DeletePolicy"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NetworkPolicies(_Model):
    """Default network policy of the namespace, specifying ingress and egress rules.

    :ivar ingress: Enum representing different network policy rules. Known values are: "DenyAll",
     "AllowAll", and "AllowSameNamespace".
    :vartype ingress: str or ~azure.mgmt.containerservice.models.PolicyRule
    :ivar egress: Enum representing different network policy rules. Known values are: "DenyAll",
     "AllowAll", and "AllowSameNamespace".
    :vartype egress: str or ~azure.mgmt.containerservice.models.PolicyRule
    """

    ingress: Optional[Union[str, "_models.PolicyRule"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Enum representing different network policy rules. Known values are: \"DenyAll\", \"AllowAll\",
     and \"AllowSameNamespace\"."""
    egress: Optional[Union[str, "_models.PolicyRule"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Enum representing different network policy rules. Known values are: \"DenyAll\", \"AllowAll\",
     and \"AllowSameNamespace\"."""

    @overload
    def __init__(
        self,
        *,
        ingress: Optional[Union[str, "_models.PolicyRule"]] = None,
        egress: Optional[Union[str, "_models.PolicyRule"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NetworkProfileForSnapshot(_Model):
    """network profile for managed cluster snapshot, these properties are read only.

    :ivar network_plugin: networkPlugin for managed cluster snapshot. Known values are: "azure",
     "kubenet", and "none".
    :vartype network_plugin: str or ~azure.mgmt.containerservice.models.NetworkPlugin
    :ivar network_plugin_mode: NetworkPluginMode for managed cluster snapshot. "overlay"
    :vartype network_plugin_mode: str or ~azure.mgmt.containerservice.models.NetworkPluginMode
    :ivar network_policy: networkPolicy for managed cluster snapshot. Known values are: "none",
     "calico", "azure", and "cilium".
    :vartype network_policy: str or ~azure.mgmt.containerservice.models.NetworkPolicy
    :ivar network_mode: networkMode for managed cluster snapshot. Known values are: "transparent"
     and "bridge".
    :vartype network_mode: str or ~azure.mgmt.containerservice.models.NetworkMode
    :ivar load_balancer_sku: loadBalancerSku for managed cluster snapshot. Known values are:
     "standard" and "basic".
    :vartype load_balancer_sku: str or ~azure.mgmt.containerservice.models.LoadBalancerSku
    """

    network_plugin: Optional[Union[str, "_models.NetworkPlugin"]] = rest_field(
        name="networkPlugin", visibility=["read", "create", "update", "delete", "query"]
    )
    """networkPlugin for managed cluster snapshot. Known values are: \"azure\", \"kubenet\", and
     \"none\"."""
    network_plugin_mode: Optional[Union[str, "_models.NetworkPluginMode"]] = rest_field(
        name="networkPluginMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """NetworkPluginMode for managed cluster snapshot. \"overlay\""""
    network_policy: Optional[Union[str, "_models.NetworkPolicy"]] = rest_field(
        name="networkPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """networkPolicy for managed cluster snapshot. Known values are: \"none\", \"calico\", \"azure\",
     and \"cilium\"."""
    network_mode: Optional[Union[str, "_models.NetworkMode"]] = rest_field(
        name="networkMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """networkMode for managed cluster snapshot. Known values are: \"transparent\" and \"bridge\"."""
    load_balancer_sku: Optional[Union[str, "_models.LoadBalancerSku"]] = rest_field(
        name="loadBalancerSku", visibility=["read", "create", "update", "delete", "query"]
    )
    """loadBalancerSku for managed cluster snapshot. Known values are: \"standard\" and \"basic\"."""

    @overload
    def __init__(
        self,
        *,
        network_plugin: Optional[Union[str, "_models.NetworkPlugin"]] = None,
        network_plugin_mode: Optional[Union[str, "_models.NetworkPluginMode"]] = None,
        network_policy: Optional[Union[str, "_models.NetworkPolicy"]] = None,
        network_mode: Optional[Union[str, "_models.NetworkMode"]] = None,
        load_balancer_sku: Optional[Union[str, "_models.LoadBalancerSku"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NodeCustomizationProfile(_Model):
    """Settings to determine the node customization used to provision nodes in a pool.

    :ivar node_customization_id: The resource ID of the node customization resource to use. This
     can be a version. Omitting the version will use the latest version of the node customization.
    :vartype node_customization_id: str
    """

    node_customization_id: Optional[str] = rest_field(
        name="nodeCustomizationId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource ID of the node customization resource to use. This can be a version. Omitting the
     version will use the latest version of the node customization."""

    @overload
    def __init__(
        self,
        *,
        node_customization_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NodeImageVersion(_Model):
    """node image version profile for given major.minor.patch release.

    :ivar os: The operating system of the node image. Example: AKSUbuntu.
    :vartype os: str
    :ivar sku: The SKU or flavor of the node image. Example: 2004gen2containerd.
    :vartype sku: str
    :ivar version: major.minor.patch version of the node image version release. Example:
     2024.02.02.
    :vartype version: str
    :ivar full_name: The OS + SKU + version of the node image. Example:
     AKSUbuntu-1804gen2containerd-2024.02.02.
    :vartype full_name: str
    """

    os: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The operating system of the node image. Example: AKSUbuntu."""
    sku: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The SKU or flavor of the node image. Example: 2004gen2containerd."""
    version: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """major.minor.patch version of the node image version release. Example: 2024.02.02."""
    full_name: Optional[str] = rest_field(name="fullName", visibility=["read", "create", "update", "delete", "query"])
    """The OS + SKU + version of the node image. Example: AKSUbuntu-1804gen2containerd-2024.02.02."""

    @overload
    def __init__(
        self,
        *,
        os: Optional[str] = None,
        sku: Optional[str] = None,
        version: Optional[str] = None,
        full_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OperationStatusResult(_Model):
    """The current status of an async operation.

    :ivar id: Fully qualified ID for the async operation.
    :vartype id: str
    :ivar name: Name of the async operation.
    :vartype name: str
    :ivar status: Operation status. Required.
    :vartype status: str
    :ivar percent_complete: Percent of the operation that is complete.
    :vartype percent_complete: float
    :ivar start_time: The start time of the operation.
    :vartype start_time: ~datetime.datetime
    :ivar end_time: The end time of the operation.
    :vartype end_time: ~datetime.datetime
    :ivar operations: The operations list.
    :vartype operations: list[~azure.mgmt.containerservice.models.OperationStatusResult]
    :ivar error: If present, details of the operation error.
    :vartype error: ~azure.mgmt.containerservice.models.ErrorDetail
    :ivar resource_id: Fully qualified ID of the resource against which the original async
     operation was started.
    :vartype resource_id: str
    """

    id: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Fully qualified ID for the async operation."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Name of the async operation."""
    status: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Operation status. Required."""
    percent_complete: Optional[float] = rest_field(
        name="percentComplete", visibility=["read", "create", "update", "delete", "query"]
    )
    """Percent of the operation that is complete."""
    start_time: Optional[datetime.datetime] = rest_field(
        name="startTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start time of the operation."""
    end_time: Optional[datetime.datetime] = rest_field(
        name="endTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The end time of the operation."""
    operations: Optional[list["_models.OperationStatusResult"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The operations list."""
    error: Optional["_models.ErrorDetail"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """If present, details of the operation error."""
    resource_id: Optional[str] = rest_field(name="resourceId", visibility=["read"])
    """Fully qualified ID of the resource against which the original async operation was started."""

    @overload
    def __init__(
        self,
        *,
        status: str,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        percent_complete: Optional[float] = None,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        operations: Optional[list["_models.OperationStatusResult"]] = None,
        error: Optional["_models.ErrorDetail"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OperationValue(_Model):
    """Describes the properties of a Operation value.

    :ivar origin: The origin of the operation.
    :vartype origin: str
    :ivar name: The name of the operation.
    :vartype name: str
    :ivar display: Describes the properties of a Operation Value Display.
    :vartype display: ~azure.mgmt.containerservice.models.OperationValueDisplay
    """

    origin: Optional[str] = rest_field(visibility=["read"])
    """The origin of the operation."""
    name: Optional[str] = rest_field(visibility=["read"])
    """The name of the operation."""
    display: Optional["_models.OperationValueDisplay"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Describes the properties of a Operation Value Display."""

    __flattened_items = ["operation", "resource", "description", "provider"]

    @overload
    def __init__(
        self,
        *,
        display: Optional["_models.OperationValueDisplay"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.display is None:
                return None
            return getattr(self.display, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.display is None:
                self.display = self._attr_to_rest_field["display"]._class_type()
            setattr(self.display, key, value)
        else:
            super().__setattr__(key, value)


class OperationValueDisplay(_Model):
    """Describes the properties of a Operation Value Display.

    :ivar operation: The display name of the operation.
    :vartype operation: str
    :ivar resource: The display name of the resource the operation applies to.
    :vartype resource: str
    :ivar description: The description of the operation.
    :vartype description: str
    :ivar provider: The resource provider for the operation.
    :vartype provider: str
    """

    operation: Optional[str] = rest_field(visibility=["read"])
    """The display name of the operation."""
    resource: Optional[str] = rest_field(visibility=["read"])
    """The display name of the resource the operation applies to."""
    description: Optional[str] = rest_field(visibility=["read"])
    """The description of the operation."""
    provider: Optional[str] = rest_field(visibility=["read"])
    """The resource provider for the operation."""


class OutboundEnvironmentEndpoint(_Model):
    """Egress endpoints which AKS agent nodes connect to for common purpose.

    :ivar category: The category of endpoints accessed by the AKS agent node, e.g.
     azure-resource-management, apiserver, etc.
    :vartype category: str
    :ivar endpoints: The endpoints that AKS agent nodes connect to.
    :vartype endpoints: list[~azure.mgmt.containerservice.models.EndpointDependency]
    """

    category: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The category of endpoints accessed by the AKS agent node, e.g. azure-resource-management,
     apiserver, etc."""
    endpoints: Optional[list["_models.EndpointDependency"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The endpoints that AKS agent nodes connect to."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[str] = None,
        endpoints: Optional[list["_models.EndpointDependency"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PortRange(_Model):
    """The port range.

    :ivar port_start: The minimum port that is included in the range. It should be ranged from 1 to
     65535, and be less than or equal to portEnd.
    :vartype port_start: int
    :ivar port_end: The maximum port that is included in the range. It should be ranged from 1 to
     65535, and be greater than or equal to portStart.
    :vartype port_end: int
    :ivar protocol: The network protocol of the port. Known values are: "TCP" and "UDP".
    :vartype protocol: str or ~azure.mgmt.containerservice.models.Protocol
    """

    port_start: Optional[int] = rest_field(name="portStart", visibility=["read", "create", "update", "delete", "query"])
    """The minimum port that is included in the range. It should be ranged from 1 to 65535, and be
     less than or equal to portEnd."""
    port_end: Optional[int] = rest_field(name="portEnd", visibility=["read", "create", "update", "delete", "query"])
    """The maximum port that is included in the range. It should be ranged from 1 to 65535, and be
     greater than or equal to portStart."""
    protocol: Optional[Union[str, "_models.Protocol"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The network protocol of the port. Known values are: \"TCP\" and \"UDP\"."""

    @overload
    def __init__(
        self,
        *,
        port_start: Optional[int] = None,
        port_end: Optional[int] = None,
        protocol: Optional[Union[str, "_models.Protocol"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PowerState(_Model):
    """Describes the Power State of the cluster.

    :ivar code: Tells whether the cluster is Running or Stopped. Known values are: "Running" and
     "Stopped".
    :vartype code: str or ~azure.mgmt.containerservice.models.Code
    """

    code: Optional[Union[str, "_models.Code"]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Tells whether the cluster is Running or Stopped. Known values are: \"Running\" and \"Stopped\"."""

    @overload
    def __init__(
        self,
        *,
        code: Optional[Union[str, "_models.Code"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrivateEndpoint(_Model):
    """Private endpoint which a connection belongs to.

    :ivar id: The resource ID of the private endpoint.
    :vartype id: str
    """

    id: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The resource ID of the private endpoint."""

    @overload
    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrivateEndpointConnection(ProxyResource):
    """A private endpoint connection.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: The properties of a private endpoint connection.
    :vartype properties: ~azure.mgmt.containerservice.models.PrivateEndpointConnectionProperties
    """

    properties: Optional["_models.PrivateEndpointConnectionProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of a private endpoint connection."""

    __flattened_items = ["provisioning_state", "private_endpoint", "private_link_service_connection_state"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.PrivateEndpointConnectionProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class PrivateEndpointConnectionListResult(_Model):
    """A list of private endpoint connections.

    :ivar value: The collection value.
    :vartype value: list[~azure.mgmt.containerservice.models.PrivateEndpointConnection]
    """

    value: Optional[list["_models.PrivateEndpointConnection"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The collection value."""

    @overload
    def __init__(
        self,
        *,
        value: Optional[list["_models.PrivateEndpointConnection"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrivateEndpointConnectionProperties(_Model):
    """Properties of a private endpoint connection.

    :ivar provisioning_state: The current provisioning state. Known values are: "Canceled",
     "Creating", "Deleting", "Failed", and "Succeeded".
    :vartype provisioning_state: str or
     ~azure.mgmt.containerservice.models.PrivateEndpointConnectionProvisioningState
    :ivar private_endpoint: The resource of private endpoint.
    :vartype private_endpoint: ~azure.mgmt.containerservice.models.PrivateEndpoint
    :ivar private_link_service_connection_state: A collection of information about the state of the
     connection between service consumer and provider. Required.
    :vartype private_link_service_connection_state:
     ~azure.mgmt.containerservice.models.PrivateLinkServiceConnectionState
    """

    provisioning_state: Optional[Union[str, "_models.PrivateEndpointConnectionProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The current provisioning state. Known values are: \"Canceled\", \"Creating\", \"Deleting\",
     \"Failed\", and \"Succeeded\"."""
    private_endpoint: Optional["_models.PrivateEndpoint"] = rest_field(
        name="privateEndpoint", visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource of private endpoint."""
    private_link_service_connection_state: "_models.PrivateLinkServiceConnectionState" = rest_field(
        name="privateLinkServiceConnectionState", visibility=["read", "create", "update", "delete", "query"]
    )
    """A collection of information about the state of the connection between service consumer and
     provider. Required."""

    @overload
    def __init__(
        self,
        *,
        private_link_service_connection_state: "_models.PrivateLinkServiceConnectionState",
        private_endpoint: Optional["_models.PrivateEndpoint"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrivateLinkResource(_Model):
    """A private link resource.

    :ivar id: The ID of the private link resource.
    :vartype id: str
    :ivar name: The name of the private link resource.
    :vartype name: str
    :ivar type: The resource type.
    :vartype type: str
    :ivar group_id: The group ID of the resource.
    :vartype group_id: str
    :ivar required_members: The RequiredMembers of the resource.
    :vartype required_members: list[str]
    :ivar private_link_service_id: The private link service ID of the resource, this field is
     exposed only to NRP internally.
    :vartype private_link_service_id: str
    """

    id: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The ID of the private link resource."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the private link resource."""
    type: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The resource type."""
    group_id: Optional[str] = rest_field(name="groupId", visibility=["read", "create", "update", "delete", "query"])
    """The group ID of the resource."""
    required_members: Optional[list[str]] = rest_field(
        name="requiredMembers", visibility=["read", "create", "update", "delete", "query"]
    )
    """The RequiredMembers of the resource."""
    private_link_service_id: Optional[str] = rest_field(name="privateLinkServiceID", visibility=["read"])
    """The private link service ID of the resource, this field is exposed only to NRP internally."""

    @overload
    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        type: Optional[str] = None,
        group_id: Optional[str] = None,
        required_members: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrivateLinkResourcesListResult(_Model):
    """A list of private link resources.

    :ivar value: The collection value.
    :vartype value: list[~azure.mgmt.containerservice.models.PrivateLinkResource]
    """

    value: Optional[list["_models.PrivateLinkResource"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The collection value."""

    @overload
    def __init__(
        self,
        *,
        value: Optional[list["_models.PrivateLinkResource"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrivateLinkServiceConnectionState(_Model):
    """The state of a private link service connection.

    :ivar status: The private link service connection status. Known values are: "Pending",
     "Approved", "Rejected", and "Disconnected".
    :vartype status: str or ~azure.mgmt.containerservice.models.ConnectionStatus
    :ivar description: The private link service connection description.
    :vartype description: str
    """

    status: Optional[Union[str, "_models.ConnectionStatus"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The private link service connection status. Known values are: \"Pending\", \"Approved\",
     \"Rejected\", and \"Disconnected\"."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The private link service connection description."""

    @overload
    def __init__(
        self,
        *,
        status: Optional[Union[str, "_models.ConnectionStatus"]] = None,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RebalanceLoadBalancersRequestBody(_Model):
    """The names of the load balancers to rebalance. If set to empty, all load balancers will be
    rebalanced.

    :ivar load_balancer_names: The load balancer names list.
    :vartype load_balancer_names: list[str]
    """

    load_balancer_names: Optional[list[str]] = rest_field(
        name="loadBalancerNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """The load balancer names list."""

    @overload
    def __init__(
        self,
        *,
        load_balancer_names: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RelativeMonthlySchedule(_Model):
    """For schedules like: 'recur every month on the first Monday' or 'recur every 3 months on last
    Friday'.

    :ivar interval_months: Specifies the number of months between each set of occurrences.
     Required.
    :vartype interval_months: int
    :ivar week_index: The week index. Specifies on which week of the month the dayOfWeek applies.
     Required. Known values are: "First", "Second", "Third", "Fourth", and "Last".
    :vartype week_index: str or ~azure.mgmt.containerservice.models.Type
    :ivar day_of_week: Specifies on which day of the week the maintenance occurs. Required. Known
     values are: "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", and "Saturday".
    :vartype day_of_week: str or ~azure.mgmt.containerservice.models.WeekDay
    """

    interval_months: int = rest_field(name="intervalMonths", visibility=["read", "create", "update", "delete", "query"])
    """Specifies the number of months between each set of occurrences. Required."""
    week_index: Union[str, "_models.Type"] = rest_field(
        name="weekIndex", visibility=["read", "create", "update", "delete", "query"]
    )
    """The week index. Specifies on which week of the month the dayOfWeek applies. Required. Known
     values are: \"First\", \"Second\", \"Third\", \"Fourth\", and \"Last\"."""
    day_of_week: Union[str, "_models.WeekDay"] = rest_field(
        name="dayOfWeek", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies on which day of the week the maintenance occurs. Required. Known values are:
     \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", and \"Saturday\"."""

    @overload
    def __init__(
        self,
        *,
        interval_months: int,
        week_index: Union[str, "_models.Type"],
        day_of_week: Union[str, "_models.WeekDay"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ResourceQuota(_Model):
    """Resource quota for the namespace.

    :ivar cpu_request: CPU request of the namespace in one-thousandth CPU form. See `CPU resource
     units
     <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu>`_
     for more details.
    :vartype cpu_request: str
    :ivar cpu_limit: CPU limit of the namespace in one-thousandth CPU form. See `CPU resource units
     <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu>`_
     for more details.
    :vartype cpu_limit: str
    :ivar memory_request: Memory request of the namespace in the power-of-two equivalents form: Ei,
     Pi, Ti, Gi, Mi, Ki. See `Memory resource units
     <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory>`_
     for more details.
    :vartype memory_request: str
    :ivar memory_limit: Memory limit of the namespace in the power-of-two equivalents form: Ei, Pi,
     Ti, Gi, Mi, Ki. See `Memory resource units
     <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory>`_
     for more details.
    :vartype memory_limit: str
    """

    cpu_request: Optional[str] = rest_field(
        name="cpuRequest", visibility=["read", "create", "update", "delete", "query"]
    )
    """CPU request of the namespace in one-thousandth CPU form. See `CPU resource units
     <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu>`_
     for more details."""
    cpu_limit: Optional[str] = rest_field(name="cpuLimit", visibility=["read", "create", "update", "delete", "query"])
    """CPU limit of the namespace in one-thousandth CPU form. See `CPU resource units
     <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu>`_
     for more details."""
    memory_request: Optional[str] = rest_field(
        name="memoryRequest", visibility=["read", "create", "update", "delete", "query"]
    )
    """Memory request of the namespace in the power-of-two equivalents form: Ei, Pi, Ti, Gi, Mi, Ki.
     See `Memory resource units
     <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory>`_
     for more details."""
    memory_limit: Optional[str] = rest_field(
        name="memoryLimit", visibility=["read", "create", "update", "delete", "query"]
    )
    """Memory limit of the namespace in the power-of-two equivalents form: Ei, Pi, Ti, Gi, Mi, Ki. See
     `Memory resource units
     <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory>`_
     for more details."""

    @overload
    def __init__(
        self,
        *,
        cpu_request: Optional[str] = None,
        cpu_limit: Optional[str] = None,
        memory_request: Optional[str] = None,
        memory_limit: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ResourceReference(_Model):
    """A reference to an Azure resource.

    :ivar id: The fully qualified Azure resource id.
    :vartype id: str
    """

    id: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The fully qualified Azure resource id."""

    @overload
    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunCommandRequest(_Model):
    """A run command request.

    :ivar command: The command to run. Required.
    :vartype command: str
    :ivar context: A base64 encoded zip file containing the files required by the command.
    :vartype context: str
    :ivar cluster_token: AuthToken issued for AKS AAD Server App.
    :vartype cluster_token: str
    """

    command: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The command to run. Required."""
    context: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A base64 encoded zip file containing the files required by the command."""
    cluster_token: Optional[str] = rest_field(
        name="clusterToken", visibility=["read", "create", "update", "delete", "query"]
    )
    """AuthToken issued for AKS AAD Server App."""

    @overload
    def __init__(
        self,
        *,
        command: str,
        context: Optional[str] = None,
        cluster_token: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunCommandResult(_Model):
    """run command result.

    :ivar id: The command id.
    :vartype id: str
    :ivar properties: Properties of command result.
    :vartype properties: ~azure.mgmt.containerservice.models.CommandResultProperties
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """The command id."""
    properties: Optional["_models.CommandResultProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of command result."""

    __flattened_items = ["provisioning_state", "exit_code", "started_at", "finished_at", "logs", "reason"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.CommandResultProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class SafeguardsAvailableVersion(ProxyResource):
    """Available Safeguards Version.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: Whether the version is default or not and support info. Required.
    :vartype properties: ~azure.mgmt.containerservice.models.SafeguardsAvailableVersionsProperties
    """

    properties: "_models.SafeguardsAvailableVersionsProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether the version is default or not and support info. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.SafeguardsAvailableVersionsProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SafeguardsAvailableVersionsProperties(_Model):
    """Whether the version is default or not and support info.

    :ivar is_default_version:
    :vartype is_default_version: bool
    :ivar support: Whether the version is preview or stable. Known values are: "Preview" and
     "Stable".
    :vartype support: str or ~azure.mgmt.containerservice.models.SafeguardsSupport
    """

    is_default_version: Optional[bool] = rest_field(name="isDefaultVersion", visibility=["read"])
    support: Optional[Union[str, "_models.SafeguardsSupport"]] = rest_field(visibility=["read"])
    """Whether the version is preview or stable. Known values are: \"Preview\" and \"Stable\"."""


class ScaleProfile(_Model):
    """Specifications on how to scale a VirtualMachines agent pool.

    :ivar manual: Specifications on how to scale the VirtualMachines agent pool to a fixed size.
    :vartype manual: list[~azure.mgmt.containerservice.models.ManualScaleProfile]
    :ivar autoscale: Specifications on how to auto-scale the VirtualMachines agent pool within a
     predefined size range.
    :vartype autoscale: ~azure.mgmt.containerservice.models.AutoScaleProfile
    """

    manual: Optional[list["_models.ManualScaleProfile"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifications on how to scale the VirtualMachines agent pool to a fixed size."""
    autoscale: Optional["_models.AutoScaleProfile"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifications on how to auto-scale the VirtualMachines agent pool within a predefined size
     range."""

    @overload
    def __init__(
        self,
        *,
        manual: Optional[list["_models.ManualScaleProfile"]] = None,
        autoscale: Optional["_models.AutoScaleProfile"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Schedule(_Model):
    """One and only one of the schedule types should be specified. Choose either 'daily', 'weekly',
    'absoluteMonthly' or 'relativeMonthly' for your maintenance schedule.

    :ivar daily: For schedules like: 'recur every day' or 'recur every 3 days'.
    :vartype daily: ~azure.mgmt.containerservice.models.DailySchedule
    :ivar weekly: For schedules like: 'recur every Monday' or 'recur every 3 weeks on Wednesday'.
    :vartype weekly: ~azure.mgmt.containerservice.models.WeeklySchedule
    :ivar absolute_monthly: For schedules like: 'recur every month on the 15th' or 'recur every 3
     months on the 20th'.
    :vartype absolute_monthly: ~azure.mgmt.containerservice.models.AbsoluteMonthlySchedule
    :ivar relative_monthly: For schedules like: 'recur every month on the first Monday' or 'recur
     every 3 months on last Friday'.
    :vartype relative_monthly: ~azure.mgmt.containerservice.models.RelativeMonthlySchedule
    """

    daily: Optional["_models.DailySchedule"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """For schedules like: 'recur every day' or 'recur every 3 days'."""
    weekly: Optional["_models.WeeklySchedule"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """For schedules like: 'recur every Monday' or 'recur every 3 weeks on Wednesday'."""
    absolute_monthly: Optional["_models.AbsoluteMonthlySchedule"] = rest_field(
        name="absoluteMonthly", visibility=["read", "create", "update", "delete", "query"]
    )
    """For schedules like: 'recur every month on the 15th' or 'recur every 3 months on the 20th'."""
    relative_monthly: Optional["_models.RelativeMonthlySchedule"] = rest_field(
        name="relativeMonthly", visibility=["read", "create", "update", "delete", "query"]
    )
    """For schedules like: 'recur every month on the first Monday' or 'recur every 3 months on last
     Friday'."""

    @overload
    def __init__(
        self,
        *,
        daily: Optional["_models.DailySchedule"] = None,
        weekly: Optional["_models.WeeklySchedule"] = None,
        absolute_monthly: Optional["_models.AbsoluteMonthlySchedule"] = None,
        relative_monthly: Optional["_models.RelativeMonthlySchedule"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SchedulerInstanceProfile(_Model):
    """The scheduler profile for a single scheduler instance.

    :ivar scheduler_config_mode: The config customization mode for this scheduler instance. Known
     values are: "Default" and "ManagedByCRD".
    :vartype scheduler_config_mode: str or ~azure.mgmt.containerservice.models.SchedulerConfigMode
    """

    scheduler_config_mode: Optional[Union[str, "_models.SchedulerConfigMode"]] = rest_field(
        name="schedulerConfigMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The config customization mode for this scheduler instance. Known values are: \"Default\" and
     \"ManagedByCRD\"."""

    @overload
    def __init__(
        self,
        *,
        scheduler_config_mode: Optional[Union[str, "_models.SchedulerConfigMode"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SchedulerProfile(_Model):
    """The pod scheduler profile for the cluster.

    :ivar scheduler_instance_profiles: Mapping of each scheduler instance to its profile.
    :vartype scheduler_instance_profiles:
     ~azure.mgmt.containerservice.models.SchedulerProfileSchedulerInstanceProfiles
    """

    scheduler_instance_profiles: Optional["_models.SchedulerProfileSchedulerInstanceProfiles"] = rest_field(
        name="schedulerInstanceProfiles", visibility=["read", "create", "update", "delete", "query"]
    )
    """Mapping of each scheduler instance to its profile."""

    @overload
    def __init__(
        self,
        *,
        scheduler_instance_profiles: Optional["_models.SchedulerProfileSchedulerInstanceProfiles"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SchedulerProfileSchedulerInstanceProfiles(_Model):  # pylint: disable=name-too-long
    """Mapping of each scheduler instance to its profile.

    :ivar upstream: The scheduler profile for the upstream scheduler instance.
    :vartype upstream: ~azure.mgmt.containerservice.models.SchedulerInstanceProfile
    """

    upstream: Optional["_models.SchedulerInstanceProfile"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The scheduler profile for the upstream scheduler instance."""

    @overload
    def __init__(
        self,
        *,
        upstream: Optional["_models.SchedulerInstanceProfile"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceMeshProfile(_Model):
    """Service mesh profile for a managed cluster.

    :ivar mode: Mode of the service mesh. Required. Known values are: "Istio" and "Disabled".
    :vartype mode: str or ~azure.mgmt.containerservice.models.ServiceMeshMode
    :ivar istio: Istio service mesh configuration.
    :vartype istio: ~azure.mgmt.containerservice.models.IstioServiceMesh
    """

    mode: Union[str, "_models.ServiceMeshMode"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Mode of the service mesh. Required. Known values are: \"Istio\" and \"Disabled\"."""
    istio: Optional["_models.IstioServiceMesh"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Istio service mesh configuration."""

    @overload
    def __init__(
        self,
        *,
        mode: Union[str, "_models.ServiceMeshMode"],
        istio: Optional["_models.IstioServiceMesh"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Snapshot(TrackedResource):
    """A node pool snapshot resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: Properties of a snapshot.
    :vartype properties: ~azure.mgmt.containerservice.models.SnapshotProperties
    """

    properties: Optional["_models.SnapshotProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of a snapshot."""

    __flattened_items = [
        "creation_data",
        "snapshot_type",
        "kubernetes_version",
        "node_image_version",
        "os_type",
        "os_sku",
        "vm_size",
        "enable_fips",
    ]

    @overload
    def __init__(
        self,
        *,
        location: str,
        tags: Optional[dict[str, str]] = None,
        properties: Optional["_models.SnapshotProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class SnapshotProperties(_Model):
    """Properties used to configure a node pool snapshot.

    :ivar creation_data: CreationData to be used to specify the source agent pool resource ID to
     create this snapshot.
    :vartype creation_data: ~azure.mgmt.containerservice.models.CreationData
    :ivar snapshot_type: The type of a snapshot. The default is NodePool. Known values are:
     "NodePool" and "ManagedCluster".
    :vartype snapshot_type: str or ~azure.mgmt.containerservice.models.SnapshotType
    :ivar kubernetes_version: The version of Kubernetes.
    :vartype kubernetes_version: str
    :ivar node_image_version: The version of node image.
    :vartype node_image_version: str
    :ivar os_type: The operating system type. The default is Linux. Known values are: "Linux" and
     "Windows".
    :vartype os_type: str or ~azure.mgmt.containerservice.models.OSType
    :ivar os_sku: Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is
     Linux. The default is Windows2019 when Kubernetes <= 1.24 or Windows2022 when Kubernetes >=
     1.25 if OSType is Windows. Known values are: "Ubuntu", "AzureLinux", "AzureLinux3", "Mariner",
     "Flatcar", "CBLMariner", "Windows2019", "Windows2022", "Ubuntu2204", "Windows2025",
     "WindowsAnnual", and "Ubuntu2404".
    :vartype os_sku: str or ~azure.mgmt.containerservice.models.OSSKU
    :ivar vm_size: The size of the VM.
    :vartype vm_size: str
    :ivar enable_fips: Whether to use a FIPS-enabled OS.
    :vartype enable_fips: bool
    """

    creation_data: Optional["_models.CreationData"] = rest_field(
        name="creationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """CreationData to be used to specify the source agent pool resource ID to create this snapshot."""
    snapshot_type: Optional[Union[str, "_models.SnapshotType"]] = rest_field(
        name="snapshotType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of a snapshot. The default is NodePool. Known values are: \"NodePool\" and
     \"ManagedCluster\"."""
    kubernetes_version: Optional[str] = rest_field(name="kubernetesVersion", visibility=["read"])
    """The version of Kubernetes."""
    node_image_version: Optional[str] = rest_field(name="nodeImageVersion", visibility=["read"])
    """The version of node image."""
    os_type: Optional[Union[str, "_models.OSType"]] = rest_field(name="osType", visibility=["read"])
    """The operating system type. The default is Linux. Known values are: \"Linux\" and \"Windows\"."""
    os_sku: Optional[Union[str, "_models.OSSKU"]] = rest_field(name="osSku", visibility=["read"])
    """Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The
     default is Windows2019 when Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType
     is Windows. Known values are: \"Ubuntu\", \"AzureLinux\", \"AzureLinux3\", \"Mariner\",
     \"Flatcar\", \"CBLMariner\", \"Windows2019\", \"Windows2022\", \"Ubuntu2204\", \"Windows2025\",
     \"WindowsAnnual\", and \"Ubuntu2404\"."""
    vm_size: Optional[str] = rest_field(name="vmSize", visibility=["read"])
    """The size of the VM."""
    enable_fips: Optional[bool] = rest_field(name="enableFIPS", visibility=["read"])
    """Whether to use a FIPS-enabled OS."""

    @overload
    def __init__(
        self,
        *,
        creation_data: Optional["_models.CreationData"] = None,
        snapshot_type: Optional[Union[str, "_models.SnapshotType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SysctlConfig(_Model):
    """Sysctl settings for Linux agent nodes.

    :ivar net_core_somaxconn: Sysctl setting net.core.somaxconn.
    :vartype net_core_somaxconn: int
    :ivar net_core_netdev_max_backlog: Sysctl setting net.core.netdev_max_backlog.
    :vartype net_core_netdev_max_backlog: int
    :ivar net_core_rmem_default: Sysctl setting net.core.rmem_default.
    :vartype net_core_rmem_default: int
    :ivar net_core_rmem_max: Sysctl setting net.core.rmem_max.
    :vartype net_core_rmem_max: int
    :ivar net_core_wmem_default: Sysctl setting net.core.wmem_default.
    :vartype net_core_wmem_default: int
    :ivar net_core_wmem_max: Sysctl setting net.core.wmem_max.
    :vartype net_core_wmem_max: int
    :ivar net_core_optmem_max: Sysctl setting net.core.optmem_max.
    :vartype net_core_optmem_max: int
    :ivar net_ipv4_tcp_max_syn_backlog: Sysctl setting net.ipv4.tcp_max_syn_backlog.
    :vartype net_ipv4_tcp_max_syn_backlog: int
    :ivar net_ipv4_tcp_max_tw_buckets: Sysctl setting net.ipv4.tcp_max_tw_buckets.
    :vartype net_ipv4_tcp_max_tw_buckets: int
    :ivar net_ipv4_tcp_fin_timeout: Sysctl setting net.ipv4.tcp_fin_timeout.
    :vartype net_ipv4_tcp_fin_timeout: int
    :ivar net_ipv4_tcp_keepalive_time: Sysctl setting net.ipv4.tcp_keepalive_time.
    :vartype net_ipv4_tcp_keepalive_time: int
    :ivar net_ipv4_tcp_keepalive_probes: Sysctl setting net.ipv4.tcp_keepalive_probes.
    :vartype net_ipv4_tcp_keepalive_probes: int
    :ivar net_ipv4_tcpkeepalive_intvl: Sysctl setting net.ipv4.tcp_keepalive_intvl.
    :vartype net_ipv4_tcpkeepalive_intvl: int
    :ivar net_ipv4_tcp_tw_reuse: Sysctl setting net.ipv4.tcp_tw_reuse.
    :vartype net_ipv4_tcp_tw_reuse: bool
    :ivar net_ipv4_ip_local_port_range: Sysctl setting net.ipv4.ip_local_port_range.
    :vartype net_ipv4_ip_local_port_range: str
    :ivar net_ipv4_neigh_default_gc_thresh1: Sysctl setting net.ipv4.neigh.default.gc_thresh1.
    :vartype net_ipv4_neigh_default_gc_thresh1: int
    :ivar net_ipv4_neigh_default_gc_thresh2: Sysctl setting net.ipv4.neigh.default.gc_thresh2.
    :vartype net_ipv4_neigh_default_gc_thresh2: int
    :ivar net_ipv4_neigh_default_gc_thresh3: Sysctl setting net.ipv4.neigh.default.gc_thresh3.
    :vartype net_ipv4_neigh_default_gc_thresh3: int
    :ivar net_netfilter_nf_conntrack_max: Sysctl setting net.netfilter.nf_conntrack_max.
    :vartype net_netfilter_nf_conntrack_max: int
    :ivar net_netfilter_nf_conntrack_buckets: Sysctl setting net.netfilter.nf_conntrack_buckets.
    :vartype net_netfilter_nf_conntrack_buckets: int
    :ivar fs_inotify_max_user_watches: Sysctl setting fs.inotify.max_user_watches.
    :vartype fs_inotify_max_user_watches: int
    :ivar fs_file_max: Sysctl setting fs.file-max.
    :vartype fs_file_max: int
    :ivar fs_aio_max_nr: Sysctl setting fs.aio-max-nr.
    :vartype fs_aio_max_nr: int
    :ivar fs_nr_open: Sysctl setting fs.nr_open.
    :vartype fs_nr_open: int
    :ivar kernel_threads_max: Sysctl setting kernel.threads-max.
    :vartype kernel_threads_max: int
    :ivar vm_max_map_count: Sysctl setting vm.max_map_count.
    :vartype vm_max_map_count: int
    :ivar vm_swappiness: Sysctl setting vm.swappiness.
    :vartype vm_swappiness: int
    :ivar vm_vfs_cache_pressure: Sysctl setting vm.vfs_cache_pressure.
    :vartype vm_vfs_cache_pressure: int
    """

    net_core_somaxconn: Optional[int] = rest_field(
        name="netCoreSomaxconn", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.core.somaxconn."""
    net_core_netdev_max_backlog: Optional[int] = rest_field(
        name="netCoreNetdevMaxBacklog", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.core.netdev_max_backlog."""
    net_core_rmem_default: Optional[int] = rest_field(
        name="netCoreRmemDefault", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.core.rmem_default."""
    net_core_rmem_max: Optional[int] = rest_field(
        name="netCoreRmemMax", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.core.rmem_max."""
    net_core_wmem_default: Optional[int] = rest_field(
        name="netCoreWmemDefault", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.core.wmem_default."""
    net_core_wmem_max: Optional[int] = rest_field(
        name="netCoreWmemMax", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.core.wmem_max."""
    net_core_optmem_max: Optional[int] = rest_field(
        name="netCoreOptmemMax", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.core.optmem_max."""
    net_ipv4_tcp_max_syn_backlog: Optional[int] = rest_field(
        name="netIpv4TcpMaxSynBacklog", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.ipv4.tcp_max_syn_backlog."""
    net_ipv4_tcp_max_tw_buckets: Optional[int] = rest_field(
        name="netIpv4TcpMaxTwBuckets", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.ipv4.tcp_max_tw_buckets."""
    net_ipv4_tcp_fin_timeout: Optional[int] = rest_field(
        name="netIpv4TcpFinTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.ipv4.tcp_fin_timeout."""
    net_ipv4_tcp_keepalive_time: Optional[int] = rest_field(
        name="netIpv4TcpKeepaliveTime", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.ipv4.tcp_keepalive_time."""
    net_ipv4_tcp_keepalive_probes: Optional[int] = rest_field(
        name="netIpv4TcpKeepaliveProbes", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.ipv4.tcp_keepalive_probes."""
    net_ipv4_tcpkeepalive_intvl: Optional[int] = rest_field(
        name="netIpv4TcpkeepaliveIntvl", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.ipv4.tcp_keepalive_intvl."""
    net_ipv4_tcp_tw_reuse: Optional[bool] = rest_field(
        name="netIpv4TcpTwReuse", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.ipv4.tcp_tw_reuse."""
    net_ipv4_ip_local_port_range: Optional[str] = rest_field(
        name="netIpv4IpLocalPortRange", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.ipv4.ip_local_port_range."""
    net_ipv4_neigh_default_gc_thresh1: Optional[int] = rest_field(
        name="netIpv4NeighDefaultGcThresh1", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.ipv4.neigh.default.gc_thresh1."""
    net_ipv4_neigh_default_gc_thresh2: Optional[int] = rest_field(
        name="netIpv4NeighDefaultGcThresh2", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.ipv4.neigh.default.gc_thresh2."""
    net_ipv4_neigh_default_gc_thresh3: Optional[int] = rest_field(
        name="netIpv4NeighDefaultGcThresh3", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.ipv4.neigh.default.gc_thresh3."""
    net_netfilter_nf_conntrack_max: Optional[int] = rest_field(
        name="netNetfilterNfConntrackMax", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.netfilter.nf_conntrack_max."""
    net_netfilter_nf_conntrack_buckets: Optional[int] = rest_field(
        name="netNetfilterNfConntrackBuckets", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting net.netfilter.nf_conntrack_buckets."""
    fs_inotify_max_user_watches: Optional[int] = rest_field(
        name="fsInotifyMaxUserWatches", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting fs.inotify.max_user_watches."""
    fs_file_max: Optional[int] = rest_field(
        name="fsFileMax", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting fs.file-max."""
    fs_aio_max_nr: Optional[int] = rest_field(
        name="fsAioMaxNr", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting fs.aio-max-nr."""
    fs_nr_open: Optional[int] = rest_field(name="fsNrOpen", visibility=["read", "create", "update", "delete", "query"])
    """Sysctl setting fs.nr_open."""
    kernel_threads_max: Optional[int] = rest_field(
        name="kernelThreadsMax", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting kernel.threads-max."""
    vm_max_map_count: Optional[int] = rest_field(
        name="vmMaxMapCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting vm.max_map_count."""
    vm_swappiness: Optional[int] = rest_field(
        name="vmSwappiness", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting vm.swappiness."""
    vm_vfs_cache_pressure: Optional[int] = rest_field(
        name="vmVfsCachePressure", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sysctl setting vm.vfs_cache_pressure."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        net_core_somaxconn: Optional[int] = None,
        net_core_netdev_max_backlog: Optional[int] = None,
        net_core_rmem_default: Optional[int] = None,
        net_core_rmem_max: Optional[int] = None,
        net_core_wmem_default: Optional[int] = None,
        net_core_wmem_max: Optional[int] = None,
        net_core_optmem_max: Optional[int] = None,
        net_ipv4_tcp_max_syn_backlog: Optional[int] = None,
        net_ipv4_tcp_max_tw_buckets: Optional[int] = None,
        net_ipv4_tcp_fin_timeout: Optional[int] = None,
        net_ipv4_tcp_keepalive_time: Optional[int] = None,
        net_ipv4_tcp_keepalive_probes: Optional[int] = None,
        net_ipv4_tcpkeepalive_intvl: Optional[int] = None,
        net_ipv4_tcp_tw_reuse: Optional[bool] = None,
        net_ipv4_ip_local_port_range: Optional[str] = None,
        net_ipv4_neigh_default_gc_thresh1: Optional[int] = None,
        net_ipv4_neigh_default_gc_thresh2: Optional[int] = None,
        net_ipv4_neigh_default_gc_thresh3: Optional[int] = None,
        net_netfilter_nf_conntrack_max: Optional[int] = None,
        net_netfilter_nf_conntrack_buckets: Optional[int] = None,
        fs_inotify_max_user_watches: Optional[int] = None,
        fs_file_max: Optional[int] = None,
        fs_aio_max_nr: Optional[int] = None,
        fs_nr_open: Optional[int] = None,
        kernel_threads_max: Optional[int] = None,
        vm_max_map_count: Optional[int] = None,
        vm_swappiness: Optional[int] = None,
        vm_vfs_cache_pressure: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SystemData(_Model):
    """Metadata pertaining to creation and last modification of the resource.

    :ivar created_by: The identity that created the resource.
    :vartype created_by: str
    :ivar created_by_type: The type of identity that created the resource. Known values are:
     "User", "Application", "ManagedIdentity", and "Key".
    :vartype created_by_type: str or ~azure.mgmt.containerservice.models.CreatedByType
    :ivar created_at: The timestamp of resource creation (UTC).
    :vartype created_at: ~datetime.datetime
    :ivar last_modified_by: The identity that last modified the resource.
    :vartype last_modified_by: str
    :ivar last_modified_by_type: The type of identity that last modified the resource. Known values
     are: "User", "Application", "ManagedIdentity", and "Key".
    :vartype last_modified_by_type: str or ~azure.mgmt.containerservice.models.CreatedByType
    :ivar last_modified_at: The timestamp of resource last modification (UTC).
    :vartype last_modified_at: ~datetime.datetime
    """

    created_by: Optional[str] = rest_field(name="createdBy", visibility=["read", "create", "update", "delete", "query"])
    """The identity that created the resource."""
    created_by_type: Optional[Union[str, "_models.CreatedByType"]] = rest_field(
        name="createdByType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of identity that created the resource. Known values are: \"User\", \"Application\",
     \"ManagedIdentity\", and \"Key\"."""
    created_at: Optional[datetime.datetime] = rest_field(
        name="createdAt", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The timestamp of resource creation (UTC)."""
    last_modified_by: Optional[str] = rest_field(
        name="lastModifiedBy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The identity that last modified the resource."""
    last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = rest_field(
        name="lastModifiedByType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of identity that last modified the resource. Known values are: \"User\",
     \"Application\", \"ManagedIdentity\", and \"Key\"."""
    last_modified_at: Optional[datetime.datetime] = rest_field(
        name="lastModifiedAt", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The timestamp of resource last modification (UTC)."""

    @overload
    def __init__(
        self,
        *,
        created_by: Optional[str] = None,
        created_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
        created_at: Optional[datetime.datetime] = None,
        last_modified_by: Optional[str] = None,
        last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
        last_modified_at: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TagsObject(_Model):
    """Tags object for patch operations.

    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    """

    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""

    @overload
    def __init__(
        self,
        *,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TimeInWeek(_Model):
    """Time in a week.

    :ivar day: The day of the week. Known values are: "Sunday", "Monday", "Tuesday", "Wednesday",
     "Thursday", "Friday", and "Saturday".
    :vartype day: str or ~azure.mgmt.containerservice.models.WeekDay
    :ivar hour_slots: A list of hours in the day used to identify a time range. Each integer hour
     represents a time range beginning at 0m after the hour ending at the next hour (non-inclusive).
     0 corresponds to 00:00 UTC, 23 corresponds to 23:00 UTC. Specifying [0, 1] means the 00:00 -
     02:00 UTC time range.
    :vartype hour_slots: list[int]
    """

    day: Optional[Union[str, "_models.WeekDay"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The day of the week. Known values are: \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",
     \"Thursday\", \"Friday\", and \"Saturday\"."""
    hour_slots: Optional[list[int]] = rest_field(
        name="hourSlots", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list of hours in the day used to identify a time range. Each integer hour represents a time
     range beginning at 0m after the hour ending at the next hour (non-inclusive). 0 corresponds to
     00:00 UTC, 23 corresponds to 23:00 UTC. Specifying [0, 1] means the 00:00 - 02:00 UTC time
     range."""

    @overload
    def __init__(
        self,
        *,
        day: Optional[Union[str, "_models.WeekDay"]] = None,
        hour_slots: Optional[list[int]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TimeSpan(_Model):
    """A time range. For example, between 2021-05-25T13:00:00Z and 2021-05-25T14:00:00Z.

    :ivar start: The start of a time span.
    :vartype start: ~datetime.datetime
    :ivar end: The end of a time span.
    :vartype end: ~datetime.datetime
    """

    start: Optional[datetime.datetime] = rest_field(
        visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start of a time span."""
    end: Optional[datetime.datetime] = rest_field(
        visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The end of a time span."""

    @overload
    def __init__(
        self,
        *,
        start: Optional[datetime.datetime] = None,
        end: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TrustedAccessRole(_Model):
    """Trusted access role definition.

    :ivar source_resource_type: Resource type of Azure resource.
    :vartype source_resource_type: str
    :ivar name: Name of role, name is unique under a source resource type.
    :vartype name: str
    :ivar rules: List of rules for the role. This maps to 'rules' property of `Kubernetes Cluster
     Role
     <https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/cluster-role-v1/#ClusterRole>`_.
    :vartype rules: list[~azure.mgmt.containerservice.models.TrustedAccessRoleRule]
    """

    source_resource_type: Optional[str] = rest_field(name="sourceResourceType", visibility=["read"])
    """Resource type of Azure resource."""
    name: Optional[str] = rest_field(visibility=["read"])
    """Name of role, name is unique under a source resource type."""
    rules: Optional[list["_models.TrustedAccessRoleRule"]] = rest_field(visibility=["read"])
    """List of rules for the role. This maps to 'rules' property of `Kubernetes Cluster Role
     <https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/cluster-role-v1/#ClusterRole>`_."""


class TrustedAccessRoleBinding(ProxyResource):
    """Defines binding between a resource and role.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.containerservice.models.SystemData
    :ivar properties: Properties for trusted access role binding. Required.
    :vartype properties: ~azure.mgmt.containerservice.models.TrustedAccessRoleBindingProperties
    """

    properties: "_models.TrustedAccessRoleBindingProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties for trusted access role binding. Required."""

    __flattened_items = ["provisioning_state", "source_resource_id", "roles"]

    @overload
    def __init__(
        self,
        *,
        properties: "_models.TrustedAccessRoleBindingProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class TrustedAccessRoleBindingProperties(_Model):
    """Properties for trusted access role binding.

    :ivar provisioning_state: The current provisioning state of trusted access role binding. Known
     values are: "Canceled", "Deleting", "Failed", "Succeeded", and "Updating".
    :vartype provisioning_state: str or
     ~azure.mgmt.containerservice.models.TrustedAccessRoleBindingProvisioningState
    :ivar source_resource_id: The ARM resource ID of source resource that trusted access is
     configured for. Required.
    :vartype source_resource_id: str
    :ivar roles: A list of roles to bind, each item is a resource type qualified role name. For
     example: 'Microsoft.MachineLearningServices/workspaces/reader'. Required.
    :vartype roles: list[str]
    """

    provisioning_state: Optional[Union[str, "_models.TrustedAccessRoleBindingProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The current provisioning state of trusted access role binding. Known values are: \"Canceled\",
     \"Deleting\", \"Failed\", \"Succeeded\", and \"Updating\"."""
    source_resource_id: str = rest_field(
        name="sourceResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The ARM resource ID of source resource that trusted access is configured for. Required."""
    roles: list[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A list of roles to bind, each item is a resource type qualified role name. For example:
     'Microsoft.MachineLearningServices/workspaces/reader'. Required."""

    @overload
    def __init__(
        self,
        *,
        source_resource_id: str,
        roles: list[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TrustedAccessRoleRule(_Model):
    """Rule for trusted access role.

    :ivar verbs: List of allowed verbs.
    :vartype verbs: list[str]
    :ivar api_groups: List of allowed apiGroups.
    :vartype api_groups: list[str]
    :ivar resources: List of allowed resources.
    :vartype resources: list[str]
    :ivar resource_names: List of allowed names.
    :vartype resource_names: list[str]
    :ivar non_resource_ur_ls: List of allowed nonResourceURLs.
    :vartype non_resource_ur_ls: list[str]
    """

    verbs: Optional[list[str]] = rest_field(visibility=["read"])
    """List of allowed verbs."""
    api_groups: Optional[list[str]] = rest_field(name="apiGroups", visibility=["read"])
    """List of allowed apiGroups."""
    resources: Optional[list[str]] = rest_field(visibility=["read"])
    """List of allowed resources."""
    resource_names: Optional[list[str]] = rest_field(name="resourceNames", visibility=["read"])
    """List of allowed names."""
    non_resource_ur_ls: Optional[list[str]] = rest_field(name="nonResourceURLs", visibility=["read"])
    """List of allowed nonResourceURLs."""


class UpgradeOverrideSettings(_Model):
    """Settings for overrides when upgrading a cluster.

    :ivar force_upgrade: Whether to force upgrade the cluster. Note that this option instructs
     upgrade operation to bypass upgrade protections such as checking for deprecated API usage.
     Enable this option only with caution.
    :vartype force_upgrade: bool
    :ivar until: Until when the overrides are effective. Note that this only matches the start time
     of an upgrade, and the effectiveness won't change once an upgrade starts even if the ``until``
     expires as upgrade proceeds. This field is not set by default. It must be set for the overrides
     to take effect.
    :vartype until: ~datetime.datetime
    """

    force_upgrade: Optional[bool] = rest_field(
        name="forceUpgrade", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether to force upgrade the cluster. Note that this option instructs upgrade operation to
     bypass upgrade protections such as checking for deprecated API usage. Enable this option only
     with caution."""
    until: Optional[datetime.datetime] = rest_field(
        visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """Until when the overrides are effective. Note that this only matches the start time of an
     upgrade, and the effectiveness won't change once an upgrade starts even if the ``until``
     expires as upgrade proceeds. This field is not set by default. It must be set for the overrides
     to take effect."""

    @overload
    def __init__(
        self,
        *,
        force_upgrade: Optional[bool] = None,
        until: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VirtualMachineNodes(_Model):
    """Current status on a group of nodes of the same vm size.

    :ivar size: The VM size of the agents used to host this group of nodes.
    :vartype size: str
    :ivar count: Number of nodes.
    :vartype count: int
    """

    size: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The VM size of the agents used to host this group of nodes."""
    count: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Number of nodes."""

    @overload
    def __init__(
        self,
        *,
        size: Optional[str] = None,
        count: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VirtualMachinesProfile(_Model):
    """Specifications on VirtualMachines agent pool.

    :ivar scale: Specifications on how to scale a VirtualMachines agent pool.
    :vartype scale: ~azure.mgmt.containerservice.models.ScaleProfile
    """

    scale: Optional["_models.ScaleProfile"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifications on how to scale a VirtualMachines agent pool."""

    @overload
    def __init__(
        self,
        *,
        scale: Optional["_models.ScaleProfile"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WeeklySchedule(_Model):
    """For schedules like: 'recur every Monday' or 'recur every 3 weeks on Wednesday'.

    :ivar interval_weeks: Specifies the number of weeks between each set of occurrences. Required.
    :vartype interval_weeks: int
    :ivar day_of_week: Specifies on which day of the week the maintenance occurs. Required. Known
     values are: "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", and "Saturday".
    :vartype day_of_week: str or ~azure.mgmt.containerservice.models.WeekDay
    """

    interval_weeks: int = rest_field(name="intervalWeeks", visibility=["read", "create", "update", "delete", "query"])
    """Specifies the number of weeks between each set of occurrences. Required."""
    day_of_week: Union[str, "_models.WeekDay"] = rest_field(
        name="dayOfWeek", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies on which day of the week the maintenance occurs. Required. Known values are:
     \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", and \"Saturday\"."""

    @overload
    def __init__(
        self,
        *,
        interval_weeks: int,
        day_of_week: Union[str, "_models.WeekDay"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WindowsGmsaProfile(_Model):
    """Windows gMSA Profile in the managed cluster.

    :ivar enabled: Whether to enable Windows gMSA. Specifies whether to enable Windows gMSA in the
     managed cluster.
    :vartype enabled: bool
    :ivar dns_server: Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you
     have configured the DNS server in the vnet which is used to create the managed cluster.
    :vartype dns_server: str
    :ivar root_domain_name: Specifies the root domain name for Windows gMSA. <br><br> Set it to
     empty if you have configured the DNS server in the vnet which is used to create the managed
     cluster.
    :vartype root_domain_name: str
    """

    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to enable Windows gMSA. Specifies whether to enable Windows gMSA in the managed
     cluster."""
    dns_server: Optional[str] = rest_field(name="dnsServer", visibility=["read", "create", "update", "delete", "query"])
    """Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the
     DNS server in the vnet which is used to create the managed cluster."""
    root_domain_name: Optional[str] = rest_field(
        name="rootDomainName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have
     configured the DNS server in the vnet which is used to create the managed cluster."""

    @overload
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        dns_server: Optional[str] = None,
        root_domain_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
