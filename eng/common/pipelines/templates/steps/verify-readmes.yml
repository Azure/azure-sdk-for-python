parameters:
- name: PackagePropertiesFolder
  type: string
- name: RepoRoot
  type: string
  default: $(Build.SourcesDirectory)
- name: SettingsPath
  type: string
  default: '$(Build.SourcesDirectory)/eng/.docsettings.yml'
- name: DocWardenVersion
  type: string
  default: ''
- name: Condition
  type: string
  default: succeeded()
- name: IncludeIndirect
  type: boolean
  default: true

steps:
- pwsh: |
    $includeIndirect = $${{ parameters.IncludeIndirect }}
    $packageProperties = Get-ChildItem -Recurse "${{ parameters.PackagePropertiesFolder }}" *.json
    $paths = @()

    if (-not $includeIndirect) {
      $packageProperties = $packageProperties | Where-Object { (Get-Content -Raw $_ | ConvertFrom-Json).IncludedForValidation -eq $false }
    }

    foreach($propertiesFile in $packageProperties) {
      $PackageProp = Get-Content -Path $propertiesFile | ConvertFrom-Json

      $paths += (Join-Path "$(Build.SourcesDirectory)" $PackageProp.DirectoryPath)
    }

    $scanPaths = $paths -join ","
    Write-Host "##vso[task.setvariable variable=ScanPathArgument;]$scanPaths"
  displayName: Populate Scan Paths
  condition: ${{ parameters.Condition }}

- pwsh: |
    # Install azsdk tool and capture installation path
    $repoRoot = "${{ parameters.RepoRoot }}"
    if ([string]::IsNullOrWhiteSpace($repoRoot)) {
      $repoRoot = "$(Build.SourcesDirectory)"
    }
    $installer = Join-Path $repoRoot "eng/common/mcp/azure-sdk-mcp.ps1"
    $installOutput = & $installer 2>&1 | Tee-Object -Variable installLogs
    
    # Parse installation output to find tool path
    $toolPath = $null
    foreach ($line in $installLogs) {
      Write-Host "Debug: $line"
      if ($line -match "Package \w+ is installed at (.+)") {
        $toolPath = $matches[1].Trim()
        Write-Host "Found tool path: $toolPath"
        break
      }
    }
    
    if (-not $toolPath) {
      Write-Host "Installation logs:"
      $installLogs | ForEach-Object { Write-Host "  $_" }
      throw "Could not parse tool installation path from output"
    }
    
    if (-not (Test-Path $toolPath)) {
      throw "azsdk tool not found at parsed path: $toolPath"
    }
    
    Write-Host "Using azsdk tool at: $toolPath"
    
    # Run readme validation on discovered paths
    $scanPathsValue = '$(ScanPathArgument)'
    if ([string]::IsNullOrWhiteSpace($scanPathsValue)) {
      throw "ScanPathArgument cannot be empty."
    }

    $paths = $scanPathsValue.Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
    if (-not $paths) {
      throw "No valid scan paths provided."
    }

    $exitCode = 0
    foreach ($path in $paths) {
      if (-not (Test-Path -Path $path -PathType Container)) {
        Write-Error "path '$path' does not exist or is not a directory"
        $exitCode = 1
        continue
      }

      Write-Host "Validating README content in '$path'"
      & $toolPath package run-checks readme --package-path $path
      if ($LASTEXITCODE -ne 0) {
        $exitCode = $LASTEXITCODE
      }
    }

    if ($exitCode -ne 0) {
      exit $exitCode
    }
  displayName: "Verify Readmes"
  condition: ${{ parameters.Condition }}
